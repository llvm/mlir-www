<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::OpAsmParser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlir_1_1OpAsmParser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::OpAsmParser Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classmlir_1_1OpAsmParser.html" title="The OpAsmParser has methods for interacting with the asm parser: parsing things from it,...">OpAsmParser</a> has methods for interacting with the asm parser: parsing things from it, emitting errors etc.  
 <a href="classmlir_1_1OpAsmParser.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="OpImplementation_8h_source.html">mlir/IR/OpImplementation.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mlir::OpAsmParser:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classmlir_1_1OpAsmParser__inherit__graph.svg" width="154" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the representation of an operand reference.  <a href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2a5344cbddd8e2003180192f22fbb54c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a2a5344cbddd8e2003180192f22fbb54c">~OpAsmParser</a> () override</td></tr>
<tr class="separator:a2a5344cbddd8e2003180192f22fbb54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2bfd458e054cd6263449dfb4d551b2"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a7e2bfd458e054cd6263449dfb4d551b2">parseOptionalLocationSpecifier</a> (std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; &amp;result)=0</td></tr>
<tr class="memdesc:a7e2bfd458e054cd6263449dfb4d551b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a loc(...) specifier if present, filling in result if so.  <a href="classmlir_1_1OpAsmParser.html#a7e2bfd458e054cd6263449dfb4d551b2">More...</a><br /></td></tr>
<tr class="separator:a7e2bfd458e054cd6263449dfb4d551b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dfae2d5ed359f6871069ce4dfe8219"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; StringRef, unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a05dfae2d5ed359f6871069ce4dfe8219">getResultName</a> (unsigned resultNo) const =0</td></tr>
<tr class="memdesc:a05dfae2d5ed359f6871069ce4dfe8219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the specified result in the specified syntax, as well as the sub-element in the name.  <a href="classmlir_1_1OpAsmParser.html#a05dfae2d5ed359f6871069ce4dfe8219">More...</a><br /></td></tr>
<tr class="separator:a05dfae2d5ed359f6871069ce4dfe8219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a9326d8bf403a0156e9784730b427f"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a09a9326d8bf403a0156e9784730b427f">getNumResults</a> () const =0</td></tr>
<tr class="memdesc:a09a9326d8bf403a0156e9784730b427f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of declared SSA results.  <a href="classmlir_1_1OpAsmParser.html#a09a9326d8bf403a0156e9784730b427f">More...</a><br /></td></tr>
<tr class="separator:a09a9326d8bf403a0156e9784730b427f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac205e2e553a432fe9a2b490c55c33dee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#ac205e2e553a432fe9a2b490c55c33dee">parseGenericOperation</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *insertBlock, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> insertPt)=0</td></tr>
<tr class="memdesc:ac205e2e553a432fe9a2b490c55c33dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an operation in its generic form.  <a href="classmlir_1_1OpAsmParser.html#ac205e2e553a432fe9a2b490c55c33dee">More...</a><br /></td></tr>
<tr class="separator:ac205e2e553a432fe9a2b490c55c33dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a393d03057c4acd7b86f8772daaaae"><td class="memItemLeft" align="right" valign="top">virtual FailureOr&lt; <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#aa9a393d03057c4acd7b86f8772daaaae">parseCustomOperationName</a> ()=0</td></tr>
<tr class="memdesc:aa9a393d03057c4acd7b86f8772daaaae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the name of an operation, in the custom form.  <a href="classmlir_1_1OpAsmParser.html#aa9a393d03057c4acd7b86f8772daaaae">More...</a><br /></td></tr>
<tr class="separator:aa9a393d03057c4acd7b86f8772daaaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bef3fcb4503ec111e33ebdcddb6cd01"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a4bef3fcb4503ec111e33ebdcddb6cd01">parseGenericOperationAfterOpName</a> (<a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result, std::optional&lt; <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt;&gt; parsedOperandType=std::nullopt, std::optional&lt; <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;&gt; parsedSuccessors=std::nullopt, std::optional&lt; <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; std::unique_ptr&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&gt;&gt; parsedRegions=std::nullopt, std::optional&lt; <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt;&gt; parsedAttributes=std::nullopt, std::optional&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; parsedPropertiesAttribute=std::nullopt, std::optional&lt; FunctionType &gt; parsedFnType=std::nullopt)=0</td></tr>
<tr class="memdesc:a4bef3fcb4503ec111e33ebdcddb6cd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse different components, viz., use-info of operand(s), successor(s), region(s), attribute(s) and function-type, of the generic form of an operation instance and populate the input operation-state 'result' with those components.  <a href="classmlir_1_1OpAsmParser.html#a4bef3fcb4503ec111e33ebdcddb6cd01">More...</a><br /></td></tr>
<tr class="separator:a4bef3fcb4503ec111e33ebdcddb6cd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30f229849bfc580b251da20cc8923ee"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#ac30f229849bfc580b251da20cc8923ee">parseOperand</a> (<a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &amp;result, bool allowResultNumber=true)=0</td></tr>
<tr class="memdesc:ac30f229849bfc580b251da20cc8923ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a single SSA value operand name along with a result number if <code>allowResultNumber</code> is true.  <a href="classmlir_1_1OpAsmParser.html#ac30f229849bfc580b251da20cc8923ee">More...</a><br /></td></tr>
<tr class="separator:ac30f229849bfc580b251da20cc8923ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd765b541880aa1f11ca238ce62ad9d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a8fd765b541880aa1f11ca238ce62ad9d">parseOptionalOperand</a> (<a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &amp;result, bool allowResultNumber=true)=0</td></tr>
<tr class="memdesc:a8fd765b541880aa1f11ca238ce62ad9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a single operand if present.  <a href="classmlir_1_1OpAsmParser.html#a8fd765b541880aa1f11ca238ce62ad9d">More...</a><br /></td></tr>
<tr class="separator:a8fd765b541880aa1f11ca238ce62ad9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16d3e3ef46bd2bd45b4e8db657c221a"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#af16d3e3ef46bd2bd45b4e8db657c221a">parseOperandList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt; &amp;result, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba6adf97f83acf6453d4a6a4b1070f3754">Delimiter::None</a>, bool allowResultNumber=true, int requiredOperandCount=-1)=0</td></tr>
<tr class="memdesc:af16d3e3ef46bd2bd45b4e8db657c221a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse zero or more SSA comma-separated operand references with a specified surrounding delimiter, and an optional required operand count.  <a href="classmlir_1_1OpAsmParser.html#af16d3e3ef46bd2bd45b4e8db657c221a">More...</a><br /></td></tr>
<tr class="separator:af16d3e3ef46bd2bd45b4e8db657c221a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac66ff1f25e13f351765b8afef96fcef"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#aac66ff1f25e13f351765b8afef96fcef">parseOperandList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt; &amp;result, int requiredOperandCount, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba6adf97f83acf6453d4a6a4b1070f3754">Delimiter::None</a>)</td></tr>
<tr class="memdesc:aac66ff1f25e13f351765b8afef96fcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a specified number of comma separated operands.  <a href="classmlir_1_1OpAsmParser.html#aac66ff1f25e13f351765b8afef96fcef">More...</a><br /></td></tr>
<tr class="separator:aac66ff1f25e13f351765b8afef96fcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d468dc0848a3666d92ee8ff699d5a5f"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a4d468dc0848a3666d92ee8ff699d5a5f">parseTrailingOperandList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt; &amp;result, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba6adf97f83acf6453d4a6a4b1070f3754">Delimiter::None</a>)</td></tr>
<tr class="memdesc:a4d468dc0848a3666d92ee8ff699d5a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse zero or more trailing SSA comma-separated trailing operand references with a specified surrounding delimiter, and an optional required operand count.  <a href="classmlir_1_1OpAsmParser.html#a4d468dc0848a3666d92ee8ff699d5a5f">More...</a><br /></td></tr>
<tr class="separator:a4d468dc0848a3666d92ee8ff699d5a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c583b0d425ac93c7f8a867f5546db6a"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a8c583b0d425ac93c7f8a867f5546db6a">resolveOperand</a> (const <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &amp;operand, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;result)=0</td></tr>
<tr class="memdesc:a8c583b0d425ac93c7f8a867f5546db6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve an operand to an SSA value, emitting an error on failure.  <a href="classmlir_1_1OpAsmParser.html#a8c583b0d425ac93c7f8a867f5546db6a">More...</a><br /></td></tr>
<tr class="separator:a8c583b0d425ac93c7f8a867f5546db6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd56f3f603a23b43c86c7d6b6f38d7a"><td class="memTemplParams" colspan="2">template&lt;typename Operands  = ArrayRef&lt;UnresolvedOperand&gt;&gt; </td></tr>
<tr class="memitem:aafd56f3f603a23b43c86c7d6b6f38d7a"><td class="memTemplItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#aafd56f3f603a23b43c86c7d6b6f38d7a">resolveOperands</a> (Operands &amp;&amp;operands, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:aafd56f3f603a23b43c86c7d6b6f38d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve a list of operands to SSA values, emitting an error on failure, or appending the results to the list on success.  <a href="classmlir_1_1OpAsmParser.html#aafd56f3f603a23b43c86c7d6b6f38d7a">More...</a><br /></td></tr>
<tr class="separator:aafd56f3f603a23b43c86c7d6b6f38d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e09a95735c13cd607e4c7552098760b"><td class="memTemplParams" colspan="2">template&lt;typename Operands  = ArrayRef&lt;UnresolvedOperand&gt;&gt; </td></tr>
<tr class="memitem:a4e09a95735c13cd607e4c7552098760b"><td class="memTemplItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a4e09a95735c13cd607e4c7552098760b">resolveOperands</a> (Operands &amp;&amp;operands, <a class="el" href="classmlir_1_1Type.html">Type</a> type, SMLoc loc, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;result)</td></tr>
<tr class="separator:a4e09a95735c13cd607e4c7552098760b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7dab9683e2cd00025f0961cae4b7d35"><td class="memTemplParams" colspan="2">template&lt;typename Operands  = ArrayRef&lt;UnresolvedOperand&gt;, typename Types  = ArrayRef&lt;Type&gt;&gt; </td></tr>
<tr class="memitem:ad7dab9683e2cd00025f0961cae4b7d35"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_convertible&lt; Types, <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;::value, ParseResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#ad7dab9683e2cd00025f0961cae4b7d35">resolveOperands</a> (Operands &amp;&amp;operands, Types &amp;&amp;types, SMLoc loc, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ad7dab9683e2cd00025f0961cae4b7d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve a list of operands and a list of operand types to SSA values, emitting an error and returning failure, or appending the results to the list on success.  <a href="classmlir_1_1OpAsmParser.html#ad7dab9683e2cd00025f0961cae4b7d35">More...</a><br /></td></tr>
<tr class="separator:ad7dab9683e2cd00025f0961cae4b7d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ebc9079a03a42c71c883b21e733dfa"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a55ebc9079a03a42c71c883b21e733dfa">parseAffineMapOfSSAIds</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt; &amp;operands, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;map, StringRef attrName, <a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;attrs, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">Delimiter::Square</a>)=0</td></tr>
<tr class="memdesc:a55ebc9079a03a42c71c883b21e733dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an affine map attribute where dims and symbols are SSA operands.  <a href="classmlir_1_1OpAsmParser.html#a55ebc9079a03a42c71c883b21e733dfa">More...</a><br /></td></tr>
<tr class="separator:a55ebc9079a03a42c71c883b21e733dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96f497332866979248e25e170e6bd40"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#ac96f497332866979248e25e170e6bd40">parseAffineExprOfSSAIds</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt; &amp;dimOperands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt; &amp;symbOperands, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;expr)=0</td></tr>
<tr class="memdesc:ac96f497332866979248e25e170e6bd40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an affine expression where dims and symbols are SSA operands.  <a href="classmlir_1_1OpAsmParser.html#ac96f497332866979248e25e170e6bd40">More...</a><br /></td></tr>
<tr class="separator:ac96f497332866979248e25e170e6bd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491f39b888aaea001f423a946a782e19"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a491f39b888aaea001f423a946a782e19">parseArgument</a> (<a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a> &amp;result, bool allowType=false, bool allowAttrs=false)=0</td></tr>
<tr class="memdesc:a491f39b888aaea001f423a946a782e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a single argument with the following syntax:  <a href="classmlir_1_1OpAsmParser.html#a491f39b888aaea001f423a946a782e19">More...</a><br /></td></tr>
<tr class="separator:a491f39b888aaea001f423a946a782e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa56215a35491d0afb991f6cc8dd700"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a7aa56215a35491d0afb991f6cc8dd700">parseOptionalArgument</a> (<a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a> &amp;result, bool allowType=false, bool allowAttrs=false)=0</td></tr>
<tr class="memdesc:a7aa56215a35491d0afb991f6cc8dd700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a single argument if present.  <a href="classmlir_1_1OpAsmParser.html#a7aa56215a35491d0afb991f6cc8dd700">More...</a><br /></td></tr>
<tr class="separator:a7aa56215a35491d0afb991f6cc8dd700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530427ff32aa6170dd20d2abd94ea880"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a530427ff32aa6170dd20d2abd94ea880">parseArgumentList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a> &gt; &amp;result, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba6adf97f83acf6453d4a6a4b1070f3754">Delimiter::None</a>, bool allowType=false, bool allowAttrs=false)=0</td></tr>
<tr class="memdesc:a530427ff32aa6170dd20d2abd94ea880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse zero or more arguments with a specified surrounding delimiter.  <a href="classmlir_1_1OpAsmParser.html#a530427ff32aa6170dd20d2abd94ea880">More...</a><br /></td></tr>
<tr class="separator:a530427ff32aa6170dd20d2abd94ea880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa6346885471aae41b7f63c33894af5"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a1aa6346885471aae41b7f63c33894af5">parseRegion</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a> &gt; arguments={}, bool enableNameShadowing=false)=0</td></tr>
<tr class="memdesc:a1aa6346885471aae41b7f63c33894af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a region.  <a href="classmlir_1_1OpAsmParser.html#a1aa6346885471aae41b7f63c33894af5">More...</a><br /></td></tr>
<tr class="separator:a1aa6346885471aae41b7f63c33894af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1c62f9f4cd1cb3b44348ae404ab0e9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a9c1c62f9f4cd1cb3b44348ae404ab0e9">parseOptionalRegion</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a> &gt; arguments={}, bool enableNameShadowing=false)=0</td></tr>
<tr class="memdesc:a9c1c62f9f4cd1cb3b44348ae404ab0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a region if present.  <a href="classmlir_1_1OpAsmParser.html#a9c1c62f9f4cd1cb3b44348ae404ab0e9">More...</a><br /></td></tr>
<tr class="separator:a9c1c62f9f4cd1cb3b44348ae404ab0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffdc9be08e1966a9245254caa9f83ec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#adffdc9be08e1966a9245254caa9f83ec">parseOptionalRegion</a> (std::unique_ptr&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; &amp;region, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a> &gt; arguments={}, bool enableNameShadowing=false)=0</td></tr>
<tr class="memdesc:adffdc9be08e1966a9245254caa9f83ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a region if present.  <a href="classmlir_1_1OpAsmParser.html#adffdc9be08e1966a9245254caa9f83ec">More...</a><br /></td></tr>
<tr class="separator:adffdc9be08e1966a9245254caa9f83ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9fe3c427588618221405e793801740"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a2d9fe3c427588618221405e793801740">parseSuccessor</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *&amp;dest)=0</td></tr>
<tr class="memdesc:a2d9fe3c427588618221405e793801740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a single operation successor.  <a href="classmlir_1_1OpAsmParser.html#a2d9fe3c427588618221405e793801740">More...</a><br /></td></tr>
<tr class="separator:a2d9fe3c427588618221405e793801740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf71a21c58dda44441e32396934aa8d7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#acf71a21c58dda44441e32396934aa8d7">parseOptionalSuccessor</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *&amp;dest)=0</td></tr>
<tr class="memdesc:acf71a21c58dda44441e32396934aa8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an optional operation successor.  <a href="classmlir_1_1OpAsmParser.html#acf71a21c58dda44441e32396934aa8d7">More...</a><br /></td></tr>
<tr class="separator:acf71a21c58dda44441e32396934aa8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3c28975dee14289c711345ba31bdda"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a9b3c28975dee14289c711345ba31bdda">parseSuccessorAndUseList</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *&amp;dest, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands)=0</td></tr>
<tr class="memdesc:a9b3c28975dee14289c711345ba31bdda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a single operation successor and its operand list.  <a href="classmlir_1_1OpAsmParser.html#a9b3c28975dee14289c711345ba31bdda">More...</a><br /></td></tr>
<tr class="separator:a9b3c28975dee14289c711345ba31bdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817e151fa68d44de0e39b17b365e2223"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a817e151fa68d44de0e39b17b365e2223">parseAssignmentList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a> &gt; &amp;lhs, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a817e151fa68d44de0e39b17b365e2223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a list of assignments of the form (x1 = y1, x2 = y2, ...)  <a href="classmlir_1_1OpAsmParser.html#a817e151fa68d44de0e39b17b365e2223">More...</a><br /></td></tr>
<tr class="separator:a817e151fa68d44de0e39b17b365e2223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e2984db44d0a267a04a3daa6d4f89d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a13e2984db44d0a267a04a3daa6d4f89d">parseOptionalAssignmentList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a> &gt; &amp;lhs, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt; &amp;rhs)=0</td></tr>
<tr class="separator:a13e2984db44d0a267a04a3daa6d4f89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128af21674eec348f0cb475399551fbe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html#a128af21674eec348f0cb475399551fbe">AsmParser</a> ()=default</td></tr>
<tr class="separator:a128af21674eec348f0cb475399551fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1AsmParser"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1AsmParser')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1AsmParser.html">mlir::AsmParser</a></td></tr>
<tr class="memitem:a128af21674eec348f0cb475399551fbe inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a128af21674eec348f0cb475399551fbe">AsmParser</a> ()=default</td></tr>
<tr class="separator:a128af21674eec348f0cb475399551fbe inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fa84e93dcbc085eda6d426ccddb9ad inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ad7fa84e93dcbc085eda6d426ccddb9ad">~AsmParser</a> ()</td></tr>
<tr class="separator:ad7fa84e93dcbc085eda6d426ccddb9ad inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31925defda8094469f7577d42edfc02a inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a31925defda8094469f7577d42edfc02a">getContext</a> () const</td></tr>
<tr class="separator:a31925defda8094469f7577d42edfc02a inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d00f93debeb1567ae8f7bbb76cdea37 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual SMLoc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">getNameLoc</a> () const =0</td></tr>
<tr class="memdesc:a8d00f93debeb1567ae8f7bbb76cdea37 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the location of the original name token.  <a href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">More...</a><br /></td></tr>
<tr class="separator:a8d00f93debeb1567ae8f7bbb76cdea37 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33803273c4fc1a660d73cb91aceac30b inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">emitError</a> (SMLoc loc, const Twine &amp;message={})=0</td></tr>
<tr class="memdesc:a33803273c4fc1a660d73cb91aceac30b inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a diagnostic at the specified location and return failure.  <a href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">More...</a><br /></td></tr>
<tr class="separator:a33803273c4fc1a660d73cb91aceac30b inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf38020e304fa596401f15d1eb30e1d inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">getBuilder</a> () const =0</td></tr>
<tr class="memdesc:a2bf38020e304fa596401f15d1eb30e1d inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a builder which provides useful access to <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a>, global objects like types and attributes.  <a href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">More...</a><br /></td></tr>
<tr class="separator:a2bf38020e304fa596401f15d1eb30e1d inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7850fe0a2961f835384adb372758d58b inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual SMLoc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a7850fe0a2961f835384adb372758d58b">getCurrentLocation</a> ()=0</td></tr>
<tr class="memdesc:a7850fe0a2961f835384adb372758d58b inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the location of the next token and store it into the argument.  <a href="classmlir_1_1AsmParser.html#a7850fe0a2961f835384adb372758d58b">More...</a><br /></td></tr>
<tr class="separator:a7850fe0a2961f835384adb372758d58b inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93116709ab7d30bdf97eec8647cbb16b inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a93116709ab7d30bdf97eec8647cbb16b">getCurrentLocation</a> (SMLoc *loc)</td></tr>
<tr class="separator:a93116709ab7d30bdf97eec8647cbb16b inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c7eab67a3bdcc108298678d3be769e inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a32c7eab67a3bdcc108298678d3be769e">getEncodedSourceLoc</a> (SMLoc loc)=0</td></tr>
<tr class="memdesc:a32c7eab67a3bdcc108298678d3be769e inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-encode the given source location as an MLIR location and return it.  <a href="classmlir_1_1AsmParser.html#a32c7eab67a3bdcc108298678d3be769e">More...</a><br /></td></tr>
<tr class="separator:a32c7eab67a3bdcc108298678d3be769e inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadaac62d4dff4fde5f3a8b9ee355d923 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#aadaac62d4dff4fde5f3a8b9ee355d923">parseArrow</a> ()=0</td></tr>
<tr class="memdesc:aadaac62d4dff4fde5f3a8b9ee355d923 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '-&gt;' token.  <a href="classmlir_1_1AsmParser.html#aadaac62d4dff4fde5f3a8b9ee355d923">More...</a><br /></td></tr>
<tr class="separator:aadaac62d4dff4fde5f3a8b9ee355d923 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4083edc5426df1be5544fe617fb9d7ad inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a4083edc5426df1be5544fe617fb9d7ad">parseOptionalArrow</a> ()=0</td></tr>
<tr class="memdesc:a4083edc5426df1be5544fe617fb9d7ad inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '-&gt;' token if present.  <a href="classmlir_1_1AsmParser.html#a4083edc5426df1be5544fe617fb9d7ad">More...</a><br /></td></tr>
<tr class="separator:a4083edc5426df1be5544fe617fb9d7ad inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063b62998d38e227efa96a8c7ed98d5c inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a063b62998d38e227efa96a8c7ed98d5c">parseLBrace</a> ()=0</td></tr>
<tr class="memdesc:a063b62998d38e227efa96a8c7ed98d5c inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>{</code> token.  <a href="classmlir_1_1AsmParser.html#a063b62998d38e227efa96a8c7ed98d5c">More...</a><br /></td></tr>
<tr class="separator:a063b62998d38e227efa96a8c7ed98d5c inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeed196cd354285453d3b33924339f08 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#afeed196cd354285453d3b33924339f08">parseOptionalLBrace</a> ()=0</td></tr>
<tr class="memdesc:afeed196cd354285453d3b33924339f08 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>{</code> token if present.  <a href="classmlir_1_1AsmParser.html#afeed196cd354285453d3b33924339f08">More...</a><br /></td></tr>
<tr class="separator:afeed196cd354285453d3b33924339f08 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b79f806cdba4918d6c0e43c2e38f611 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a4b79f806cdba4918d6c0e43c2e38f611">parseRBrace</a> ()=0</td></tr>
<tr class="memdesc:a4b79f806cdba4918d6c0e43c2e38f611 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>}</code> token.  <a href="classmlir_1_1AsmParser.html#a4b79f806cdba4918d6c0e43c2e38f611">More...</a><br /></td></tr>
<tr class="separator:a4b79f806cdba4918d6c0e43c2e38f611 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9ebc82938b2135166856c71fa9c2d4 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a1d9ebc82938b2135166856c71fa9c2d4">parseOptionalRBrace</a> ()=0</td></tr>
<tr class="memdesc:a1d9ebc82938b2135166856c71fa9c2d4 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>}</code> token if present.  <a href="classmlir_1_1AsmParser.html#a1d9ebc82938b2135166856c71fa9c2d4">More...</a><br /></td></tr>
<tr class="separator:a1d9ebc82938b2135166856c71fa9c2d4 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8189a65faf2f6e51c78ca21f945100bb inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a8189a65faf2f6e51c78ca21f945100bb">parseColon</a> ()=0</td></tr>
<tr class="memdesc:a8189a65faf2f6e51c78ca21f945100bb inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>:</code> token.  <a href="classmlir_1_1AsmParser.html#a8189a65faf2f6e51c78ca21f945100bb">More...</a><br /></td></tr>
<tr class="separator:a8189a65faf2f6e51c78ca21f945100bb inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33bde3c236547b8765afb2f0719cb4d4 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a33bde3c236547b8765afb2f0719cb4d4">parseOptionalColon</a> ()=0</td></tr>
<tr class="memdesc:a33bde3c236547b8765afb2f0719cb4d4 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>:</code> token if present.  <a href="classmlir_1_1AsmParser.html#a33bde3c236547b8765afb2f0719cb4d4">More...</a><br /></td></tr>
<tr class="separator:a33bde3c236547b8765afb2f0719cb4d4 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ae46c606240d5588dbd91262f3a9a4 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ac6ae46c606240d5588dbd91262f3a9a4">parseComma</a> ()=0</td></tr>
<tr class="memdesc:ac6ae46c606240d5588dbd91262f3a9a4 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>,</code> token.  <a href="classmlir_1_1AsmParser.html#ac6ae46c606240d5588dbd91262f3a9a4">More...</a><br /></td></tr>
<tr class="separator:ac6ae46c606240d5588dbd91262f3a9a4 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4ae1e32399518a5051d27e4effd8fb inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a7c4ae1e32399518a5051d27e4effd8fb">parseOptionalComma</a> ()=0</td></tr>
<tr class="memdesc:a7c4ae1e32399518a5051d27e4effd8fb inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>,</code> token if present.  <a href="classmlir_1_1AsmParser.html#a7c4ae1e32399518a5051d27e4effd8fb">More...</a><br /></td></tr>
<tr class="separator:a7c4ae1e32399518a5051d27e4effd8fb inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f240da7e00c4072d9f268efe1179b1d inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a5f240da7e00c4072d9f268efe1179b1d">parseEqual</a> ()=0</td></tr>
<tr class="memdesc:a5f240da7e00c4072d9f268efe1179b1d inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>=</code> token.  <a href="classmlir_1_1AsmParser.html#a5f240da7e00c4072d9f268efe1179b1d">More...</a><br /></td></tr>
<tr class="separator:a5f240da7e00c4072d9f268efe1179b1d inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d725d47025c0e22ca8b2d44fce78ea7 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a2d725d47025c0e22ca8b2d44fce78ea7">parseOptionalEqual</a> ()=0</td></tr>
<tr class="memdesc:a2d725d47025c0e22ca8b2d44fce78ea7 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>=</code> token if present.  <a href="classmlir_1_1AsmParser.html#a2d725d47025c0e22ca8b2d44fce78ea7">More...</a><br /></td></tr>
<tr class="separator:a2d725d47025c0e22ca8b2d44fce78ea7 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552432315336762e7c3145941cbe625f inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a552432315336762e7c3145941cbe625f">parseLess</a> ()=0</td></tr>
<tr class="memdesc:a552432315336762e7c3145941cbe625f inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '&lt;' token.  <a href="classmlir_1_1AsmParser.html#a552432315336762e7c3145941cbe625f">More...</a><br /></td></tr>
<tr class="separator:a552432315336762e7c3145941cbe625f inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94976a6ddf09e6edb7cfe006b0c31faa inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a94976a6ddf09e6edb7cfe006b0c31faa">parseOptionalLess</a> ()=0</td></tr>
<tr class="memdesc:a94976a6ddf09e6edb7cfe006b0c31faa inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '&lt;' token if present.  <a href="classmlir_1_1AsmParser.html#a94976a6ddf09e6edb7cfe006b0c31faa">More...</a><br /></td></tr>
<tr class="separator:a94976a6ddf09e6edb7cfe006b0c31faa inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c07420f37ac78e5376cccc48e6e0d4 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ab0c07420f37ac78e5376cccc48e6e0d4">parseGreater</a> ()=0</td></tr>
<tr class="memdesc:ab0c07420f37ac78e5376cccc48e6e0d4 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '&gt;' token.  <a href="classmlir_1_1AsmParser.html#ab0c07420f37ac78e5376cccc48e6e0d4">More...</a><br /></td></tr>
<tr class="separator:ab0c07420f37ac78e5376cccc48e6e0d4 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5d484a9b7fe5ce83a0652a0f699e51 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a5d5d484a9b7fe5ce83a0652a0f699e51">parseOptionalGreater</a> ()=0</td></tr>
<tr class="memdesc:a5d5d484a9b7fe5ce83a0652a0f699e51 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '&gt;' token if present.  <a href="classmlir_1_1AsmParser.html#a5d5d484a9b7fe5ce83a0652a0f699e51">More...</a><br /></td></tr>
<tr class="separator:a5d5d484a9b7fe5ce83a0652a0f699e51 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c529c891085cde1ccf582573d9d56dd inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a9c529c891085cde1ccf582573d9d56dd">parseQuestion</a> ()=0</td></tr>
<tr class="memdesc:a9c529c891085cde1ccf582573d9d56dd inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '?' token.  <a href="classmlir_1_1AsmParser.html#a9c529c891085cde1ccf582573d9d56dd">More...</a><br /></td></tr>
<tr class="separator:a9c529c891085cde1ccf582573d9d56dd inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39eb6b27def6a489bf72fa951b09b50 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#af39eb6b27def6a489bf72fa951b09b50">parseOptionalQuestion</a> ()=0</td></tr>
<tr class="memdesc:af39eb6b27def6a489bf72fa951b09b50 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '?' token if present.  <a href="classmlir_1_1AsmParser.html#af39eb6b27def6a489bf72fa951b09b50">More...</a><br /></td></tr>
<tr class="separator:af39eb6b27def6a489bf72fa951b09b50 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22020d024fe46c73625b242628eec8fc inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a22020d024fe46c73625b242628eec8fc">parsePlus</a> ()=0</td></tr>
<tr class="memdesc:a22020d024fe46c73625b242628eec8fc inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '+' token.  <a href="classmlir_1_1AsmParser.html#a22020d024fe46c73625b242628eec8fc">More...</a><br /></td></tr>
<tr class="separator:a22020d024fe46c73625b242628eec8fc inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58794347ef55d2c6237478e50b56c2c3 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a58794347ef55d2c6237478e50b56c2c3">parseOptionalPlus</a> ()=0</td></tr>
<tr class="memdesc:a58794347ef55d2c6237478e50b56c2c3 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '+' token if present.  <a href="classmlir_1_1AsmParser.html#a58794347ef55d2c6237478e50b56c2c3">More...</a><br /></td></tr>
<tr class="separator:a58794347ef55d2c6237478e50b56c2c3 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7493fb0cf651565b0f67104a2018154d inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a7493fb0cf651565b0f67104a2018154d">parseSlash</a> ()=0</td></tr>
<tr class="memdesc:a7493fb0cf651565b0f67104a2018154d inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '/' token.  <a href="classmlir_1_1AsmParser.html#a7493fb0cf651565b0f67104a2018154d">More...</a><br /></td></tr>
<tr class="separator:a7493fb0cf651565b0f67104a2018154d inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebda50c500b4a7206d8c494955dfb46 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a9ebda50c500b4a7206d8c494955dfb46">parseOptionalSlash</a> ()=0</td></tr>
<tr class="memdesc:a9ebda50c500b4a7206d8c494955dfb46 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '/' token if present.  <a href="classmlir_1_1AsmParser.html#a9ebda50c500b4a7206d8c494955dfb46">More...</a><br /></td></tr>
<tr class="separator:a9ebda50c500b4a7206d8c494955dfb46 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00514c318ccd86b955c07ad44fa558a6 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a00514c318ccd86b955c07ad44fa558a6">parseMinus</a> ()=0</td></tr>
<tr class="memdesc:a00514c318ccd86b955c07ad44fa558a6 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '-' token.  <a href="classmlir_1_1AsmParser.html#a00514c318ccd86b955c07ad44fa558a6">More...</a><br /></td></tr>
<tr class="separator:a00514c318ccd86b955c07ad44fa558a6 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202700670a8027a81eac727cde3a5b3f inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a202700670a8027a81eac727cde3a5b3f">parseOptionalMinus</a> ()=0</td></tr>
<tr class="memdesc:a202700670a8027a81eac727cde3a5b3f inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '-' token if present.  <a href="classmlir_1_1AsmParser.html#a202700670a8027a81eac727cde3a5b3f">More...</a><br /></td></tr>
<tr class="separator:a202700670a8027a81eac727cde3a5b3f inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69019eb899e024c81552e6a8c49242fb inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a69019eb899e024c81552e6a8c49242fb">parseStar</a> ()=0</td></tr>
<tr class="memdesc:a69019eb899e024c81552e6a8c49242fb inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '*' token.  <a href="classmlir_1_1AsmParser.html#a69019eb899e024c81552e6a8c49242fb">More...</a><br /></td></tr>
<tr class="separator:a69019eb899e024c81552e6a8c49242fb inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c3fd33e05a68c67aa6787828003bb7 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a95c3fd33e05a68c67aa6787828003bb7">parseOptionalStar</a> ()=0</td></tr>
<tr class="memdesc:a95c3fd33e05a68c67aa6787828003bb7 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '*' token if present.  <a href="classmlir_1_1AsmParser.html#a95c3fd33e05a68c67aa6787828003bb7">More...</a><br /></td></tr>
<tr class="separator:a95c3fd33e05a68c67aa6787828003bb7 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768e85bd4a706332bf6d11b7b6553f4f inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a768e85bd4a706332bf6d11b7b6553f4f">parseVerticalBar</a> ()=0</td></tr>
<tr class="memdesc:a768e85bd4a706332bf6d11b7b6553f4f inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '|' token.  <a href="classmlir_1_1AsmParser.html#a768e85bd4a706332bf6d11b7b6553f4f">More...</a><br /></td></tr>
<tr class="separator:a768e85bd4a706332bf6d11b7b6553f4f inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef0ba9c2ed2a90a41badd85bd629aa4 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#adef0ba9c2ed2a90a41badd85bd629aa4">parseOptionalVerticalBar</a> ()=0</td></tr>
<tr class="memdesc:adef0ba9c2ed2a90a41badd85bd629aa4 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a '|' token if present.  <a href="classmlir_1_1AsmParser.html#adef0ba9c2ed2a90a41badd85bd629aa4">More...</a><br /></td></tr>
<tr class="separator:adef0ba9c2ed2a90a41badd85bd629aa4 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5717e1a12aeeebae3f482a85f95a4628 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a5717e1a12aeeebae3f482a85f95a4628">parseString</a> (std::string *string)</td></tr>
<tr class="memdesc:a5717e1a12aeeebae3f482a85f95a4628 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a quoted string token.  <a href="classmlir_1_1AsmParser.html#a5717e1a12aeeebae3f482a85f95a4628">More...</a><br /></td></tr>
<tr class="separator:a5717e1a12aeeebae3f482a85f95a4628 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903f7c633c673afb8b9d8e59993dcb59 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a903f7c633c673afb8b9d8e59993dcb59">parseOptionalString</a> (std::string *string)=0</td></tr>
<tr class="memdesc:a903f7c633c673afb8b9d8e59993dcb59 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a quoted string token if present.  <a href="classmlir_1_1AsmParser.html#a903f7c633c673afb8b9d8e59993dcb59">More...</a><br /></td></tr>
<tr class="separator:a903f7c633c673afb8b9d8e59993dcb59 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d1dd286f90e302a002ec562f8f6234 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ae0d1dd286f90e302a002ec562f8f6234">parseBase64Bytes</a> (std::vector&lt; char &gt; *bytes)=0</td></tr>
<tr class="memdesc:ae0d1dd286f90e302a002ec562f8f6234 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a Base64 encoded string of bytes.  <a href="classmlir_1_1AsmParser.html#ae0d1dd286f90e302a002ec562f8f6234">More...</a><br /></td></tr>
<tr class="separator:ae0d1dd286f90e302a002ec562f8f6234 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4382d557de477b5b1b7bbfbbf7ba03f inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ab4382d557de477b5b1b7bbfbbf7ba03f">parseLParen</a> ()=0</td></tr>
<tr class="memdesc:ab4382d557de477b5b1b7bbfbbf7ba03f inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>(</code> token.  <a href="classmlir_1_1AsmParser.html#ab4382d557de477b5b1b7bbfbbf7ba03f">More...</a><br /></td></tr>
<tr class="separator:ab4382d557de477b5b1b7bbfbbf7ba03f inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8bb7b19bcdc7638597791aff1bafed inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#aca8bb7b19bcdc7638597791aff1bafed">parseOptionalLParen</a> ()=0</td></tr>
<tr class="memdesc:aca8bb7b19bcdc7638597791aff1bafed inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>(</code> token if present.  <a href="classmlir_1_1AsmParser.html#aca8bb7b19bcdc7638597791aff1bafed">More...</a><br /></td></tr>
<tr class="separator:aca8bb7b19bcdc7638597791aff1bafed inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33657a4e5f2cd8018b6d57d468b5f04a inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a33657a4e5f2cd8018b6d57d468b5f04a">parseRParen</a> ()=0</td></tr>
<tr class="memdesc:a33657a4e5f2cd8018b6d57d468b5f04a inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>)</code> token.  <a href="classmlir_1_1AsmParser.html#a33657a4e5f2cd8018b6d57d468b5f04a">More...</a><br /></td></tr>
<tr class="separator:a33657a4e5f2cd8018b6d57d468b5f04a inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5451069c3f54f92ff35dae3b0b316078 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a5451069c3f54f92ff35dae3b0b316078">parseOptionalRParen</a> ()=0</td></tr>
<tr class="memdesc:a5451069c3f54f92ff35dae3b0b316078 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>)</code> token if present.  <a href="classmlir_1_1AsmParser.html#a5451069c3f54f92ff35dae3b0b316078">More...</a><br /></td></tr>
<tr class="separator:a5451069c3f54f92ff35dae3b0b316078 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354eef7fe28257f8977711d8a0890375 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a354eef7fe28257f8977711d8a0890375">parseLSquare</a> ()=0</td></tr>
<tr class="memdesc:a354eef7fe28257f8977711d8a0890375 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>[</code> token.  <a href="classmlir_1_1AsmParser.html#a354eef7fe28257f8977711d8a0890375">More...</a><br /></td></tr>
<tr class="separator:a354eef7fe28257f8977711d8a0890375 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed41da9f5ed12ea4b41136ef1b6239dd inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#aed41da9f5ed12ea4b41136ef1b6239dd">parseOptionalLSquare</a> ()=0</td></tr>
<tr class="memdesc:aed41da9f5ed12ea4b41136ef1b6239dd inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>[</code> token if present.  <a href="classmlir_1_1AsmParser.html#aed41da9f5ed12ea4b41136ef1b6239dd">More...</a><br /></td></tr>
<tr class="separator:aed41da9f5ed12ea4b41136ef1b6239dd inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1446df423154a41d52374b062ee1ff inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a3a1446df423154a41d52374b062ee1ff">parseRSquare</a> ()=0</td></tr>
<tr class="memdesc:a3a1446df423154a41d52374b062ee1ff inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>]</code> token.  <a href="classmlir_1_1AsmParser.html#a3a1446df423154a41d52374b062ee1ff">More...</a><br /></td></tr>
<tr class="separator:a3a1446df423154a41d52374b062ee1ff inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb77758ffb3701ad5ede6299de580f0 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#aacb77758ffb3701ad5ede6299de580f0">parseOptionalRSquare</a> ()=0</td></tr>
<tr class="memdesc:aacb77758ffb3701ad5ede6299de580f0 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>]</code> token if present.  <a href="classmlir_1_1AsmParser.html#aacb77758ffb3701ad5ede6299de580f0">More...</a><br /></td></tr>
<tr class="separator:aacb77758ffb3701ad5ede6299de580f0 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd6389c75de4247835462e1c795da0d inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#abfd6389c75de4247835462e1c795da0d">parseEllipsis</a> ()=0</td></tr>
<tr class="memdesc:abfd6389c75de4247835462e1c795da0d inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>...</code> token.  <a href="classmlir_1_1AsmParser.html#abfd6389c75de4247835462e1c795da0d">More...</a><br /></td></tr>
<tr class="separator:abfd6389c75de4247835462e1c795da0d inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab708b0a33e137f348363c2aa27c89fbd inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ab708b0a33e137f348363c2aa27c89fbd">parseOptionalEllipsis</a> ()=0</td></tr>
<tr class="memdesc:ab708b0a33e137f348363c2aa27c89fbd inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a <code>...</code> token if present;.  <a href="classmlir_1_1AsmParser.html#ab708b0a33e137f348363c2aa27c89fbd">More...</a><br /></td></tr>
<tr class="separator:ab708b0a33e137f348363c2aa27c89fbd inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae777f03268a68dd4b1c5368b149e4d82 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ae777f03268a68dd4b1c5368b149e4d82">parseFloat</a> (double &amp;result)=0</td></tr>
<tr class="memdesc:ae777f03268a68dd4b1c5368b149e4d82 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a floating point value from the stream.  <a href="classmlir_1_1AsmParser.html#ae777f03268a68dd4b1c5368b149e4d82">More...</a><br /></td></tr>
<tr class="separator:ae777f03268a68dd4b1c5368b149e4d82 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6438ed22c164a58d86db859edd7ed8c6 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a6438ed22c164a58d86db859edd7ed8c6">parseFloat</a> (const llvm::fltSemantics &amp;semantics, APFloat &amp;result)=0</td></tr>
<tr class="memdesc:a6438ed22c164a58d86db859edd7ed8c6 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a floating point value into APFloat from the stream.  <a href="classmlir_1_1AsmParser.html#a6438ed22c164a58d86db859edd7ed8c6">More...</a><br /></td></tr>
<tr class="separator:a6438ed22c164a58d86db859edd7ed8c6 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4034dff64870321209dc1253fc799870 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename IntT &gt; </td></tr>
<tr class="memitem:a4034dff64870321209dc1253fc799870 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a4034dff64870321209dc1253fc799870">parseInteger</a> (IntT &amp;result)</td></tr>
<tr class="memdesc:a4034dff64870321209dc1253fc799870 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an integer value from the stream.  <a href="classmlir_1_1AsmParser.html#a4034dff64870321209dc1253fc799870">More...</a><br /></td></tr>
<tr class="separator:a4034dff64870321209dc1253fc799870 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f767f734ccfd669fcaf3cfc996208a2 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename IntT &gt; </td></tr>
<tr class="memitem:a1f767f734ccfd669fcaf3cfc996208a2 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a1f767f734ccfd669fcaf3cfc996208a2">parseDecimalInteger</a> (IntT &amp;result)</td></tr>
<tr class="memdesc:a1f767f734ccfd669fcaf3cfc996208a2 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a decimal integer value from the stream.  <a href="classmlir_1_1AsmParser.html#a1f767f734ccfd669fcaf3cfc996208a2">More...</a><br /></td></tr>
<tr class="separator:a1f767f734ccfd669fcaf3cfc996208a2 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfa785dd4e270b0c87016feb006ca85 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a0cfa785dd4e270b0c87016feb006ca85">parseOptionalInteger</a> (APInt &amp;result)=0</td></tr>
<tr class="memdesc:a0cfa785dd4e270b0c87016feb006ca85 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an optional integer value from the stream.  <a href="classmlir_1_1AsmParser.html#a0cfa785dd4e270b0c87016feb006ca85">More...</a><br /></td></tr>
<tr class="separator:a0cfa785dd4e270b0c87016feb006ca85 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46159faa836b872aca6a137132954790 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a46159faa836b872aca6a137132954790">parseOptionalDecimalInteger</a> (APInt &amp;result)=0</td></tr>
<tr class="separator:a46159faa836b872aca6a137132954790 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925473b3e39277944c0aadadc30783c1 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename IntT &gt; </td></tr>
<tr class="memitem:a925473b3e39277944c0aadadc30783c1 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a925473b3e39277944c0aadadc30783c1">parseOptionalInteger</a> (IntT &amp;result)</td></tr>
<tr class="separator:a925473b3e39277944c0aadadc30783c1 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab208a7d128eff4881761efc8b6030638 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename IntT &gt; </td></tr>
<tr class="memitem:ab208a7d128eff4881761efc8b6030638 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ab208a7d128eff4881761efc8b6030638">parseOptionalDecimalInteger</a> (IntT &amp;result)</td></tr>
<tr class="separator:ab208a7d128eff4881761efc8b6030638 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2839f5b817f7fd118a6b0381da695436 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a2839f5b817f7fd118a6b0381da695436">parseCommaSeparatedList</a> (<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">Delimiter</a> delimiter, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; ParseResult()&gt; parseElementFn, StringRef contextMessage=StringRef())=0</td></tr>
<tr class="memdesc:a2839f5b817f7fd118a6b0381da695436 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a list of comma-separated items with an optional delimiter.  <a href="classmlir_1_1AsmParser.html#a2839f5b817f7fd118a6b0381da695436">More...</a><br /></td></tr>
<tr class="separator:a2839f5b817f7fd118a6b0381da695436 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75854cd8289ea57128430809724b62a0 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a75854cd8289ea57128430809724b62a0">parseCommaSeparatedList</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; ParseResult()&gt; parseElementFn)</td></tr>
<tr class="memdesc:a75854cd8289ea57128430809724b62a0 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a comma separated list of elements that must have at least one entry in it.  <a href="classmlir_1_1AsmParser.html#a75854cd8289ea57128430809724b62a0">More...</a><br /></td></tr>
<tr class="separator:a75854cd8289ea57128430809724b62a0 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebff8eb3c3728866721b4eaabd3a29a4 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#aebff8eb3c3728866721b4eaabd3a29a4">parseKeyword</a> (StringRef keyword)</td></tr>
<tr class="memdesc:aebff8eb3c3728866721b4eaabd3a29a4 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a given keyword.  <a href="classmlir_1_1AsmParser.html#aebff8eb3c3728866721b4eaabd3a29a4">More...</a><br /></td></tr>
<tr class="separator:aebff8eb3c3728866721b4eaabd3a29a4 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affeb3526bfce71223b4d7b0412de0716 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#affeb3526bfce71223b4d7b0412de0716">parseKeyword</a> (StringRef keyword, const Twine &amp;msg)=0</td></tr>
<tr class="separator:affeb3526bfce71223b4d7b0412de0716 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e244ba4010e0db7fedf495697d5a82 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a26e244ba4010e0db7fedf495697d5a82">parseKeyword</a> (StringRef *keyword)</td></tr>
<tr class="memdesc:a26e244ba4010e0db7fedf495697d5a82 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a keyword into 'keyword'.  <a href="classmlir_1_1AsmParser.html#a26e244ba4010e0db7fedf495697d5a82">More...</a><br /></td></tr>
<tr class="separator:a26e244ba4010e0db7fedf495697d5a82 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305f6334c61eb92a164bd865851f55f4 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a305f6334c61eb92a164bd865851f55f4">parseOptionalKeyword</a> (StringRef keyword)=0</td></tr>
<tr class="memdesc:a305f6334c61eb92a164bd865851f55f4 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the given keyword if present.  <a href="classmlir_1_1AsmParser.html#a305f6334c61eb92a164bd865851f55f4">More...</a><br /></td></tr>
<tr class="separator:a305f6334c61eb92a164bd865851f55f4 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9922fa23143b37e9b1ff0404cca58a1 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ae9922fa23143b37e9b1ff0404cca58a1">parseOptionalKeyword</a> (StringRef *keyword)=0</td></tr>
<tr class="memdesc:ae9922fa23143b37e9b1ff0404cca58a1 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a keyword, if present, into 'keyword'.  <a href="classmlir_1_1AsmParser.html#ae9922fa23143b37e9b1ff0404cca58a1">More...</a><br /></td></tr>
<tr class="separator:ae9922fa23143b37e9b1ff0404cca58a1 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a52270ccc4f4f542b8c0d1e9d10fb87 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a5a52270ccc4f4f542b8c0d1e9d10fb87">parseOptionalKeyword</a> (StringRef *keyword, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; allowedValues)=0</td></tr>
<tr class="memdesc:a5a52270ccc4f4f542b8c0d1e9d10fb87 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a keyword, if present, and if one of the 'allowedValues', into 'keyword'.  <a href="classmlir_1_1AsmParser.html#a5a52270ccc4f4f542b8c0d1e9d10fb87">More...</a><br /></td></tr>
<tr class="separator:a5a52270ccc4f4f542b8c0d1e9d10fb87 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c7342ef0e73b9140eaf6fb091ad7df inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a47c7342ef0e73b9140eaf6fb091ad7df">parseKeywordOrString</a> (std::string *result)</td></tr>
<tr class="memdesc:a47c7342ef0e73b9140eaf6fb091ad7df inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a keyword or a quoted string.  <a href="classmlir_1_1AsmParser.html#a47c7342ef0e73b9140eaf6fb091ad7df">More...</a><br /></td></tr>
<tr class="separator:a47c7342ef0e73b9140eaf6fb091ad7df inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15afcc2b04a93de0fe89aac0d0bf8a87 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a15afcc2b04a93de0fe89aac0d0bf8a87">parseOptionalKeywordOrString</a> (std::string *result)=0</td></tr>
<tr class="memdesc:a15afcc2b04a93de0fe89aac0d0bf8a87 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an optional keyword or string.  <a href="classmlir_1_1AsmParser.html#a15afcc2b04a93de0fe89aac0d0bf8a87">More...</a><br /></td></tr>
<tr class="separator:a15afcc2b04a93de0fe89aac0d0bf8a87 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec648bf1f265375347162bd1d70c85d inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... ParamsT&gt; </td></tr>
<tr class="memitem:a7ec648bf1f265375347162bd1d70c85d inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a7ec648bf1f265375347162bd1d70c85d">getChecked</a> (SMLoc loc, ParamsT &amp;&amp;...params)</td></tr>
<tr class="memdesc:a7ec648bf1f265375347162bd1d70c85d inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the <code>getChecked</code> method of the given <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> or <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> class, using the provided location to emit errors in the case of failure.  <a href="classmlir_1_1AsmParser.html#a7ec648bf1f265375347162bd1d70c85d">More...</a><br /></td></tr>
<tr class="separator:a7ec648bf1f265375347162bd1d70c85d inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a60e349e364f7addb26f3e63d2a083 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... ParamsT&gt; </td></tr>
<tr class="memitem:ac2a60e349e364f7addb26f3e63d2a083 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ac2a60e349e364f7addb26f3e63d2a083">getChecked</a> (ParamsT &amp;&amp;...params)</td></tr>
<tr class="memdesc:ac2a60e349e364f7addb26f3e63d2a083 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <code>getChecked</code> that uses the result of <code>getNameLoc</code> to emit errors.  <a href="classmlir_1_1AsmParser.html#ac2a60e349e364f7addb26f3e63d2a083">More...</a><br /></td></tr>
<tr class="separator:ac2a60e349e364f7addb26f3e63d2a083 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc30172e59d0a9e4a28d8ba7ddf1ac42 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">parseAttribute</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;result, <a class="el" href="classmlir_1_1Type.html">Type</a> type={})=0</td></tr>
<tr class="memdesc:afc30172e59d0a9e4a28d8ba7ddf1ac42 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an arbitrary attribute of a given type and return it in result.  <a href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">More...</a><br /></td></tr>
<tr class="separator:afc30172e59d0a9e4a28d8ba7ddf1ac42 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549cd58b084b7ffdd299334506ba2aee inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a549cd58b084b7ffdd299334506ba2aee">parseCustomAttributeWithFallback</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;result, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; ParseResult(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;result, <a class="el" href="classmlir_1_1Type.html">Type</a> type)&gt; <a class="el" href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">parseAttribute</a>)=0</td></tr>
<tr class="memdesc:a549cd58b084b7ffdd299334506ba2aee inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a custom attribute with the provided callback, unless the next token is <code>#</code>, in which case the generic parser is invoked.  <a href="classmlir_1_1AsmParser.html#a549cd58b084b7ffdd299334506ba2aee">More...</a><br /></td></tr>
<tr class="separator:a549cd58b084b7ffdd299334506ba2aee inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479218e2b5ce9987e57eb625330712d8 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename AttrType &gt; </td></tr>
<tr class="memitem:a479218e2b5ce9987e57eb625330712d8 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a479218e2b5ce9987e57eb625330712d8">parseAttribute</a> (AttrType &amp;result, <a class="el" href="classmlir_1_1Type.html">Type</a> type={})</td></tr>
<tr class="memdesc:a479218e2b5ce9987e57eb625330712d8 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an attribute of a specific kind and type.  <a href="classmlir_1_1AsmParser.html#a479218e2b5ce9987e57eb625330712d8">More...</a><br /></td></tr>
<tr class="separator:a479218e2b5ce9987e57eb625330712d8 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8586994be613a57d010224eabbf3bc8f inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a8586994be613a57d010224eabbf3bc8f">parseAttribute</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;result, StringRef attrName, <a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;attrs)</td></tr>
<tr class="memdesc:a8586994be613a57d010224eabbf3bc8f inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an arbitrary attribute and return it in result.  <a href="classmlir_1_1AsmParser.html#a8586994be613a57d010224eabbf3bc8f">More...</a><br /></td></tr>
<tr class="separator:a8586994be613a57d010224eabbf3bc8f inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba450abf880072f1b41ce9383794ccf7 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename AttrType &gt; </td></tr>
<tr class="memitem:aba450abf880072f1b41ce9383794ccf7 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#aba450abf880072f1b41ce9383794ccf7">parseAttribute</a> (AttrType &amp;result, StringRef attrName, <a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;attrs)</td></tr>
<tr class="memdesc:aba450abf880072f1b41ce9383794ccf7 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an attribute of a specific kind and type.  <a href="classmlir_1_1AsmParser.html#aba450abf880072f1b41ce9383794ccf7">More...</a><br /></td></tr>
<tr class="separator:aba450abf880072f1b41ce9383794ccf7 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472a515c4034eae4e8a424d76abfb296 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename AttrType &gt; </td></tr>
<tr class="memitem:a472a515c4034eae4e8a424d76abfb296 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a472a515c4034eae4e8a424d76abfb296">parseAttribute</a> (AttrType &amp;result, <a class="el" href="classmlir_1_1Type.html">Type</a> type, StringRef attrName, <a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;attrs)</td></tr>
<tr class="memdesc:a472a515c4034eae4e8a424d76abfb296 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an arbitrary attribute of a given type and populate it in <code>result</code>.  <a href="classmlir_1_1AsmParser.html#a472a515c4034eae4e8a424d76abfb296">More...</a><br /></td></tr>
<tr class="separator:a472a515c4034eae4e8a424d76abfb296 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af438e74aa398c0308a189339452918fc inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename AttrType &gt; </td></tr>
<tr class="memitem:af438e74aa398c0308a189339452918fc inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="classmlir_1_1AsmParser.html#a009f2fa8545f56ece83e1a53eee0fb99">detect_has_parse_method</a>&lt; AttrType &gt;::value, ParseResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#af438e74aa398c0308a189339452918fc">parseCustomAttributeWithFallback</a> (AttrType &amp;result, <a class="el" href="classmlir_1_1Type.html">Type</a> type, StringRef attrName, <a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;attrs)</td></tr>
<tr class="memdesc:af438e74aa398c0308a189339452918fc inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a custom attribute of a given type unless the next token is <code>#</code>, in which case the generic parser is invoked.  <a href="classmlir_1_1AsmParser.html#af438e74aa398c0308a189339452918fc">More...</a><br /></td></tr>
<tr class="separator:af438e74aa398c0308a189339452918fc inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616dc2ddf87ad9f4616b4f86f4869a7f inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename AttrType &gt; </td></tr>
<tr class="memitem:a616dc2ddf87ad9f4616b4f86f4869a7f inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="classmlir_1_1AsmParser.html#a009f2fa8545f56ece83e1a53eee0fb99">detect_has_parse_method</a>&lt; AttrType &gt;::value, ParseResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a616dc2ddf87ad9f4616b4f86f4869a7f">parseCustomAttributeWithFallback</a> (AttrType &amp;result, <a class="el" href="classmlir_1_1Type.html">Type</a> type, StringRef attrName, <a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;attrs)</td></tr>
<tr class="memdesc:a616dc2ddf87ad9f4616b4f86f4869a7f inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE parsing method for <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> that don't implement a parse method.  <a href="classmlir_1_1AsmParser.html#a616dc2ddf87ad9f4616b4f86f4869a7f">More...</a><br /></td></tr>
<tr class="separator:a616dc2ddf87ad9f4616b4f86f4869a7f inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b912acc98b23b262424216cf9e3014 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename AttrType &gt; </td></tr>
<tr class="memitem:a74b912acc98b23b262424216cf9e3014 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="classmlir_1_1AsmParser.html#a009f2fa8545f56ece83e1a53eee0fb99">detect_has_parse_method</a>&lt; AttrType &gt;::value, ParseResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a74b912acc98b23b262424216cf9e3014">parseCustomAttributeWithFallback</a> (AttrType &amp;result, <a class="el" href="classmlir_1_1Type.html">Type</a> type={})</td></tr>
<tr class="memdesc:a74b912acc98b23b262424216cf9e3014 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a custom attribute of a given type unless the next token is <code>#</code>, in which case the generic parser is invoked.  <a href="classmlir_1_1AsmParser.html#a74b912acc98b23b262424216cf9e3014">More...</a><br /></td></tr>
<tr class="separator:a74b912acc98b23b262424216cf9e3014 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74af15c5542af30e7a6e96b242d5c72 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename AttrType &gt; </td></tr>
<tr class="memitem:ab74af15c5542af30e7a6e96b242d5c72 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="classmlir_1_1AsmParser.html#a009f2fa8545f56ece83e1a53eee0fb99">detect_has_parse_method</a>&lt; AttrType &gt;::value, ParseResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ab74af15c5542af30e7a6e96b242d5c72">parseCustomAttributeWithFallback</a> (AttrType &amp;result, <a class="el" href="classmlir_1_1Type.html">Type</a> type={})</td></tr>
<tr class="memdesc:ab74af15c5542af30e7a6e96b242d5c72 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE parsing method for <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> that don't implement a parse method.  <a href="classmlir_1_1AsmParser.html#ab74af15c5542af30e7a6e96b242d5c72">More...</a><br /></td></tr>
<tr class="separator:ab74af15c5542af30e7a6e96b242d5c72 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71146cf4bb8b8d1454abc423ef4b8c27 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a71146cf4bb8b8d1454abc423ef4b8c27">parseOptionalAttribute</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;result, <a class="el" href="classmlir_1_1Type.html">Type</a> type={})=0</td></tr>
<tr class="memdesc:a71146cf4bb8b8d1454abc423ef4b8c27 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an arbitrary optional attribute of a given type and return it in result.  <a href="classmlir_1_1AsmParser.html#a71146cf4bb8b8d1454abc423ef4b8c27">More...</a><br /></td></tr>
<tr class="separator:a71146cf4bb8b8d1454abc423ef4b8c27 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663a90d94683b02961ccd0f96fb7087a inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a663a90d94683b02961ccd0f96fb7087a">parseOptionalAttribute</a> (ArrayAttr &amp;result, <a class="el" href="classmlir_1_1Type.html">Type</a> type={})=0</td></tr>
<tr class="memdesc:a663a90d94683b02961ccd0f96fb7087a inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an optional array attribute and return it in result.  <a href="classmlir_1_1AsmParser.html#a663a90d94683b02961ccd0f96fb7087a">More...</a><br /></td></tr>
<tr class="separator:a663a90d94683b02961ccd0f96fb7087a inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c1bc31ca447b03f57f5cbe441af436 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a88c1bc31ca447b03f57f5cbe441af436">parseOptionalAttribute</a> (StringAttr &amp;result, <a class="el" href="classmlir_1_1Type.html">Type</a> type={})=0</td></tr>
<tr class="memdesc:a88c1bc31ca447b03f57f5cbe441af436 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an optional string attribute and return it in result.  <a href="classmlir_1_1AsmParser.html#a88c1bc31ca447b03f57f5cbe441af436">More...</a><br /></td></tr>
<tr class="separator:a88c1bc31ca447b03f57f5cbe441af436 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baad1864d801780a2f22df3197cc71d inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a9baad1864d801780a2f22df3197cc71d">parseOptionalAttribute</a> (SymbolRefAttr &amp;result, <a class="el" href="classmlir_1_1Type.html">Type</a> type={})=0</td></tr>
<tr class="memdesc:a9baad1864d801780a2f22df3197cc71d inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an optional symbol ref attribute and return it in result.  <a href="classmlir_1_1AsmParser.html#a9baad1864d801780a2f22df3197cc71d">More...</a><br /></td></tr>
<tr class="separator:a9baad1864d801780a2f22df3197cc71d inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e64962cd5ee42e5d9828aeeafa5b58a inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename AttrType &gt; </td></tr>
<tr class="memitem:a7e64962cd5ee42e5d9828aeeafa5b58a inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a7e64962cd5ee42e5d9828aeeafa5b58a">parseOptionalAttribute</a> (AttrType &amp;result, StringRef attrName, <a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;attrs)</td></tr>
<tr class="memdesc:a7e64962cd5ee42e5d9828aeeafa5b58a inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an optional attribute of a specific type and add it to the list with the specified name.  <a href="classmlir_1_1AsmParser.html#a7e64962cd5ee42e5d9828aeeafa5b58a">More...</a><br /></td></tr>
<tr class="separator:a7e64962cd5ee42e5d9828aeeafa5b58a inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9732cc6e8f412fcb479a3055b5928f8c inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename AttrType &gt; </td></tr>
<tr class="memitem:a9732cc6e8f412fcb479a3055b5928f8c inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a9732cc6e8f412fcb479a3055b5928f8c">parseOptionalAttribute</a> (AttrType &amp;result, <a class="el" href="classmlir_1_1Type.html">Type</a> type, StringRef attrName, <a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;attrs)</td></tr>
<tr class="memdesc:a9732cc6e8f412fcb479a3055b5928f8c inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an optional attribute of a specific type and add it to the list with the specified name.  <a href="classmlir_1_1AsmParser.html#a9732cc6e8f412fcb479a3055b5928f8c">More...</a><br /></td></tr>
<tr class="separator:a9732cc6e8f412fcb479a3055b5928f8c inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf4b8149e630797ac1ac90d8e118c4b inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a2bf4b8149e630797ac1ac90d8e118c4b">parseOptionalAttrDict</a> (<a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;result)=0</td></tr>
<tr class="memdesc:a2bf4b8149e630797ac1ac90d8e118c4b inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a named dictionary into 'result' if it is present.  <a href="classmlir_1_1AsmParser.html#a2bf4b8149e630797ac1ac90d8e118c4b">More...</a><br /></td></tr>
<tr class="separator:a2bf4b8149e630797ac1ac90d8e118c4b inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db278b74a263f4222bc92c534bbd0f0 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a6db278b74a263f4222bc92c534bbd0f0">parseOptionalAttrDictWithKeyword</a> (<a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;result)=0</td></tr>
<tr class="memdesc:a6db278b74a263f4222bc92c534bbd0f0 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a named dictionary into 'result' if the <code>attributes</code> keyword is present.  <a href="classmlir_1_1AsmParser.html#a6db278b74a263f4222bc92c534bbd0f0">More...</a><br /></td></tr>
<tr class="separator:a6db278b74a263f4222bc92c534bbd0f0 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efddbd9e378c89e5fe4009dee87654e inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a4efddbd9e378c89e5fe4009dee87654e">parseAffineMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map)=0</td></tr>
<tr class="memdesc:a4efddbd9e378c89e5fe4009dee87654e inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an affine map instance into 'map'.  <a href="classmlir_1_1AsmParser.html#a4efddbd9e378c89e5fe4009dee87654e">More...</a><br /></td></tr>
<tr class="separator:a4efddbd9e378c89e5fe4009dee87654e inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac318882b06010d0d669cb0b1b8aa9d65 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ac318882b06010d0d669cb0b1b8aa9d65">parseAffineExpr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; StringRef, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&gt; symbolSet, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;expr)=0</td></tr>
<tr class="memdesc:ac318882b06010d0d669cb0b1b8aa9d65 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an affine expr instance into 'expr' using the already computed mapping from symbols to affine expressions in 'symbolSet'.  <a href="classmlir_1_1AsmParser.html#ac318882b06010d0d669cb0b1b8aa9d65">More...</a><br /></td></tr>
<tr class="separator:ac318882b06010d0d669cb0b1b8aa9d65 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1334188e41e2eac91cff28a37a01b0b0 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a1334188e41e2eac91cff28a37a01b0b0">parseIntegerSet</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> &amp;set)=0</td></tr>
<tr class="memdesc:a1334188e41e2eac91cff28a37a01b0b0 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an integer set instance into 'set'.  <a href="classmlir_1_1AsmParser.html#a1334188e41e2eac91cff28a37a01b0b0">More...</a><br /></td></tr>
<tr class="separator:a1334188e41e2eac91cff28a37a01b0b0 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02477a10d39446f2684214055eecccd5 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a02477a10d39446f2684214055eecccd5">parseSymbolName</a> (StringAttr &amp;result)</td></tr>
<tr class="memdesc:a02477a10d39446f2684214055eecccd5 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an -identifier and store it (without the '@' symbol) in a string attribute.  <a href="classmlir_1_1AsmParser.html#a02477a10d39446f2684214055eecccd5">More...</a><br /></td></tr>
<tr class="separator:a02477a10d39446f2684214055eecccd5 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83b46592379f850649ed5d24c79f66b inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ae83b46592379f850649ed5d24c79f66b">parseSymbolName</a> (StringAttr &amp;result, StringRef attrName, <a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;attrs)</td></tr>
<tr class="memdesc:ae83b46592379f850649ed5d24c79f66b inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an -identifier and store it (without the '@' symbol) in a string attribute named 'attrName'.  <a href="classmlir_1_1AsmParser.html#ae83b46592379f850649ed5d24c79f66b">More...</a><br /></td></tr>
<tr class="separator:ae83b46592379f850649ed5d24c79f66b inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4fad5c4f55c093f7f2ab01cfc63650 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a1c4fad5c4f55c093f7f2ab01cfc63650">parseOptionalSymbolName</a> (StringAttr &amp;result)=0</td></tr>
<tr class="memdesc:a1c4fad5c4f55c093f7f2ab01cfc63650 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an optional -identifier and store it (without the '@' symbol) in a string attribute.  <a href="classmlir_1_1AsmParser.html#a1c4fad5c4f55c093f7f2ab01cfc63650">More...</a><br /></td></tr>
<tr class="separator:a1c4fad5c4f55c093f7f2ab01cfc63650 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44018f4053f93fa6b281b29e7aaf49b6 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a44018f4053f93fa6b281b29e7aaf49b6">parseOptionalSymbolName</a> (StringAttr &amp;result, StringRef attrName, <a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;attrs)</td></tr>
<tr class="memdesc:a44018f4053f93fa6b281b29e7aaf49b6 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an optional -identifier and store it (without the '@' symbol) in a string attribute named 'attrName'.  <a href="classmlir_1_1AsmParser.html#a44018f4053f93fa6b281b29e7aaf49b6">More...</a><br /></td></tr>
<tr class="separator:a44018f4053f93fa6b281b29e7aaf49b6 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f91a8befcb603d6d7eb7390876814b inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename ResourceT &gt; </td></tr>
<tr class="memitem:af9f91a8befcb603d6d7eb7390876814b inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; ResourceT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#af9f91a8befcb603d6d7eb7390876814b">parseResourceHandle</a> ()</td></tr>
<tr class="memdesc:af9f91a8befcb603d6d7eb7390876814b inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a handle to a resource within the assembly format.  <a href="classmlir_1_1AsmParser.html#af9f91a8befcb603d6d7eb7390876814b">More...</a><br /></td></tr>
<tr class="separator:af9f91a8befcb603d6d7eb7390876814b inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85d23c93adf11e18d6507779bf95fad inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ab85d23c93adf11e18d6507779bf95fad">parseType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> &amp;result)=0</td></tr>
<tr class="memdesc:ab85d23c93adf11e18d6507779bf95fad inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a type.  <a href="classmlir_1_1AsmParser.html#ab85d23c93adf11e18d6507779bf95fad">More...</a><br /></td></tr>
<tr class="separator:ab85d23c93adf11e18d6507779bf95fad inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637463bf8149cbc3c35e9fdca474f2a3 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a637463bf8149cbc3c35e9fdca474f2a3">parseCustomTypeWithFallback</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> &amp;result, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; ParseResult(<a class="el" href="classmlir_1_1Type.html">Type</a> &amp;result)&gt; <a class="el" href="classmlir_1_1AsmParser.html#ab85d23c93adf11e18d6507779bf95fad">parseType</a>)=0</td></tr>
<tr class="memdesc:a637463bf8149cbc3c35e9fdca474f2a3 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a custom type with the provided callback, unless the next token is <code>#</code>, in which case the generic parser is invoked.  <a href="classmlir_1_1AsmParser.html#a637463bf8149cbc3c35e9fdca474f2a3">More...</a><br /></td></tr>
<tr class="separator:a637463bf8149cbc3c35e9fdca474f2a3 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3153b88a176fa97fda06cf4b4210ecca inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a3153b88a176fa97fda06cf4b4210ecca">parseOptionalType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> &amp;result)=0</td></tr>
<tr class="memdesc:a3153b88a176fa97fda06cf4b4210ecca inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an optional type.  <a href="classmlir_1_1AsmParser.html#a3153b88a176fa97fda06cf4b4210ecca">More...</a><br /></td></tr>
<tr class="separator:a3153b88a176fa97fda06cf4b4210ecca inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac48ee09ac84aa8cab570cf719530b6b inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename TypeT &gt; </td></tr>
<tr class="memitem:aac48ee09ac84aa8cab570cf719530b6b inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#aac48ee09ac84aa8cab570cf719530b6b">parseType</a> (TypeT &amp;result)</td></tr>
<tr class="memdesc:aac48ee09ac84aa8cab570cf719530b6b inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a type of a specific type.  <a href="classmlir_1_1AsmParser.html#aac48ee09ac84aa8cab570cf719530b6b">More...</a><br /></td></tr>
<tr class="separator:aac48ee09ac84aa8cab570cf719530b6b inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ffd130df85a334861dd6ae9f2b849b inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename TypeT &gt; </td></tr>
<tr class="memitem:a82ffd130df85a334861dd6ae9f2b849b inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="classmlir_1_1AsmParser.html#ae6e01b7c9e041bedade5a24621b6221c">detect_type_has_parse_method</a>&lt; TypeT &gt;::value, ParseResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a82ffd130df85a334861dd6ae9f2b849b">parseCustomTypeWithFallback</a> (TypeT &amp;result)</td></tr>
<tr class="memdesc:a82ffd130df85a334861dd6ae9f2b849b inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a custom <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> of a given type unless the next token is <code>#</code>, in which case the generic parser is invoked.  <a href="classmlir_1_1AsmParser.html#a82ffd130df85a334861dd6ae9f2b849b">More...</a><br /></td></tr>
<tr class="separator:a82ffd130df85a334861dd6ae9f2b849b inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e34f800847c7b46d0f59188eab4291 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename TypeT &gt; </td></tr>
<tr class="memitem:a32e34f800847c7b46d0f59188eab4291 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="classmlir_1_1AsmParser.html#ae6e01b7c9e041bedade5a24621b6221c">detect_type_has_parse_method</a>&lt; TypeT &gt;::value, ParseResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a32e34f800847c7b46d0f59188eab4291">parseCustomTypeWithFallback</a> (TypeT &amp;result)</td></tr>
<tr class="memdesc:a32e34f800847c7b46d0f59188eab4291 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE parsing method for <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> that don't implement a parse method.  <a href="classmlir_1_1AsmParser.html#a32e34f800847c7b46d0f59188eab4291">More...</a><br /></td></tr>
<tr class="separator:a32e34f800847c7b46d0f59188eab4291 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf96ba07fce8e97b2176381a28fdc58b inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#adf96ba07fce8e97b2176381a28fdc58b">parseTypeList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:adf96ba07fce8e97b2176381a28fdc58b inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a type list.  <a href="classmlir_1_1AsmParser.html#adf96ba07fce8e97b2176381a28fdc58b">More...</a><br /></td></tr>
<tr class="separator:adf96ba07fce8e97b2176381a28fdc58b inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad139546e9f4d72c44d58721646d64541 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ad139546e9f4d72c44d58721646d64541">parseArrowTypeList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)=0</td></tr>
<tr class="memdesc:ad139546e9f4d72c44d58721646d64541 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an arrow followed by a type list.  <a href="classmlir_1_1AsmParser.html#ad139546e9f4d72c44d58721646d64541">More...</a><br /></td></tr>
<tr class="separator:ad139546e9f4d72c44d58721646d64541 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dd551c69e3209e1d5ca180c4778362 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ac8dd551c69e3209e1d5ca180c4778362">parseOptionalArrowTypeList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)=0</td></tr>
<tr class="memdesc:ac8dd551c69e3209e1d5ca180c4778362 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an optional arrow followed by a type list.  <a href="classmlir_1_1AsmParser.html#ac8dd551c69e3209e1d5ca180c4778362">More...</a><br /></td></tr>
<tr class="separator:ac8dd551c69e3209e1d5ca180c4778362 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709cff503c00735e0a35ecd795364a2a inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a709cff503c00735e0a35ecd795364a2a">parseColonType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> &amp;result)=0</td></tr>
<tr class="memdesc:a709cff503c00735e0a35ecd795364a2a inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a colon followed by a type.  <a href="classmlir_1_1AsmParser.html#a709cff503c00735e0a35ecd795364a2a">More...</a><br /></td></tr>
<tr class="separator:a709cff503c00735e0a35ecd795364a2a inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02bfd87e3225dceae6165cf8dd25cbb inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename TypeType &gt; </td></tr>
<tr class="memitem:ab02bfd87e3225dceae6165cf8dd25cbb inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ab02bfd87e3225dceae6165cf8dd25cbb">parseColonType</a> (TypeType &amp;result)</td></tr>
<tr class="memdesc:ab02bfd87e3225dceae6165cf8dd25cbb inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a colon followed by a type of a specific kind, e.g. a FunctionType.  <a href="classmlir_1_1AsmParser.html#ab02bfd87e3225dceae6165cf8dd25cbb">More...</a><br /></td></tr>
<tr class="separator:ab02bfd87e3225dceae6165cf8dd25cbb inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1313f3689e72471402e478d479ff269b inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a1313f3689e72471402e478d479ff269b">parseColonTypeList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)=0</td></tr>
<tr class="memdesc:a1313f3689e72471402e478d479ff269b inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a colon followed by a type list, which must have at least one type.  <a href="classmlir_1_1AsmParser.html#a1313f3689e72471402e478d479ff269b">More...</a><br /></td></tr>
<tr class="separator:a1313f3689e72471402e478d479ff269b inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401c803f8bc13ba30fc39847e188c6a0 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a401c803f8bc13ba30fc39847e188c6a0">parseOptionalColonTypeList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)=0</td></tr>
<tr class="memdesc:a401c803f8bc13ba30fc39847e188c6a0 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an optional colon followed by a type list, which if present must have at least one type.  <a href="classmlir_1_1AsmParser.html#a401c803f8bc13ba30fc39847e188c6a0">More...</a><br /></td></tr>
<tr class="separator:a401c803f8bc13ba30fc39847e188c6a0 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc75e09332516972e8055069673930d inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#acbc75e09332516972e8055069673930d">parseKeywordType</a> (const char *keyword, <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;result)</td></tr>
<tr class="memdesc:acbc75e09332516972e8055069673930d inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a keyword followed by a type.  <a href="classmlir_1_1AsmParser.html#acbc75e09332516972e8055069673930d">More...</a><br /></td></tr>
<tr class="separator:acbc75e09332516972e8055069673930d inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5388726df20380e9ec64e547a0666cb5 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a5388726df20380e9ec64e547a0666cb5">addTypeToList</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a5388726df20380e9ec64e547a0666cb5 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the specified type to the end of the specified type list and return success.  <a href="classmlir_1_1AsmParser.html#a5388726df20380e9ec64e547a0666cb5">More...</a><br /></td></tr>
<tr class="separator:a5388726df20380e9ec64e547a0666cb5 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822a59d034af9593e68c586daa85a731 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a822a59d034af9593e68c586daa85a731">addTypesToList</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; types, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a822a59d034af9593e68c586daa85a731 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the specified types to the end of the specified type list and return success.  <a href="classmlir_1_1AsmParser.html#a822a59d034af9593e68c586daa85a731">More...</a><br /></td></tr>
<tr class="separator:a822a59d034af9593e68c586daa85a731 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d178f0d42011618d0c479b1d48cc0a inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a55d178f0d42011618d0c479b1d48cc0a">parseDimensionList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;dimensions, bool allowDynamic=true, bool withTrailingX=true)=0</td></tr>
<tr class="memdesc:a55d178f0d42011618d0c479b1d48cc0a inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a dimension list of a tensor or memref type.  <a href="classmlir_1_1AsmParser.html#a55d178f0d42011618d0c479b1d48cc0a">More...</a><br /></td></tr>
<tr class="separator:a55d178f0d42011618d0c479b1d48cc0a inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0d47ed1678fcfc285991c581010459 inherit pub_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#afe0d47ed1678fcfc285991c581010459">parseXInDimensionList</a> ()=0</td></tr>
<tr class="memdesc:afe0d47ed1678fcfc285991c581010459 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an 'x' token in a dimension list, handling the case where the x is juxtaposed with an element type, as in "xf32", leaving the "f32" as the next token.  <a href="classmlir_1_1AsmParser.html#afe0d47ed1678fcfc285991c581010459">More...</a><br /></td></tr>
<tr class="separator:afe0d47ed1678fcfc285991c581010459 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5465aa79bd2ec34b871c10bb0c2384 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;class AttrOrTypeT &gt; </td></tr>
<tr class="memitem:a1d5465aa79bd2ec34b871c10bb0c2384 inherit pub_methods_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1AsmParser_1_1CyclicParseReset.html">CyclicParseReset</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a1d5465aa79bd2ec34b871c10bb0c2384">tryStartCyclicParse</a> (AttrOrTypeT attrOrType)</td></tr>
<tr class="memdesc:a1d5465aa79bd2ec34b871c10bb0c2384 inherit pub_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to start a cyclic parsing region for <code>attrOrType</code>.  <a href="classmlir_1_1AsmParser.html#a1d5465aa79bd2ec34b871c10bb0c2384">More...</a><br /></td></tr>
<tr class="separator:a1d5465aa79bd2ec34b871c10bb0c2384 inherit pub_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classmlir_1_1AsmParser"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmlir_1_1AsmParser')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmlir_1_1AsmParser.html">mlir::AsmParser</a></td></tr>
<tr class="memitem:a0a231d61eec795d5dbdef78d1ec4e95b inherit pub_types_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">Delimiter</a> { <br />
&#160;&#160;<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba6adf97f83acf6453d4a6a4b1070f3754">None</a>
, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba3f5a1b4ee2e68aebee8e1fa43e0eed27">Paren</a>
, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">Square</a>
, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95bad411a412a8bf8a305ab1f55e5684eb81">LessGreater</a>
, <br />
&#160;&#160;<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba8311ff5156079ef3ccdb396f50b0ae4c">Braces</a>
, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95bacddf0a192538f630a64c76daa3445f9a">OptionalParen</a>
, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95bae4e85fd5ca8927b9be287e34162aab21">OptionalSquare</a>
, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba6c364e4011ff6dedf34eea7c990f88b5">OptionalLessGreater</a>
, <br />
&#160;&#160;<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95bab40884d48601764f2a91f554361e186b">OptionalBraces</a>
<br />
 }</td></tr>
<tr class="memdesc:a0a231d61eec795d5dbdef78d1ec4e95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the supported delimiters around operand lists and region argument lists, used by parseOperandList.  <a href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">More...</a><br /></td></tr>
<tr class="separator:a0a231d61eec795d5dbdef78d1ec4e95b inherit pub_types_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a18fb33142f37168ee435bc3a8440e6 inherit pub_types_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename AttrType &gt; </td></tr>
<tr class="memitem:a2a18fb33142f37168ee435bc3a8440e6 inherit pub_types_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a2a18fb33142f37168ee435bc3a8440e6">has_parse_method</a> = decltype(AttrType::parse(std::declval&lt; <a class="el" href="classmlir_1_1AsmParser.html">AsmParser</a> &amp; &gt;(), std::declval&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;()))</td></tr>
<tr class="memdesc:a2a18fb33142f37168ee435bc3a8440e6 inherit pub_types_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if <code>AttrType</code> provides a <code>parse</code> method.  <a href="classmlir_1_1AsmParser.html#a2a18fb33142f37168ee435bc3a8440e6">More...</a><br /></td></tr>
<tr class="separator:a2a18fb33142f37168ee435bc3a8440e6 inherit pub_types_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009f2fa8545f56ece83e1a53eee0fb99 inherit pub_types_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename AttrType &gt; </td></tr>
<tr class="memitem:a009f2fa8545f56ece83e1a53eee0fb99 inherit pub_types_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a009f2fa8545f56ece83e1a53eee0fb99">detect_has_parse_method</a> = llvm::is_detected&lt; <a class="el" href="classmlir_1_1AsmParser.html#a2a18fb33142f37168ee435bc3a8440e6">has_parse_method</a>, AttrType &gt;</td></tr>
<tr class="separator:a009f2fa8545f56ece83e1a53eee0fb99 inherit pub_types_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea72b42e68d2a716ca46c849d9c05582 inherit pub_types_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename TypeT &gt; </td></tr>
<tr class="memitem:aea72b42e68d2a716ca46c849d9c05582 inherit pub_types_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#aea72b42e68d2a716ca46c849d9c05582">type_has_parse_method</a> = decltype(TypeT::parse(std::declval&lt; <a class="el" href="classmlir_1_1AsmParser.html">AsmParser</a> &amp; &gt;()))</td></tr>
<tr class="memdesc:aea72b42e68d2a716ca46c849d9c05582 inherit pub_types_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if <code>TypeT</code> provides a <code>parse</code> method.  <a href="classmlir_1_1AsmParser.html#aea72b42e68d2a716ca46c849d9c05582">More...</a><br /></td></tr>
<tr class="separator:aea72b42e68d2a716ca46c849d9c05582 inherit pub_types_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e01b7c9e041bedade5a24621b6221c inherit pub_types_classmlir_1_1AsmParser"><td class="memTemplParams" colspan="2">template&lt;typename TypeT &gt; </td></tr>
<tr class="memitem:ae6e01b7c9e041bedade5a24621b6221c inherit pub_types_classmlir_1_1AsmParser"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ae6e01b7c9e041bedade5a24621b6221c">detect_type_has_parse_method</a> = llvm::is_detected&lt; <a class="el" href="classmlir_1_1AsmParser.html#aea72b42e68d2a716ca46c849d9c05582">type_has_parse_method</a>, TypeT &gt;</td></tr>
<tr class="separator:ae6e01b7c9e041bedade5a24621b6221c inherit pub_types_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1AsmParser"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1AsmParser')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1AsmParser.html">mlir::AsmParser</a></td></tr>
<tr class="memitem:aef190e1d339b1852b2cb4ae285812095 inherit pro_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual FailureOr&lt; <a class="el" href="classmlir_1_1AsmDialectResourceHandle.html">AsmDialectResourceHandle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#aef190e1d339b1852b2cb4ae285812095">parseResourceHandle</a> (<a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *dialect)=0</td></tr>
<tr class="memdesc:aef190e1d339b1852b2cb4ae285812095 inherit pro_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a handle to a resource within the assembly format for the given dialect.  <a href="classmlir_1_1AsmParser.html#aef190e1d339b1852b2cb4ae285812095">More...</a><br /></td></tr>
<tr class="separator:aef190e1d339b1852b2cb4ae285812095 inherit pro_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed48832a14453a97cbfcddd70bd75694 inherit pro_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#aed48832a14453a97cbfcddd70bd75694">pushCyclicParsing</a> (const void *opaquePointer)=0</td></tr>
<tr class="memdesc:aed48832a14453a97cbfcddd70bd75694 inherit pro_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a new attribute or type in the form of a type erased pointer into an internal set.  <a href="classmlir_1_1AsmParser.html#aed48832a14453a97cbfcddd70bd75694">More...</a><br /></td></tr>
<tr class="separator:aed48832a14453a97cbfcddd70bd75694 inherit pro_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc4ac77110a5ecc4a89fb906bccd1a3 inherit pro_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a2bc4ac77110a5ecc4a89fb906bccd1a3">popCyclicParsing</a> ()=0</td></tr>
<tr class="memdesc:a2bc4ac77110a5ecc4a89fb906bccd1a3 inherit pro_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element that was last inserted with a successful call to <code>pushCyclicParsing</code>.  <a href="classmlir_1_1AsmParser.html#a2bc4ac77110a5ecc4a89fb906bccd1a3">More...</a><br /></td></tr>
<tr class="separator:a2bc4ac77110a5ecc4a89fb906bccd1a3 inherit pro_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76420de7ba417ba40292030ccb334a4 inherit pro_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#ae76420de7ba417ba40292030ccb334a4">parseKeywordOrCompletion</a> (StringRef *keyword)=0</td></tr>
<tr class="memdesc:ae76420de7ba417ba40292030ccb334a4 inherit pro_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a keyword, or an empty string if the current location signals a code completion.  <a href="classmlir_1_1AsmParser.html#ae76420de7ba417ba40292030ccb334a4">More...</a><br /></td></tr>
<tr class="separator:ae76420de7ba417ba40292030ccb334a4 inherit pro_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0f83aa37dd61d8c6682d131a76ec15 inherit pro_methods_classmlir_1_1AsmParser"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmParser.html#a4b0f83aa37dd61d8c6682d131a76ec15">codeCompleteExpectedTokens</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; tokens)=0</td></tr>
<tr class="memdesc:a4b0f83aa37dd61d8c6682d131a76ec15 inherit pro_methods_classmlir_1_1AsmParser"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal the code completion of a set of expected tokens.  <a href="classmlir_1_1AsmParser.html#a4b0f83aa37dd61d8c6682d131a76ec15">More...</a><br /></td></tr>
<tr class="separator:a4b0f83aa37dd61d8c6682d131a76ec15 inherit pro_methods_classmlir_1_1AsmParser"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classmlir_1_1OpAsmParser.html" title="The OpAsmParser has methods for interacting with the asm parser: parsing things from it,...">OpAsmParser</a> has methods for interacting with the asm parser: parsing things from it, emitting errors etc. </p>
<p>It has an intentionally high-level API that is designed to reduce/constrain syntax innovation in individual operations.</p>
<p>For example, consider an op like this:</p>
<p>x = load p[%1, %2] : memref&lt;...&gt;</p>
<p>The "%x = load" tokens are already parsed and therefore invisible to the custom op parser. This can be supported by calling <code>parseOperandList</code> to parse the p, then calling <code>parseOperandList</code> with a <code>SquareDelimiter</code> to parse the indices, then calling <code>parseColonTypeList</code> to parse the result type. </p>

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l01514">1514</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2a5344cbddd8e2003180192f22fbb54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5344cbddd8e2003180192f22fbb54c">&#9670;&nbsp;</a></span>~OpAsmParser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpAsmParser::~OpAsmParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a128af21674eec348f0cb475399551fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128af21674eec348f0cb475399551fbe">&#9670;&nbsp;</a></span>AsmParser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::AsmParser::AsmParser</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09a9326d8bf403a0156e9784730b427f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a9326d8bf403a0156e9784730b427f">&#9670;&nbsp;</a></span>getNumResults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t mlir::OpAsmParser::getNumResults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of declared SSA results. </p>
<p>This returns 4 for the foo.op example in the comment for <code>getResultName</code>. </p>

<p class="reference">Referenced by <a class="el" href="GPUDialect_8cpp_source.html#l00491">parseAsyncDependencies()</a>.</p>

</div>
</div>
<a id="a05dfae2d5ed359f6871069ce4dfe8219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dfae2d5ed359f6871069ce4dfe8219">&#9670;&nbsp;</a></span>getResultName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;StringRef, unsigned&gt; mlir::OpAsmParser::getResultName </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>resultNo</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the name of the specified result in the specified syntax, as well as the sub-element in the name. </p>
<p>It returns an empty string and ~0U for invalid result numbers. For example, in this operation:</p>
<p>x, y:2, z = foo.op</p>
<p>getResultName(0) == {"x", 0 } getResultName(1) == {"y", 0 } getResultName(2) == {"y", 1 } getResultName(3) == {"z", 0 } getResultName(4) == {"", ~0U } </p>

</div>
</div>
<a id="ac96f497332866979248e25e170e6bd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96f497332866979248e25e170e6bd40">&#9670;&nbsp;</a></span>parseAffineExprOfSSAIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ParseResult mlir::OpAsmParser::parseAffineExprOfSSAIds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses an affine expression where dims and symbols are SSA operands. </p>
<p>Operand values must come from single-result sources, and be valid dimensions/symbol identifiers according to mlir::isValidDim/Symbol. </p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l04353">parseAffineMapWithMinMax()</a>.</p>

</div>
</div>
<a id="a55ebc9079a03a42c71c883b21e733dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ebc9079a03a42c71c883b21e733dfa">&#9670;&nbsp;</a></span>parseAffineMapOfSSAIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ParseResult mlir::OpAsmParser::parseAffineMapOfSSAIds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>attrName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">Delimiter</a>&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">Delimiter::Square</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses an affine map attribute where dims and symbols are SSA operands. </p>
<p>Operand values must come from single-result sources, and be valid dimensions/symbol identifiers according to mlir::isValidDim/Symbol. </p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01794">mlir::affine::AffineDmaStartOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01975">mlir::affine::AffineDmaWaitOp::parse()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l04353">parseAffineMapWithMinMax()</a>.</p>

</div>
</div>
<a id="a491f39b888aaea001f423a946a782e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491f39b888aaea001f423a946a782e19">&#9670;&nbsp;</a></span>parseArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ParseResult mlir::OpAsmParser::parseArgument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowType</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowAttrs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a single argument with the following syntax: </p>
<p><code>ssaName : !type { optionalAttrDict} loc(optionalSourceLoc)</code></p>
<p>If <code>allowType</code> is false or <code>allowAttrs</code> are false then the respective parts of the grammar are not parsed. </p>

</div>
</div>
<a id="a530427ff32aa6170dd20d2abd94ea880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530427ff32aa6170dd20d2abd94ea880">&#9670;&nbsp;</a></span>parseArgumentList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ParseResult mlir::OpAsmParser::parseArgumentList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">Delimiter</a>&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba6adf97f83acf6453d4a6a4b1070f3754">Delimiter::None</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowType</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowAttrs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse zero or more arguments with a specified surrounding delimiter. </p>

<p class="reference">Referenced by <a class="el" href="GPUDialect_8cpp_source.html#l00528">parseAttributions()</a>, and <a class="el" href="OpenACC_8cpp_source.html#l02786">parseLoopControl()</a>.</p>

</div>
</div>
<a id="a817e151fa68d44de0e39b17b365e2223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817e151fa68d44de0e39b17b365e2223">&#9670;&nbsp;</a></span>parseAssignmentList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::OpAsmParser::parseAssignmentList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a list of assignments of the form (x1 = y1, x2 = y2, ...) </p>

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l01767">1767</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a7850fe0a2961f835384adb372758d58b">mlir::AsmParser::getCurrentLocation()</a>, <a class="el" href="OpDefinition_8h_source.html#l00050">mlir::OptionalParseResult::has_value()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a13e2984db44d0a267a04a3daa6d4f89d">parseOptionalAssignmentList()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00053">mlir::OptionalParseResult::value()</a>.</p>

</div>
</div>
<a id="aa9a393d03057c4acd7b86f8772daaaae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a393d03057c4acd7b86f8772daaaae">&#9670;&nbsp;</a></span>parseCustomOperationName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual FailureOr&lt;<a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&gt; mlir::OpAsmParser::parseCustomOperationName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the name of an operation, in the custom form. </p>
<p>On success, return a an object of type '<a class="el" href="classmlir_1_1OperationName.html">OperationName</a>'. Otherwise, failure is returned. </p>

</div>
</div>
<a id="ac205e2e553a432fe9a2b490c55c33dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac205e2e553a432fe9a2b490c55c33dee">&#9670;&nbsp;</a></span>parseGenericOperation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmlir_1_1Operation.html">Operation</a>* mlir::OpAsmParser::parseGenericOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>insertBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>insertPt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse an operation in its generic form. </p>
<p>The parsed operation is parsed in the current context and inserted in the provided block and insertion point. The results produced by this operation aren't mapped to any named value in the parser. Returns nullptr on failure. </p>

</div>
</div>
<a id="a4bef3fcb4503ec111e33ebdcddb6cd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bef3fcb4503ec111e33ebdcddb6cd01">&#9670;&nbsp;</a></span>parseGenericOperationAfterOpName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ParseResult mlir::OpAsmParser::parseGenericOperationAfterOpName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>parsedOperandType</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;&gt;&#160;</td>
          <td class="paramname"><em>parsedSuccessors</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; std::unique_ptr&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>parsedRegions</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>parsedAttributes</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>parsedPropertiesAttribute</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; FunctionType &gt;&#160;</td>
          <td class="paramname"><em>parsedFnType</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse different components, viz., use-info of operand(s), successor(s), region(s), attribute(s) and function-type, of the generic form of an operation instance and populate the input operation-state 'result' with those components. </p>
<p>If any of the components is explicitly provided, then skip parsing that component. </p>

</div>
</div>
<a id="ac30f229849bfc580b251da20cc8923ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30f229849bfc580b251da20cc8923ee">&#9670;&nbsp;</a></span>parseOperand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ParseResult mlir::OpAsmParser::parseOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowResultNumber</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a single SSA value operand name along with a result number if <code>allowResultNumber</code> is true. </p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01794">mlir::affine::AffineDmaStartOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01975">mlir::affine::AffineDmaWaitOp::parse()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00360">parseAccVar()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00123">parseAllocateAndAllocator()</a>, <a class="el" href="TransformOps_8cpp_source.html#l00874">parseApplyRegisteredPassOptions()</a>, <a class="el" href="Dialect_2IRDL_2IR_2IRDL_8cpp_source.html#l00423">parseAttributesOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00260">parseCmpOp()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00066">parseCreateOperationOpAttributes()</a>, <a class="el" href="OpenACC_8cpp_source.html#l02236">parseGangValue()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00699">parseGEPIndices()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00478">parseGranularityClause()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01351">parseLaunchFuncOperands()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00191">parseLinearClause()</a>, <a class="el" href="Dialect_2IRDL_2IR_2IRDL_8cpp_source.html#l00317">parseNamedValueListImpl()</a>, <a class="el" href="OpenACC_8cpp_source.html#l01758">parseOperandWithKeywordOnly()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00147">parseOperationOpAttributes()</a>, <a class="el" href="Dialect_2Transform_2Utils_2Utils_8cpp_source.html#l00033">mlir::transform::parsePackedOrDynamicIndexList()</a>, <a class="el" href="OpenMPDialect_8cpp_source.html#l00362">parseScheduleClause()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00965">parseSizeAssignment()</a>, <a class="el" href="Dialect_2IRDL_2IR_2IRDL_8cpp_source.html#l00295">parseValueWithVariadicity()</a>, and <a class="el" href="OpenACC_8cpp_source.html#l00336">parseVar()</a>.</p>

</div>
</div>
<a id="af16d3e3ef46bd2bd45b4e8db657c221a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16d3e3ef46bd2bd45b4e8db657c221a">&#9670;&nbsp;</a></span>parseOperandList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ParseResult mlir::OpAsmParser::parseOperandList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">Delimiter</a>&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba6adf97f83acf6453d4a6a4b1070f3754">Delimiter::None</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowResultNumber</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>requiredOperandCount</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse zero or more SSA comma-separated operand references with a specified surrounding delimiter, and an optional required operand count. </p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l03471">parseAffineMinMaxOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00267">parseArithmeticExtendedBinaryOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00491">parseAsyncDependencies()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02151">parseBound()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00242">parseCommonStructuredOpParts()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00102">parseCreateOperationOpResults()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00505">mlir::affine::parseDimAndSymbolList()</a>, <a class="el" href="OpenACC_8cpp_source.html#l02786">parseLoopControl()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00181">parseOneOpBundle()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00120">parseOneResultSameOperandTypeOp()</a>, <a class="el" href="OpImplementation_8h_source.html#l01606">parseOperandList()</a>, <a class="el" href="SMTOps_8cpp_source.html#l00095">parseSameOperandTypeVariadicToBoolOp()</a>, <a class="el" href="TransformOps_8cpp_source.html#l02810">parseSequenceOpOperands()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00965">parseSizeAssignment()</a>, <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00504">parseSwitchOpCases()</a>, <a class="el" href="MLProgramOps_8cpp_source.html#l00029">parseTokenOrdering()</a>, and <a class="el" href="OpImplementation_8h_source.html#l01618">parseTrailingOperandList()</a>.</p>

</div>
</div>
<a id="aac66ff1f25e13f351765b8afef96fcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac66ff1f25e13f351765b8afef96fcef">&#9670;&nbsp;</a></span>parseOperandList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::OpAsmParser::parseOperandList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>requiredOperandCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">Delimiter</a>&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba6adf97f83acf6453d4a6a4b1070f3754">Delimiter::None</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a specified number of comma separated operands. </p>

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l01606">1606</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmParser.html#af16d3e3ef46bd2bd45b4e8db657c221a">parseOperandList()</a>.</p>

</div>
</div>
<a id="a7aa56215a35491d0afb991f6cc8dd700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa56215a35491d0afb991f6cc8dd700">&#9670;&nbsp;</a></span>parseOptionalArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a> mlir::OpAsmParser::parseOptionalArgument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowType</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowAttrs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a single argument if present. </p>

<p class="reference">Referenced by <a class="el" href="FunctionImplementation_8cpp_source.html#l00017">parseFunctionArgumentList()</a>.</p>

</div>
</div>
<a id="a13e2984db44d0a267a04a3daa6d4f89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e2984db44d0a267a04a3daa6d4f89d">&#9670;&nbsp;</a></span>parseOptionalAssignmentList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a> mlir::OpAsmParser::parseOptionalAssignmentList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="OpImplementation_8h_source.html#l01767">parseAssignmentList()</a>.</p>

</div>
</div>
<a id="a7e2bfd458e054cd6263449dfb4d551b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2bfd458e054cd6263449dfb4d551b2">&#9670;&nbsp;</a></span>parseOptionalLocationSpecifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ParseResult mlir::OpAsmParser::parseOptionalLocationSpecifier </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a loc(...) specifier if present, filling in result if so. </p>
<p><a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> for <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a> and <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> may be deferred with an alias, in which case an OpaqueLoc is set and will be resolved when parsing completes. </p>

</div>
</div>
<a id="a8fd765b541880aa1f11ca238ce62ad9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd765b541880aa1f11ca238ce62ad9d">&#9670;&nbsp;</a></span>parseOptionalOperand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a> mlir::OpAsmParser::parseOptionalOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowResultNumber</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a single operand if present. </p>

<p class="reference">Referenced by <a class="el" href="ViewLikeInterface_8cpp_source.html#l00231">mlir::parseDynamicIndexList()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01345">parseOptionalCallFuncPtr()</a>, <a class="el" href="XeGPUOps_8cpp_source.html#l00322">mlir::xegpu::parseOptionalDynamicIndexList()</a>, and <a class="el" href="TransformOps_8cpp_source.html#l02810">parseSequenceOpOperands()</a>.</p>

</div>
</div>
<a id="a9c1c62f9f4cd1cb3b44348ae404ab0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1c62f9f4cd1cb3b44348ae404ab0e9">&#9670;&nbsp;</a></span>parseOptionalRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a> mlir::OpAsmParser::parseOptionalRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname"><em>arguments</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableNameShadowing</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a region if present. </p>

<p class="reference">Referenced by <a class="el" href="FunctionImplementation_8cpp_source.html#l00086">mlir::function_interface_impl::parseFunctionOp()</a>, and <a class="el" href="Dialect_2IRDL_2IR_2IRDL_8cpp_source.html#l00058">parseSingleBlockRegion()</a>.</p>

</div>
</div>
<a id="adffdc9be08e1966a9245254caa9f83ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adffdc9be08e1966a9245254caa9f83ec">&#9670;&nbsp;</a></span>parseOptionalRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a> mlir::OpAsmParser::parseOptionalRegion </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname"><em>arguments</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableNameShadowing</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a region if present. </p>
<p>If the region is present, a new region is allocated and placed in <code>region</code>. If no region is present or on failure, <code>region</code> remains untouched. </p>

</div>
</div>
<a id="acf71a21c58dda44441e32396934aa8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf71a21c58dda44441e32396934aa8d7">&#9670;&nbsp;</a></span>parseOptionalSuccessor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a> mlir::OpAsmParser::parseOptionalSuccessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse an optional operation successor. </p>

</div>
</div>
<a id="a1aa6346885471aae41b7f63c33894af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa6346885471aae41b7f63c33894af5">&#9670;&nbsp;</a></span>parseRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ParseResult mlir::OpAsmParser::parseRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1Argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname"><em>arguments</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableNameShadowing</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a region. </p>
<p>Any parsed blocks are appended to 'region' and must be moved to the op regions after the op is created. The first block of the region takes 'arguments'.</p>
<p>If 'enableNameShadowing' is set to true, the argument names are allowed to shadow the names of other existing SSA values defined above the region scope. 'enableNameShadowing' can only be set to true for regions attached to operations that are 'IsolatedFromAbove'. </p>

<p class="reference">Referenced by <a class="el" href="OpenMPDialect_8cpp_source.html#l00776">parseBlockArgRegion()</a>, <a class="el" href="OpenACC_8cpp_source.html#l02786">parseLoopControl()</a>, and <a class="el" href="Dialect_2EmitC_2IR_2EmitC_8cpp_source.html#l01263">parseSwitchCases()</a>.</p>

</div>
</div>
<a id="a2d9fe3c427588618221405e793801740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9fe3c427588618221405e793801740">&#9670;&nbsp;</a></span>parseSuccessor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ParseResult mlir::OpAsmParser::parseSuccessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a single operation successor. </p>

<p class="reference">Referenced by <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00504">parseSwitchOpCases()</a>.</p>

</div>
</div>
<a id="a9b3c28975dee14289c711345ba31bdda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3c28975dee14289c711345ba31bdda">&#9670;&nbsp;</a></span>parseSuccessorAndUseList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ParseResult mlir::OpAsmParser::parseSuccessorAndUseList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a single operation successor and its operand list. </p>

</div>
</div>
<a id="a4d468dc0848a3666d92ee8ff699d5a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d468dc0848a3666d92ee8ff699d5a5f">&#9670;&nbsp;</a></span>parseTrailingOperandList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::OpAsmParser::parseTrailingOperandList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">Delimiter</a>&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba6adf97f83acf6453d4a6a4b1070f3754">Delimiter::None</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse zero or more trailing SSA comma-separated trailing operand references with a specified surrounding delimiter, and an optional required operand count. </p>
<p>A leading comma is expected before the operands. </p>

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l01618">1618</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmParser.html#af16d3e3ef46bd2bd45b4e8db657c221a">parseOperandList()</a>, and <a class="el" href="classmlir_1_1AsmParser.html#a7c4ae1e32399518a5051d27e4effd8fb">mlir::AsmParser::parseOptionalComma()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01794">mlir::affine::AffineDmaStartOp::parse()</a>.</p>

</div>
</div>
<a id="a8c583b0d425ac93c7f8a867f5546db6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c583b0d425ac93c7f8a867f5546db6a">&#9670;&nbsp;</a></span>resolveOperand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ParseResult mlir::OpAsmParser::resolveOperand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">UnresolvedOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve an operand to an SSA value, emitting an error on failure. </p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01794">mlir::affine::AffineDmaStartOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01975">mlir::affine::AffineDmaWaitOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02151">parseBound()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00260">parseCmpOp()</a>, and <a class="el" href="OpImplementation_8h_source.html#l01634">resolveOperands()</a>.</p>

</div>
</div>
<a id="aafd56f3f603a23b43c86c7d6b6f38d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd56f3f603a23b43c86c7d6b6f38d7a">&#9670;&nbsp;</a></span>resolveOperands() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Operands  = ArrayRef&lt;UnresolvedOperand&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::OpAsmParser::resolveOperands </td>
          <td>(</td>
          <td class="paramtype">Operands &amp;&amp;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve a list of operands to SSA values, emitting an error on failure, or appending the results to the list on success. </p>
<p>This method should be used when all operands have the same type. </p>

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l01634">1634</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmParser.html#a8c583b0d425ac93c7f8a867f5546db6a">resolveOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l04306">deduplicateAndResolveOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01794">mlir::affine::AffineDmaStartOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01975">mlir::affine::AffineDmaWaitOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03471">parseAffineMinMaxOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00267">parseArithmeticExtendedBinaryOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01294">parseCallTypeAndResolveOperands()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00242">parseCommonStructuredOpParts()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00505">mlir::affine::parseDimAndSymbolList()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00120">parseOneResultSameOperandTypeOp()</a>, <a class="el" href="SMTOps_8cpp_source.html#l00095">parseSameOperandTypeVariadicToBoolOp()</a>, and <a class="el" href="OpImplementation_8h_source.html#l01642">resolveOperands()</a>.</p>

</div>
</div>
<a id="a4e09a95735c13cd607e4c7552098760b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e09a95735c13cd607e4c7552098760b">&#9670;&nbsp;</a></span>resolveOperands() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Operands  = ArrayRef&lt;UnresolvedOperand&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::OpAsmParser::resolveOperands </td>
          <td>(</td>
          <td class="paramtype">Operands &amp;&amp;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SMLoc&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l01642">1642</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="OpImplementation_8h_source.html#l01634">resolveOperands()</a>.</p>

</div>
</div>
<a id="ad7dab9683e2cd00025f0961cae4b7d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7dab9683e2cd00025f0961cae4b7d35">&#9670;&nbsp;</a></span>resolveOperands() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Operands  = ArrayRef&lt;UnresolvedOperand&gt;, typename Types  = ArrayRef&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_convertible&lt;Types, <a class="el" href="classmlir_1_1Type.html">Type</a>&gt;::value, ParseResult&gt; mlir::OpAsmParser::resolveOperands </td>
          <td>(</td>
          <td class="paramtype">Operands &amp;&amp;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Types &amp;&amp;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SMLoc&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve a list of operands and a list of operand types to SSA values, emitting an error and returning failure, or appending the results to the list on success. </p>

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l01653">1653</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, and <a class="el" href="classmlir_1_1OpAsmParser.html#a8c583b0d425ac93c7f8a867f5546db6a">resolveOperand()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/IR/<a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a></li>
<li>lib/IR/<a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:30 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
