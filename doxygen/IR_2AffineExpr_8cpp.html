<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/IR/AffineExpr.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a href="dir_bfcfa2223a05221bedc89835a6573260.html">IR</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">AffineExpr.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &quot;<a class="el" href="AffineExprDetail_8h_source.html">AffineExprDetail.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">mlir/IR/AffineExpr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineExprVisitor_8h_source.html">mlir/IR/AffineExprVisitor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineMap_8h_source.html">mlir/IR/AffineMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2IntegerSet_8h_source.html">mlir/IR/IntegerSet.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/Support/MathExtras.h&quot;</code><br />
<code>#include &lt;numeric&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
</div>
<p><a href="IR_2AffineExpr_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a804419930b6088cfe6e71549cd86f60e" id="r_a804419930b6088cfe6e71549cd86f60e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a804419930b6088cfe6e71549cd86f60e">static_cast&lt; unsigned &gt;</a> (AffineExprKind::Add)</td></tr>
<tr class="memitem:a227fb67967b53341825990e2e250fb03" id="r_a227fb67967b53341825990e2e250fb03"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a227fb67967b53341825990e2e250fb03">simplifyMul</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memdesc:a227fb67967b53341825990e2e250fb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify a multiply expression. Return nullptr if it can't be simplified.  <br /></td></tr>
<tr class="memitem:a9af6c331b3e502a654eb10028bca0473" id="r_a9af6c331b3e502a654eb10028bca0473"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9af6c331b3e502a654eb10028bca0473">simplifyFloorDiv</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:a9977690f3eed7f5e712717d31050f734" id="r_a9977690f3eed7f5e712717d31050f734"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9977690f3eed7f5e712717d31050f734">simplifyCeilDiv</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:a344e507f6bc090352457050fdba8141f" id="r_a344e507f6bc090352457050fdba8141f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a344e507f6bc090352457050fdba8141f">simplifyMod</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:a8768d385bd3d0cbf2771e9a8fbfa44c2" id="r_a8768d385bd3d0cbf2771e9a8fbfa44c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8768d385bd3d0cbf2771e9a8fbfa44c2">getSemiAffineExprFromFlatForm</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; flatExprs, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; localExprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a8768d385bd3d0cbf2771e9a8fbfa44c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a semi-affine expression from a flat <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>. If there are local identifiers (neither dimensional nor symbolic) that appear in the sum of products expression, <span class="tt">localExprs</span> is expected to have the AffineExprs for it, and is substituted into. The <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a> <span class="tt">flatExprs</span> is expected to be in the format [dims, symbols, locals, constant term]. The semi-affine expression is constructed in the sorted order of dimension and symbol position numbers. Note: local expressions/ids are used for mod, div as well as symbolic RHS terms for terms that are not pure affine.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a204f446339af7929852f44df41484be5" id="r_a204f446339af7929852f44df41484be5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a204f446339af7929852f44df41484be5">lhs</a></td></tr>
<tr class="memitem:ac7f01b5df0ebd2339035b77990cda224" id="r_ac7f01b5df0ebd2339035b77990cda224"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7f01b5df0ebd2339035b77990cda224">rhs</a></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a8768d385bd3d0cbf2771e9a8fbfa44c2" name="a8768d385bd3d0cbf2771e9a8fbfa44c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8768d385bd3d0cbf2771e9a8fbfa44c2">&#9670;&#160;</a></span>getSemiAffineExprFromFlatForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> getSemiAffineExprFromFlatForm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>flatExprs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numSymbols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>localExprs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a semi-affine expression from a flat <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>. If there are local identifiers (neither dimensional nor symbolic) that appear in the sum of products expression, <span class="tt">localExprs</span> is expected to have the AffineExprs for it, and is substituted into. The <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a> <span class="tt">flatExprs</span> is expected to be in the format [dims, symbols, locals, constant term]. The semi-affine expression is constructed in the sorted order of dimension and symbol position numbers. Note: local expressions/ids are used for mod, div as well as symbolic RHS terms for terms that are not pure affine. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01133">1133</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>, <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>, <a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">mlir::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00338">mlir::AffineBinaryOpExpr::getLHS()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00341">mlir::AffineBinaryOpExpr::getRHS()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01612">mlir::simplifyAffineExpr()</a>.</p>

</div>
</div>
<a id="a9977690f3eed7f5e712717d31050f734" name="a9977690f3eed7f5e712717d31050f734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9977690f3eed7f5e712717d31050f734">&#9670;&#160;</a></span>simplifyCeilDiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> simplifyCeilDiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00972">972</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00043">mlir::Mul</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01009">mlir::AffineExpr::ceilDiv()</a>.</p>

</div>
</div>
<a id="a9af6c331b3e502a654eb10028bca0473" name="a9af6c331b3e502a654eb10028bca0473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af6c331b3e502a654eb10028bca0473">&#9670;&#160;</a></span>simplifyFloorDiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> simplifyFloorDiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00913">913</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00041">mlir::Add</a>, <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00043">mlir::Mul</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00962">mlir::AffineExpr::floorDiv()</a>.</p>

</div>
</div>
<a id="a344e507f6bc090352457050fdba8141f" name="a344e507f6bc090352457050fdba8141f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344e507f6bc090352457050fdba8141f">&#9670;&#160;</a></span>simplifyMod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> simplifyMod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01019">1019</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00041">mlir::Add</a>, <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00046">mlir::Mod</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01067">mlir::AffineExpr::operator%()</a>.</p>

</div>
</div>
<a id="a227fb67967b53341825990e2e250fb03" name="a227fb67967b53341825990e2e250fb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227fb67967b53341825990e2e250fb03">&#9670;&#160;</a></span>simplifyMul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> simplifyMul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplify a multiply expression. Return nullptr if it can't be simplified. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00836">836</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00043">mlir::Mul</a>, <a class="el" href="GPUHeuristics_8cpp_source.html#l00112">product()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00891">mlir::AffineExpr::operator*()</a>.</p>

</div>
</div>
<a id="a804419930b6088cfe6e71549cd86f60e" name="a804419930b6088cfe6e71549cd86f60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804419930b6088cfe6e71549cd86f60e">&#9670;&#160;</a></span>static_cast&lt; unsigned &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static_cast&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">AffineExprKind::Add</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a204f446339af7929852f44df41484be5" name="a204f446339af7929852f44df41484be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204f446339af7929852f44df41484be5">&#9670;&#160;</a></span>lhs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lhs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">832</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00311">mlir::ArithBuilder::_and()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00374">mlir::affine::AffineBuilder::add()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00314">mlir::ArithBuilder::add()</a>, <a class="el" href="Var_8cpp_source.html#l00103">mlir::sparse_tensor::ir_detail::VarSet::add()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00520">mlir::xegpu::addElementwise()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00051">addIntegerAttrs()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01594">mlir::SimpleAffineExprFlattener::addLocalIdSemiAffine()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00545">mlir::xegpu::addWithRightAligned()</a>, <a class="el" href="AliasAnalysis_8cpp_source.html#l00080">mlir::AliasAnalysis::alias()</a>, <a class="el" href="classmlir_1_1detail_1_1AliasAnalysisTraits_1_1Concept.html#a83f50cc4bbe59ecf0e96b7f492ca8a1d">mlir::detail::AliasAnalysisTraits::Concept::alias()</a>, <a class="el" href="AliasAnalysis_8h_source.html#l00203">mlir::detail::AliasAnalysisTraits::Model&lt; ImplT &gt;::alias()</a>, <a class="el" href="LocalAliasAnalysis_8cpp_source.html#l00440">mlir::LocalAliasAnalysis::alias()</a>, <a class="el" href="LocalAliasAnalysis_8cpp_source.html#l00342">mlir::LocalAliasAnalysis::aliasImpl()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02082">mlir::arith::applyCmpPredicate()</a>, <a class="el" href="ArithOps_8cpp_source.html#l01939">mlir::arith::applyCmpPredicate()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00058">mlir::PatternApplicator::applyCostModel()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00042">applyToIntegerAttrs()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00893">binaryFolder()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00772">MmaSyncBuilder::buildMmaSync()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03796">canonicalizeMapExprAndTermOrder()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00387">mlir::affine::AffineBuilder::ceil()</a>, <a class="el" href="LocalAliasAnalysis_8cpp_source.html#l00320">checkDistinctObjects()</a>, <a class="el" href="ArithmeticUtils_8h_source.html#l00123">mlir::sparse_tensor::detail::checkedMul()</a>, <a class="el" href="ShardingInterface_8cpp_source.html#l00036">checkOperandAffineExprRecursively()</a>, <a class="el" href="DuplicateFunctionElimination_8cpp_source.html#l00056">mlir::func::impl::DuplicateFunctionEliminationPassBase&lt; DerivedT &gt;::clonePass()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00782">mlir::ValueBoundsConstraintSet::compare()</a>, <a class="el" href="IndexOps_8cpp_source.html#l00586">compareIndices()</a>, <a class="el" href="OperationSupport_8h_source.html#l00448">mlir::OperationName::compareOpProperties()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00036">comparePosDepth()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00930">mlir::OperationName::UnregisteredOpModel::compareProperties()</a>, <a class="el" href="OperationSupport_8h_source.html#l00653">mlir::RegisteredOperationName::Model&lt; ConcreteOp &gt;::compareProperties()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01954">composedAffineMultiply()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00217">concatArrayAttr()</a>, <a class="el" href="CommonFolders_8h_source.html#l00046">mlir::constFoldBinaryOpConditional()</a>, <a class="el" href="OperationSupport_8h_source.html#l00444">mlir::OperationName::copyOpProperties()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00496">mlir::DynamicOpDefinition::copyProperties()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00926">mlir::OperationName::UnregisteredOpModel::copyProperties()</a>, <a class="el" href="OperationSupport_8h_source.html#l00660">mlir::RegisteredOperationName::Model&lt; ConcreteOp &gt;::copyProperties()</a>, <a class="el" href="DuplicateFunctionElimination_8cpp_source.html#l00079">mlir::func::createDuplicateFunctionEliminationPass()</a>, <a class="el" href="TosaValidation_8cpp_source.html#l00872">mlir::tosa::createTosaValidation()</a>, <a class="el" href="mlir-c_2AffineExpr_8h.html#acef8f06738133e9c8680f649b997c7d4">DEFINE_C_API_STRUCT()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00313">deriveStaticUpperBound()</a>, <a class="el" href="Mem2Reg_8cpp_source.html#l00543">dominanceSort()</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00041">equalIterationSpaces()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00719">mlir::intrange::evaluatePred()</a>, <a class="el" href="OperationSupport_8h_source.html#l01405">mlir::OperationEquivalence::exactValueMatch()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00113">findDepIdxSet()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00383">mlir::affine::AffineBuilder::floor()</a>, <a class="el" href="IndexOps_8cpp_source.html#l00094">foldBinaryOpChecked()</a>, <a class="el" href="IndexOps_8cpp_source.html#l00068">foldBinaryOpUnchecked()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00672">foldDivMul()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00430">mlir::sparse_tensor::foreachInSparseConstant()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00281">genBuffers()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00935">mlir::pdl_to_pdl_interp::MatcherNode::generateMatcherTree()</a>, <a class="el" href="ReductionNode_8cpp_source.html#l00051">mlir::ReductionNode::generateNewVariants()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeDetail_8h_source.html#l00061">mlir::quant::detail::AnyQuantizedTypeStorage::KeyTy::genericIsEqual()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeDetail_8h_source.html#l00388">mlir::quant::detail::CalibratedQuantizedTypeStorage::KeyTy::genericIsEqual()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeDetail_8h_source.html#l00193">mlir::quant::detail::UniformQuantizedPerAxisTypeStorage::KeyTy::genericIsEqual()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeDetail_8h_source.html#l00289">mlir::quant::detail::UniformQuantizedSubChannelTypeStorage::KeyTy::genericIsEqual()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeDetail_8h_source.html#l00120">mlir::quant::detail::UniformQuantizedTypeStorage::KeyTy::genericIsEqual()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00751">genExpand()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00681">genInvariants()</a>, <a class="el" href="Sparsification_8cpp_source.html#l01360">genResult()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00068">mlir::getAffineBinaryOpExpr()</a>, <a class="el" href="namespacemlir.html#ace395202c24e4dc75013296cf46ed692">mlir::getAffineConstantExprs()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00601">getAffineExprOfType()</a>, <a class="el" href="IntRangeOptimizations_8cpp_source.html#l00431">mlir::arith::impl::ArithIntRangeOptsBase&lt; DerivedT &gt;::getArgumentName()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00385">mlir::vector::getConstantVscaleMultiplier()</a>, <a class="el" href="OuterProductFusion_8cpp_source.html#l00176">mlir::arm_sme::impl::OuterProductFusionBase&lt; DerivedT &gt;::getDependentDialects()</a>, <a class="el" href="DuplicateFunctionElimination_8cpp_source.html#l00061">mlir::func::impl::DuplicateFunctionEliminationPassBase&lt; DerivedT &gt;::getDependentDialects()</a>, <a class="el" href="classmlir_1_1dataflow_1_1AbstractSparseBackwardDataFlowAnalysis.html#a67bf1550637f0af439412e69dc7fb2c3">mlir::dataflow::AbstractSparseBackwardDataFlowAnalysis::getLatticeElement()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00338">mlir::AffineBinaryOpExpr::getLHS()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00434">mlir::MLIRContext::getLoadedDialects()</a>, <a class="el" href="OuterProductFusion_8cpp_source.html#l00163">mlir::arm_sme::impl::OuterProductFusionBase&lt; DerivedT &gt;::getName()</a>, <a class="el" href="OuterProductFusion_8cpp_source.html#l00160">mlir::arm_sme::impl::OuterProductFusionBase&lt; DerivedT &gt;::getPassName()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02786">mlir::arith::getReductionOp()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00711">mlir::MLIRContext::getRegisteredOperationsByDialect()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01133">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="ScalableValueBoundsConstraintSet_8cpp_source.html#l00014">mlir::vector::ScalableValueBoundsConstraintSet::ConstantOrScalableBound::getSize()</a>, <a class="el" href="IRNumbering_8cpp_source.html#l00081">groupByDialectPerByte()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00905">hasSizeMismatch()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00557">idivCheck()</a>, <a class="el" href="OperationSupport_8h_source.html#l01400">mlir::OperationEquivalence::ignoreValueEquivalence()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00184">mlir::intrange::inferAdd()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00367">mlir::intrange::inferCeilDivS()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00319">mlir::intrange::inferCeilDivU()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00360">mlir::intrange::inferDivS()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00339">inferDivSRange()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00312">mlir::intrange::inferDivU()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00288">inferDivURange()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00401">mlir::intrange::inferFloorDivS()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00492">mlir::intrange::inferMaxS()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00501">mlir::intrange::inferMaxU()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00510">mlir::intrange::inferMinS()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00519">mlir::intrange::inferMinU()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00249">mlir::intrange::inferMul()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00422">mlir::intrange::inferRemS()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00461">mlir::intrange::inferRemU()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00593">mlir::intrange::inferShl()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00627">mlir::intrange::inferShrS()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00639">mlir::intrange::inferShrU()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00217">mlir::intrange::inferSub()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00577">mlir::intrange::inferXor()</a>, <a class="el" href="LowerVectorShapeCast_8cpp_source.html#l00048">inplaceAdd()</a>, <a class="el" href="IRNumbering_8cpp_source.html#l00130">mlir::bytecode::detail::IRNumberingState::IRNumberingState()</a>, <a class="el" href="CodegenEnv_8cpp_source.html#l00135">mlir::sparse_tensor::CodegenEnv::isAdmissibleTensorExp()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00412">mlir::linalg::isDimTimesConstantOrDimOnly()</a>, <a class="el" href="OpImplementation_8h_source.html#l01871">llvm::DenseMapInfo&lt; mlir::AsmDialectResourceHandle &gt;::isEqual()</a>, <a class="el" href="Block_8h_source.html#l00444">llvm::DenseMapInfo&lt; mlir::Block::iterator &gt;::isEqual()</a>, <a class="el" href="Attributes_8h_source.html#l00361">llvm::DenseMapInfo&lt; mlir::NamedAttribute &gt;::isEqual()</a>, <a class="el" href="OperationSupport_8h_source.html#l01452">llvm::DenseMapInfo&lt; mlir::OperationName &gt;::isEqual()</a>, <a class="el" href="PassInstrumentation_8h_source.html#l00149">llvm::DenseMapInfo&lt; mlir::PassInstrumentation::PipelineParentInfo &gt;::isEqual()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8h_source.html#l00409">llvm::DenseMapInfo&lt; mlir::pdll::ast::Type &gt;::isEqual()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00805">llvm::DenseMapInfo&lt; mlir::ProgramPoint &gt;::isEqual()</a>, <a class="el" href="Remarks_8h_source.html#l00641">llvm::DenseMapInfo&lt; mlir::remark::detail::Remark &gt;::isEqual()</a>, <a class="el" href="BlockSupport_8h_source.html#l00190">llvm::DenseMapInfo&lt; mlir::SuccessorRange &gt;::isEqual()</a>, <a class="el" href="structllvm_1_1DenseMapInfo_3_01mlir_1_1tblgen_1_1Constraint_01_4.html#a8e243a7aa8b6febee70910bb7fe13f7c">llvm::DenseMapInfo&lt; mlir::tblgen::Constraint &gt;::isEqual()</a>, <a class="el" href="include_2mlir_2TableGen_2Pattern_8h_source.html#l00704">llvm::DenseMapInfo&lt; mlir::tblgen::DagLeaf &gt;::isEqual()</a>, <a class="el" href="include_2mlir_2TableGen_2Pattern_8h_source.html#l00686">llvm::DenseMapInfo&lt; mlir::tblgen::DagNode &gt;::isEqual()</a>, <a class="el" href="TypeID_8h_source.html#l00408">llvm::DenseMapInfo&lt; mlir::TypeID &gt;::isEqual()</a>, <a class="el" href="TypeRange_8h_source.html#l00206">llvm::DenseMapInfo&lt; mlir::TypeRange &gt;::isEqual()</a>, <a class="el" href="Value_8h_source.html#l00517">llvm::DenseMapInfo&lt; mlir::Value &gt;::isEqual()</a>, <a class="el" href="NanobindUtils_8h_source.html#l00430">llvm::DenseMapInfo&lt; MlirTypeID &gt;::isEqual()</a>, <a class="el" href="InterfaceSupport_8h_source.html#l00298">llvm::DenseMapInfo&lt; T, std::enable_if_t&lt; mlir::detail::IsInterface&lt; T &gt;::value &gt; &gt;::isEqual()</a>, <a class="el" href="OpDefinition_8h_source.html#l02151">llvm::DenseMapInfo&lt; T, std::enable_if_t&lt; std::is_base_of&lt; mlir::OpState, T &gt;::value &amp;&amp;!mlir::detail::IsInterface&lt; T &gt;::value &gt; &gt;::isEqual()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00756">mlir::DataFlowSolver::isEquivalent()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00897">mlir::OperationEquivalence::isEquivalentTo()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00829">mlir::OperationEquivalence::isEquivalentTo()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00709">mlir::OperationEquivalence::isRegionEquivalentTo()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00812">mlir::OperationEquivalence::isRegionEquivalentTo()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00679">isStaticallyTrue()</a>, <a class="el" href="DenseAnalysis_8h_source.html#l00115">mlir::dataflow::AbstractDenseForwardDataFlowAnalysis::join()</a>, <a class="el" href="SparseAnalysis_8cpp_source.html#l00350">mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::join()</a>, <a class="el" href="ConstantPropagationAnalysis_8h_source.html#l00073">mlir::dataflow::ConstantValue::join()</a>, <a class="el" href="InferIntRangeInterface_8h_source.html#l00140">mlir::IntegerValueRange::join()</a>, <a class="el" href="InferStridedMetadataInterface_8h_source.html#l00085">mlir::StridedMetadataRange::join()</a>, <a class="el" href="ShapeUtils_8h_source.html#l00081">mlir::tosa::ValueKnowledge::join()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01084">mlir::affine::loopUnrollJamByFactor()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00981">makeAtomicReductionGen()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00951">makeReductionGen()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00735">makeVectorShapes()</a>, <a class="el" href="ArithToAPFloat_8cpp_source.html#l00171">BinaryArithOpToAPFloatConversion&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01736">CanonicalizeContractMatmulToMMT::matchAndRewrite()</a>, <a class="el" href="ArithToAPFloat_8cpp_source.html#l00413">CmpFOpToAPFloatConversion::matchAndRewrite()</a>, <a class="el" href="FoldAddIntoDest_8cpp_source.html#l00058">FoldAddIntoDest::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00133">IAddCarryFold::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00213">MulExtendedFold&lt; spirv::SMulExtendedOp, true &gt;::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00289">UMulExtendedOpXOne::matchAndRewrite()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00061">materializeBinaryNanCheckIfRequired()</a>, <a class="el" href="DenseAnalysis_8h_source.html#l00412">mlir::dataflow::AbstractDenseBackwardDataFlowAnalysis::meet()</a>, <a class="el" href="SparseAnalysis_8cpp_source.html#l00668">mlir::dataflow::AbstractSparseBackwardDataFlowAnalysis::meet()</a>, <a class="el" href="ShapeUtils_8h_source.html#l00136">mlir::tosa::ValueKnowledge::meet()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00057">minMaxBy()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00137">mlirAffineAddExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00190">mlirAffineCeilDivExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00024">mlirAffineExprEqual()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00176">mlirAffineFloorDivExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00163">mlirAffineModExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00150">mlirAffineMulExprGet()</a>, <a class="el" href="IR_8cpp_source.html#l00468">mlirModuleEqual()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00380">mlir::affine::AffineBuilder::mul()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00324">mlir::ArithBuilder::mul()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00061">mulIntegerAttrs()</a>, <a class="el" href="OpDefinition_8h_source.html#l00265">mlir::operator!=()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00270">mlir::operator!=()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01060">mlir::operator!=()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01066">mlir::operator!=()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01072">mlir::operator!=()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01076">mlir::operator!=()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00222">mlir::RegionSuccessor::operator!=</a>, <a class="el" href="Enums_8h_source.html#l00297">mlir::sparse_tensor::LevelType::operator!=()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00048">mlir::operator&amp;()</a>, <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00222">mlir::bufferization::ValueComparator::operator()()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00891">mlir::AffineExpr::operator*()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00069">operator*()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00062">operator/()</a>, <a class="el" href="SPIRVTypes_8h_source.html#l00280">mlir::spirv::StructType::MemberDecorationInfo::operator&lt;</a>, <a class="el" href="SPIRVTypes_8h_source.html#l00303">mlir::spirv::StructType::StructDecorationInfo::operator&lt;</a>, <a class="el" href="TypeRange_8h_source.html#l00167">mlir::operator==()</a>, <a class="el" href="OpDefinition_8h_source.html#l00262">mlir::operator==()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01059">mlir::operator==()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01063">mlir::operator==()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01069">mlir::operator==()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01073">mlir::operator==()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00257">mlir::RegionBranchPoint::operator==</a>, <a class="el" href="Enums_8h_source.html#l00294">mlir::sparse_tensor::LevelType::operator==()</a>, <a class="el" href="SPIRVTypes_8h_source.html#l00273">mlir::spirv::StructType::MemberDecorationInfo::operator==</a>, <a class="el" href="SPIRVTypes_8h_source.html#l00297">mlir::spirv::StructType::StructDecorationInfo::operator==</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00041">mlir::operator|()</a>, <a class="el" href="Class_8h_source.html#l00490">operator|()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00044">mlir::operator|=()</a>, <a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html#l00089">mlir::sparse_tensor::I64BitSet::operator|=()</a>, <a class="el" href="Class_8h_source.html#l00497">operator|=()</a>, <a class="el" href="OpImplementation_8h_source.html#l01767">mlir::OpAsmParser::parseAssignmentList()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00294">parseCmpOp()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a13e2984db44d0a267a04a3daa6d4f89d">mlir::OpAsmParser::parseOptionalAssignmentList()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00774">mlir::ValueBoundsConstraintSet::populateAndCompare()</a>, <a class="el" href="DebugCounter_8cpp_source.html#l00091">mlir::tracing::DebugCounter::print()</a>, <a class="el" href="Translation_8cpp_source.html#l00166">mlir::TranslationParser::printOptionInfo()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00072">mlir::printRegisteredPasses()</a>, <a class="el" href="PassStatistics_8cpp_source.html#l00059">printResultsAsList()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00155">mlir::AffineExpr::replace()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00087">mlir::AffineExpr::replaceDimsAndSymbols()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00339">mlir::ArithBuilder::select()</a>, <a class="el" href="classmlir_1_1dataflow_1_1AbstractSparseForwardDataFlowAnalysis.html#a4c7bfb6ffb519d4f8d9606ce5f37dab5">mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::setToEntryState()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00329">mlir::ArithBuilder::sgt()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01133">shortenAddChainsContainingAll()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00972">simplifyCeilDiv()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00913">simplifyFloorDiv()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01019">simplifyMod()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00836">simplifyMul()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00334">mlir::ArithBuilder::slt()</a>, <a class="el" href="Storage_8h_source.html#l00356">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::sortInPlace()</a>, <a class="el" href="ODS_2Context_8cpp_source.html#l00081">sortMapByName()</a>, <a class="el" href="File_8cpp_source.html#l00109">streq()</a>, <a class="el" href="File_8cpp_source.html#l00114">strne()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00801">mlir::ValueBoundsConstraintSet::strongCompare()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00377">mlir::affine::AffineBuilder::sub()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00319">mlir::ArithBuilder::sub()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00056">subIntegerAttrs()</a>, <a class="el" href="Class_8cpp_source.html#l00054">mlir::tblgen::MethodParameters::subsumes()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00754">mlir::detail::OpToOpPassAdaptor::tryMergeInto()</a>, <a class="el" href="DimLvlMap_8cpp_source.html#l00040">mlir::sparse_tensor::ir_detail::DimLvlExpr::unpackBinop()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01347">mlir::SimpleAffineExprFlattener::visitAddExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01371">mlir::SimpleAffineExprFlattener::visitModExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01320">mlir::SimpleAffineExprFlattener::visitMulExpr()</a>, <a class="el" href="classmlir_1_1arith_1_1impl_1_1ArithIntRangeOptsBase.html#ae6c162833de835e2faca963ec827a786">mlir::arith::impl::ArithIntRangeOptsBase&lt; DerivedT &gt;::~ArithIntRangeOptsBase()</a>, <a class="el" href="classmlir_1_1LocalAliasAnalysis.html#a68468af8b42038a15f857b5f229e2c44">mlir::LocalAliasAnalysis::~LocalAliasAnalysis()</a>, and <a class="el" href="classmlir_1_1SimpleAffineExprFlattener.html#a87c4398e4b523c2f51f8e19e85b8a56c">mlir::SimpleAffineExprFlattener::~SimpleAffineExprFlattener()</a>.</p>

</div>
</div>
<a id="ac7f01b5df0ebd2339035b77990cda224" name="ac7f01b5df0ebd2339035b77990cda224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f01b5df0ebd2339035b77990cda224">&#9670;&#160;</a></span>rhs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rhs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">832</a> of file <a class="el" href="IR_2AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
