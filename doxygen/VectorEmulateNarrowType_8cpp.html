<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Vector/Transforms/VectorEmulateNarrowType.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a href="dir_84ad971b6ccc87b19bc57b4cf8f3f79f.html">Vector</a></li><li class="navelem"><a href="dir_7b47e7ae615a7c9f8246c22d2b9965e5.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">VectorEmulateNarrowType.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Arith_2IR_2Arith_8h_source.html">mlir/Dialect/Arith/IR/Arith.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="NarrowTypeEmulationConverter_8h_source.html">mlir/Dialect/Arith/Transforms/NarrowTypeEmulationConverter.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html">mlir/Dialect/Arith/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2MemRef_2IR_2MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html">mlir/Dialect/MemRef/Utils/MemRefUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StaticValueUtils_8h_source.html">mlir/Dialect/Utils/StaticValueUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VectorOps_8h_source.html">mlir/Dialect/Vector/IR/VectorOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VectorRewritePatterns_8h_source.html">mlir/Dialect/Vector/Transforms/VectorRewritePatterns.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">mlir/IR/BuiltinAttributes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html">mlir/IR/BuiltinTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OpDefinition_8h_source.html">mlir/IR/OpDefinition.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TypeUtilities_8h_source.html">mlir/IR/TypeUtilities.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Value_8h_source.html">mlir/IR/Value.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DialectConversion_8h_source.html">mlir/Transforms/DialectConversion.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallVector.h&quot;</code><br />
<code>#include &quot;llvm/Support/DebugLog.h&quot;</code><br />
<code>#include &quot;llvm/Support/MathExtras.h&quot;</code><br />
<code>#include &quot;llvm/Support/raw_ostream.h&quot;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2MemRef_2Transforms_2Transforms_8h_source.html">mlir/Dialect/MemRef/Transforms/Transforms.h</a>&quot;</code><br />
</div>
<p><a href="VectorEmulateNarrowType_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d" id="r_ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;vector-narrow-type-emulation&quot;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2d64d471ce94f28c7e82b6f29fa0e431" id="r_a2d64d471ce94f28c7e82b6f29fa0e431"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d64d471ce94f28c7e82b6f29fa0e431">VectorValue</a> = <a class="el" href="namespacemlir.html#a864cb5eb1fea4a548c28cda535ba7213">TypedValue</a>&lt;VectorType&gt;</td></tr>
<tr class="memitem:a28033943fc021db6b8deba1ec1450120" id="r_a28033943fc021db6b8deba1ec1450120"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28033943fc021db6b8deba1ec1450120">MemRefValue</a> = <a class="el" href="namespacemlir.html#a864cb5eb1fea4a548c28cda535ba7213">TypedValue</a>&lt;MemRefType&gt;</td></tr>
<tr class="memitem:a26a9bf6c66c6d4510e9e77b83304007e" id="r_a26a9bf6c66c6d4510e9e77b83304007e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26a9bf6c66c6d4510e9e77b83304007e">ExtractNBitsFn</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a38b889553f2c05291ada9279b800e744" id="r_a38b889553f2c05291ada9279b800e744"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38b889553f2c05291ada9279b800e744">getCompressedMaskOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> mask, int numSrcElems, int numSrcElemsPerDest, int numFrontPadElems=0)</td></tr>
<tr class="memdesc:a38b889553f2c05291ada9279b800e744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a compressed mask for the emulated vector.  <br /></td></tr>
<tr class="memitem:a76133999c3d0810950b851092ce284e6" id="r_a76133999c3d0810950b851092ce284e6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76133999c3d0810950b851092ce284e6">staticallyExtractSubvector</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classint64__t.html">int64_t</a> offset, <a class="el" href="classint64__t.html">int64_t</a> numElemsToExtract)</td></tr>
<tr class="memdesc:a76133999c3d0810950b851092ce284e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts 1-D subvector from a 1-D vector.  <br /></td></tr>
<tr class="memitem:a6948cb6d9ad21681ceef633c97286069" id="r_a6948cb6d9ad21681ceef633c97286069"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6948cb6d9ad21681ceef633c97286069">staticallyInsertSubvector</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dest, <a class="el" href="classint64__t.html">int64_t</a> offset)</td></tr>
<tr class="memdesc:a6948cb6d9ad21681ceef633c97286069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts 1-D subvector into a 1-D vector.  <br /></td></tr>
<tr class="memitem:a89da042778402bda8563e362fa434987" id="r_a89da042778402bda8563e362fa434987"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89da042778402bda8563e362fa434987">dynamicallyExtractSubVector</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dest, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> offset, <a class="el" href="classint64__t.html">int64_t</a> numElemsToExtract)</td></tr>
<tr class="memdesc:a89da042778402bda8563e362fa434987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts 1-D subvector from a 1-D vector.  <br /></td></tr>
<tr class="memitem:a5f100d0dc86bf5acd8c9781de38e2b3a" id="r_a5f100d0dc86bf5acd8c9781de38e2b3a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f100d0dc86bf5acd8c9781de38e2b3a">dynamicallyInsertSubVector</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dest, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> offset, <a class="el" href="classint64__t.html">int64_t</a> numElemsToInsert)</td></tr>
<tr class="memdesc:a5f100d0dc86bf5acd8c9781de38e2b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts 1-D subvector into a 1-D vector.  <br /></td></tr>
<tr class="memitem:a2ad49d596deced30e386bcbdcbfdf185" id="r_a2ad49d596deced30e386bcbdcbfdf185"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a2d64d471ce94f28c7e82b6f29fa0e431">VectorValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ad49d596deced30e386bcbdcbfdf185">emulatedVectorLoad</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> base, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> linearizedIndices, <a class="el" href="classint64__t.html">int64_t</a> numContainerElemsToLoad, <a class="el" href="classmlir_1_1Type.html">Type</a> emulatedElemTy, <a class="el" href="classmlir_1_1Type.html">Type</a> containerElemTy)</td></tr>
<tr class="memdesc:a2ad49d596deced30e386bcbdcbfdf185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emulate a vector load for <span class="tt">emulatedElemTy</span> using <span class="tt">containerElemTy</span>  <br /></td></tr>
<tr class="memitem:a4d640fe27780dd868376f9434eb880d8" id="r_a4d640fe27780dd868376f9434eb880d8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d640fe27780dd868376f9434eb880d8">downcastSelectAndUpcast</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, VectorType downcastType, VectorType upcastType, <a class="el" href="classmlir_1_1Value.html">Value</a> mask, <a class="el" href="classmlir_1_1Value.html">Value</a> trueValue, <a class="el" href="classmlir_1_1Value.html">Value</a> falseValue)</td></tr>
<tr class="memdesc:a4d640fe27780dd868376f9434eb880d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downcast two values to <span class="tt">downcastType</span>, then select values based on <span class="tt">mask</span>, and casts the result to <span class="tt">upcastType</span>.  <br /></td></tr>
<tr class="memitem:a6970f1dfcca73a2693324031f791d74f" id="r_a6970f1dfcca73a2693324031f791d74f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6970f1dfcca73a2693324031f791d74f">atomicRMW</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="#a28033943fc021db6b8deba1ec1450120">MemRefValue</a> linearizedMemref, <a class="el" href="classmlir_1_1Value.html">Value</a> storeIdx, <a class="el" href="#a2d64d471ce94f28c7e82b6f29fa0e431">VectorValue</a> valueToStore, <a class="el" href="classmlir_1_1Value.html">Value</a> mask)</td></tr>
<tr class="memdesc:a6970f1dfcca73a2693324031f791d74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits <span class="tt">memref.generic_atomic_rmw</span> op to store a subbyte-sized value to a byte in <span class="tt">linearizedMemref</span>, with a mask.  <br /></td></tr>
<tr class="memitem:aa138c8bc07ff189c5720bb403c08eefa" id="r_aa138c8bc07ff189c5720bb403c08eefa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa138c8bc07ff189c5720bb403c08eefa">nonAtomicRMW</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="#a28033943fc021db6b8deba1ec1450120">MemRefValue</a> linearizedMemref, <a class="el" href="classmlir_1_1Value.html">Value</a> linearizedIndex, <a class="el" href="#a2d64d471ce94f28c7e82b6f29fa0e431">VectorValue</a> valueToStore, <a class="el" href="classmlir_1_1Value.html">Value</a> mask)</td></tr>
<tr class="memdesc:aa138c8bc07ff189c5720bb403c08eefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a non-atomic read-modify-write sequence for storing to the emulated type.  <br /></td></tr>
<tr class="memitem:a04719b05f14cef6baf87cb070aef78b6" id="r_a04719b05f14cef6baf87cb070aef78b6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04719b05f14cef6baf87cb070aef78b6">extractSliceIntoByte</a> (ConversionPatternRewriter &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="#a2d64d471ce94f28c7e82b6f29fa0e431">VectorValue</a> vector, <a class="el" href="classint64__t.html">int64_t</a> extractOffset, <a class="el" href="classint64__t.html">int64_t</a> sliceNumElements, <a class="el" href="classint64__t.html">int64_t</a> insertOffset)</td></tr>
<tr class="memdesc:a04719b05f14cef6baf87cb070aef78b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract <span class="tt">sliceNumElements</span> from source <span class="tt">vector</span> at <span class="tt">extractOffset</span>, and insert it into an empty vector at <span class="tt">insertOffset</span>.  <br /></td></tr>
<tr class="memitem:aeb1b24f3cde50d42fef303b0ebe67364" id="r_aeb1b24f3cde50d42fef303b0ebe67364"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb1b24f3cde50d42fef303b0ebe67364">operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, const <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; SourceElementRangeList &gt; &amp;vec)</td></tr>
<tr class="memitem:a7d96e76e84d8af92f8ac368b72d4b40e" id="r_a7d96e76e84d8af92f8ac368b72d4b40e"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d96e76e84d8af92f8ac368b72d4b40e">commonConversionPrecondition</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, VectorType preconditionType, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a7d96e76e84d8af92f8ac368b72d4b40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the precondition type meets the common preconditions for any conversion.  <br /></td></tr>
<tr class="memitem:a960826bbcd93fb9974ff9ad1792541b2" id="r_a960826bbcd93fb9974ff9ad1792541b2"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a960826bbcd93fb9974ff9ad1792541b2">alignedConversionPrecondition</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, VectorType subByteVecTy, <a class="el" href="classmlir_1_1Type.html">Type</a> containerTy, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a960826bbcd93fb9974ff9ad1792541b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that <span class="tt">subByteVecTy</span> (vector) and <span class="tt">containerTy</span> (scalar) are aligned.  <br /></td></tr>
<tr class="memitem:ab04194675eda9f63545082591a0d8b4b" id="r_ab04194675eda9f63545082591a0d8b4b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab04194675eda9f63545082591a0d8b4b">bitcastSubByteVectorToI8</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> subByteVec)</td></tr>
<tr class="memdesc:ab04194675eda9f63545082591a0d8b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitcasts the aligned <span class="tt">subByteVec</span> vector to a vector of i8.  <br /></td></tr>
<tr class="memitem:ae0c0836374a33b256b8cefd18f39fc6c" id="r_ae0c0836374a33b256b8cefd18f39fc6c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0c0836374a33b256b8cefd18f39fc6c">extractNBitsPerByteAndSignExtendToI8</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> src, int bitIdx, int numBits)</td></tr>
<tr class="memdesc:ae0c0836374a33b256b8cefd18f39fc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a signed N-bit sequence from each element of a vector of bytes, starting at the specified bit index.  <br /></td></tr>
<tr class="memitem:ad6eef611a08fd66817cbbb78cfaf214a" id="r_ad6eef611a08fd66817cbbb78cfaf214a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6eef611a08fd66817cbbb78cfaf214a">extractNBitsPerByteAndExtendToI8</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> src, int bitIdx, int numBits)</td></tr>
<tr class="memdesc:ad6eef611a08fd66817cbbb78cfaf214a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an unsigned N-bit sequence from each element of a vector of bytes, starting at the specified bit index.  <br /></td></tr>
<tr class="memitem:a5610570a3e54108118ed5e794e39f098" id="r_a5610570a3e54108118ed5e794e39f098"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5610570a3e54108118ed5e794e39f098">rewriteI4ToI8Ext</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> srcValue, const <a class="el" href="#a26a9bf6c66c6d4510e9e77b83304007e">ExtractNBitsFn</a> &amp;extFn)</td></tr>
<tr class="memdesc:a5610570a3e54108118ed5e794e39f098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the i4 -&gt; i8 extension into a sequence of shuffles and bitwise ops to avoid leaving <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> to scramble with peephole optimizations.  <br /></td></tr>
<tr class="memitem:adcc7d07af18af15c996fa1dea0343384" id="r_adcc7d07af18af15c996fa1dea0343384"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcc7d07af18af15c996fa1dea0343384">rewriteI2ToI8Ext</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> srcValue, const <a class="el" href="#a26a9bf6c66c6d4510e9e77b83304007e">ExtractNBitsFn</a> &amp;extFn)</td></tr>
<tr class="memdesc:adcc7d07af18af15c996fa1dea0343384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the i2 -&gt; i8 extension into a sequence of shuffles and bitwise ops to avoid leaving <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> to scramble with peephole optimizations.  <br /></td></tr>
<tr class="memitem:a20ed0123915a373d03e3ff9aaa3840b0" id="r_a20ed0123915a373d03e3ff9aaa3840b0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20ed0123915a373d03e3ff9aaa3840b0">rewriteI8ToI4Trunc</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> srcValue)</td></tr>
<tr class="memdesc:a20ed0123915a373d03e3ff9aaa3840b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the i8 -&gt; i4 truncation into a deinterleave and series of bitwise ops to avoid leaving <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> to scramble with peephole optimizations.  <br /></td></tr>
</table>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&#160;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;vector-narrow-type-emulation&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00045">45</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

</div>
</div>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a26a9bf6c66c6d4510e9e77b83304007e" name="a26a9bf6c66c6d4510e9e77b83304007e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a9bf6c66c6d4510e9e77b83304007e">&#9670;&#160;</a></span>ExtractNBitsFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a26a9bf6c66c6d4510e9e77b83304007e">ExtractNBitsFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;<a class="code hl_class" href="classmlir_1_1Value.html">Value</a>(<a class="code hl_class" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;, <a class="code hl_class" href="classmlir_1_1Location.html">Location</a>, <a class="code hl_class" href="classmlir_1_1Value.html">Value</a>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>)&gt;</div>
<div class="ttc" id="aclassmlir_1_1Location_html"><div class="ttname"><a href="classmlir_1_1Location.html">mlir::Location</a></div><div class="ttdoc">This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...</div><div class="ttdef"><b>Definition</b> <a href="Location_8h_source.html#l00076">Location.h:76</a></div></div>
<div class="ttc" id="aclassmlir_1_1PatternRewriter_html"><div class="ttname"><a href="classmlir_1_1PatternRewriter.html">mlir::PatternRewriter</a></div><div class="ttdoc">A special type of RewriterBase that coordinates the application of a rewrite pattern on the current I...</div><div class="ttdef"><b>Definition</b> <a href="PatternMatch_8h_source.html#l00793">PatternMatch.h:793</a></div></div>
<div class="ttc" id="aclassmlir_1_1Value_html"><div class="ttname"><a href="classmlir_1_1Value.html">mlir::Value</a></div><div class="ttdoc">This class represents an instance of an SSA value in the MLIR system, representing a computable value...</div><div class="ttdef"><b>Definition</b> <a href="Value_8h_source.html#l00096">Value.h:96</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01847">1847</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

</div>
</div>
<a id="a28033943fc021db6b8deba1ec1450120" name="a28033943fc021db6b8deba1ec1450120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28033943fc021db6b8deba1ec1450120">&#9670;&#160;</a></span>MemRefValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a28033943fc021db6b8deba1ec1450120">MemRefValue</a> = <a class="el" href="namespacemlir.html#a864cb5eb1fea4a548c28cda535ba7213">TypedValue</a>&lt;MemRefType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00048">48</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

</div>
</div>
<a id="a2d64d471ce94f28c7e82b6f29fa0e431" name="a2d64d471ce94f28c7e82b6f29fa0e431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d64d471ce94f28c7e82b6f29fa0e431">&#9670;&#160;</a></span>VectorValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2d64d471ce94f28c7e82b6f29fa0e431">VectorValue</a> = <a class="el" href="namespacemlir.html#a864cb5eb1fea4a548c28cda535ba7213">TypedValue</a>&lt;VectorType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00047">47</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a960826bbcd93fb9974ff9ad1792541b2" name="a960826bbcd93fb9974ff9ad1792541b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960826bbcd93fb9974ff9ad1792541b2">&#9670;&#160;</a></span>alignedConversionPrecondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult alignedConversionPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>subByteVecTy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>containerTy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify that <span class="tt">subByteVecTy</span> (vector) and <span class="tt">containerTy</span> (scalar) are aligned. </p>
<p>Alignment means that <span class="tt">subByteVecTy</span> can be packed into a vector of <span class="tt">containerTy</span> elements. More specifically:</p><ol type="1">
<li>The bit-width of <span class="tt">containerTy</span> is a multiple of the bit-width of <span class="tt">subByteVecTy</span> elements. For example, for <span class="tt">i4</span> and <span class="tt">i16</span> this multiple is 4.</li>
<li>The multiple from 1. above divides evenly the number of the (trailing) elements in <span class="tt">subByteVecTy</span>.</li>
</ol>
<p>EXAMPLE 1: <span class="tt">subByteVecTy = vector&lt;2xi4&gt;</span>, and <span class="tt">containerTy = i16</span></p>
<p>2 divides evenly 4 ( = 16 / 4), hence both conditions are <em>met</em>.</p>
<p>EXAMPLE 2: <span class="tt">subByteVecTy = vector&lt;3xi4&gt;</span>, and <span class="tt">containerTy = i16</span></p>
<p>3 <em>does not</em> divide evenly 4 (= 16/4), hence the conditions are <em>not met</em>.</p>
<p>EXAMPLE 3: <span class="tt">subByteVecTy = vector&lt;3xi3&gt;</span>, and <span class="tt">containerTy = i16</span></p>
<p>16 <em>is not</em> a multiple of 3, hence the conditions are <em>not met</em>.</p>
<p>NOTE: This method assumes that common conversion preconditions are met. In particular, <span class="tt">containerTy</span> is assumed to be a multi-byte scalar type (e.g., i8, i16, i32). </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01634">1634</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00122">mlir::Type::getIntOrFloatBitWidth()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00116">mlir::Type::isIntOrFloat()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a6970f1dfcca73a2693324031f791d74f" name="a6970f1dfcca73a2693324031f791d74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6970f1dfcca73a2693324031f791d74f">&#9670;&#160;</a></span>atomicRMW()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> atomicRMW </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a28033943fc021db6b8deba1ec1450120">MemRefValue</a></td>          <td class="paramname"><span class="paramname"><em>linearizedMemref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>storeIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2d64d471ce94f28c7e82b6f29fa0e431">VectorValue</a></td>          <td class="paramname"><span class="paramname"><em>valueToStore</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emits <span class="tt">memref.generic_atomic_rmw</span> op to store a subbyte-sized value to a byte in <span class="tt">linearizedMemref</span>, with a mask. </p>
<p>The <span class="tt">valueToStore</span> is a vector of subbyte-sized elements, with size of 8 bits, and the mask is used to select which elements to store.</p>
<p>Inputs: linearizedMemref = |2|2|2|2| : &lt;4xi2&gt; (&lt;1xi8&gt;) storeIdx = 2 valueToStore = |3|3|3|3| : <a class="el" href="namespacemlir_1_1vector.html">vector&lt;4xi2&gt;</a> mask = |0|0|1|1| : <a class="el" href="namespacemlir_1_1vector.html">vector&lt;4xi1&gt;</a></p>
<p>Result: linearizedMemref = |2|2|3|3| : &lt;4xi2&gt; (&lt;1xi8&gt;) </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00419">419</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00384">downcastSelectAndUpcast()</a>, and <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="ab04194675eda9f63545082591a0d8b4b" name="ab04194675eda9f63545082591a0d8b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04194675eda9f63545082591a0d8b4b">&#9670;&#160;</a></span>bitcastSubByteVectorToI8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> bitcastSubByteVectorToI8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>subByteVec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitcasts the aligned <span class="tt">subByteVec</span> vector to a vector of i8. </p>
<p>Where aligned means it satisfies the alignedConversionPreconditions.</p>
<p>Example: <a class="el" href="namespacemlir_1_1vector.html">vector&lt;16x16xi2&gt;</a> -&gt; <a class="el" href="namespacemlir_1_1vector.html">vector&lt;16x4xi8&gt;</a> <a class="el" href="namespacemlir_1_1vector.html">vector&lt;16x16xi4&gt;</a> -&gt; <a class="el" href="namespacemlir_1_1vector.html">vector&lt;16x8xi8&gt;</a> </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01753">1753</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00059">mlir::Builder::getI8Type()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01872">rewriteI2ToI8Ext()</a>, and <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01852">rewriteI4ToI8Ext()</a>.</p>

</div>
</div>
<a id="a7d96e76e84d8af92f8ac368b72d4b40e" name="a7d96e76e84d8af92f8ac368b72d4b40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d96e76e84d8af92f8ac368b72d4b40e">&#9670;&#160;</a></span>commonConversionPrecondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult commonConversionPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>preconditionType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify that the precondition type meets the common preconditions for any conversion. </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01576">1576</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a4d640fe27780dd868376f9434eb880d8" name="a4d640fe27780dd868376f9434eb880d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d640fe27780dd868376f9434eb880d8">&#9670;&#160;</a></span>downcastSelectAndUpcast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> downcastSelectAndUpcast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>downcastType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>upcastType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>trueValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>falseValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downcast two values to <span class="tt">downcastType</span>, then select values based on <span class="tt">mask</span>, and casts the result to <span class="tt">upcastType</span>. </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00384">384</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00419">atomicRMW()</a>, and <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00450">nonAtomicRMW()</a>.</p>

</div>
</div>
<a id="a89da042778402bda8563e362fa434987" name="a89da042778402bda8563e362fa434987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89da042778402bda8563e362fa434987">&#9670;&#160;</a></span>dynamicallyExtractSubVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> dynamicallyExtractSubVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>numElemsToExtract</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts 1-D subvector from a 1-D vector. </p>
<p>Given the input rank-1 source vector, extracts <span class="tt">numElemsToExtact</span> elements from <span class="tt">src</span>, starting at <span class="tt">offset</span>. The result is also a rank-1 vector:</p>
<p>vector&lt;numElemsToExtact x !elType&gt;</p>
<p>(<span class="tt">!elType</span> is the element type of the source vector). As <span class="tt">offset</span> is assumed to be a <em>dynamic</em> SSA value, this helper method generates a sequence of <span class="tt">vector.extract</span> + <span class="tt">vector.insert</span> pairs.</p>
<p>EXAMPLE: v1 = vector.extract src[offset] : i2 from <a class="el" href="namespacemlir_1_1vector.html">vector&lt;8xi2&gt;</a> r1 = vector.insert v1, dest[0] : i2 into <a class="el" href="namespacemlir_1_1vector.html">vector&lt;3xi2&gt;</a> c1 = arith.constant 1 : index idx2 = arith.addi offset, c1 : index v2 = vector.extract src[idx2] : i2 from <a class="el" href="namespacemlir_1_1vector.html">vector&lt;8xi2&gt;</a> r2 = vector.insert v2, r1 [1] : i2 into <a class="el" href="namespacemlir_1_1vector.html">vector&lt;3xi2&gt;</a> (...) </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00283">283</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="Builders_8cpp_source.html#l00051">mlir::Builder::getIndexType()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a5f100d0dc86bf5acd8c9781de38e2b3a" name="a5f100d0dc86bf5acd8c9781de38e2b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f100d0dc86bf5acd8c9781de38e2b3a">&#9670;&#160;</a></span>dynamicallyInsertSubVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> dynamicallyInsertSubVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>numElemsToInsert</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts 1-D subvector into a 1-D vector. </p>
<p>Inserts the input rank-1 source vector into the destination vector starting at <span class="tt">offset</span>. As <span class="tt">offset</span> is assumed to be a <em>dynamic</em> SSA value, this hook uses a sequence of <span class="tt">vector.extract</span> + <span class="tt">vector.insert</span> pairs.</p>
<p>EXAMPLE: v1 = vector.extract src[0] : i2 from <a class="el" href="namespacemlir_1_1vector.html">vector&lt;8xi2&gt;</a> r1 = vector.insert v1, dest[offset] : i2 into <a class="el" href="namespacemlir_1_1vector.html">vector&lt;3xi2&gt;</a> c1 = arith.constant 1 : index idx2 = arith.addi offset, c1 : index v2 = vector.extract src[1] : i2 from <a class="el" href="namespacemlir_1_1vector.html">vector&lt;8xi2&gt;</a> r2 = vector.insert v2, r1 [idx2] : i2 into <a class="el" href="namespacemlir_1_1vector.html">vector&lt;3xi2&gt;</a> (...) </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00327">327</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="Builders_8cpp_source.html#l00051">mlir::Builder::getIndexType()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>.</p>

</div>
</div>
<a id="a2ad49d596deced30e386bcbdcbfdf185" name="a2ad49d596deced30e386bcbdcbfdf185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad49d596deced30e386bcbdcbfdf185">&#9670;&#160;</a></span>emulatedVectorLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2d64d471ce94f28c7e82b6f29fa0e431">VectorValue</a> emulatedVectorLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>linearizedIndices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>numContainerElemsToLoad</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>emulatedElemTy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>containerElemTy</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emulate a vector load for <span class="tt">emulatedElemTy</span> using <span class="tt">containerElemTy</span> </p>
<p>Specifically, use <span class="tt">containerElemTy</span> for loading a vector of <span class="tt">emulatedElemTy</span>. The load location is given by <span class="tt">base</span> and <span class="tt">linearizedIndices</span>, and the load size is given by <span class="tt">numEmulatedElementsToLoad</span>. </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00364">364</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00122">mlir::Type::getIntOrFloatBitWidth()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>.</p>

</div>
</div>
<a id="ad6eef611a08fd66817cbbb78cfaf214a" name="ad6eef611a08fd66817cbbb78cfaf214a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6eef611a08fd66817cbbb78cfaf214a">&#9670;&#160;</a></span>extractNBitsPerByteAndExtendToI8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> extractNBitsPerByteAndExtendToI8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bitIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numBits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an unsigned N-bit sequence from each element of a vector of bytes, starting at the specified bit index. </p>
<p>The <span class="tt">bitIdx</span> starts at 0 from the LSB and moves to the left.</p>
<p>Example for a single element: Extract numBits=2 starting at bitIdx=2 src = [0 | 1 | 0 | 1 | 1 | 0 | 1 | 0] indices = [7 | 6 | 5 | 4 | 3 | 2 | 1 | 0] target = [. . . . ^ ^ . .]</p>
<p>The target sequence is [10](decimal=2) as unsigned 2-bit integer. So the result should be [00 00 00 10](decimal=2) as unsigned 8-bit integer.</p>
<p>src = [01 01 10 10] mask = [00 00 00 11] shr = arith.shrui(src, 2) = [00 01 01 10] result = arith.andi(shr, mask) = [00 00 00 10] NOTE: Similarly to extractNBitsPerByteAndSignExtendToI8, this could be achieved by using arith::ShLIOp + arith::ShRUIOp instead of the masking. However, by using arith::ShRUIOp + arith::AndIOp, we are eliminating shift left when the index is 0. </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01825">1825</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="ae0c0836374a33b256b8cefd18f39fc6c" name="ae0c0836374a33b256b8cefd18f39fc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c0836374a33b256b8cefd18f39fc6c">&#9670;&#160;</a></span>extractNBitsPerByteAndSignExtendToI8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> extractNBitsPerByteAndSignExtendToI8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bitIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numBits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a signed N-bit sequence from each element of a vector of bytes, starting at the specified bit index. </p>
<p>The <span class="tt">bitIdx</span> starts at 0 from the LSB and moves to the left.</p>
<p>Example for a single element: Extract numBits=2 starting at bitIdx=2 src = [0 | 1 | 0 | 1 | 1 | 1 | 1 | 0] indices = [7 | 6 | 5 | 4 | 3 | 2 | 1 | 0] target = [. . . . ^ ^ . .]</p>
<p>The target sequence is [11](decimal=-1) as signed 2-bit integer. So the result should be [11 11 11 11](decimal=-1) as signed 8-bit integer.</p>
<p>src = [01 01 11 10] shl = arith.shl(src, 4) -&gt; [11 10 00 00] result = arith.shrsi(shl, 6) -&gt; [11 11 11 11] </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01783">1783</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a04719b05f14cef6baf87cb070aef78b6" name="a04719b05f14cef6baf87cb070aef78b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04719b05f14cef6baf87cb070aef78b6">&#9670;&#160;</a></span>extractSliceIntoByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> extractSliceIntoByte </td>
          <td>(</td>
          <td class="paramtype">ConversionPatternRewriter &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2d64d471ce94f28c7e82b6f29fa0e431">VectorValue</a></td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>extractOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>sliceNumElements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>insertOffset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract <span class="tt">sliceNumElements</span> from source <span class="tt">vector</span> at <span class="tt">extractOffset</span>, and insert it into an empty vector at <span class="tt">insertOffset</span>. </p>
<p>Inputs: vec_in = |0|1|2|3| : <a class="el" href="namespacemlir_1_1vector.html">vector&lt;4xi2&gt;</a> extractOffset = 1 sliceNumElements = 2 insertOffset = 2 Output: vec_out = |0|0|1|2| : <a class="el" href="namespacemlir_1_1vector.html">vector&lt;4xi2&gt;</a> </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00479">479</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00214">staticallyExtractSubvector()</a>, and <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00247">staticallyInsertSubvector()</a>.</p>

</div>
</div>
<a id="a38b889553f2c05291ada9279b800e744" name="a38b889553f2c05291ada9279b800e744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b889553f2c05291ada9279b800e744">&#9670;&#160;</a></span>getCompressedMaskOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; getCompressedMaskOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSrcElems</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSrcElemsPerDest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numFrontPadElems</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a compressed mask for the emulated vector. </p>
<p>For example, when emulating an eight-element <span class="tt">i8</span> vector with <span class="tt">i32</span> (i.e. when the source elements span two dest elements), this method compresses <span class="tt">vector&lt;8xi1&gt;</span> into <span class="tt">vector&lt;2xi1&gt;</span>.</p>
<p>The compressed/output mask value is set iff any mask in the corresponding <span class="tt">numSrcElemsPerDest</span> range of uncompressed/input masks is set. E.g., if <span class="tt">numSrcElemsPerDest</span> equals to 2, and <span class="tt">numFrontPadElems</span> equals to 1, the following mask:</p>
<p>mask = [1, 1, 0, 0, 0, 0]</p>
<p>will first be padded in the front with <span class="tt">numFrontPadElems</span> zeros, and zeros will be added in the back to make the number of elements a multiple of <span class="tt">numSrcElemsPerDest</span> (for easier computation). The resulting mask will be:</p>
<p>mask = [0, 1, 1, 0, 0, 0, 0, 0]</p>
<p>then it will return the following new compressed mask:</p>
<p>mask = [1, 1, 0, 0]</p>
<p>NOTE: <span class="tt">numFrontPadElems</span> is assumed to be strictly smaller than <span class="tt">numSrcElemsPerDest</span>. </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00078">78</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00081">mlir::getAsOpFoldResult()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Builders_8cpp_source.html#l00053">mlir::Builder::getI1Type()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00428">mlir::Operation::getResultTypes()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

</div>
</div>
<a id="aa138c8bc07ff189c5720bb403c08eefa" name="aa138c8bc07ff189c5720bb403c08eefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa138c8bc07ff189c5720bb403c08eefa">&#9670;&#160;</a></span>nonAtomicRMW()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> nonAtomicRMW </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a28033943fc021db6b8deba1ec1450120">MemRefValue</a></td>          <td class="paramname"><span class="paramname"><em>linearizedMemref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>linearizedIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2d64d471ce94f28c7e82b6f29fa0e431">VectorValue</a></td>          <td class="paramname"><span class="paramname"><em>valueToStore</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a non-atomic read-modify-write sequence for storing to the emulated type. </p>
<p>It has similar logic to <span class="tt">atomicRMWStore</span>, but without atomicity. </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00450">450</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00384">downcastSelectAndUpcast()</a>, and <a class="el" href="LLVMDialect_8cpp_source.html#l03239">getElementType()</a>.</p>

</div>
</div>
<a id="aeb1b24f3cde50d42fef303b0ebe67364" name="aeb1b24f3cde50d42fef303b0ebe67364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1b24f3cde50d42fef303b0ebe67364">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; SourceElementRangeList &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01519">1519</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

</div>
</div>
<a id="adcc7d07af18af15c996fa1dea0343384" name="adcc7d07af18af15c996fa1dea0343384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc7d07af18af15c996fa1dea0343384">&#9670;&#160;</a></span>rewriteI2ToI8Ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> rewriteI2ToI8Ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>srcValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a26a9bf6c66c6d4510e9e77b83304007e">ExtractNBitsFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>extFn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrite the i2 -&gt; i8 extension into a sequence of shuffles and bitwise ops to avoid leaving <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> to scramble with peephole optimizations. </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01872">1872</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01753">bitcastSubByteVectorToI8()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a5610570a3e54108118ed5e794e39f098" name="a5610570a3e54108118ed5e794e39f098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5610570a3e54108118ed5e794e39f098">&#9670;&#160;</a></span>rewriteI4ToI8Ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> rewriteI4ToI8Ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>srcValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a26a9bf6c66c6d4510e9e77b83304007e">ExtractNBitsFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>extFn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrite the i4 -&gt; i8 extension into a sequence of shuffles and bitwise ops to avoid leaving <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> to scramble with peephole optimizations. </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01852">1852</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01753">bitcastSubByteVectorToI8()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a20ed0123915a373d03e3ff9aaa3840b0" name="a20ed0123915a373d03e3ff9aaa3840b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ed0123915a373d03e3ff9aaa3840b0">&#9670;&#160;</a></span>rewriteI8ToI4Trunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> rewriteI8ToI4Trunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>srcValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrite the i8 -&gt; i4 truncation into a deinterleave and series of bitwise ops to avoid leaving <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> to scramble with peephole optimizations. </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01908">1908</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00057">mlir::Builder::getI4Type()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a76133999c3d0810950b851092ce284e6" name="a76133999c3d0810950b851092ce284e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76133999c3d0810950b851092ce284e6">&#9670;&#160;</a></span>staticallyExtractSubvector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> staticallyExtractSubvector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>numElemsToExtract</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts 1-D subvector from a 1-D vector. </p>
<p>Given the input rank-1 source vector, extracts <span class="tt">numElemsToExtract</span> elements from <span class="tt">src</span>, starting at <span class="tt">offset</span>. The result is also a rank-1 vector:</p>
<p>vector&lt;numElemsToExtract x !elemType&gt;</p>
<p>(<span class="tt">!elType</span> is the element type of the source vector). As <span class="tt">offset</span> is a known <em>static</em> value, this helper hook emits <span class="tt">vector.extract_strided_slice</span>.</p>
<p>EXAMPLE: res = vector.extract_strided_slice src { offsets = [offset], sizes = [numElemsToExtract], strides = [1] } </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00214">214</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00281">mlir::Builder::getI64ArrayAttr()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00479">extractSliceIntoByte()</a>.</p>

</div>
</div>
<a id="a6948cb6d9ad21681ceef633c97286069" name="a6948cb6d9ad21681ceef633c97286069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6948cb6d9ad21681ceef633c97286069">&#9670;&#160;</a></span>staticallyInsertSubvector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> staticallyInsertSubvector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts 1-D subvector into a 1-D vector. </p>
<p>Inserts the input rank-1 source vector into the destination vector starting at <span class="tt">offset</span>. As <span class="tt">offset</span> is a known <em>static</em> value, this helper hook emits <span class="tt">vector.insert_strided_slice</span>.</p>
<p>EXAMPLE: res = vector.insert_strided_slice src, dest {offsets = [offset], strides [1]} </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00247">247</a> of file <a class="el" href="VectorEmulateNarrowType_8cpp_source.html">VectorEmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00281">mlir::Builder::getI64ArrayAttr()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00479">extractSliceIntoByte()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
