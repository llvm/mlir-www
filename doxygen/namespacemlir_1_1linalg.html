<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::linalg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1linalg.html">linalg</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::linalg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1linalg_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1LinalgOpToLibraryCallRewrite.html">LinalgOpToLibraryCallRewrite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ContractionDimensions.html">ContractionDimensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions of a Linalg op loops that correspond to different kinds of a contraction dimension.  <a href="structmlir_1_1linalg_1_1ContractionDimensions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ConvolutionDimensions.html">ConvolutionDimensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions of a Linalg op loops that correspond to different kinds of a convolution dimension.  <a href="structmlir_1_1linalg_1_1ConvolutionDimensions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingAndFusionOptions.html">LinalgTilingAndFusionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1SplitReductionOptions.html">SplitReductionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split Reduction options.  <a href="structmlir_1_1linalg_1_1SplitReductionOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation to drop unit-extent dimensions from <code>linalg.generic</code> operations.  <a href="structmlir_1_1linalg_1_1ControlDropUnitDims.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DropUnitDimsResult.html">DropUnitDimsResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html">ElementwiseOpFusionResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse two <code>linalg.generic</code> operations that have a producer-consumer relationship captured through <code>fusedOperand</code>.  <a href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform standalone tiling of a single LinalgOp by <code>tileSizes</code>.  <a href="structmlir_1_1linalg_1_1TiledLinalgOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer using the <code>allocationFn</code> provided.  <a href="structmlir_1_1linalg_1_1PromotionInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1VectorizationResult.html">VectorizationResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after vectorizing.  <a href="structmlir_1_1linalg_1_1VectorizationResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1MultiSizeSpecification.html">MultiSizeSpecification</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A description of a multi-size tiling comprising tile sizes and numbers of tiles, expressed as Values which may or may not be constant.  <a href="structmlir_1_1linalg_1_1MultiSizeSpecification.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1StaticMultiSizeSpecification.html">StaticMultiSizeSpecification</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ContinuousTileSizeSpecification.html">ContinuousTileSizeSpecification</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1StaticContinuousTileSizeSpecification.html">StaticContinuousTileSizeSpecification</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html">ForallReductionTilingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after reduction tiling.  <a href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply transformation to split the single linalg op reduction into a parallel and reduction dimension.  <a href="structmlir_1_1linalg_1_1SplitReductionResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1CollapseResult.html">CollapseResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LowerPackResult.html">LowerPackResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LowerUnPackOpResult.html">LowerUnPackOpResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold the result of a <code>pack</code> call.  <a href="structmlir_1_1linalg_1_1PackResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PackTransposeResult.html">PackTransposeResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold the result of a <code>packTranspose</code> call.  <a href="structmlir_1_1linalg_1_1PackTransposeResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1BlockPackMatmulOptions.html">BlockPackMatmulOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DownscaleSizeOneWindowed2DConvolution.html">DownscaleSizeOneWindowed2DConvolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites 2-D convolution ops with size-1 window dimensions into 1-D convolution ops.  <a href="structmlir_1_1linalg_1_1DownscaleSizeOneWindowed2DConvolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DownscaleDepthwiseConv2DNhwcHwcOp.html">DownscaleDepthwiseConv2DNhwcHwcOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites 2-D depthwise convolution ops with size-1 (w, kw) or (h, kh) dimensions into 1-D depthwise convolution ops.  <a href="structmlir_1_1linalg_1_1DownscaleDepthwiseConv2DNhwcHwcOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DownscaleConv2DOp.html">DownscaleConv2DOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgGeneralizationPattern.html">LinalgGeneralizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg generalization pattern.  <a href="structmlir_1_1linalg_1_1LinalgGeneralizationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgSpecializationPattern.html">LinalgSpecializationPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1CopyVectorizationPattern.html">CopyVectorizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorization pattern for memref::CopyOp.  <a href="structmlir_1_1linalg_1_1CopyVectorizationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DecomposePadOpPattern.html">DecomposePadOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a tensor::PadOp into a sequence of EmptyOp, FillOp and InsertSliceOp.  <a href="structmlir_1_1linalg_1_1DecomposePadOpPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DecomposeOuterUnitDimsPackOpPattern.html">DecomposeOuterUnitDimsPackOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites a linalg::PackOp into a sequence of:  <a href="structmlir_1_1linalg_1_1DecomposeOuterUnitDimsPackOpPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DecomposeOuterUnitDimsUnPackOpPattern.html">DecomposeOuterUnitDimsUnPackOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites a linalg::UnPackOp into a sequence of rank-reduced.  <a href="structmlir_1_1linalg_1_1DecomposeOuterUnitDimsUnPackOpPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html">LinalgCopyVTRForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern:  <a href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html">LinalgCopyVTWForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern:  <a href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ExtractSliceOfPadTensorSwapPattern.html">ExtractSliceOfPadTensorSwapPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite extract_slice(tensor.pad(x)) into tensor.pad(extract_slice(x)).  <a href="structmlir_1_1linalg_1_1ExtractSliceOfPadTensorSwapPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containg offsets-sizes-strides arguments of the tiled shape.  <a href="structmlir_1_1linalg_1_1SliceParameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing the Linalg producer before and after fusion.  <a href="structmlir_1_1linalg_1_1FusionInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to get processor ID, and number of processors used for distribution for all parallel loops generated.  <a href="structmlir_1_1linalg_1_1ProcInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgLoopDistributionOptions.html">LinalgLoopDistributionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options that allow distribution of loops generated in Linalg transforms to processors while generating the loops.  <a href="structmlir_1_1linalg_1_1LinalgLoopDistributionOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1RegionMatcher.html">RegionMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing common matchers over linalg op's region.  <a href="structmlir_1_1linalg_1_1RegionMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1GenerateLoopNest.html">GenerateLoopNest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class used to generate nested loops with ranges described by <code>loopRanges</code> and loop type described by the <code>iteratorTypes</code>.  <a href="structmlir_1_1linalg_1_1GenerateLoopNest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1FoldTensorCastPackOp.html">FoldTensorCastPackOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds a tensor.cast op into a consuming PackOp op if the <code>tensor.cast</code> has source that is more static than the consuming op.  <a href="structmlir_1_1linalg_1_1FoldTensorCastPackOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1FoldTensorCastUnPackOp.html">FoldTensorCastUnPackOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds a tensor.cast op into a consuming UnPackOp op if the <code>tensor.cast</code> has source that is more static than the consuming op.  <a href="structmlir_1_1linalg_1_1FoldTensorCastUnPackOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a730df0415b8172eb93f8f7b346e04440"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a730df0415b8172eb93f8f7b346e04440">TileSizeComputationFunction</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td></tr>
<tr class="separator:a730df0415b8172eb93f8f7b346e04440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcbad447f843c9b98886ad6f49469a9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1bcbad447f843c9b98886ad6f49469a9">AllocBufferCallbackFn</a> = std::function&lt; std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, memref::SubViewOp subView, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; boundingSubViewSize, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)&gt;</td></tr>
<tr class="memdesc:a1bcbad447f843c9b98886ad6f49469a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to perform the allocation for the promoted <code>subView</code>.  <a href="namespacemlir_1_1linalg.html#a1bcbad447f843c9b98886ad6f49469a9">More...</a><br /></td></tr>
<tr class="separator:a1bcbad447f843c9b98886ad6f49469a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7afb284c4be072a74a24eeb71cc985"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3d7afb284c4be072a74a24eeb71cc985">DeallocBufferCallbackFn</a> = std::function&lt; LogicalResult(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> buffer)&gt;</td></tr>
<tr class="memdesc:a3d7afb284c4be072a74a24eeb71cc985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to deallocate the buffers used to hold the promoted subview.  <a href="namespacemlir_1_1linalg.html#a3d7afb284c4be072a74a24eeb71cc985">More...</a><br /></td></tr>
<tr class="separator:a3d7afb284c4be072a74a24eeb71cc985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49994e2aab61b35167972384684cf24"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa49994e2aab61b35167972384684cf24">CopyCallbackFn</a> = std::function&lt; LogicalResult(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)&gt;</td></tr>
<tr class="memdesc:aa49994e2aab61b35167972384684cf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to insert copy from original subview to subview of the promoted region for the read operands/subview of promoted region to original subview for the results.  <a href="namespacemlir_1_1linalg.html#aa49994e2aab61b35167972384684cf24">More...</a><br /></td></tr>
<tr class="separator:aa49994e2aab61b35167972384684cf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16099880d7579f488dd714c6273ea4c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> = std::function&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionOptions.html">SplitReductionOptions</a>(LinalgOp op)&gt;</td></tr>
<tr class="memdesc:ad16099880d7579f488dd714c6273ea4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function signature to control reduction splitting.  <a href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">More...</a><br /></td></tr>
<tr class="separator:ad16099880d7579f488dd714c6273ea4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9ca79033211e3e53e0eb25a8e9551b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, 4 &gt;</td></tr>
<tr class="separator:a4a9ca79033211e3e53e0eb25a8e9551b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f38324ff992b8ceebc6e3f0c01a57d1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a2f38324ff992b8ceebc6e3f0c01a57d1">DroppedUnitDimsBuilder</a> = std::function&lt; IndexingMapOpInterface(<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, IndexingMapOpInterface, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; newOperands, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; newIndexingMaps, const llvm::SmallDenseSet&lt; unsigned &gt; &amp;droppedDims)&gt;</td></tr>
<tr class="separator:a2f38324ff992b8ceebc6e3f0c01a57d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac636a02565dd1c1bdcb8eb5982bd07c1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac636a02565dd1c1bdcb8eb5982bd07c1">PadSizeComputationFunction</a> = std::function&lt; FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;(<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;, const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;)&gt;</td></tr>
<tr class="separator:ac636a02565dd1c1bdcb8eb5982bd07c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2363d9b68019db04dbf0c710afe7f224"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">LoopIndexToRangeIndexMap</a> = <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; int, int &gt;</td></tr>
<tr class="memdesc:a2363d9b68019db04dbf0c710afe7f224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a number of ranges equal to the number of non-zero in <code>tileSizes</code>.  <a href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">More...</a><br /></td></tr>
<tr class="separator:a2363d9b68019db04dbf0c710afe7f224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae020263d273fb7b7f80c4970556da5f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae020263d273fb7b7f80c4970556da5f8">ControlBlockPackMatmulFn</a> = std::function&lt; std::optional&lt; <a class="el" href="structmlir_1_1linalg_1_1BlockPackMatmulOptions.html">BlockPackMatmulOptions</a> &gt;(linalg::LinalgOp)&gt;</td></tr>
<tr class="memdesc:ae020263d273fb7b7f80c4970556da5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control matmul packing.  <a href="namespacemlir_1_1linalg.html#ae020263d273fb7b7f80c4970556da5f8">More...</a><br /></td></tr>
<tr class="separator:ae020263d273fb7b7f80c4970556da5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7326883dfd3172d344f305860482e9ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7326883dfd3172d344f305860482e9ff">OptimizeCopyFn</a> = std::function&lt; LogicalResult(<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;, tensor::PadOp, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td></tr>
<tr class="separator:a7326883dfd3172d344f305860482e9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3115e251fd057529cff9b2d44a0ba1c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)&gt;</td></tr>
<tr class="memdesc:a3115e251fd057529cff9b2d44a0ba1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control when to stop fusion.  <a href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">More...</a><br /></td></tr>
<tr class="separator:a3115e251fd057529cff9b2d44a0ba1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab145fd297a4850ad34e09aab2f669e65"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab145fd297a4850ad34e09aab2f669e65">ControlPropagationFn</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *opOperand)&gt;</td></tr>
<tr class="memdesc:ab145fd297a4850ad34e09aab2f669e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control propagation of <a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a>/unpack ops.  <a href="namespacemlir_1_1linalg.html#ab145fd297a4850ad34e09aab2f669e65">More...</a><br /></td></tr>
<tr class="separator:ab145fd297a4850ad34e09aab2f669e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d01335b6fc341e4b908d9ea5df7482"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac1d01335b6fc341e4b908d9ea5df7482">GetCollapsableDimensionsFn</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt;(linalg::LinalgOp)&gt;</td></tr>
<tr class="memdesc:ac1d01335b6fc341e4b908d9ea5df7482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type to control generic op dimension collapsing.  <a href="namespacemlir_1_1linalg.html#ac1d01335b6fc341e4b908d9ea5df7482">More...</a><br /></td></tr>
<tr class="separator:ac1d01335b6fc341e4b908d9ea5df7482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8978399adc7b5ab6a4574123f59d1f52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8978399adc7b5ab6a4574123f59d1f52">ControlFoldIntoPackUnpackFn</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *opOperand)&gt;</td></tr>
<tr class="memdesc:a8978399adc7b5ab6a4574123f59d1f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control folding operations like <code>tensor.pad</code> and <code>tensor.extract_slice</code> into <a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a>/unpack ops.  <a href="namespacemlir_1_1linalg.html#a8978399adc7b5ab6a4574123f59d1f52">More...</a><br /></td></tr>
<tr class="separator:a8978399adc7b5ab6a4574123f59d1f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651199aee7abd57b3b297b905d109183"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a651199aee7abd57b3b297b905d109183">ProcInfoCallBackFn</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a> &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; parallelLoopRanges)&gt;</td></tr>
<tr class="separator:a651199aee7abd57b3b297b905d109183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f513853f0b1d301ba8269c1d38a2a16"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9f513853f0b1d301ba8269c1d38a2a16">GridAxis</a> = <a class="el" href="namespacemlir_1_1shard.html#a0586307df42ba3b890713faf226e8736">shard::GridAxis</a></td></tr>
<tr class="separator:a9f513853f0b1d301ba8269c1d38a2a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc368615dd2afa818f751044efd890c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5dc368615dd2afa818f751044efd890c">ReductionKind</a> = shard::ReductionKind</td></tr>
<tr class="separator:a5dc368615dd2afa818f751044efd890c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4ef4fd46eecd339c2489be75f16729"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4c4ef4fd46eecd339c2489be75f16729">Sharding</a> = <a class="el" href="classmlir_1_1shard_1_1Sharding.html">shard::Sharding</a></td></tr>
<tr class="separator:a4c4ef4fd46eecd339c2489be75f16729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5799a7ecfd2ecc2d8c6f7e89f35ebbc5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5799a7ecfd2ecc2d8c6f7e89f35ebbc5">ShardingArray</a> = <a class="el" href="namespacemlir_1_1shard.html#a525729e2e9b80d6a92600457dd822f91">shard::ShardingArray</a></td></tr>
<tr class="separator:a5799a7ecfd2ecc2d8c6f7e89f35ebbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4c3fb63365bf26fe671663cd4d6d57"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5f4c3fb63365bf26fe671663cd4d6d57">GridOp</a> = shard::GridOp</td></tr>
<tr class="separator:a5f4c3fb63365bf26fe671663cd4d6d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">LinalgTilingLoopType</a> { <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8">Loops</a> = 0
, <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a6d8bf0bdeaca5ef4693524bf04c4c877">AffineLoops</a> = 1
, <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7">ParallelLoops</a> = 2
 }</td></tr>
<tr class="memdesc:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of loops to be generated during tiling.  <a href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">More...</a><br /></td></tr>
<tr class="separator:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7382d59369873eb3a9a9ddd571056982"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">DistributionMethod</a> { <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982ad71670d62b238eaf063979407361034e">Cyclic</a> = 0
, <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982abab54876ff518ecd2d59b46fd3be9c0e">CyclicNumProcsGeNumIters</a> = 1
, <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982ad93606014b9a6b479ba0e6faa948540b">CyclicNumProcsEqNumIters</a> = 2
, <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982a6adf97f83acf6453d4a6a4b1070f3754">None</a> = 3
 }</td></tr>
<tr class="memdesc:a7382d59369873eb3a9a9ddd571056982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheme used to distribute loops to processors.  <a href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">More...</a><br /></td></tr>
<tr class="separator:a7382d59369873eb3a9a9ddd571056982"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a703d4f21c6f57b8c680dc20dd6928a61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a703d4f21c6f57b8c680dc20dd6928a61">populateLinalgToStandardConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a703d4f21c6f57b8c680dc20dd6928a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Linalg to Standard.  <a href="namespacemlir_1_1linalg.html#a703d4f21c6f57b8c680dc20dd6928a61">More...</a><br /></td></tr>
<tr class="separator:a703d4f21c6f57b8c680dc20dd6928a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754ec5c5960c640563ddcd9727b77d87"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a754ec5c5960c640563ddcd9727b77d87">generateLibraryCallName</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a754ec5c5960c640563ddcd9727b77d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name mangled library call name to disambiguate between different overloads at the C level.  <a href="namespacemlir_1_1linalg.html#a754ec5c5960c640563ddcd9727b77d87">More...</a><br /></td></tr>
<tr class="separator:a754ec5c5960c640563ddcd9727b77d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962a46fba2ac497e30bb6d23fef35d1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a962a46fba2ac497e30bb6d23fef35d1a">makeAffineDimExprs</a> (unsigned num, unsigned &amp;startIdx, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a962a46fba2ac497e30bb6d23fef35d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>num</code> <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> dimensions at positions [startIdx, startIdx + num) and increments <code>startIdx</code> to <code>startIdx + num</code>.  <a href="namespacemlir_1_1linalg.html#a962a46fba2ac497e30bb6d23fef35d1a">More...</a><br /></td></tr>
<tr class="separator:a962a46fba2ac497e30bb6d23fef35d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956959faad992424aaa215510e50e618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a956959faad992424aaa215510e50e618">extractOrIdentityMap</a> (std::optional&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maybeMap, unsigned rank, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a956959faad992424aaa215510e50e618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code><a class="el" href="namespacemlir.html#ab4871db68c59a176135e0e35a3625e73" title="Helper method that injects context only if needed, this helps unify some of the attribute constructio...">maybeMap.get()</a></code> if <code>maybeMap</code> is set, otherwise returns the symbol-less identity map of <code>rank</code>.  <a href="namespacemlir_1_1linalg.html#a956959faad992424aaa215510e50e618">More...</a><br /></td></tr>
<tr class="separator:a956959faad992424aaa215510e50e618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4f8ea0aae80d24eeffa3fef8f1f08c43">concat</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; a, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; b)</td></tr>
<tr class="memdesc:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector that is the concatenation of <code>a</code> and <code>b</code>.  <a href="namespacemlir_1_1linalg.html#a4f8ea0aae80d24eeffa3fef8f1f08c43">More...</a><br /></td></tr>
<tr class="separator:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf73bb051fb347d6519cdcb174ba230e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aaf73bb051fb347d6519cdcb174ba230e">createOrFoldDimOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> val, int64_t dim)</td></tr>
<tr class="memdesc:aaf73bb051fb347d6519cdcb174ba230e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create one memref::DimOp or tensor::DimOp depending on the type of <code>val</code>.  <a href="namespacemlir_1_1linalg.html#aaf73bb051fb347d6519cdcb174ba230e">More...</a><br /></td></tr>
<tr class="separator:aaf73bb051fb347d6519cdcb174ba230e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dac633b692c130881f315320220fcce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6dac633b692c130881f315320220fcce">createFoldedDimOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> val, int64_t dim)</td></tr>
<tr class="memdesc:a6dac633b692c130881f315320220fcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create one memref::DimOp or tensor::DimOp depending on the type of <code>val</code>.  <a href="namespacemlir_1_1linalg.html#a6dac633b692c130881f315320220fcce">More...</a><br /></td></tr>
<tr class="separator:a6dac633b692c130881f315320220fcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae474be1b8e656c231ec447b79d2d5e8d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; WinogradConv2DFmr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae474be1b8e656c231ec447b79d2d5e8d">getWinogradConv2DFmr</a> (int64_t m, int64_t r)</td></tr>
<tr class="memdesc:ae474be1b8e656c231ec447b79d2d5e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given <code>m</code> and <code>r</code> parameters to a WinogradConv2DFmr enumeration value.  <a href="namespacemlir_1_1linalg.html#ae474be1b8e656c231ec447b79d2d5e8d">More...</a><br /></td></tr>
<tr class="separator:ae474be1b8e656c231ec447b79d2d5e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc482eff5fffe862c02f038c2a9d20f9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int64_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#acc482eff5fffe862c02f038c2a9d20f9">getFmrFromWinogradConv2DFmr</a> (WinogradConv2DFmr fmr)</td></tr>
<tr class="memdesc:acc482eff5fffe862c02f038c2a9d20f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given WinogradConv2DFmr enumeration value to a pair of m and r parameters.  <a href="namespacemlir_1_1linalg.html#acc482eff5fffe862c02f038c2a9d20f9">More...</a><br /></td></tr>
<tr class="separator:acc482eff5fffe862c02f038c2a9d20f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36b73b6c38d09eef01a3ab1bde4438f"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename  = std::enable_if_t&lt;std::is_same_v&lt;OpTy, linalg::PackOp&gt; ||                                      std::is_same_v&lt;OpTy, linalg::UnPackOp&gt;&gt;&gt; </td></tr>
<tr class="memitem:af36b73b6c38d09eef01a3ab1bde4438f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af36b73b6c38d09eef01a3ab1bde4438f">getPackedOuterShapeWithoutTransposition</a> (OpTy packOrUnPack)</td></tr>
<tr class="memdesc:af36b73b6c38d09eef01a3ab1bde4438f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outer shape in the packed domain before applying the transposition.  <a href="namespacemlir_1_1linalg.html#af36b73b6c38d09eef01a3ab1bde4438f">More...</a><br /></td></tr>
<tr class="separator:af36b73b6c38d09eef01a3ab1bde4438f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fe10e20900f7c49da8d51805f9e9f0"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContractionDimensions.html">ContractionDimensions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa2fe10e20900f7c49da8d51805f9e9f0">inferContractionDims</a> (LinalgOp linalgOp)</td></tr>
<tr class="memdesc:aa2fe10e20900f7c49da8d51805f9e9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find at least 2 parallel (m and n) and 1 reduction (k) dimension candidates that form a matmul subcomputation within <code>linalgOp</code>.  <a href="namespacemlir_1_1linalg.html#aa2fe10e20900f7c49da8d51805f9e9f0">More...</a><br /></td></tr>
<tr class="separator:aa2fe10e20900f7c49da8d51805f9e9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc6445c80fee3f958456e7e94740557"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContractionDimensions.html">ContractionDimensions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6cc6445c80fee3f958456e7e94740557">inferContractionDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; indexingMaps)</td></tr>
<tr class="separator:a6cc6445c80fee3f958456e7e94740557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5277093c168682f123f1e99d90461f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab5277093c168682f123f1e99d90461f0">isaContractionOpInterface</a> (LinalgOp linalgOp)</td></tr>
<tr class="memdesc:ab5277093c168682f123f1e99d90461f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>linalgOp</code> conforms to ContractionOpInterface.  <a href="namespacemlir_1_1linalg.html#ab5277093c168682f123f1e99d90461f0">More...</a><br /></td></tr>
<tr class="separator:ab5277093c168682f123f1e99d90461f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f1beb2cf9d6935a346b2e4b4d3c7f5"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ConvolutionDimensions.html">ConvolutionDimensions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a63f1beb2cf9d6935a346b2e4b4d3c7f5">inferConvolutionDims</a> (LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a63f1beb2cf9d6935a346b2e4b4d3c7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find at least 1 parallel (output_image) and reduction (filter_loop) dimension candidates that form a convolution subcomputation within <code>linalgOp</code>.  <a href="namespacemlir_1_1linalg.html#a63f1beb2cf9d6935a346b2e4b4d3c7f5">More...</a><br /></td></tr>
<tr class="separator:a63f1beb2cf9d6935a346b2e4b4d3c7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c76ee8dee2d6cb36fd4c974c60463f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7c76ee8dee2d6cb36fd4c974c60463f3">isaConvolutionOpInterface</a> (LinalgOp linalgOp, bool allowEmptyConvolvedDims=false)</td></tr>
<tr class="memdesc:a7c76ee8dee2d6cb36fd4c974c60463f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>linalgOp</code> conforms to ConvolutionOpInterface.  <a href="namespacemlir_1_1linalg.html#a7c76ee8dee2d6cb36fd4c974c60463f3">More...</a><br /></td></tr>
<tr class="separator:a7c76ee8dee2d6cb36fd4c974c60463f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171ae143026d28b2e6954c74bb535831"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a171ae143026d28b2e6954c74bb535831">isaCopyOpInterface</a> (LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a171ae143026d28b2e6954c74bb535831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>linalgOp</code> is semantically equivalent to a <code>linalg.copyOp</code>.  <a href="namespacemlir_1_1linalg.html#a171ae143026d28b2e6954c74bb535831">More...</a><br /></td></tr>
<tr class="separator:a171ae143026d28b2e6954c74bb535831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdf6fd72d97540e86680857176b705e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9fdf6fd72d97540e86680857176b705e">isaBroadcastOpInterface</a> (GenericOp genericOp)</td></tr>
<tr class="memdesc:a9fdf6fd72d97540e86680857176b705e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>genericOp</code> is semantically equivalent to a <code>linalg.broadcast</code>.  <a href="namespacemlir_1_1linalg.html#a9fdf6fd72d97540e86680857176b705e">More...</a><br /></td></tr>
<tr class="separator:a9fdf6fd72d97540e86680857176b705e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e0016d67ebca76011c67253b093af0"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a03e0016d67ebca76011c67253b093af0">isaTransposeOpInterface</a> (GenericOp genericOp)</td></tr>
<tr class="memdesc:a03e0016d67ebca76011c67253b093af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>genericOp</code> is semantically equivalent to a <code>linalg.transpose</code>.  <a href="namespacemlir_1_1linalg.html#a03e0016d67ebca76011c67253b093af0">More...</a><br /></td></tr>
<tr class="separator:a03e0016d67ebca76011c67253b093af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14eec3edd7d29c8980b155ed0dee1a0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a14eec3edd7d29c8980b155ed0dee1a0c">isaElemwiseSingleUnaryOpInterface</a> (GenericOp genericOp)</td></tr>
<tr class="memdesc:a14eec3edd7d29c8980b155ed0dee1a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a given <code>genericOp</code> is semantically equivalent to a single linalgelementwise unary op.  <a href="namespacemlir_1_1linalg.html#a14eec3edd7d29c8980b155ed0dee1a0c">More...</a><br /></td></tr>
<tr class="separator:a14eec3edd7d29c8980b155ed0dee1a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc247b3bd43d4462293e09845b698e7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#afc247b3bd43d4462293e09845b698e7a">isaElemwiseSingleBinaryOpInterface</a> (GenericOp genericOp)</td></tr>
<tr class="memdesc:afc247b3bd43d4462293e09845b698e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>genericOp</code> is semantically equivalent to a single linalg elementwise binary op e.g.  <a href="namespacemlir_1_1linalg.html#afc247b3bd43d4462293e09845b698e7a">More...</a><br /></td></tr>
<tr class="separator:afc247b3bd43d4462293e09845b698e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1ca69a91110433c24e13af5c4ae3a9"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aea1ca69a91110433c24e13af5c4ae3a9">isaFillOpInterface</a> (GenericOp genericOp)</td></tr>
<tr class="memdesc:aea1ca69a91110433c24e13af5c4ae3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>genericOp</code> is semantically equivalent to a <code>linalg.fill</code>.  <a href="namespacemlir_1_1linalg.html#aea1ca69a91110433c24e13af5c4ae3a9">More...</a><br /></td></tr>
<tr class="separator:aea1ca69a91110433c24e13af5c4ae3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e756b2e152d167af6823f8fb6298933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5e756b2e152d167af6823f8fb6298933">registerValueBoundsOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a5e756b2e152d167af6823f8fb6298933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64270d2058ef5fd99281df6e7de4464"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae64270d2058ef5fd99281df6e7de4464">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ae64270d2058ef5fd99281df6e7de4464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae5e64320c923f94446d6b60153fee4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0ae5e64320c923f94446d6b60153fee4">registerAllDialectInterfaceImplementations</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a0ae5e64320c923f94446d6b60153fee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab570ed1db81a641eb5b3d9948775e517"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab570ed1db81a641eb5b3d9948775e517">registerBufferizableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ab570ed1db81a641eb5b3d9948775e517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b3914ef0f129c2145a4c6512cdac8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae6b3914ef0f129c2145a4c6512cdac8c">hoistRedundantVectorTransfers</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *root, bool verifyNonZeroTrip=false)</td></tr>
<tr class="memdesc:ae6b3914ef0f129c2145a4c6512cdac8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist vector.transfer_read/vector.transfer_write on buffers pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are true:  <a href="namespacemlir_1_1linalg.html#ae6b3914ef0f129c2145a4c6512cdac8c">More...</a><br /></td></tr>
<tr class="separator:ae6b3914ef0f129c2145a4c6512cdac8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab283416b78913b7c9bb7f322758d98c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab283416b78913b7c9bb7f322758d98c9">hoistRedundantVectorBroadcasts</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *root)</td></tr>
<tr class="memdesc:ab283416b78913b7c9bb7f322758d98c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist vector.extract/vector.broadcast pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are met:  <a href="namespacemlir_1_1linalg.html#ab283416b78913b7c9bb7f322758d98c9">More...</a><br /></td></tr>
<tr class="separator:ab283416b78913b7c9bb7f322758d98c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d52ce7a6266192f3f98587b7c6575b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a34d52ce7a6266192f3f98587b7c6575b">registerRuntimeVerifiableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a34d52ce7a6266192f3f98587b7c6575b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ef5d2a9e63222d223b416027377828"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac6ef5d2a9e63222d223b416027377828">registerShardingInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ac6ef5d2a9e63222d223b416027377828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac973b30789682417b95981a6ea093fb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac973b30789682417b95981a6ea093fb3">registerSubsetOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ac973b30789682417b95981a6ea093fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae430d8314310084f3bfae3c0de4081dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae430d8314310084f3bfae3c0de4081dd">registerTilingInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ae430d8314310084f3bfae3c0de4081dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ea527040089116cd00f5fec9802ad8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a61ea527040089116cd00f5fec9802ad8">registerTilingInterfaceExternalModelsForPackUnPackOps</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a61ea527040089116cd00f5fec9802ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the above registeration, but it is only for <code>tensor.pack</code> and <code>tensor.unpack</code> ops.  <a href="namespacemlir_1_1linalg.html#a61ea527040089116cd00f5fec9802ad8">More...</a><br /></td></tr>
<tr class="separator:a61ea527040089116cd00f5fec9802ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27267a4634c46beba8c9f55c14cdfa1"><td class="memItemLeft" align="right" valign="top">enum WinogradConv2DFmr uint32_t std::optional&lt; vector::CombiningKind &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae27267a4634c46beba8c9f55c14cdfa1">getCombinerOpKind</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *combinerOp)</td></tr>
<tr class="memdesc:ae27267a4634c46beba8c9f55c14cdfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return vector::CombiningKind for the given op.  <a href="namespacemlir_1_1linalg.html#ae27267a4634c46beba8c9f55c14cdfa1">More...</a><br /></td></tr>
<tr class="separator:ae27267a4634c46beba8c9f55c14cdfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300387e92135ddafe3e8fcb45a1d0f4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a300387e92135ddafe3e8fcb45a1d0f4c">bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, tensor::PadOp padOp, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint=nullptr)</td></tr>
<tr class="memdesc:a300387e92135ddafe3e8fcb45a1d0f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a buffer allocation for the given tensor.pad op and lower the op to linalg.fill/linalg.generic + bufferization.materialize_in_destination.  <a href="namespacemlir_1_1linalg.html#a300387e92135ddafe3e8fcb45a1d0f4c">More...</a><br /></td></tr>
<tr class="separator:a300387e92135ddafe3e8fcb45a1d0f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6184483164da0417ac58d1d5086bbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a2b6184483164da0417ac58d1d5086bbc">bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, vector::MaskOp maskOp, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint=nullptr)</td></tr>
<tr class="memdesc:a2b6184483164da0417ac58d1d5086bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a buffer allocation for the given vector.mask op and bufferize the op, including its region.  <a href="namespacemlir_1_1linalg.html#a2b6184483164da0417ac58d1d5086bbc">More...</a><br /></td></tr>
<tr class="separator:a2b6184483164da0417ac58d1d5086bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73274fcc2e8e228f5f44c6336b96e7b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a73274fcc2e8e228f5f44c6336b96e7b7">bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, bufferization::AllocTensorOp allocTensorOp, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint=nullptr)</td></tr>
<tr class="memdesc:a73274fcc2e8e228f5f44c6336b96e7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a buffer allocation for the given bufferization.alloc_tensor op and lower the op to memref.alloc + memref.tensor_store.  <a href="namespacemlir_1_1linalg.html#a73274fcc2e8e228f5f44c6336b96e7b7">More...</a><br /></td></tr>
<tr class="separator:a73274fcc2e8e228f5f44c6336b96e7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d0ebe64f6077953145c8111cc3d955"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a72d0ebe64f6077953145c8111cc3d955">bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint=nullptr)</td></tr>
<tr class="memdesc:a72d0ebe64f6077953145c8111cc3d955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize the given op with tensor semantics and materialize the result in a newly allocated buffer.  <a href="namespacemlir_1_1linalg.html#a72d0ebe64f6077953145c8111cc3d955">More...</a><br /></td></tr>
<tr class="separator:a72d0ebe64f6077953145c8111cc3d955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7f777c5538e35bbdd3aaabdb07e6f7"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7b7f777c5538e35bbdd3aaabdb07e6f7">linalgOpAnchoredEmptyTensorEliminationStep</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">bufferization::OneShotAnalysisState</a> &amp;state)</td></tr>
<tr class="memdesc:a7b7f777c5538e35bbdd3aaabdb07e6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to eliminate tensor::EmptyOps inside <code>op</code> that are anchored on a LinalgOp.  <a href="namespacemlir_1_1linalg.html#a7b7f777c5538e35bbdd3aaabdb07e6f7">More...</a><br /></td></tr>
<tr class="separator:a7b7f777c5538e35bbdd3aaabdb07e6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa220da60546acce7c4a8b3635d5b21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8fa220da60546acce7c4a8b3635d5b21">areElementwiseOpsFusable</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)</td></tr>
<tr class="memdesc:a8fa220da60546acce7c4a8b3635d5b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if two <code>linalg.generic</code> operations with producer/consumer relationship through <code>fusedOperand</code> can be fused using elementwise op fusion.  <a href="namespacemlir_1_1linalg.html#a8fa220da60546acce7c4a8b3635d5b21">More...</a><br /></td></tr>
<tr class="separator:a8fa220da60546acce7c4a8b3635d5b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850b9fd11404efe17bca02011aff2e88"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a850b9fd11404efe17bca02011aff2e88">promoteSubviewsPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a850b9fd11404efe17bca02011aff2e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote memref.subviews feeding linalg-on-buffers operations.  <a href="namespacemlir_1_1linalg.html#a850b9fd11404efe17bca02011aff2e88">More...</a><br /></td></tr>
<tr class="separator:a850b9fd11404efe17bca02011aff2e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0310adee4f127279f9147a71db0181"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8d0310adee4f127279f9147a71db0181">vectorizeOpPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt; inputScalableVecDims={}, bool vectorizeNDExtract=false, bool flatten1DDepthwiseConv=false)</td></tr>
<tr class="memdesc:a8d0310adee4f127279f9147a71db0181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return success if the operation can be vectorized.  <a href="namespacemlir_1_1linalg.html#a8d0310adee4f127279f9147a71db0181">More...</a><br /></td></tr>
<tr class="separator:a8d0310adee4f127279f9147a71db0181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac980878e4ea40184d0a2183288fd0f61"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1DropUnitDimsResult.html">DropUnitDimsResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac980878e4ea40184d0a2183288fd0f61">dropUnitDims</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, IndexingMapOpInterface op, const <a class="el" href="namespacemlir_1_1linalg.html#a2f38324ff992b8ceebc6e3f0c01a57d1">DroppedUnitDimsBuilder</a> &amp;droppedUnitDimsBuilder, const <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:ac980878e4ea40184d0a2183288fd0f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6d6c0f10b756281634aebb9f69d5dd"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1DropUnitDimsResult.html">DropUnitDimsResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5b6d6c0f10b756281634aebb9f69d5dd">dropUnitDims</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, GenericOp genericOp, const <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:a5b6d6c0f10b756281634aebb9f69d5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ceec493e0b40673125a0402c3cf78e4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html">ElementwiseOpFusionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4ceec493e0b40673125a0402c3cf78e4">fuseElementwiseOps</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)</td></tr>
<tr class="separator:a4ceec493e0b40673125a0402c3cf78e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f70173e3ee102c2077ef5cdf5908001"><td class="memItemLeft" align="right" valign="top">llvm::SmallDenseSet&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4f70173e3ee102c2077ef5cdf5908001">getPreservedProducerResults</a> (GenericOp producer, GenericOp consumer, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)</td></tr>
<tr class="memdesc:a4f70173e3ee102c2077ef5cdf5908001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set of indices of the producer's results which would be preserved after the fusion.  <a href="namespacemlir_1_1linalg.html#a4f70173e3ee102c2077ef5cdf5908001">More...</a><br /></td></tr>
<tr class="separator:a4f70173e3ee102c2077ef5cdf5908001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae273bd1d7e48f4503eefba4f1487fa56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae273bd1d7e48f4503eefba4f1487fa56">peelLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ae273bd1d7e48f4503eefba4f1487fa56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to peel and canonicalize loop <code>op</code> and return the new result.  <a href="namespacemlir_1_1linalg.html#ae273bd1d7e48f4503eefba4f1487fa56">More...</a><br /></td></tr>
<tr class="separator:ae273bd1d7e48f4503eefba4f1487fa56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faa18744febf8ff36b38176ca04d8fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5faa18744febf8ff36b38176ca04d8fc">peelLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; loops)</td></tr>
<tr class="memdesc:a5faa18744febf8ff36b38176ca04d8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peel 'loops' and applies affine_min/max bounds simplification on the fly where relevant.  <a href="namespacemlir_1_1linalg.html#a5faa18744febf8ff36b38176ca04d8fc">More...</a><br /></td></tr>
<tr class="separator:a5faa18744febf8ff36b38176ca04d8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d1dafbd1447fdcbad0e11434292563"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a08d1dafbd1447fdcbad0e11434292563">rewriteAsPaddedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp opToPad, const <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, LinalgOp &amp;paddedOp, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;replacements, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; tensor::PadOp &gt; &amp;padOps)</td></tr>
<tr class="memdesc:a08d1dafbd1447fdcbad0e11434292563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the iterator dimensions <code>options.paddingDimensions</code> of all <code>opToPad</code> operands to a static bounding box.  <a href="namespacemlir_1_1linalg.html#a08d1dafbd1447fdcbad0e11434292563">More...</a><br /></td></tr>
<tr class="separator:a08d1dafbd1447fdcbad0e11434292563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372334d0c7a18ff500631d618d77c495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a372334d0c7a18ff500631d618d77c495">computePaddedShape</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="namespacemlir.html#a39768b5816332d4970911da09de5cec4">TypedValue</a>&lt; RankedTensorType &gt; v, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexingMap, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; indexingSizes, const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a372334d0c7a18ff500631d618d77c495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to compute the padded shape of the given value <code>v</code> of <code>RankedTensorType</code> given:  <a href="namespacemlir_1_1linalg.html#a372334d0c7a18ff500631d618d77c495">More...</a><br /></td></tr>
<tr class="separator:a372334d0c7a18ff500631d618d77c495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf886d8eb4668c4b2ad34db3a2d4bad"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8cf886d8eb4668c4b2ad34db3a2d4bad">computeIndexingMapOpInterfacePaddedShape</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;operandToPad, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; iterationDomain, const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a8cf886d8eb4668c4b2ad34db3a2d4bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specific helper for Linalg ops.  <a href="namespacemlir_1_1linalg.html#a8cf886d8eb4668c4b2ad34db3a2d4bad">More...</a><br /></td></tr>
<tr class="separator:a8cf886d8eb4668c4b2ad34db3a2d4bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bb7dd79e2a9d97a336bbd51ac947a4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; TilingInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae0bb7dd79e2a9d97a336bbd51ac947a4">rewriteAsPaddedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface opToPad, const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;constOptions, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; tensor::PadOp &gt; &amp;padOps, <a class="el" href="namespacemlir_1_1linalg.html#ac636a02565dd1c1bdcb8eb5982bd07c1">PadSizeComputationFunction</a> computePaddingSizeFun=&amp;<a class="el" href="namespacemlir_1_1linalg.html#a8cf886d8eb4668c4b2ad34db3a2d4bad">computeIndexingMapOpInterfacePaddedShape</a>)</td></tr>
<tr class="memdesc:ae0bb7dd79e2a9d97a336bbd51ac947a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the iterator dimensions <code>options.paddingDimensions</code> of <code>opToPad</code>.  <a href="namespacemlir_1_1linalg.html#ae0bb7dd79e2a9d97a336bbd51ac947a4">More...</a><br /></td></tr>
<tr class="separator:ae0bb7dd79e2a9d97a336bbd51ac947a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344a0fa8893af22df90d795e19c1a713"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a344a0fa8893af22df90d795e19c1a713">hoistPaddingOnTensors</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PadOp opToHoist, int64_t numLoops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; transposeVector, tensor::PadOp &amp;hoistedOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; TransposeOp &gt; &amp;transposeOps)</td></tr>
<tr class="memdesc:a344a0fa8893af22df90d795e19c1a713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mechanically hoist padding operations on tensors by <code>numLoops</code> into a new, generally larger tensor.  <a href="namespacemlir_1_1linalg.html#a344a0fa8893af22df90d795e19c1a713">More...</a><br /></td></tr>
<tr class="separator:a344a0fa8893af22df90d795e19c1a713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d7ae638195a0c07357a33d4b8cfec0"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac1d7ae638195a0c07357a33d4b8cfec0">hoistPaddingOnTensors</a> (tensor::PadOp opToHoist, int64_t numLoops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; transposeVector, tensor::PadOp &amp;hoistedOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; TransposeOp &gt; &amp;transposeOps)</td></tr>
<tr class="memdesc:ac1d7ae638195a0c07357a33d4b8cfec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls into <code>hoistPaddingOnTensors</code> with a local <a class="el" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ...">IRRewriter</a>.  <a href="namespacemlir_1_1linalg.html#ac1d7ae638195a0c07357a33d4b8cfec0">More...</a><br /></td></tr>
<tr class="separator:ac1d7ae638195a0c07357a33d4b8cfec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad04f1a354ddbbdec275dd9afd45bdce"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aad04f1a354ddbbdec275dd9afd45bdce">padAndHoistLinalgOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp, const <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:aad04f1a354ddbbdec275dd9afd45bdce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply padding and hoisting to <code>linalgOp</code> according to the configuration specified in <code>options</code>.  <a href="namespacemlir_1_1linalg.html#aad04f1a354ddbbdec275dd9afd45bdce">More...</a><br /></td></tr>
<tr class="separator:aad04f1a354ddbbdec275dd9afd45bdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af025e45095e64f984901c4f65fa3c72f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; TilingInterface, TilingInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af025e45095e64f984901c4f65fa3c72f">splitOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, unsigned dimension, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> splitPoint)</td></tr>
<tr class="memdesc:af025e45095e64f984901c4f65fa3c72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given <code>op</code> into two parts along the given iteration space <code>dimension</code> at the specified <code>splitPoint</code>, and return the two parts.  <a href="namespacemlir_1_1linalg.html#af025e45095e64f984901c4f65fa3c72f">More...</a><br /></td></tr>
<tr class="separator:af025e45095e64f984901c4f65fa3c72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13050e75a64a26bf82a80b19006d0e9"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac13050e75a64a26bf82a80b19006d0e9">tileLinalgOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, LinalgOp op, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:ac13050e75a64a26bf82a80b19006d0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcc62e199cdb1863a3d6f30e4dc317a"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; GenericOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8dcc62e199cdb1863a3d6f30e4dc317a">interchangeGenericOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, GenericOp genericOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; interchangeVector)</td></tr>
<tr class="memdesc:a8dcc62e199cdb1863a3d6f30e4dc317a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interchange the <code>iterator_types</code> and <code>iterator_maps</code> dimensions and adapts the index accesses of <code>op</code>.  <a href="namespacemlir_1_1linalg.html#a8dcc62e199cdb1863a3d6f30e4dc317a">More...</a><br /></td></tr>
<tr class="separator:a8dcc62e199cdb1863a3d6f30e4dc317a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc28f76b6a2798611e0008260ae388d"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; GenericOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7fc28f76b6a2798611e0008260ae388d">generalizeNamedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a7fc28f76b6a2798611e0008260ae388d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a GenericOp from the given named operation <code>linalgOp</code> and replace the given <code>linalgOp</code>.  <a href="namespacemlir_1_1linalg.html#a7fc28f76b6a2798611e0008260ae388d">More...</a><br /></td></tr>
<tr class="separator:a7fc28f76b6a2798611e0008260ae388d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be344205769eaea42d412b4c0fae11a"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3be344205769eaea42d412b4c0fae11a">specializeGenericOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, GenericOp genericOp)</td></tr>
<tr class="memdesc:a3be344205769eaea42d412b4c0fae11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a namedOp from the given GenericOp and replace the GenericOp.  <a href="namespacemlir_1_1linalg.html#a3be344205769eaea42d412b4c0fae11a">More...</a><br /></td></tr>
<tr class="separator:a3be344205769eaea42d412b4c0fae11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed54a24fbd0044060290027188db5c0"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4ed54a24fbd0044060290027188db5c0">promoteSubviewAsNewBuffer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, memref::SubViewOp subView, bool useOriginalSubviewSize, const <a class="el" href="namespacemlir_1_1linalg.html#a1bcbad447f843c9b98886ad6f49469a9">AllocBufferCallbackFn</a> &amp;allocationFn, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)</td></tr>
<tr class="separator:a4ed54a24fbd0044060290027188db5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd639dc165f0ab64ec7afbac992c4d65"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#acd639dc165f0ab64ec7afbac992c4d65">promoteSubViews</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp op, const <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:acd639dc165f0ab64ec7afbac992c4d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the <code>subViews</code> into a new buffer allocated at the insertion point <code>b</code>.  <a href="namespacemlir_1_1linalg.html#acd639dc165f0ab64ec7afbac992c4d65">More...</a><br /></td></tr>
<tr class="separator:acd639dc165f0ab64ec7afbac992c4d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266200755192d09deb827c799e59277b"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a266200755192d09deb827c799e59277b">allocateWorkgroupMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, memref::SubViewOp subview, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizeBounds, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;)</td></tr>
<tr class="memdesc:a266200755192d09deb827c799e59277b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the subview in the GPU workgroup memory.  <a href="namespacemlir_1_1linalg.html#a266200755192d09deb827c799e59277b">More...</a><br /></td></tr>
<tr class="separator:a266200755192d09deb827c799e59277b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6babd80190e8df26f441fca7d2fbe31"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad6babd80190e8df26f441fca7d2fbe31">deallocateWorkgroupMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a>)</td></tr>
<tr class="memdesc:ad6babd80190e8df26f441fca7d2fbe31"><td class="mdescLeft">&#160;</td><td class="mdescRight">In case of GPU group memory there is no need to deallocate.  <a href="namespacemlir_1_1linalg.html#ad6babd80190e8df26f441fca7d2fbe31">More...</a><br /></td></tr>
<tr class="separator:ad6babd80190e8df26f441fca7d2fbe31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fb3984f986840e0dc914c1ab90dc3b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a72fb3984f986840e0dc914c1ab90dc3b">copyToWorkgroupMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)</td></tr>
<tr class="memdesc:a72fb3984f986840e0dc914c1ab90dc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Memref copy operations and add gpu barrier guards before and after the copy operation to ensure data integrity.  <a href="namespacemlir_1_1linalg.html#a72fb3984f986840e0dc914c1ab90dc3b">More...</a><br /></td></tr>
<tr class="separator:a72fb3984f986840e0dc914c1ab90dc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5606dfca8a9078fc6bc9b74972f15fdc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5606dfca8a9078fc6bc9b74972f15fdc">allocateGPUPrivateMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, memref::SubViewOp subview, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizeBounds, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;)</td></tr>
<tr class="memdesc:a5606dfca8a9078fc6bc9b74972f15fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the subview in the GPU private memory.  <a href="namespacemlir_1_1linalg.html#a5606dfca8a9078fc6bc9b74972f15fdc">More...</a><br /></td></tr>
<tr class="separator:a5606dfca8a9078fc6bc9b74972f15fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88359f69353831d971485ff6b6b86dc1"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a88359f69353831d971485ff6b6b86dc1">copyToGPUPrivateMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)</td></tr>
<tr class="memdesc:a88359f69353831d971485ff6b6b86dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal copy to between src and dst.  <a href="namespacemlir_1_1linalg.html#a88359f69353831d971485ff6b6b86dc1">More...</a><br /></td></tr>
<tr class="separator:a88359f69353831d971485ff6b6b86dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487d4430e8217b1dabc50cb28bb93342"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a487d4430e8217b1dabc50cb28bb93342">deallocateGPUPrivateMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a>)</td></tr>
<tr class="memdesc:a487d4430e8217b1dabc50cb28bb93342"><td class="mdescLeft">&#160;</td><td class="mdescRight">In case of GPU private memory there is no need to deallocate since the memory is freed when going outside of the scope.  <a href="namespacemlir_1_1linalg.html#a487d4430e8217b1dabc50cb28bb93342">More...</a><br /></td></tr>
<tr class="separator:a487d4430e8217b1dabc50cb28bb93342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142a09c03dbaa0d795e44f62d4b6b395"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a142a09c03dbaa0d795e44f62d4b6b395">hasVectorizationImpl</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)</td></tr>
<tr class="memdesc:a142a09c03dbaa0d795e44f62d4b6b395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there's dedicated logic in the Linalg Vectorizer to vectorize this <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a>, false otherwise.  <a href="namespacemlir_1_1linalg.html#a142a09c03dbaa0d795e44f62d4b6b395">More...</a><br /></td></tr>
<tr class="separator:a142a09c03dbaa0d795e44f62d4b6b395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303bb59c046a82276569e6b906002997"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1VectorizationResult.html">VectorizationResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a303bb59c046a82276569e6b906002997">vectorize</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt; inputScalableVecDims={}, bool vectorizeNDExtract=false, bool flatten1DDepthwiseConv=false, bool assumeDynamicDimsMatchVecSizes=false, bool createNamedContraction=false)</td></tr>
<tr class="memdesc:a303bb59c046a82276569e6b906002997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="structmlir_1_1linalg_1_1VectorizationResult.html" title="Transformation information returned after vectorizing.">VectorizationResult</a></code> containing the results of the vectorized op, or failure if the transformation fails.  <a href="namespacemlir_1_1linalg.html#a303bb59c046a82276569e6b906002997">More...</a><br /></td></tr>
<tr class="separator:a303bb59c046a82276569e6b906002997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c63bc9239511b70751c238a12f5b1da"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8c63bc9239511b70751c238a12f5b1da">vectorizeCopy</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;builder, memref::CopyOp copyOp)</td></tr>
<tr class="memdesc:a8c63bc9239511b70751c238a12f5b1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a suitable vector form for a Copy op with fully static shape.  <a href="namespacemlir_1_1linalg.html#a8c63bc9239511b70751c238a12f5b1da">More...</a><br /></td></tr>
<tr class="separator:a8c63bc9239511b70751c238a12f5b1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edd4be30bfb8af9bc8e486f8368c1e2"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7edd4be30bfb8af9bc8e486f8368c1e2">linalgOpToLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a7edd4be30bfb8af9bc8e486f8368c1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a loop nest of <code>scf.for</code> with the proper body for <code>linalgOp</code>.  <a href="namespacemlir_1_1linalg.html#a7edd4be30bfb8af9bc8e486f8368c1e2">More...</a><br /></td></tr>
<tr class="separator:a7edd4be30bfb8af9bc8e486f8368c1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff809877c1d119dae06d06a8bad953e4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aff809877c1d119dae06d06a8bad953e4">linalgOpToParallelLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:aff809877c1d119dae06d06a8bad953e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a loop nest of <code>scf.parallel</code> with the proper body for <code>linalgOp</code>.  <a href="namespacemlir_1_1linalg.html#aff809877c1d119dae06d06a8bad953e4">More...</a><br /></td></tr>
<tr class="separator:aff809877c1d119dae06d06a8bad953e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f289e066dcbb7844bd444c0880fc36"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a95f289e066dcbb7844bd444c0880fc36">linalgOpToAffineLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a95f289e066dcbb7844bd444c0880fc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a loop nest of <code>affine.for</code> with the proper body for <code>linalgOp</code>.  <a href="namespacemlir_1_1linalg.html#a95f289e066dcbb7844bd444c0880fc36">More...</a><br /></td></tr>
<tr class="separator:a95f289e066dcbb7844bd444c0880fc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8144efefcad502e511c24aa5ce5b36e8"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 4 &gt;, <a class="el" href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">LoopIndexToRangeIndexMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8144efefcad502e511c24aa5ce5b36e8">makeTiledLoopRanges</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; allShapeSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; allTileSizes)</td></tr>
<tr class="separator:a8144efefcad502e511c24aa5ce5b36e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ef5fd09c3c79a47b8c4732ace79928"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1MultiSizeSpecification.html">MultiSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af8ef5fd09c3c79a47b8c4732ace79928">computeMultiTileSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, LinalgOp op, unsigned dimension, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> targetSize, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> divisor, bool emitAssertions=true)</td></tr>
<tr class="memdesc:af8ef5fd09c3c79a47b8c4732ace79928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits the IR computing the multi-sized tiling specification with two tile sizes not exceeding <code>targetSize</code>, each divisible by <code>sizeDivisor</code>, such that there exist numbers of tiles with these sizes that fully cover the given iteration space <code>dimension</code> of the structured <code>op</code>.  <a href="namespacemlir_1_1linalg.html#af8ef5fd09c3c79a47b8c4732ace79928">More...</a><br /></td></tr>
<tr class="separator:af8ef5fd09c3c79a47b8c4732ace79928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c1fb37672289a396df9c95a9b1dd0b"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1StaticMultiSizeSpecification.html">StaticMultiSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a91c1fb37672289a396df9c95a9b1dd0b">computeStaticMultiTileSizes</a> (LinalgOp op, unsigned dimension, int64_t targetSize, int64_t divisor)</td></tr>
<tr class="separator:a91c1fb37672289a396df9c95a9b1dd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cdafc77c113c1fa2db8782dc0bdb29"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1StaticContinuousTileSizeSpecification.html">StaticContinuousTileSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa3cdafc77c113c1fa2db8782dc0bdb29">computeStaticContinuousTileSizes</a> (LinalgOp op, unsigned dimension, unsigned targetSize)</td></tr>
<tr class="separator:aa3cdafc77c113c1fa2db8782dc0bdb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18c5afa193d9ff81a24877f1087fec4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContinuousTileSizeSpecification.html">ContinuousTileSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa18c5afa193d9ff81a24877f1087fec4">computeContinuousTileSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, TilingInterface op, unsigned dimension, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> targetSize, bool emitAssertions)</td></tr>
<tr class="separator:aa18c5afa193d9ff81a24877f1087fec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3085a8dbbf3c572b3279bdcc53dbe72"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html">ForallReductionTilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab3085a8dbbf3c572b3279bdcc53dbe72">tileReductionUsingForall</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, PartialReductionOpInterface op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes={}, std::optional&lt; ArrayAttr &gt; mapping=std::nullopt)</td></tr>
<tr class="memdesc:ab3085a8dbbf3c572b3279bdcc53dbe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to tile a reduction to parallel iterations computing partial reductions.  <a href="namespacemlir_1_1linalg.html#ab3085a8dbbf3c572b3279bdcc53dbe72">More...</a><br /></td></tr>
<tr class="separator:ab3085a8dbbf3c572b3279bdcc53dbe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2368f6f815597fcf395106e8978e44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1b2368f6f815597fcf395106e8978e44">transformIndexOps</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, LinalgOp op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivs, const <a class="el" href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">LoopIndexToRangeIndexMap</a> &amp;loopIndexToRangeIndex)</td></tr>
<tr class="memdesc:a1b2368f6f815597fcf395106e8978e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">All indices returned by IndexOp should be invariant with respect to tiling.  <a href="namespacemlir_1_1linalg.html#a1b2368f6f815597fcf395106e8978e44">More...</a><br /></td></tr>
<tr class="separator:a1b2368f6f815597fcf395106e8978e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4f58f6a18fb7c9af60fb15122e0994"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aaa4f58f6a18fb7c9af60fb15122e0994">splitReduction</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, LinalgOp op, const <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> &amp;controlSplitReductionFn, bool useAlloc=false)</td></tr>
<tr class="separator:aaa4f58f6a18fb7c9af60fb15122e0994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87c3f5c965b8e271579136775d51ffc"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af87c3f5c965b8e271579136775d51ffc">splitReductionByScaling</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, LinalgOp op, const <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> &amp;controlSplitReductionFn, bool useAlloc=false)</td></tr>
<tr class="memdesc:af87c3f5c965b8e271579136775d51ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling-based implementation of the split reduction transformation.  <a href="namespacemlir_1_1linalg.html#af87c3f5c965b8e271579136775d51ffc">More...</a><br /></td></tr>
<tr class="separator:af87c3f5c965b8e271579136775d51ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31426a6a1dc69e5819138ba53c6e7ef9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a31426a6a1dc69e5819138ba53c6e7ef9">isDimSequencePreserved</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="namespacemlir.html#a7ed845b40509fa999492a04654211321">ReassociationIndicesRef</a> dimSequence)</td></tr>
<tr class="memdesc:a31426a6a1dc69e5819138ba53c6e7ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if a given sequence of dimensions are contiguous in the range of the specified indexing map.  <a href="namespacemlir_1_1linalg.html#a31426a6a1dc69e5819138ba53c6e7ef9">More...</a><br /></td></tr>
<tr class="separator:a31426a6a1dc69e5819138ba53c6e7ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133a3ec0d7cd50a886d2cd558fdc9030"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a133a3ec0d7cd50a886d2cd558fdc9030">areDimSequencesPreserved</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; dimSequences)</td></tr>
<tr class="memdesc:a133a3ec0d7cd50a886d2cd558fdc9030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if all sequences of dimensions specified in <code>dimSequences</code> are contiguous in all the ranges of the <code>maps</code>.  <a href="namespacemlir_1_1linalg.html#a133a3ec0d7cd50a886d2cd558fdc9030">More...</a><br /></td></tr>
<tr class="separator:a133a3ec0d7cd50a886d2cd558fdc9030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a3be2f9306a873810377797b78bfc6"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1CollapseResult.html">CollapseResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae6a3be2f9306a873810377797b78bfc6">collapseOpIterationDims</a> (LinalgOp op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; foldedIterationDims, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter)</td></tr>
<tr class="memdesc:ae6a3be2f9306a873810377797b78bfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapses dimensions of linalg.generic/linalg.copy operation.  <a href="namespacemlir_1_1linalg.html#ae6a3be2f9306a873810377797b78bfc6">More...</a><br /></td></tr>
<tr class="separator:ae6a3be2f9306a873810377797b78bfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebe4a9f3b87bb8f196bf2d577511a05"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1LowerPackResult.html">LowerPackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#afebe4a9f3b87bb8f196bf2d577511a05">lowerPack</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::PackOp packOp, bool lowerPadLikeWithInsertSlice=true)</td></tr>
<tr class="memdesc:afebe4a9f3b87bb8f196bf2d577511a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite pack as pad + reshape + transpose.  <a href="namespacemlir_1_1linalg.html#afebe4a9f3b87bb8f196bf2d577511a05">More...</a><br /></td></tr>
<tr class="separator:afebe4a9f3b87bb8f196bf2d577511a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cea34f55211c79271dff09bb07c3279"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1LowerUnPackOpResult.html">LowerUnPackOpResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3cea34f55211c79271dff09bb07c3279">lowerUnPack</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::UnPackOp unPackOp, bool lowerUnpadLikeWithExtractSlice=true)</td></tr>
<tr class="memdesc:a3cea34f55211c79271dff09bb07c3279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite pack as empty + transpose + reshape + extract_slice.  <a href="namespacemlir_1_1linalg.html#a3cea34f55211c79271dff09bb07c3279">More...</a><br /></td></tr>
<tr class="separator:a3cea34f55211c79271dff09bb07c3279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd29d6299d2891ae1d092974bc1c4e30"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30">pack</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; packedSizes)</td></tr>
<tr class="memdesc:abd29d6299d2891ae1d092974bc1c4e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement packing of a single LinalgOp by <code>packedSizes</code>.  <a href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30">More...</a><br /></td></tr>
<tr class="separator:abd29d6299d2891ae1d092974bc1c4e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e3825819b0563bb199218baf11ca73"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackTransposeResult.html">PackTransposeResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a26e3825819b0563bb199218baf11ca73">packTranspose</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::PackOp packOp, linalg::LinalgOp linalgOp, linalg::UnPackOp maybeUnPackOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; outerPerm, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; innerPerm)</td></tr>
<tr class="memdesc:a26e3825819b0563bb199218baf11ca73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose a single PackOp -&gt; LinalgOp -&gt; UnPackOp chain and return the transposed PackOp -&gt; LinalgOp -&gt; UnPackOp chain after replacements.  <a href="namespacemlir_1_1linalg.html#a26e3825819b0563bb199218baf11ca73">More...</a><br /></td></tr>
<tr class="separator:a26e3825819b0563bb199218baf11ca73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3567489d885b34059aa8286957de564"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab3567489d885b34059aa8286957de564">packMatmulGreedily</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mnkPackedSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; mnkPaddedSizesNextMultipleOf, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; mnkOrder)</td></tr>
<tr class="memdesc:ab3567489d885b34059aa8286957de564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a LinalgOp by greedily inferring matmul dimensions (m, n, k) where m and n are proper parallel dimensions and k is a proper reduction dimension.  <a href="namespacemlir_1_1linalg.html#ab3567489d885b34059aa8286957de564">More...</a><br /></td></tr>
<tr class="separator:ab3567489d885b34059aa8286957de564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca967d8e0b6ff895d26faaf60a79263"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5ca967d8e0b6ff895d26faaf60a79263">blockPackMatmul</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::LinalgOp linalgOp, const <a class="el" href="namespacemlir_1_1linalg.html#ae020263d273fb7b7f80c4970556da5f8">ControlBlockPackMatmulFn</a> &amp;controlPackMatmul)</td></tr>
<tr class="memdesc:a5ca967d8e0b6ff895d26faaf60a79263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a matmul operation into blocked 4D layout.  <a href="namespacemlir_1_1linalg.html#a5ca967d8e0b6ff895d26faaf60a79263">More...</a><br /></td></tr>
<tr class="separator:a5ca967d8e0b6ff895d26faaf60a79263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a579fdd0e468c7aec96f84d016c829e"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5a579fdd0e468c7aec96f84d016c829e">rewriteInDestinationPassingStyle</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::FromElementsOp fromElementsOp)</td></tr>
<tr class="memdesc:a5a579fdd0e468c7aec96f84d016c829e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite tensor.from_elements to linalg.generic.  <a href="namespacemlir_1_1linalg.html#a5a579fdd0e468c7aec96f84d016c829e">More...</a><br /></td></tr>
<tr class="separator:a5a579fdd0e468c7aec96f84d016c829e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e500c4bf906d65572af9b3d2982852"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab2e500c4bf906d65572af9b3d2982852">rewriteInDestinationPassingStyle</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::GenerateOp generateOp)</td></tr>
<tr class="memdesc:ab2e500c4bf906d65572af9b3d2982852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite tensor.generate to linalg.generic.  <a href="namespacemlir_1_1linalg.html#ab2e500c4bf906d65572af9b3d2982852">More...</a><br /></td></tr>
<tr class="separator:ab2e500c4bf906d65572af9b3d2982852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3e743297fd7a20a30c7c4e39608fbc"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#acf3e743297fd7a20a30c7c4e39608fbc">rewriteInDestinationPassingStyle</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PadOp padOp)</td></tr>
<tr class="memdesc:acf3e743297fd7a20a30c7c4e39608fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite tensor.pad to linalg.generic + tensor.insert_slice.  <a href="namespacemlir_1_1linalg.html#acf3e743297fd7a20a30c7c4e39608fbc">More...</a><br /></td></tr>
<tr class="separator:acf3e743297fd7a20a30c7c4e39608fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2c1f265ce47a53398eab6e8f18b30c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0e2c1f265ce47a53398eab6e8f18b30c">rewriteInIm2Col</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcHwcfOp convOp)</td></tr>
<tr class="memdesc:a0e2c1f265ce47a53398eab6e8f18b30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linalg.conv_2d_nhwc_hwcf into linalg.generic (for img2col packing) and linalg.matmul.  <a href="namespacemlir_1_1linalg.html#a0e2c1f265ce47a53398eab6e8f18b30c">More...</a><br /></td></tr>
<tr class="separator:a0e2c1f265ce47a53398eab6e8f18b30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efbd1a00187259d6074a842842175c2"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7efbd1a00187259d6074a842842175c2">rewriteInIm2Col</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcFhwcOp convOp)</td></tr>
<tr class="memdesc:a7efbd1a00187259d6074a842842175c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the above but for Fhwc channel orderings in the filter.  <a href="namespacemlir_1_1linalg.html#a7efbd1a00187259d6074a842842175c2">More...</a><br /></td></tr>
<tr class="separator:a7efbd1a00187259d6074a842842175c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f61511bb9ed963c3eeb360bfdb1a6a"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a49f61511bb9ed963c3eeb360bfdb1a6a">rewriteInIm2Col</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::DepthwiseConv2DNhwcHwcOp convOp)</td></tr>
<tr class="memdesc:a49f61511bb9ed963c3eeb360bfdb1a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to rewriteInIm2Col with linalg::Conv2DNhwcHwcfOp except there is no reduction among the input channels so each convolution can be a matrix-vector product and by transposing both input filter so channels are outer most the computation is a batched matrix-vector product.  <a href="namespacemlir_1_1linalg.html#a49f61511bb9ed963c3eeb360bfdb1a6a">More...</a><br /></td></tr>
<tr class="separator:a49f61511bb9ed963c3eeb360bfdb1a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43dfb86d76bed86ecd1117849e5b6f4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad43dfb86d76bed86ecd1117849e5b6f4">rewriteInIm2Col</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNchwFchwOp convOp)</td></tr>
<tr class="memdesc:ad43dfb86d76bed86ecd1117849e5b6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to rewriteInIm2Col with linalg::Conv2DNhwcHwcfOp except because the channels are to the left of the image shape dimensions, the position of the contraction dimension in the resulting matmul is reversed.  <a href="namespacemlir_1_1linalg.html#ad43dfb86d76bed86ecd1117849e5b6f4">More...</a><br /></td></tr>
<tr class="separator:ad43dfb86d76bed86ecd1117849e5b6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea35f9b824fbdf551b76ddf974fc418"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6ea35f9b824fbdf551b76ddf974fc418">transposeConv2D</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcFhwcOp op)</td></tr>
<tr class="memdesc:a6ea35f9b824fbdf551b76ddf974fc418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linalg.conv_2d_nhwc_fhwc(_q) to linalg.conv_2d_nhwc_hwcf(_q) by materializing transpose.  <a href="namespacemlir_1_1linalg.html#a6ea35f9b824fbdf551b76ddf974fc418">More...</a><br /></td></tr>
<tr class="separator:a6ea35f9b824fbdf551b76ddf974fc418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada14eab9218f7ff7f15f695a980fb717"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ada14eab9218f7ff7f15f695a980fb717">transposeConv2D</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcFhwcQOp op)</td></tr>
<tr class="separator:ada14eab9218f7ff7f15f695a980fb717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8836bfb07ad8fc4f7bda9aa174da988"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad8836bfb07ad8fc4f7bda9aa174da988">transposeMatmul</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::MatmulOp op, bool transposeLHS=true)</td></tr>
<tr class="memdesc:ad8836bfb07ad8fc4f7bda9aa174da988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Linalg matmul ops to transposed variants.  <a href="namespacemlir_1_1linalg.html#ad8836bfb07ad8fc4f7bda9aa174da988">More...</a><br /></td></tr>
<tr class="separator:ad8836bfb07ad8fc4f7bda9aa174da988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816f67d5546592d18de9ec5de0e791f3"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a816f67d5546592d18de9ec5de0e791f3">transposeBatchMatmul</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::BatchMatmulOp op, bool transposeLHS=true)</td></tr>
<tr class="memdesc:a816f67d5546592d18de9ec5de0e791f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to replace.  <a href="namespacemlir_1_1linalg.html#a816f67d5546592d18de9ec5de0e791f3">More...</a><br /></td></tr>
<tr class="separator:a816f67d5546592d18de9ec5de0e791f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c00031d476aa3ea451687f117fabde7"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8c00031d476aa3ea451687f117fabde7">winogradConv2D</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcFhwcOp op, WinogradConv2DFmr fmr)</td></tr>
<tr class="memdesc:a8c00031d476aa3ea451687f117fabde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linalg.conv_2d_nhwc_fhwc to Winograd Conv2D algorithm F(m x m, r x r).  <a href="namespacemlir_1_1linalg.html#a8c00031d476aa3ea451687f117fabde7">More...</a><br /></td></tr>
<tr class="separator:a8c00031d476aa3ea451687f117fabde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cf4ae6a6c9f8d82a3d3f13e55100c3"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a22cf4ae6a6c9f8d82a3d3f13e55100c3">decomposeWinogradFilterTransformOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::WinogradFilterTransformOp op)</td></tr>
<tr class="memdesc:a22cf4ae6a6c9f8d82a3d3f13e55100c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite linalg.winograd_filter_transform.  <a href="namespacemlir_1_1linalg.html#a22cf4ae6a6c9f8d82a3d3f13e55100c3">More...</a><br /></td></tr>
<tr class="separator:a22cf4ae6a6c9f8d82a3d3f13e55100c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75908ded36f97719f77c8b56ed859ef"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae75908ded36f97719f77c8b56ed859ef">decomposeWinogradInputTransformOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::WinogradInputTransformOp op)</td></tr>
<tr class="memdesc:ae75908ded36f97719f77c8b56ed859ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite linalg.winograd_input_transform.  <a href="namespacemlir_1_1linalg.html#ae75908ded36f97719f77c8b56ed859ef">More...</a><br /></td></tr>
<tr class="separator:ae75908ded36f97719f77c8b56ed859ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f2f00a0e17dbbec5198127ee3151ba"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a49f2f00a0e17dbbec5198127ee3151ba">decomposeWinogradOutputTransformOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::WinogradOutputTransformOp op)</td></tr>
<tr class="memdesc:a49f2f00a0e17dbbec5198127ee3151ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite linalg.winograd_output_transform.  <a href="namespacemlir_1_1linalg.html#a49f2f00a0e17dbbec5198127ee3151ba">More...</a><br /></td></tr>
<tr class="separator:a49f2f00a0e17dbbec5198127ee3151ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88467664ee2ebeb70bc1a2c3d5876a9c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; linalg::GenericOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a88467664ee2ebeb70bc1a2c3d5876a9c">deduplicateOperandsAndRemoveDeadResults</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::GenericOp genericOp, bool removeOutputs)</td></tr>
<tr class="memdesc:a88467664ee2ebeb70bc1a2c3d5876a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to deduplicate operands and remove dead results of <code>linalg.generic</code> operations.  <a href="namespacemlir_1_1linalg.html#a88467664ee2ebeb70bc1a2c3d5876a9c">More...</a><br /></td></tr>
<tr class="separator:a88467664ee2ebeb70bc1a2c3d5876a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae61503376ad6b88f0c35f8ce358dbc9e">getLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalization patterns relevant to apply after tiling patterns.  <a href="namespacemlir_1_1linalg.html#ae61503376ad6b88f0c35f8ce358dbc9e">More...</a><br /></td></tr>
<tr class="separator:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4701ad0fa2e34da0089a80135935f02e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4701ad0fa2e34da0089a80135935f02e">populateLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="separator:a4701ad0fa2e34da0089a80135935f02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9bb5c9c8ef1aadbbc563431443b5e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ada9bb5c9c8ef1aadbbc563431443b5e2">populateLinalgNamedOpsGeneralizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ada9bb5c9c8ef1aadbbc563431443b5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg generalization patterns.  <a href="namespacemlir_1_1linalg.html#ada9bb5c9c8ef1aadbbc563431443b5e2">More...</a><br /></td></tr>
<tr class="separator:ada9bb5c9c8ef1aadbbc563431443b5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9ad663f56317f953958cb9434bd8fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#adc9ad663f56317f953958cb9434bd8fc">populateLinalgGenericOpsSpecializationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:adc9ad663f56317f953958cb9434bd8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns to convert linalg.generic ops to named ops where possible.  <a href="namespacemlir_1_1linalg.html#adc9ad663f56317f953958cb9434bd8fc">More...</a><br /></td></tr>
<tr class="separator:adc9ad663f56317f953958cb9434bd8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479c320b2d7a71b7d9c50d04047eba8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a479c320b2d7a71b7d9c50d04047eba8f">populateLinalgFoldIntoElementwisePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a479c320b2d7a71b7d9c50d04047eba8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that fold operations like <code>linalg.transform</code> into elementwise op map.  <a href="namespacemlir_1_1linalg.html#a479c320b2d7a71b7d9c50d04047eba8f">More...</a><br /></td></tr>
<tr class="separator:a479c320b2d7a71b7d9c50d04047eba8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887c3b461640ae2783747a1c89726203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a887c3b461640ae2783747a1c89726203">populateDecomposeConvolutionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a887c3b461640ae2783747a1c89726203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg decompose convolutions patterns.  <a href="namespacemlir_1_1linalg.html#a887c3b461640ae2783747a1c89726203">More...</a><br /></td></tr>
<tr class="separator:a887c3b461640ae2783747a1c89726203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96851c32371159549c91211e266f3f0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a96851c32371159549c91211e266f3f0e">populateDecomposePackUnpackPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a96851c32371159549c91211e266f3f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns to decompose <a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a> and linalg.unpack Ops into e.g.  <a href="namespacemlir_1_1linalg.html#a96851c32371159549c91211e266f3f0e">More...</a><br /></td></tr>
<tr class="separator:a96851c32371159549c91211e266f3f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93e7e4b8d10bb895e935d0b4799f3a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae93e7e4b8d10bb895e935d0b4799f3a9">populateDecomposePadPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ae93e7e4b8d10bb895e935d0b4799f3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns to decompose tensor.pad into e.g.  <a href="namespacemlir_1_1linalg.html#ae93e7e4b8d10bb895e935d0b4799f3a9">More...</a><br /></td></tr>
<tr class="separator:ae93e7e4b8d10bb895e935d0b4799f3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e349c4f7a13b98a31f89dec948c5533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1e349c4f7a13b98a31f89dec948c5533">populateConvertConv2DToImg2ColPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a1e349c4f7a13b98a31f89dec948c5533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns to transform linalg.conv_2d_xxx operations into linalg.generic (for img2col packing) and linalg.matmul.  <a href="namespacemlir_1_1linalg.html#a1e349c4f7a13b98a31f89dec948c5533">More...</a><br /></td></tr>
<tr class="separator:a1e349c4f7a13b98a31f89dec948c5533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c2ef8a778a33a17885475c11b50bdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a43c2ef8a778a33a17885475c11b50bdd">populatePadOpVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> baseBenefit=1)</td></tr>
<tr class="memdesc:a43c2ef8a778a33a17885475c11b50bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that vectorize tensor.pad.  <a href="namespacemlir_1_1linalg.html#a43c2ef8a778a33a17885475c11b50bdd">More...</a><br /></td></tr>
<tr class="separator:a43c2ef8a778a33a17885475c11b50bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6f59ca20a1e8ce21c3c29916aec917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aad6f59ca20a1e8ce21c3c29916aec917">populateDecomposeLinalgOpsPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, bool removeDeadArgsAndResults=true)</td></tr>
<tr class="memdesc:aad6f59ca20a1e8ce21c3c29916aec917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for splitting a <code>LinalgOp</code> with multiple statements within its payload into multiple <code>GenericOp</code> that have a single statement.  <a href="namespacemlir_1_1linalg.html#aad6f59ca20a1e8ce21c3c29916aec917">More...</a><br /></td></tr>
<tr class="separator:aad6f59ca20a1e8ce21c3c29916aec917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f8e903a075470f95fa853892083469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a68f8e903a075470f95fa853892083469">populateConvertToDestinationStylePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a68f8e903a075470f95fa853892083469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that convert non-destination-style ops to destination style ops.  <a href="namespacemlir_1_1linalg.html#a68f8e903a075470f95fa853892083469">More...</a><br /></td></tr>
<tr class="separator:a68f8e903a075470f95fa853892083469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891b8f2d145dcc3327ba55c7a49d44e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a891b8f2d145dcc3327ba55c7a49d44e4">populateConvolutionVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a891b8f2d145dcc3327ba55c7a49d44e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for vectorizing low-D convolution ops.  <a href="namespacemlir_1_1linalg.html#a891b8f2d145dcc3327ba55c7a49d44e4">More...</a><br /></td></tr>
<tr class="separator:a891b8f2d145dcc3327ba55c7a49d44e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a49133ef595966377878adc42196f47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7a49133ef595966377878adc42196f47">populateElementwiseToLinalgConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a7a49133ef595966377878adc42196f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that convert <code>ElementwiseMappable</code> ops to linalg parallel loops.  <a href="namespacemlir_1_1linalg.html#a7a49133ef595966377878adc42196f47">More...</a><br /></td></tr>
<tr class="separator:a7a49133ef595966377878adc42196f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49366865f5ce183ae19888eceb6667e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a49366865f5ce183ae19888eceb6667e5">populateSparseTensorRewriting</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a49366865f5ce183ae19888eceb6667e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that are only useful in the context of sparse tensors.  <a href="namespacemlir_1_1linalg.html#a49366865f5ce183ae19888eceb6667e5">More...</a><br /></td></tr>
<tr class="separator:a49366865f5ce183ae19888eceb6667e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af537f75332b531f2f627083684c201e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af537f75332b531f2f627083684c201e4">populateElementwiseOpsFusionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;controlElementwiseOpFusion)</td></tr>
<tr class="memdesc:af537f75332b531f2f627083684c201e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns for fusing linalg operation on tensors.  <a href="namespacemlir_1_1linalg.html#af537f75332b531f2f627083684c201e4">More...</a><br /></td></tr>
<tr class="separator:af537f75332b531f2f627083684c201e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0c4216814c93fb83b999f3f4923f7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3e0c4216814c93fb83b999f3f4923f7d">populateDataLayoutPropagationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#ab145fd297a4850ad34e09aab2f669e65">ControlPropagationFn</a> &amp;controlPackUnPackPropagation)</td></tr>
<tr class="memdesc:a3e0c4216814c93fb83b999f3f4923f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to bubble up or down data layout ops across other operations.  <a href="namespacemlir_1_1linalg.html#a3e0c4216814c93fb83b999f3f4923f7d">More...</a><br /></td></tr>
<tr class="separator:a3e0c4216814c93fb83b999f3f4923f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbdbb9ec2d0ed200d6a679ffd803c7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9cbdbb9ec2d0ed200d6a679ffd803c7e">populateEraseUnusedOperandsAndResultsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a9cbdbb9ec2d0ed200d6a679ffd803c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to remove dead operands and results of <code>linalg.generic</code> operations.  <a href="namespacemlir_1_1linalg.html#a9cbdbb9ec2d0ed200d6a679ffd803c7e">More...</a><br /></td></tr>
<tr class="separator:a9cbdbb9ec2d0ed200d6a679ffd803c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6e2c64c65b1a22b1794d731be0c612"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#abe6e2c64c65b1a22b1794d731be0c612">populateEraseUnnecessaryInputsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:abe6e2c64c65b1a22b1794d731be0c612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to promote inputs to outputs and remove unused inputs of <code>linalg.generic</code> ops.  <a href="namespacemlir_1_1linalg.html#abe6e2c64c65b1a22b1794d731be0c612">More...</a><br /></td></tr>
<tr class="separator:abe6e2c64c65b1a22b1794d731be0c612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef1d681922add4fcf065a64d713c3b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8ef1d681922add4fcf065a64d713c3b5">populateCollapseDimensions</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#ac1d01335b6fc341e4b908d9ea5df7482">GetCollapsableDimensionsFn</a> &amp;controlCollapseDimensions)</td></tr>
<tr class="memdesc:a8ef1d681922add4fcf065a64d713c3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to collapse dimensions in a linalg.generic op.  <a href="namespacemlir_1_1linalg.html#a8ef1d681922add4fcf065a64d713c3b5">More...</a><br /></td></tr>
<tr class="separator:a8ef1d681922add4fcf065a64d713c3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73f0e4d33b9691f06d722f2146c4a66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac73f0e4d33b9691f06d722f2146c4a66">populateFoldReshapeOpsByExpansionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;controlFoldingReshapes)</td></tr>
<tr class="memdesc:ac73f0e4d33b9691f06d722f2146c4a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold an expanding (collapsing) tensor_reshape operation with its producer (consumer) generic operation by expanding the dimensionality of the loop in the generic op.  <a href="namespacemlir_1_1linalg.html#ac73f0e4d33b9691f06d722f2146c4a66">More...</a><br /></td></tr>
<tr class="separator:ac73f0e4d33b9691f06d722f2146c4a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8bdabd42dfb2f3617cc87eccfa4199"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3c8bdabd42dfb2f3617cc87eccfa4199">populateFoldReshapeOpsByCollapsingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;controlFoldingReshapes)</td></tr>
<tr class="memdesc:a3c8bdabd42dfb2f3617cc87eccfa4199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold an expanding tensor.expand_shape operation with its producer generic operation by collapsing the dimensions of the generic op.  <a href="namespacemlir_1_1linalg.html#a3c8bdabd42dfb2f3617cc87eccfa4199">More...</a><br /></td></tr>
<tr class="separator:a3c8bdabd42dfb2f3617cc87eccfa4199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b142daa69f3f2b8986960b726ba2eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad0b142daa69f3f2b8986960b726ba2eb">populateConstantFoldLinalgOperations</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;controlFn)</td></tr>
<tr class="memdesc:ad0b142daa69f3f2b8986960b726ba2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to constant fold Linalg operations.  <a href="namespacemlir_1_1linalg.html#ad0b142daa69f3f2b8986960b726ba2eb">More...</a><br /></td></tr>
<tr class="separator:ad0b142daa69f3f2b8986960b726ba2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6bcda20dbb76f4b453abfc31adcc98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aeb6bcda20dbb76f4b453abfc31adcc98">populateFoldAddIntoDestPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aeb6bcda20dbb76f4b453abfc31adcc98"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to replace <code>linalg.add</code> when destination passing on a contraction op suffices for achieving the sum.  <a href="namespacemlir_1_1linalg.html#aeb6bcda20dbb76f4b453abfc31adcc98">More...</a><br /></td></tr>
<tr class="separator:aeb6bcda20dbb76f4b453abfc31adcc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0b4c454598e4be0bd0fcde89783a20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0e0b4c454598e4be0bd0fcde89783a20">populateFuseTensorPadWithProducerLinalgOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a0e0b4c454598e4be0bd0fcde89783a20"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to fuse a <code>tensor.pad</code> operation with the producer of its source, if the producer is a <code>linalg</code> operation with all parallel iterator types.  <a href="namespacemlir_1_1linalg.html#a0e0b4c454598e4be0bd0fcde89783a20">More...</a><br /></td></tr>
<tr class="separator:a0e0b4c454598e4be0bd0fcde89783a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0419b15db70f16465aec05d8f86f6e4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0419b15db70f16465aec05d8f86f6e4e">populateLinalgNamedOpConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a0419b15db70f16465aec05d8f86f6e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to convert from one named op to another.  <a href="namespacemlir_1_1linalg.html#a0419b15db70f16465aec05d8f86f6e4e">More...</a><br /></td></tr>
<tr class="separator:a0419b15db70f16465aec05d8f86f6e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7134894ce50357a7e8fefe7c379acac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7134894ce50357a7e8fefe7c379acac7">populateFoldUnitExtentDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a7134894ce50357a7e8fefe7c379acac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold unit-extent dimensions in operands/results of linalg ops on tensors via reassociative reshape ops.  <a href="namespacemlir_1_1linalg.html#a7134894ce50357a7e8fefe7c379acac7">More...</a><br /></td></tr>
<tr class="separator:a7134894ce50357a7e8fefe7c379acac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042bb54cd9155ed1ca8818a16ab5110a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a042bb54cd9155ed1ca8818a16ab5110a">populateMoveInitOperandsToInputPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a042bb54cd9155ed1ca8818a16ab5110a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern that converts init operands to input operands.  <a href="namespacemlir_1_1linalg.html#a042bb54cd9155ed1ca8818a16ab5110a">More...</a><br /></td></tr>
<tr class="separator:a042bb54cd9155ed1ca8818a16ab5110a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#acc64a8c8a9ecf3de84383893d8e4ddc2">populateInlineConstantOperandsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns that are used to inline constant operands into linalg generic ops.  <a href="namespacemlir_1_1linalg.html#acc64a8c8a9ecf3de84383893d8e4ddc2">More...</a><br /></td></tr>
<tr class="separator:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fce962e3d12d2dfc3b467076c71f39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a18fce962e3d12d2dfc3b467076c71f39">populateBubbleUpExtractSliceOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a18fce962e3d12d2dfc3b467076c71f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns that are used to bubble up extract slice op above linalg op.  <a href="namespacemlir_1_1linalg.html#a18fce962e3d12d2dfc3b467076c71f39">More...</a><br /></td></tr>
<tr class="separator:a18fce962e3d12d2dfc3b467076c71f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8003a713f74f7a32cc681c245ae9708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac8003a713f74f7a32cc681c245ae9708">populateSwapExtractSliceWithFillPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ac8003a713f74f7a32cc681c245ae9708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds patterns that waps tensor.extract_slice(linalg.fill(cst, init)) into linalg.fill(cst, tensor.extract_slice(init)).  <a href="namespacemlir_1_1linalg.html#ac8003a713f74f7a32cc681c245ae9708">More...</a><br /></td></tr>
<tr class="separator:ac8003a713f74f7a32cc681c245ae9708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1d8a95a9bec4041581a35ce791a503"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3a1d8a95a9bec4041581a35ce791a503">populateDecomposeProjectedPermutationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a3a1d8a95a9bec4041581a35ce791a503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add patterns to make explicit broadcasts and transforms in the input operands of a genericOp.  <a href="namespacemlir_1_1linalg.html#a3a1d8a95a9bec4041581a35ce791a503">More...</a><br /></td></tr>
<tr class="separator:a3a1d8a95a9bec4041581a35ce791a503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c26bb1f203c97b9d5bcf9b8ae6ea102"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0c26bb1f203c97b9d5bcf9b8ae6ea102">populateSplitReductionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> &amp;controlSplitReductionFn, bool useAlloc=false)</td></tr>
<tr class="memdesc:a0c26bb1f203c97b9d5bcf9b8ae6ea102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to apply <code>splitReduction</code> below.  <a href="namespacemlir_1_1linalg.html#a0c26bb1f203c97b9d5bcf9b8ae6ea102">More...</a><br /></td></tr>
<tr class="separator:a0c26bb1f203c97b9d5bcf9b8ae6ea102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0786aed514452424d437b02ff9816dce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0786aed514452424d437b02ff9816dce">populateTransposeMatmulPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, bool transposeLHS=true)</td></tr>
<tr class="memdesc:a0786aed514452424d437b02ff9816dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to convert Linalg matmul ops to transposed variants.  <a href="namespacemlir_1_1linalg.html#a0786aed514452424d437b02ff9816dce">More...</a><br /></td></tr>
<tr class="separator:a0786aed514452424d437b02ff9816dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf177055be0ddc8558b82cfbf4f8df7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1bf177055be0ddc8558b82cfbf4f8df7">populateBlockPackMatmulPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#ae020263d273fb7b7f80c4970556da5f8">ControlBlockPackMatmulFn</a> &amp;controlFn)</td></tr>
<tr class="memdesc:a1bf177055be0ddc8558b82cfbf4f8df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to block pack Linalg matmul ops.  <a href="namespacemlir_1_1linalg.html#a1bf177055be0ddc8558b82cfbf4f8df7">More...</a><br /></td></tr>
<tr class="separator:a1bf177055be0ddc8558b82cfbf4f8df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5263d91b36edf98bda8c609f486214"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4a5263d91b36edf98bda8c609f486214">populateWinogradConv2DPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, WinogradConv2DFmr fmr)</td></tr>
<tr class="memdesc:a4a5263d91b36edf98bda8c609f486214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to apply Winograd Conv2D algorithm F(m x m, r x r).  <a href="namespacemlir_1_1linalg.html#a4a5263d91b36edf98bda8c609f486214">More...</a><br /></td></tr>
<tr class="separator:a4a5263d91b36edf98bda8c609f486214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f5ef52c3bd7a0c67503bb7b5f97ae7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a88f5ef52c3bd7a0c67503bb7b5f97ae7">populateDecomposeWinogradOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a88f5ef52c3bd7a0c67503bb7b5f97ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to decompose Winograd operators.  <a href="namespacemlir_1_1linalg.html#a88f5ef52c3bd7a0c67503bb7b5f97ae7">More...</a><br /></td></tr>
<tr class="separator:a88f5ef52c3bd7a0c67503bb7b5f97ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08373cf12e45f28268db4e84f038f6ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a08373cf12e45f28268db4e84f038f6ca">populateContractionOpRankReducingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a08373cf12e45f28268db4e84f038f6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds patterns that reduce the rank of named contraction ops that have unit dimensions in the operand(s) by converting to a sequence of <code>collapse_shape</code>, <code>&lt;corresponding linalg named op&gt;</code>, <code>expand_shape</code> (if on tensors).  <a href="namespacemlir_1_1linalg.html#a08373cf12e45f28268db4e84f038f6ca">More...</a><br /></td></tr>
<tr class="separator:a08373cf12e45f28268db4e84f038f6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23b572eea62b16b1020bd964dc67d36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab23b572eea62b16b1020bd964dc67d36">populateFoldIntoPackAndUnpackPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#a8978399adc7b5ab6a4574123f59d1f52">ControlFoldIntoPackUnpackFn</a> &amp;controlFn=nullptr)</td></tr>
<tr class="memdesc:ab23b572eea62b16b1020bd964dc67d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that fold operations like <code>tensor.pad</code> and <code>tensor.extract_slice</code> into <code>tensor.pack</code> and <code>tensor.unpack</code> operations respectively.  <a href="namespacemlir_1_1linalg.html#ab23b572eea62b16b1020bd964dc67d36">More...</a><br /></td></tr>
<tr class="separator:ab23b572eea62b16b1020bd964dc67d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac248e317eae5124cbaad8bbb832a806"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aac248e317eae5124cbaad8bbb832a806">populateFoldPackUnpackIntoTensorEmptyPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aac248e317eae5124cbaad8bbb832a806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that fold operations like <code><a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a></code> and <code>linalg.unpack</code> into <code>tensor.empty</code>.  <a href="namespacemlir_1_1linalg.html#aac248e317eae5124cbaad8bbb832a806">More...</a><br /></td></tr>
<tr class="separator:aac248e317eae5124cbaad8bbb832a806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3e6438bd84e7e76e5352c0c54fb5b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aab3e6438bd84e7e76e5352c0c54fb5b7">populateSimplifyPackAndUnpackPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aab3e6438bd84e7e76e5352c0c54fb5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that simplify <code>tensor.pack</code> and <code>tensor.unpack</code> operations.  <a href="namespacemlir_1_1linalg.html#aab3e6438bd84e7e76e5352c0c54fb5b7">More...</a><br /></td></tr>
<tr class="separator:aab3e6438bd84e7e76e5352c0c54fb5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c34dd63bd77acc711bdf98d6e2c7b75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5c34dd63bd77acc711bdf98d6e2c7b75">getPackInverseDestPerm</a> (linalg::PackOp packOp)</td></tr>
<tr class="memdesc:a5c34dd63bd77acc711bdf98d6e2c7b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shell function to compute the Destination Permutation of PackOp This function uses the helper function <code>computePackUnPackPerm</code> to get the permutation vector.  <a href="namespacemlir_1_1linalg.html#a5c34dd63bd77acc711bdf98d6e2c7b75">More...</a><br /></td></tr>
<tr class="separator:a5c34dd63bd77acc711bdf98d6e2c7b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d51592527f88974d4540b6dd73a59d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa9d51592527f88974d4540b6dd73a59d">getUnPackInverseSrcPerm</a> (linalg::UnPackOp unpackOp)</td></tr>
<tr class="memdesc:aa9d51592527f88974d4540b6dd73a59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shell function to compute the Source Permutation of unPackOp.  <a href="namespacemlir_1_1linalg.html#aa9d51592527f88974d4540b6dd73a59d">More...</a><br /></td></tr>
<tr class="separator:aa9d51592527f88974d4540b6dd73a59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c342405201492a414de9f5804310f0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8c342405201492a414de9f5804310f0b">getUnPackInverseSrcPerm</a> (linalg::UnPackOp, PackingMetadata &amp;metadata)</td></tr>
<tr class="memdesc:a8c342405201492a414de9f5804310f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shell function to compute the Source rank permutation for unpackOp Unpack requires some packing metadata data information, so created another function where this value is passed by reference.  <a href="namespacemlir_1_1linalg.html#a8c342405201492a414de9f5804310f0b">More...</a><br /></td></tr>
<tr class="separator:a8c342405201492a414de9f5804310f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eda2843cbf0dc5507bc64ec67f46f22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1eda2843cbf0dc5507bc64ec67f46f22">allIndexingsAreProjectedPermutation</a> (LinalgOp op)</td></tr>
<tr class="memdesc:a1eda2843cbf0dc5507bc64ec67f46f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all indexing maps are projected permutations.  <a href="namespacemlir_1_1linalg.html#a1eda2843cbf0dc5507bc64ec67f46f22">More...</a><br /></td></tr>
<tr class="separator:a1eda2843cbf0dc5507bc64ec67f46f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5473845890c7e81fc544f7bfce900d81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5473845890c7e81fc544f7bfce900d81">hasOnlyScalarElementwiseOp</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;r)</td></tr>
<tr class="memdesc:a5473845890c7e81fc544f7bfce900d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether <code>r</code> has only ConstantOp, ElementwiseMappable and YieldOp.  <a href="namespacemlir_1_1linalg.html#a5473845890c7e81fc544f7bfce900d81">More...</a><br /></td></tr>
<tr class="separator:a5473845890c7e81fc544f7bfce900d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1c347bc995910212c197f9f8728b12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8b1c347bc995910212c197f9f8728b12">isElementwise</a> (LinalgOp op)</td></tr>
<tr class="memdesc:a8b1c347bc995910212c197f9f8728b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a LinalgOp is an element-wise operation.  <a href="namespacemlir_1_1linalg.html#a8b1c347bc995910212c197f9f8728b12">More...</a><br /></td></tr>
<tr class="separator:a8b1c347bc995910212c197f9f8728b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24909cfdf87977961b71f1ca78a25919"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a24909cfdf87977961b71f1ca78a25919">isParallelIterator</a> (utils::IteratorType iteratorType)</td></tr>
<tr class="memdesc:a24909cfdf87977961b71f1ca78a25919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if iterator type has "parallel" semantics.  <a href="namespacemlir_1_1linalg.html#a24909cfdf87977961b71f1ca78a25919">More...</a><br /></td></tr>
<tr class="separator:a24909cfdf87977961b71f1ca78a25919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5377722f56e02541897c157260bd1eee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5377722f56e02541897c157260bd1eee">isReductionIterator</a> (utils::IteratorType iteratorType)</td></tr>
<tr class="memdesc:a5377722f56e02541897c157260bd1eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if iterator type has "reduction" semantics.  <a href="namespacemlir_1_1linalg.html#a5377722f56e02541897c157260bd1eee">More...</a><br /></td></tr>
<tr class="separator:a5377722f56e02541897c157260bd1eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11bd07c6a72404260df26efdd0ba069"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad11bd07c6a72404260df26efdd0ba069">makeComposedPadHighOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, RankedTensorType type, <a class="el" href="classmlir_1_1Value.html">Value</a> source, <a class="el" href="classmlir_1_1Value.html">Value</a> padding, bool nofold, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> typeDynDims={})</td></tr>
<tr class="memdesc:ad11bd07c6a72404260df26efdd0ba069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a tensor::PadOp that pads <code>source</code> to the shape of <code>type</code> whose sizes are assumed to be greater than the dynamic <code>source</code> size.  <a href="namespacemlir_1_1linalg.html#ad11bd07c6a72404260df26efdd0ba069">More...</a><br /></td></tr>
<tr class="separator:ad11bd07c6a72404260df26efdd0ba069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30703b58e97c9678d9ee3d95c1b31f5d"><td class="memItemLeft" align="right" valign="top">GenericOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a30703b58e97c9678d9ee3d95c1b31f5d">makeMemRefCopyOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> from, <a class="el" href="classmlir_1_1Value.html">Value</a> to)</td></tr>
<tr class="memdesc:a30703b58e97c9678d9ee3d95c1b31f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns GenericOp that copies an n-D memref.  <a href="namespacemlir_1_1linalg.html#a30703b58e97c9678d9ee3d95c1b31f5d">More...</a><br /></td></tr>
<tr class="separator:a30703b58e97c9678d9ee3d95c1b31f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c303f22e35937f101dc36b676ef8861"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6c303f22e35937f101dc36b676ef8861">getReassociationMapForFoldingUnitDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedSizes)</td></tr>
<tr class="memdesc:a6c303f22e35937f101dc36b676ef8861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reassociation maps to fold the result of a extract_slice (or source of a insert_slice) operation with given offsets, and sizes to its rank-reduced version.  <a href="namespacemlir_1_1linalg.html#a6c303f22e35937f101dc36b676ef8861">More...</a><br /></td></tr>
<tr class="separator:a6c303f22e35937f101dc36b676ef8861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358e4f52f7be98a79c9189eb82a42eef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a358e4f52f7be98a79c9189eb82a42eef">computeTileOffsets</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes)</td></tr>
<tr class="memdesc:a358e4f52f7be98a79c9189eb82a42eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes tile offsets, given a list of loop <code>ivs</code> and <code>tileSizes</code>.  <a href="namespacemlir_1_1linalg.html#a358e4f52f7be98a79c9189eb82a42eef">More...</a><br /></td></tr>
<tr class="separator:a358e4f52f7be98a79c9189eb82a42eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29aed62cd711098f063d5a628905c074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a29aed62cd711098f063d5a628905c074">computeTileSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizeBounds)</td></tr>
<tr class="memdesc:a29aed62cd711098f063d5a628905c074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes tile sizes, given a list of <code>tileSizes</code> and dimension sizes (<code>sizeBounds</code>).  <a href="namespacemlir_1_1linalg.html#a29aed62cd711098f063d5a628905c074">More...</a><br /></td></tr>
<tr class="separator:a29aed62cd711098f063d5a628905c074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2da35587b12f700693b151c166fee34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af2da35587b12f700693b151c166fee34">getTensorOutputTypes</a> (LinalgOp op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memdesc:af2da35587b12f700693b151c166fee34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of tensor output types produced when the given structured operation <code>op</code> is applied to the given <code>operands</code>.  <a href="namespacemlir_1_1linalg.html#af2da35587b12f700693b151c166fee34">More...</a><br /></td></tr>
<tr class="separator:af2da35587b12f700693b151c166fee34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f9038823afe23e270d5bdc0734bc3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a78f9038823afe23e270d5bdc0734bc3e">insertSlicesBack</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, LinalgOp op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> results)</td></tr>
<tr class="memdesc:a78f9038823afe23e270d5bdc0734bc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <code>insert_slice</code> ops that insert <code>results</code> back into larger tensors they were originally extracted from with <code>extract_slice</code> before being passed as <code>operands</code> to the given structured operation <code>op</code> or its clone.  <a href="namespacemlir_1_1linalg.html#a78f9038823afe23e270d5bdc0734bc3e">More...</a><br /></td></tr>
<tr class="separator:a78f9038823afe23e270d5bdc0734bc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc396179b7b2aee5cfef868a42592c60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#afc396179b7b2aee5cfef868a42592c60">computeSliceParameters</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> valueToTile, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; lbs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; subShapeSizes, bool omitPartialTileCheck)</td></tr>
<tr class="memdesc:afc396179b7b2aee5cfef868a42592c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html" title="A struct containg offsets-sizes-strides arguments of the tiled shape.">SliceParameters</a> for a single <code>valueToTile</code> assuming that its user is being tiled with the given loop bounds <code>lbs</code> and <code>ubs</code> and the tile sizes <code>tileSizes</code>.  <a href="namespacemlir_1_1linalg.html#afc396179b7b2aee5cfef868a42592c60">More...</a><br /></td></tr>
<tr class="separator:afc396179b7b2aee5cfef868a42592c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06c54273304b8d82c1b239db2b7db90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; std::optional&lt; <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa06c54273304b8d82c1b239db2b7db90">computeAllSliceParameters</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, LinalgOp linalgOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> valuesToTile, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizeBounds, bool omitPartialTileCheck)</td></tr>
<tr class="memdesc:aa06c54273304b8d82c1b239db2b7db90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes SliceParamaters for all <code>valuesToTile</code> of the given <code>linalgOp</code>, assuming <code>linalgOp</code> is being fused into a loop nest.  <a href="namespacemlir_1_1linalg.html#aa06c54273304b8d82c1b239db2b7db90">More...</a><br /></td></tr>
<tr class="separator:aa06c54273304b8d82c1b239db2b7db90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa568a297670d2eb8609fa6df9849a449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa568a297670d2eb8609fa6df9849a449">makeTiledShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> valueToTile, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; lbs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; subShapeSizes, bool omitPartialTileCheck)</td></tr>
<tr class="memdesc:aa568a297670d2eb8609fa6df9849a449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an extract_slice/subview op for a single <code>valueToTile</code> with <code>builder</code>.  <a href="namespacemlir_1_1linalg.html#aa568a297670d2eb8609fa6df9849a449">More...</a><br /></td></tr>
<tr class="separator:aa568a297670d2eb8609fa6df9849a449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5fecbf19090f24723800d371f08271"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1a5fecbf19090f24723800d371f08271">makeTiledShapes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, LinalgOp linalgOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> valuesToTile, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizeBounds, bool omitPartialTileCheck)</td></tr>
<tr class="memdesc:a1a5fecbf19090f24723800d371f08271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates extract_slice/subview ops for all <code>valuesToTile</code> of the given <code>linalgOp</code> with <code>builder</code>, assuming <code>linalgOp</code> is being fused into a loop nest for tiling with the given induction variables <code>ivs</code> and tile sizes <code>tileSizes</code>.  <a href="namespacemlir_1_1linalg.html#a1a5fecbf19090f24723800d371f08271">More...</a><br /></td></tr>
<tr class="separator:a1a5fecbf19090f24723800d371f08271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917a655a236200d3202b07fb842561b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a917a655a236200d3202b07fb842561b8">offsetIndices</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; offests)</td></tr>
<tr class="memdesc:a917a655a236200d3202b07fb842561b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the specified offsets to any <code>linalg.index</code> ops contained in the given <code>linalgOp</code>.  <a href="namespacemlir_1_1linalg.html#a917a655a236200d3202b07fb842561b8">More...</a><br /></td></tr>
<tr class="separator:a917a655a236200d3202b07fb842561b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bed319cb33ba0b063edefa38e27309"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a34bed319cb33ba0b063edefa38e27309">offsetIndices</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; offests)</td></tr>
<tr class="separator:a34bed319cb33ba0b063edefa38e27309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c5cf1a47f0bf5b6405224845ff8d83"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a13c5cf1a47f0bf5b6405224845ff8d83">fuseProducerOfTensor</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumerOpOperand)</td></tr>
<tr class="memdesc:a13c5cf1a47f0bf5b6405224845ff8d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implements the fusion part of the "tileAndFuse on tensors" transformation and thus requires the <code>consumerOpOperand</code> to be a <code>extract_slice</code> op (generally obtained by applying the tiling transformation).  <a href="namespacemlir_1_1linalg.html#a13c5cf1a47f0bf5b6405224845ff8d83">More...</a><br /></td></tr>
<tr class="separator:a13c5cf1a47f0bf5b6405224845ff8d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7195637d33a1cf8133bc32a219adf6b"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa7195637d33a1cf8133bc32a219adf6b">fuseProducerOfTensor</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> producerOpResult, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumerOpOperand)</td></tr>
<tr class="memdesc:aa7195637d33a1cf8133bc32a219adf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implements the fusion part of the "tileAndFuse on tensors" transformation and thus requires the <code>consumerOpOperand</code> to be a <code>extract_slice</code> op (generally obtained by applying the tiling transformation).  <a href="namespacemlir_1_1linalg.html#aa7195637d33a1cf8133bc32a219adf6b">More...</a><br /></td></tr>
<tr class="separator:aa7195637d33a1cf8133bc32a219adf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb173d5edf56a08ed3610924312dd364"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aeb173d5edf56a08ed3610924312dd364">updateBoundsForCyclicDistribution</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> procId, <a class="el" href="classmlir_1_1Value.html">Value</a> nprocs, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;lb, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;ub, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;step)</td></tr>
<tr class="memdesc:aeb173d5edf56a08ed3610924312dd364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the <code>lb</code>, <code>ub</code> and <code>step</code> to get per processor <code>lb</code>, <code>ub</code> and <code>step</code>.  <a href="namespacemlir_1_1linalg.html#aeb173d5edf56a08ed3610924312dd364">More...</a><br /></td></tr>
<tr class="separator:aeb173d5edf56a08ed3610924312dd364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3c6ebbcb16507e55a2f5c07542b312"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:a6a3c6ebbcb16507e55a2f5c07542b312"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6a3c6ebbcb16507e55a2f5c07542b312">getPrunedAttributeList</a> (OpTy op)</td></tr>
<tr class="memdesc:a6a3c6ebbcb16507e55a2f5c07542b312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an attribute list that excludes pre-defined attributes.  <a href="namespacemlir_1_1linalg.html#a6a3c6ebbcb16507e55a2f5c07542b312">More...</a><br /></td></tr>
<tr class="separator:a6a3c6ebbcb16507e55a2f5c07542b312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20da6e40bc32581f1b98bfbdf172eed"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; ArrayAttr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af20da6e40bc32581f1b98bfbdf172eed">parseIndexingMapsAttr</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser)</td></tr>
<tr class="separator:af20da6e40bc32581f1b98bfbdf172eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f099443ddafc2ff4b45a9788b324d0"><td class="memItemLeft" align="right" valign="top">static ArityGroupAndKind&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a61f099443ddafc2ff4b45a9788b324d0">getArityGroupAndKind</a> (ElementwiseKind <a class="el" href="LinalgOps_8cpp.html#a28955b1aca39affb65f8316b45796bfa">kind</a>)</td></tr>
<tr class="separator:a61f099443ddafc2ff4b45a9788b324d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be24276582fa9397d22611b0c2eb7e2"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0be24276582fa9397d22611b0c2eb7e2">getPackedOuterShapeWithoutTransposition&lt; PackOp &gt;</a> (PackOp)</td></tr>
<tr class="separator:a0be24276582fa9397d22611b0c2eb7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e0bcac8732b719caf9a733c3713f1b"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad0e0bcac8732b719caf9a733c3713f1b">getPackedOuterShapeWithoutTransposition&lt; UnPackOp &gt;</a> (UnPackOp)</td></tr>
<tr class="separator:ad0e0bcac8732b719caf9a733c3713f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e0dc6ea28e24238e24a08da62df847"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa0e0dc6ea28e24238e24a08da62df847">getNewMixedTileSizes</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Type.html">Type</a> newPackedTy, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedTiles)</td></tr>
<tr class="separator:aa0e0dc6ea28e24238e24a08da62df847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0369f798f7a1803f0c897c0f33edb5e5"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:a0369f798f7a1803f0c897c0f33edb5e5"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0369f798f7a1803f0c897c0f33edb5e5">reifyResultShapesImpl</a> (OpTy op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="namespacemlir.html#a0a5ee68dc80640e6ac9c4a6011d18bc1">ReifiedRankedShapedTypeDims</a> &amp;reifiedReturnShapes)</td></tr>
<tr class="separator:a0369f798f7a1803f0c897c0f33edb5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990df5d31f0a65352b97528ace830ad2"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:a990df5d31f0a65352b97528ace830ad2"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; int64_t, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a990df5d31f0a65352b97528ace830ad2">getDimAndTileMappingImpl</a> (OpTy op)</td></tr>
<tr class="separator:a990df5d31f0a65352b97528ace830ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace20474dce44d818ee4be3dabe7b4214"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:ace20474dce44d818ee4be3dabe7b4214"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ace20474dce44d818ee4be3dabe7b4214">getMixedTilesImpl</a> (OpTy op)</td></tr>
<tr class="separator:ace20474dce44d818ee4be3dabe7b4214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281819e7457a7c85a98d5f2ee490b89c"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:a281819e7457a7c85a98d5f2ee490b89c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a281819e7457a7c85a98d5f2ee490b89c">getStaticTilesImpl</a> (OpTy op)</td></tr>
<tr class="separator:a281819e7457a7c85a98d5f2ee490b89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258a284dc398c6d6510840831132df77"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a258a284dc398c6d6510840831132df77">isInvalidPackingPosSpecification</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; dimsPos, size_t rank)</td></tr>
<tr class="memdesc:a258a284dc398c6d6510840831132df77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>dimsPos</code> is invalid.  <a href="namespacemlir_1_1linalg.html#a258a284dc398c6d6510840831132df77">More...</a><br /></td></tr>
<tr class="separator:a258a284dc398c6d6510840831132df77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf3c885687f3ae6238ad0c1106e6af8"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:aedf3c885687f3ae6238ad0c1106e6af8"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aedf3c885687f3ae6238ad0c1106e6af8">commonVerifierPackAndUnPackOp</a> (OpTy packOrUnPack)</td></tr>
<tr class="separator:aedf3c885687f3ae6238ad0c1106e6af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdc3ac4dd00e8808043082728373fd6"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:a6cdc3ac4dd00e8808043082728373fd6"><td class="memTemplItemLeft" align="right" valign="top">static PackOrUnPackTransposeResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6cdc3ac4dd00e8808043082728373fd6">commonPermutationOfPackAndUnPackOp</a> (OpTy packOrUnPackOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; innerPermutation, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; outerPermutation)</td></tr>
<tr class="separator:a6cdc3ac4dd00e8808043082728373fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21456d907d447d15a3d719753b782ff3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a21456d907d447d15a3d719753b782ff3">asShapeWithAnyValueAsDynamic</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs)</td></tr>
<tr class="memdesc:a21456d907d447d15a3d719753b782ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts OpFoldResults to int64_t shape entries, unconditionally mapping all <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>'s to kDynamic, even if they are arith.constant values.  <a href="namespacemlir_1_1linalg.html#a21456d907d447d15a3d719753b782ff3">More...</a><br /></td></tr>
<tr class="separator:a21456d907d447d15a3d719753b782ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347ae9bce651afd1c1a37679c4127e5e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a347ae9bce651afd1c1a37679c4127e5e">getPackOpResultTypeShape</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sourceShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; innerTileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; <a class="el" href="LinalgOps_8cpp.html#aa7b25f95711cd673d4f468989b6fbad1">innerDimsPos</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; <a class="el" href="LinalgOps_8cpp.html#a2f749fca1dfad319b229d0c4884bf113">outerDimsPerm</a>)</td></tr>
<tr class="memdesc:a347ae9bce651afd1c1a37679c4127e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for PackOp::{getResultShape,inferPackedType}.  <a href="namespacemlir_1_1linalg.html#a347ae9bce651afd1c1a37679c4127e5e">More...</a><br /></td></tr>
<tr class="separator:a347ae9bce651afd1c1a37679c4127e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2601c4a3969aaff305c30e389393c91"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:ac2601c4a3969aaff305c30e389393c91"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac2601c4a3969aaff305c30e389393c91">areTilesAndTiledDimsAllConstant</a> (OpTy op)</td></tr>
<tr class="memdesc:ac2601c4a3969aaff305c30e389393c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the tiles and the tiled dims are constant.  <a href="namespacemlir_1_1linalg.html#ac2601c4a3969aaff305c30e389393c91">More...</a><br /></td></tr>
<tr class="separator:ac2601c4a3969aaff305c30e389393c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3de4bb45fd63e06339cb0ba92533fa"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#abe3de4bb45fd63e06339cb0ba92533fa">hasSameInnerOuterAttribute</a> (PackOp packOp, UnPackOp unPackOp)</td></tr>
<tr class="separator:abe3de4bb45fd63e06339cb0ba92533fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa603d3bdb590cef7749279812bd8e11a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa603d3bdb590cef7749279812bd8e11a">haveSameTiles</a> (PackOp packOp, UnPackOp unPackOp)</td></tr>
<tr class="separator:aa603d3bdb590cef7749279812bd8e11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2b11de8cf430259d6ed044bfd270dd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8f2b11de8cf430259d6ed044bfd270dd">paddingIsNotNeeded</a> (PackOp op)</td></tr>
<tr class="memdesc:a8f2b11de8cf430259d6ed044bfd270dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pack op does not need a padding value.  <a href="namespacemlir_1_1linalg.html#a8f2b11de8cf430259d6ed044bfd270dd">More...</a><br /></td></tr>
<tr class="separator:a8f2b11de8cf430259d6ed044bfd270dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f85ff360bf1a176189d8a29a349623"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a19f85ff360bf1a176189d8a29a349623">inferStaticShape</a> (PackOp packOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;srcShape, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;destShape)</td></tr>
<tr class="memdesc:a19f85ff360bf1a176189d8a29a349623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <code>srcShape</code> or <code>destShape</code> is different from the one in <code>packOp</code> and populates each with the inferred static shape.  <a href="namespacemlir_1_1linalg.html#a19f85ff360bf1a176189d8a29a349623">More...</a><br /></td></tr>
<tr class="separator:a19f85ff360bf1a176189d8a29a349623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d84aa10cc5bda416b75ff65007c677"><td class="memTemplParams" colspan="2">template&lt;typename PackOrUnpackOp &gt; </td></tr>
<tr class="memitem:a20d84aa10cc5bda416b75ff65007c677"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a20d84aa10cc5bda416b75ff65007c677">isLikePadUnPad</a> (PackOrUnpackOp packOp, RankedTensorType packedTensorType)</td></tr>
<tr class="separator:a20d84aa10cc5bda416b75ff65007c677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bfb7adf709f8802dfc47a8e602ecb0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af8bfb7adf709f8802dfc47a8e602ecb0">inferStaticShape</a> (UnPackOp op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;srcShape, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;destShape)</td></tr>
<tr class="memdesc:af8bfb7adf709f8802dfc47a8e602ecb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <code>srcShape</code> or <code>destShape</code> is different from the one in <code>op</code> and populates each with the inferred static shape.  <a href="namespacemlir_1_1linalg.html#af8bfb7adf709f8802dfc47a8e602ecb0">More...</a><br /></td></tr>
<tr class="separator:af8bfb7adf709f8802dfc47a8e602ecb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab874160ec1bdc15b5c867c4799391a03"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab874160ec1bdc15b5c867c4799391a03">hasAllOneValues</a> (<a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a> attr)</td></tr>
<tr class="separator:ab874160ec1bdc15b5c867c4799391a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f801aa72135899ae36567a9c78c5b3b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3f801aa72135899ae36567a9c78c5b3b">createAdd</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> x, <a class="el" href="classmlir_1_1Value.html">Value</a> y, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="separator:a3f801aa72135899ae36567a9c78c5b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e6451d40cef8244025d03bc83cfdad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a80e6451d40cef8244025d03bc83cfdad">createMul</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> x, <a class="el" href="classmlir_1_1Value.html">Value</a> y, <a class="el" href="classmlir_1_1Type.html">Type</a> accType, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="separator:a80e6451d40cef8244025d03bc83cfdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0775243640f0e58d6cce7f49809b13"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0a0775243640f0e58d6cce7f49809b13">unrollIndex</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> index, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; factors)</td></tr>
<tr class="separator:a0a0775243640f0e58d6cce7f49809b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90b3b862ac8de64b21095282e64305c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab90b3b862ac8de64b21095282e64305c">getConvolvedIndex</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> oIndex, <a class="el" href="classmlir_1_1Value.html">Value</a> fIndex, int64_t stride)</td></tr>
<tr class="separator:ab90b3b862ac8de64b21095282e64305c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351f651dd2a55b2a452b56d68c2e2c4c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemlir_1_1linalg.html#a5dc368615dd2afa818f751044efd890c">ReductionKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a351f651dd2a55b2a452b56d68c2e2c4c">getReductionKind</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a351f651dd2a55b2a452b56d68c2e2c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a87e6c5c97ba109109f352407d323b3"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3a87e6c5c97ba109109f352407d323b3">getCombinerOp</a> (LinalgOp op)</td></tr>
<tr class="separator:a3a87e6c5c97ba109109f352407d323b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada28e3e4bc6c8c677652c60e01bf2b6a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemlir_1_1linalg.html#a5dc368615dd2afa818f751044efd890c">ReductionKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ada28e3e4bc6c8c677652c60e01bf2b6a">getReductionKindOfLinalgOp</a> (LinalgOp op)</td></tr>
<tr class="separator:ada28e3e4bc6c8c677652c60e01bf2b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb58b5d5caada44bf94cd80eb843637"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemlir_1_1linalg.html#a5f4c3fb63365bf26fe671663cd4d6d57">GridOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#affb58b5d5caada44bf94cd80eb843637">getGrid</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4c4ef4fd46eecd339c2489be75f16729">Sharding</a> &gt; operandShardings, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4c4ef4fd46eecd339c2489be75f16729">Sharding</a> &gt; resultShardings, <a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> &amp;symbolTable)</td></tr>
<tr class="separator:affb58b5d5caada44bf94cd80eb843637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491060ab8a250d42c9650c00ef3fc571"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a491060ab8a250d42c9650c00ef3fc571">createDestinationPassingStyleInitOperand</a> (LinalgOp op, int operandNumber, <a class="el" href="classmlir_1_1Value.html">Value</a> partitionedOperand, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a9f513853f0b1d301ba8269c1d38a2a16">GridAxis</a> &gt; reductionGridAxes, <a class="el" href="namespacemlir_1_1linalg.html#a5f4c3fb63365bf26fe671663cd4d6d57">GridOp</a> gridOp, <a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;builder)</td></tr>
<tr class="separator:a491060ab8a250d42c9650c00ef3fc571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d07489064352e1b6957afc5ecfd575"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a68d07489064352e1b6957afc5ecfd575">createDestinationPassingStyleInitOperands</a> (LinalgOp op, <a class="el" href="namespacemlir_1_1linalg.html#a5f4c3fb63365bf26fe671663cd4d6d57">GridOp</a> gridOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; partitionedOperands, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a9f513853f0b1d301ba8269c1d38a2a16">GridAxis</a> &gt; reductionGridAxes, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;partitionMap, <a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;builder)</td></tr>
<tr class="separator:a68d07489064352e1b6957afc5ecfd575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503baeef1328177c20af2c28710f0066"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a503baeef1328177c20af2c28710f0066">createAllReduceForResultsWithoutPartialShardings</a> (LinalgOp unshardedOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a9f513853f0b1d301ba8269c1d38a2a16">GridAxis</a> &gt; opReductionGridAxes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4c4ef4fd46eecd339c2489be75f16729">Sharding</a> &gt; resultShardings, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;partitionMap, <a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;builder)</td></tr>
<tr class="separator:a503baeef1328177c20af2c28710f0066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dadb214c30b3c13050c631d03070a9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a68dadb214c30b3c13050c631d03070a9">partitionLinalgOpWithShardedReduction</a> (LinalgOp op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; partitionedOperands, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4c4ef4fd46eecd339c2489be75f16729">Sharding</a> &gt; operandShardings, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4c4ef4fd46eecd339c2489be75f16729">Sharding</a> &gt; resultShardings, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt; loopIteratorTypes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a9f513853f0b1d301ba8269c1d38a2a16">GridAxis</a> &gt;&gt; gridAxisAssignmentForLoopIterators, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;partitionMap, <a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> &amp;symbolTable, <a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;builder)</td></tr>
<tr class="separator:a68dadb214c30b3c13050c631d03070a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645065016a10ad2397796861ba5b8c3e"><td class="memTemplParams" colspan="2">template&lt;typename OpType &gt; </td></tr>
<tr class="memitem:a645065016a10ad2397796861ba5b8c3e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a645065016a10ad2397796861ba5b8c3e">registerOne</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="separator:a645065016a10ad2397796861ba5b8c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688a83ed3c19e68f4acfed8486771451"><td class="memTemplParams" colspan="2">template&lt;typename... OpTypes&gt; </td></tr>
<tr class="memitem:a688a83ed3c19e68f4acfed8486771451"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a688a83ed3c19e68f4acfed8486771451">registerAll</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:a688a83ed3c19e68f4acfed8486771451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic helper function.  <a href="namespacemlir_1_1linalg.html#a688a83ed3c19e68f4acfed8486771451">More...</a><br /></td></tr>
<tr class="separator:a688a83ed3c19e68f4acfed8486771451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bd97b279b588f6e57a048d72a69a9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a90bd97b279b588f6e57a048d72a69a9c">populateTransposeConv2DPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="separator:a90bd97b279b588f6e57a048d72a69a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfaca7f9267827abf1cddb266e44e64"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aebfaca7f9267827abf1cddb266e44e64">winogradConv2D</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcFhwcOp op, linalg::WinogradConv2DFmr fmr)</td></tr>
<tr class="separator:aebfaca7f9267827abf1cddb266e44e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8880fcb816f23c0198e5c6153cc57dcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8880fcb816f23c0198e5c6153cc57dcf">getPackInverseDestPerm</a> (PackOp packOp)</td></tr>
<tr class="separator:a8880fcb816f23c0198e5c6153cc57dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788b113d5f6e96cc0d7753009f759ef3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a788b113d5f6e96cc0d7753009f759ef3">getUnPackInverseSrcPerm</a> (UnPackOp unpackOp)</td></tr>
<tr class="separator:a788b113d5f6e96cc0d7753009f759ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c0bfe9542727e64fb90f729f53657c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac0c0bfe9542727e64fb90f729f53657c">getUnPackInverseSrcPerm</a> (UnPackOp unpackOp, PackingMetadata &amp;metadata)</td></tr>
<tr class="separator:ac0c0bfe9542727e64fb90f729f53657c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330275ee0b8daf6e838a8bce3d70a331"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a330275ee0b8daf6e838a8bce3d70a331">generateParallelLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt; iteratorTypes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">linalg::ProcInfo</a> &gt; procInfo, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivStorage)</td></tr>
<tr class="memdesc:a330275ee0b8daf6e838a8bce3d70a331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a loop nest consisting of scf.parallel and scf.for, depending on the <code>iteratorTypes. </code> <a href="namespacemlir_1_1linalg.html#a330275ee0b8daf6e838a8bce3d70a331">More...</a><br /></td></tr>
<tr class="separator:a330275ee0b8daf6e838a8bce3d70a331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58aa52677e896e295c5fed98e9789f94"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a58aa52677e896e295c5fed98e9789f94">materializeTiledShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> valueToTile, const <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a> &amp;sliceParams)</td></tr>
<tr class="separator:a58aa52677e896e295c5fed98e9789f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a1bcbad447f843c9b98886ad6f49469a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bcbad447f843c9b98886ad6f49469a9">&#9670;&nbsp;</a></span>AllocBufferCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a1bcbad447f843c9b98886ad6f49469a9">mlir::linalg::AllocBufferCallbackFn</a> = typedef std::function&lt;std::optional&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;( <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, memref::SubViewOp subView, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; boundingSubViewSize, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to perform the allocation for the promoted <code>subView</code>. </p>
<p>In <code>boundingSubViewsize</code> a best attempt is made to find the smallest constant value for the size of the buffer needed for each dimension. If that is not possible, contains the dynamic size of the subview. The call back should return the buffer to use. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00379">379</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="ae020263d273fb7b7f80c4970556da5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae020263d273fb7b7f80c4970556da5f8">&#9670;&nbsp;</a></span>ControlBlockPackMatmulFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#ae020263d273fb7b7f80c4970556da5f8">mlir::linalg::ControlBlockPackMatmulFn</a> = typedef std::function&lt;std::optional&lt;<a class="el" href="structmlir_1_1linalg_1_1BlockPackMatmulOptions.html">BlockPackMatmulOptions</a>&gt;(linalg::LinalgOp)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type which is used to control matmul packing. </p>
<p>It is expected to return valid packing configuration for each operation. Lack of packing options indicates that no valid configuration could be assigned and the operation will not be packed. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01338">1338</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a8978399adc7b5ab6a4574123f59d1f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8978399adc7b5ab6a4574123f59d1f52">&#9670;&nbsp;</a></span>ControlFoldIntoPackUnpackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a8978399adc7b5ab6a4574123f59d1f52">mlir::linalg::ControlFoldIntoPackUnpackFn</a> = typedef std::function&lt;bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *opOperand)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type which is used to control folding operations like <code>tensor.pad</code> and <code>tensor.extract_slice</code> into <a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a>/unpack ops. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l02019">2019</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a3115e251fd057529cff9b2d44a0ba1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3115e251fd057529cff9b2d44a0ba1c0">&#9670;&nbsp;</a></span>ControlFusionFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">mlir::linalg::ControlFusionFn</a> = typedef std::function&lt;bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type which is used to control when to stop fusion. </p>
<p>It is expected that <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> is not modified in the callback. The <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> is not marked as const to allow callers to use non-const methods. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01898">1898</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="ab145fd297a4850ad34e09aab2f669e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab145fd297a4850ad34e09aab2f669e65">&#9670;&nbsp;</a></span>ControlPropagationFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#ab145fd297a4850ad34e09aab2f669e65">mlir::linalg::ControlPropagationFn</a> = typedef std::function&lt;bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *opOperand)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type which is used to control propagation of <a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a>/unpack ops. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01910">1910</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="ad16099880d7579f488dd714c6273ea4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16099880d7579f488dd714c6273ea4c">&#9670;&nbsp;</a></span>ControlSplitReductionFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">mlir::linalg::ControlSplitReductionFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1linalg_1_1SplitReductionOptions.html">SplitReductionOptions</a>(LinalgOp op)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function signature to control reduction splitting. </p>
<p>This returns <code><a class="el" href="structmlir_1_1linalg_1_1SplitReductionOptions.html" title="Split Reduction options.">SplitReductionOptions</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00490">490</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="aa49994e2aab61b35167972384684cf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49994e2aab61b35167972384684cf24">&#9670;&nbsp;</a></span>CopyCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#aa49994e2aab61b35167972384684cf24">mlir::linalg::CopyCallbackFn</a> = typedef std::function&lt;LogicalResult(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to insert copy from original subview to subview of the promoted region for the read operands/subview of promoted region to original subview for the results. </p>
<p>The copy has to happen from <code>src</code> to <code>dst</code>. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00392">392</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a3d7afb284c4be072a74a24eeb71cc985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7afb284c4be072a74a24eeb71cc985">&#9670;&nbsp;</a></span>DeallocBufferCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a3d7afb284c4be072a74a24eeb71cc985">mlir::linalg::DeallocBufferCallbackFn</a> = typedef std::function&lt;LogicalResult(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> buffer)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to deallocate the buffers used to hold the promoted subview. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00385">385</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a2f38324ff992b8ceebc6e3f0c01a57d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f38324ff992b8ceebc6e3f0c01a57d1">&#9670;&nbsp;</a></span>DroppedUnitDimsBuilder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a2f38324ff992b8ceebc6e3f0c01a57d1">mlir::linalg::DroppedUnitDimsBuilder</a> = typedef std::function&lt;IndexingMapOpInterface( <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, IndexingMapOpInterface, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; newOperands, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&gt; newIndexingMaps, const llvm::SmallDenseSet&lt;unsigned&gt; &amp;droppedDims)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00545">545</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="ac1d01335b6fc341e4b908d9ea5df7482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d01335b6fc341e4b908d9ea5df7482">&#9670;&nbsp;</a></span>GetCollapsableDimensionsFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#ac1d01335b6fc341e4b908d9ea5df7482">mlir::linalg::GetCollapsableDimensionsFn</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a>&gt;(linalg::LinalgOp)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type to control generic op dimension collapsing. </p>
<p>It is expected to return an array of <code>ReassociationIndices</code> representing dimensions that should be merged. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01928">1928</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a9f513853f0b1d301ba8269c1d38a2a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f513853f0b1d301ba8269c1d38a2a16">&#9670;&nbsp;</a></span>GridAxis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a9f513853f0b1d301ba8269c1d38a2a16">mlir::linalg::GridAxis</a> = typedef <a class="el" href="namespacemlir_1_1shard.html#a0586307df42ba3b890713faf226e8736">shard::GridAxis</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00039">39</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

</div>
</div>
<a id="a5f4c3fb63365bf26fe671663cd4d6d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4c3fb63365bf26fe671663cd4d6d57">&#9670;&nbsp;</a></span>GridOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a5f4c3fb63365bf26fe671663cd4d6d57">mlir::linalg::GridOp</a> = typedef shard::GridOp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00043">43</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

</div>
</div>
<a id="a4a9ca79033211e3e53e0eb25a8e9551b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9ca79033211e3e53e0eb25a8e9551b">&#9670;&nbsp;</a></span>LinalgLoops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">mlir::linalg::LinalgLoops</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00518">518</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a2363d9b68019db04dbf0c710afe7f224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2363d9b68019db04dbf0c710afe7f224">&#9670;&nbsp;</a></span>LoopIndexToRangeIndexMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">mlir::linalg::LoopIndexToRangeIndexMap</a> = typedef <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt;int, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a number of ranges equal to the number of non-zero in <code>tileSizes</code>. </p>
<p>One for each loop of the LinalgOp that is tiled. The <code>tileSizes</code> argument has one entry per surrounding loop. It uses zero as the convention that a particular loop is not tiled. This convention simplifies implementations by avoiding affine map manipulations. The returned ranges correspond to the loop ranges, in the proper order, that are tiled and for which new loops will be created. Also the function returns a map from loop indices of the LinalgOp to the corresponding non-empty range indices of newly created loops. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00930">930</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a7326883dfd3172d344f305860482e9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7326883dfd3172d344f305860482e9ff">&#9670;&nbsp;</a></span>OptimizeCopyFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a7326883dfd3172d344f305860482e9ff">mlir::linalg::OptimizeCopyFn</a> = typedef std::function&lt;LogicalResult(<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;, tensor::PadOp, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01633">1633</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="ac636a02565dd1c1bdcb8eb5982bd07c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac636a02565dd1c1bdcb8eb5982bd07c1">&#9670;&nbsp;</a></span>PadSizeComputationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#ac636a02565dd1c1bdcb8eb5982bd07c1">mlir::linalg::PadSizeComputationFunction</a> = typedef std::function&lt;FailureOr&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; &gt;( <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="structmlir_1_1Range.html">Range</a>&gt;, const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00628">628</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a651199aee7abd57b3b297b905d109183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651199aee7abd57b3b297b905d109183">&#9670;&nbsp;</a></span>ProcInfoCallBackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a651199aee7abd57b3b297b905d109183">mlir::linalg::ProcInfoCallBackFn</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a>&gt;( <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="structmlir_1_1Range.html">Range</a>&gt; parallelLoopRanges)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00314">314</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a5dc368615dd2afa818f751044efd890c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc368615dd2afa818f751044efd890c">&#9670;&nbsp;</a></span>ReductionKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a5dc368615dd2afa818f751044efd890c">mlir::linalg::ReductionKind</a> = typedef shard::ReductionKind</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00040">40</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

</div>
</div>
<a id="a4c4ef4fd46eecd339c2489be75f16729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4ef4fd46eecd339c2489be75f16729">&#9670;&nbsp;</a></span>Sharding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a4c4ef4fd46eecd339c2489be75f16729">mlir::linalg::Sharding</a> = typedef <a class="el" href="classmlir_1_1shard_1_1Sharding.html">shard::Sharding</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00041">41</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

</div>
</div>
<a id="a5799a7ecfd2ecc2d8c6f7e89f35ebbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5799a7ecfd2ecc2d8c6f7e89f35ebbc5">&#9670;&nbsp;</a></span>ShardingArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a5799a7ecfd2ecc2d8c6f7e89f35ebbc5">mlir::linalg::ShardingArray</a> = typedef <a class="el" href="namespacemlir_1_1shard.html#a525729e2e9b80d6a92600457dd822f91">shard::ShardingArray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00042">42</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

</div>
</div>
<a id="a730df0415b8172eb93f8f7b346e04440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730df0415b8172eb93f8f7b346e04440">&#9670;&nbsp;</a></span>TileSizeComputationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a730df0415b8172eb93f8f7b346e04440">mlir::linalg::TileSizeComputationFunction</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, 4&gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00188">188</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a7382d59369873eb3a9a9ddd571056982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7382d59369873eb3a9a9ddd571056982">&#9670;&nbsp;</a></span>DistributionMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">mlir::linalg::DistributionMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scheme used to distribute loops to processors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982ad71670d62b238eaf063979407361034e"></a>Cyclic&#160;</td><td class="fielddoc"><p>Cyclic distribution where no assumption is made about the dynamic relationship between number of processors and number of iterations of the distributed loop. </p>
<p>Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>scf.parallel(iv)= (lb + procId * step) to (ub) step (step * nprocs) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982abab54876ff518ecd2d59b46fd3be9c0e"></a>CyclicNumProcsGeNumIters&#160;</td><td class="fielddoc"><p>Cyclic distribution where the number of processors can be assumed to be more than or equal to the number of iterations of the distributed loop. </p>
<p>In such cases, a simple in-bounds check is enough (instead of materializing a loop). Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>iv = lb + procId * step cond = arith.cmpi "slt", iv, ub scf.if cond { ... } </p>
</td></tr>
<tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982ad93606014b9a6b479ba0e6faa948540b"></a>CyclicNumProcsEqNumIters&#160;</td><td class="fielddoc"><p>Cyclic distribution where the number of processors can be assumed to be equal to the number of iterations of the distributed loop. </p>
<p>In such cases, no bounds check is needed. Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>iv = lb + procId * step </p>
</td></tr>
<tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>No Distribution. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00259">259</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a3cdd229e1459c7e6ed2f9c7ee7168325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdd229e1459c7e6ed2f9c7ee7168325">&#9670;&nbsp;</a></span>LinalgTilingLoopType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">mlir::linalg::LinalgTilingLoopType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of loops to be generated during tiling. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8"></a>Loops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325a6d8bf0bdeaca5ef4693524bf04c4c877"></a>AffineLoops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7"></a>ParallelLoops&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00118">118</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1eda2843cbf0dc5507bc64ec67f46f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eda2843cbf0dc5507bc64ec67f46f22">&#9670;&nbsp;</a></span>allIndexingsAreProjectedPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::allIndexingsAreProjectedPermutation </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if all indexing maps are projected permutations. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00200">200</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00220">isElementwise()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l02362">vectorizeLinalgOpPrecondition()</a>.</p>

</div>
</div>
<a id="a5606dfca8a9078fc6bc9b74972f15fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5606dfca8a9078fc6bc9b74972f15fdc">&#9670;&nbsp;</a></span>allocateGPUPrivateMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::allocateGPUPrivateMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::SubViewOp&#160;</td>
          <td class="paramname"><em>subview</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizeBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate the subview in the GPU private memory. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00496">496</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Promotion_8cpp_source.html#l00436">allocateSubviewGPUMemoryInAddressSpace()</a>.</p>

</div>
</div>
<a id="a266200755192d09deb827c799e59277b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266200755192d09deb827c799e59277b">&#9670;&nbsp;</a></span>allocateWorkgroupMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::allocateWorkgroupMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::SubViewOp&#160;</td>
          <td class="paramname"><em>subview</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizeBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate the subview in the GPU workgroup memory. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00471">471</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Promotion_8cpp_source.html#l00436">allocateSubviewGPUMemoryInAddressSpace()</a>.</p>

</div>
</div>
<a id="a133a3ec0d7cd50a886d2cd558fdc9030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133a3ec0d7cd50a886d2cd558fdc9030">&#9670;&nbsp;</a></span>areDimSequencesPreserved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::areDimSequencesPreserved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>dimSequences</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if all sequences of dimensions specified in <code>dimSequences</code> are contiguous in all the ranges of the <code>maps</code>. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01241">1241</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01200">isDimSequencePreserved()</a>.</p>

</div>
</div>
<a id="a8fa220da60546acce7c4a8b3635d5b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa220da60546acce7c4a8b3635d5b21">&#9670;&nbsp;</a></span>areElementwiseOpsFusable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::areElementwiseOpsFusable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&#160;</td>
          <td class="paramname"><em>fusedOperand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if two <code>linalg.generic</code> operations with producer/consumer relationship through <code>fusedOperand</code> can be fused using elementwise op fusion. </p>
<p>Conditions for elementwise fusion of generic operations. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00139">139</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00047">getIndexingMapOfProducerOperandsInCoordinatesOfFusedOp()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00641">mlir::AffineMap::isPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00339">fuseElementwiseOps()</a>.</p>

</div>
</div>
<a id="ac2601c4a3969aaff305c30e389393c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2601c4a3969aaff305c30e389393c91">&#9670;&nbsp;</a></span>areTilesAndTiledDimsAllConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::areTilesAndTiledDimsAllConstant </td>
          <td>(</td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the tiles and the tiled dims are constant. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05045">5045</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01282">mlir::tile()</a>.</p>

</div>
</div>
<a id="a21456d907d447d15a3d719753b782ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21456d907d447d15a3d719753b782ff3">&#9670;&nbsp;</a></span>asShapeWithAnyValueAsDynamic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; mlir::linalg::asShapeWithAnyValueAsDynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ofrs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts OpFoldResults to int64_t shape entries, unconditionally mapping all <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>'s to kDynamic, even if they are arith.constant values. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l04910">4910</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>.</p>

</div>
</div>
<a id="a5ca967d8e0b6ff895d26faaf60a79263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca967d8e0b6ff895d26faaf60a79263">&#9670;&nbsp;</a></span>blockPackMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt; mlir::linalg::blockPackMatmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#ae020263d273fb7b7f80c4970556da5f8">ControlBlockPackMatmulFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlPackMatmul</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack a matmul operation into blocked 4D layout. </p>
<p>Relayout a matmul operation into blocked layout with two levels of subdivision:</p><ul>
<li>major 2D blocks - outer dimensions, consist of minor blocks</li>
<li>minor 2D blocks - inner dimensions, consist of scalar elements</li>
</ul>
<p>A 2D matmul MxNxK gets reshaped into blocked 4D representation as: [MB][NB][mb][nb] += [MB][KB][mb][kb] * [NB][KB][nb][kb] where the (MB, NB, KB) dimensions represent the major blocks, and the (mb, nb, kb) are the minor blocks of their respective original 2D dimensions (M, N, K).</p>
<p>Depending on the initial operands' data layout and the specified packing options, the major blocks dimensions might get transposed e.g., [MB][KB] -&gt; [KB][MB]. The minor blocks can also be transposed e.g., [mb][kb] -&gt; [kb][mb]. Any present batch dimensions remain unchanged. The final result is unpacked back to the original shape.</p>
<p>Return failure if no valid packing options are provided. </p>

<p class="definition">Definition at line <a class="el" href="BlockPackMatmul_8cpp_source.html#l00138">138</a> of file <a class="el" href="BlockPackMatmul_8cpp_source.html">BlockPackMatmul.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00079">mlir::getAsOpFoldResult()</a>, <a class="el" href="Builders_8cpp_source.html#l00276">mlir::Builder::getI64ArrayAttr()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00487">inferContractionDims()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00766">packMatmulGreedily()</a>, <a class="el" href="Builders_8h_source.html#l00410">mlir::OpBuilder::setInsertionPointAfter()</a>, <a class="el" href="BlockPackMatmul_8cpp_source.html#l00089">transposePackedMatmul()</a>, and <a class="el" href="BlockPackMatmul_8cpp_source.html#l00043">validateFullTilesOnDims()</a>.</p>

</div>
</div>
<a id="a73274fcc2e8e228f5f44c6336b96e7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73274fcc2e8e228f5f44c6336b96e7b7">&#9670;&nbsp;</a></span>bufferizeToAllocation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::bufferizeToAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bufferization::AllocTensorOp&#160;</td>
          <td class="paramname"><em>allocTensorOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>insertionPoint</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Materialize a buffer allocation for the given bufferization.alloc_tensor op and lower the op to memref.alloc + memref.tensor_store. </p>
<p>In addition to rewriting the IR, this function returns the newly allocated buffer. The <code>insertionPoint</code> parameter can be used to specify a custom insertion point for the buffer allocation. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00326">326</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00189">createAllocationForTensor()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a72d0ebe64f6077953145c8111cc3d955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d0ebe64f6077953145c8111cc3d955">&#9670;&nbsp;</a></span>bufferizeToAllocation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::bufferizeToAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>insertionPoint</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize the given op with tensor semantics and materialize the result in a newly allocated buffer. </p>
<p>Only bufferizable ops that bufferize to a memory write or have an aliasing <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> (and do not themselves bufferize to an allocation) are supported. They are bufferized using their BufferizableOpInterface implementation.</p>
<p>Selected ops that bufferize to an allocation (or need special handling) are also supported:</p><ul>
<li>tensor.pad</li>
<li>vector.mask</li>
</ul>
<p>This function returns the newly allocated buffer. The <code>insertionPoint</code> parameter can be used to specify a custom insertion point for the buffer allocation. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00476">476</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1linalg.html#a300387e92135ddafe3e8fcb45a1d0f4c">bufferizeToAllocation()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00189">createAllocationForTensor()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00056">createMemcpy()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="PatternMatch_8h_source.html#l00628">mlir::RewriterBase::modifyOpInPlace()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a300387e92135ddafe3e8fcb45a1d0f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300387e92135ddafe3e8fcb45a1d0f4c">&#9670;&nbsp;</a></span>bufferizeToAllocation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::bufferizeToAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp&#160;</td>
          <td class="paramname"><em>padOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>insertionPoint</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Materialize a buffer allocation for the given tensor.pad op and lower the op to linalg.fill/linalg.generic + bufferization.materialize_in_destination. </p>
<p>E.g.:</p>
<p>%0 = tensor.pad low[l] high[h] t ...</p>
<p>is lowered to:</p>
<p>alloc = memref.alloc linalg.fill ... outs(alloc) subview = memref.subview alloc [l] [...] [1] bufferization.materialize_in_destination t in subview %0 = bufferization.to_tensor alloc restrict writable</p>
<p>In addition to rewriting the IR as shown above, this function returns the newly allocated buffer. The <code>insertionPoint</code> parameter can be used to specify a custom insertion point for the buffer allocation. </p>

<p class="reference">Referenced by <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00259">bufferizeToAllocation()</a>.</p>

</div>
</div>
<a id="a2b6184483164da0417ac58d1d5086bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6184483164da0417ac58d1d5086bbc">&#9670;&nbsp;</a></span>bufferizeToAllocation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::bufferizeToAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector::MaskOp&#160;</td>
          <td class="paramname"><em>maskOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>insertionPoint</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Materialize a buffer allocation for the given vector.mask op and bufferize the op, including its region. </p>
<p>E.g.:</p>
<p>%0 = vector.mask { vector.transfer_write v, t : vector&lt;16xf32&gt;, tensor&lt;?xf32&gt; } : vector&lt;16xi1&gt; -&gt; tensor&lt;?xf32&gt;</p>
<p>is lowered to:</p>
<p>alloc = memref.alloc bufferization.materialize_in_destination t in subview vector.mask { vector.transfer_write arg0, alloc : vector&lt;16xf32&gt;, memref&lt;?xf32&gt; } : vector&lt;16xi1&gt; %0 = bufferization.to_tensor alloc restrict writable</p>
<p>In addition to rewriting the IR as shown above, this function returns the newly allocated buffer. The <code>insertionPoint</code> parameter can be used to specify a custom insertion point for the buffer allocation. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00259">259</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1linalg.html#a300387e92135ddafe3e8fcb45a1d0f4c">bufferizeToAllocation()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00628">mlir::RewriterBase::modifyOpInPlace()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="ae6a3be2f9306a873810377797b78bfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a3be2f9306a873810377797b78bfc6">&#9670;&nbsp;</a></span>collapseOpIterationDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1CollapseResult.html">CollapseResult</a> &gt; mlir::linalg::collapseOpIterationDims </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>foldedIterationDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collapses dimensions of linalg.generic/linalg.copy operation. </p>
<p>Implementation of fusion with reshape operation by collapsing dimensions.</p>
<p>A precondition to calling this method is that for each list in <code>foldedIterationDim</code>, the sequence of dimensions is contiguous in domains of all <code>indexing_maps</code> of the <code>linalgOp</code>. This can be checked using <code>areDimSequencePreserved</code> method. When valid, the method also collapses the operands of the op. Returns replacement values of the results of the original <code>linalgOp</code> by inserting reshapes to get back values of compatible types. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01712">1712</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00675">mlir::applyPermutationMap()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01702">createCollapsedOp()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01586">generateCollapsedIndexingRegion()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01531">getOperandReassociation()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">mlir::AffineMap::isProjectedPermutation()</a>, <a class="el" href="Matchers_8h_source.html#l00527">mlir::m_ConstantInt()</a>, <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00036">mlir::Range::offset</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00037">mlir::Range::size</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00038">mlir::Range::stride</a>.</p>

</div>
</div>
<a id="a6cdc3ac4dd00e8808043082728373fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdc3ac4dd00e8808043082728373fd6">&#9670;&nbsp;</a></span>commonPermutationOfPackAndUnPackOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PackOrUnPackTransposeResult mlir::linalg::commonPermutationOfPackAndUnPackOp </td>
          <td>(</td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>packOrUnPackOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>innerPermutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>outerPermutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l04755">4755</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00226">mlir::applyPermutationToVector()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00223">mlir::isPermutationVector()</a>.</p>

</div>
</div>
<a id="aedf3c885687f3ae6238ad0c1106e6af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf3c885687f3ae6238ad0c1106e6af8">&#9670;&nbsp;</a></span>commonVerifierPackAndUnPackOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::linalg::commonVerifierPackAndUnPackOp </td>
          <td>(</td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>packOrUnPack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l04657">4657</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00267">mlir::Operation::emitError()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l04747">innerDimsPos</a>, <a class="el" href="LinalgOps_8cpp_source.html#l04643">isInvalidPackingPosSpecification()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00018">mlir::isZeroInteger()</a>.</p>

</div>
</div>
<a id="aa06c54273304b8d82c1b239db2b7db90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06c54273304b8d82c1b239db2b7db90">&#9670;&nbsp;</a></span>computeAllSliceParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; std::optional&lt; <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a> &gt; &gt; mlir::linalg::computeAllSliceParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>valuesToTile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizeBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>omitPartialTileCheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes SliceParamaters for all <code>valuesToTile</code> of the given <code>linalgOp</code>, assuming <code>linalgOp</code> is being fused into a loop nest. </p>
<p>Calls <code>computeSliceParameters</code> for every individual value.</p>
<p>Note that a constant zero in <code>tileSizes</code> means no tiling at that implicit loop. The number of non-zero values in <code>tileSizes</code> should be equal to the number of values in <code>ivs</code>.</p>
<p>Some of the <code>valuesToTile</code> won't be affected by tiling. For these values, std::nullopt will be returned. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00811">811</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00626">computeSliceParameters()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00743">computeTileOffsets()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00757">computeTileSizes()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00074">isTiled()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00862">makeTiledShapes()</a>.</p>

</div>
</div>
<a id="aa18c5afa193d9ff81a24877f1087fec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18c5afa193d9ff81a24877f1087fec4">&#9670;&nbsp;</a></span>computeContinuousTileSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContinuousTileSizeSpecification.html">ContinuousTileSizeSpecification</a> &gt; mlir::linalg::computeContinuousTileSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>targetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emitAssertions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00156">156</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00517">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Tiling_8cpp_source.html#l00089">emitIsPositiveIndexAssertion()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00959">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="Builders_8cpp_source.html#l00363">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>, <a class="el" href="Builders_8h_source.html#l00654">mlir::ImplicitLocOpBuilder::getLoc()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01274">mlir::affine::makeComposedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00948">mlir::linalg::detail::ContinuousTileSizeSpecificationBase&lt; T &gt;::tileSizes</a>, and <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00950">mlir::linalg::detail::ContinuousTileSizeSpecificationBase&lt; T &gt;::tripCounts</a>.</p>

</div>
</div>
<a id="a8cf886d8eb4668c4b2ad34db3a2d4bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf886d8eb4668c4b2ad34db3a2d4bad">&#9670;&nbsp;</a></span>computeIndexingMapOpInterfacePaddedShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; mlir::linalg::computeIndexingMapOpInterfacePaddedShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>operandToPad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>iterationDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specific helper for Linalg ops. </p>

<p class="definition">Definition at line <a class="el" href="PadTilingInterface_8cpp_source.html#l00199">199</a> of file <a class="el" href="PadTilingInterface_8cpp_source.html">PadTilingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="PadTilingInterface_8cpp_source.html#l00097">computePaddedShape()</a>, <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00036">mlir::Range::offset</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00038">mlir::Range::stride</a>.</p>

</div>
</div>
<a id="af8ef5fd09c3c79a47b8c4732ace79928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ef5fd09c3c79a47b8c4732ace79928">&#9670;&nbsp;</a></span>computeMultiTileSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1MultiSizeSpecification.html">MultiSizeSpecification</a> &gt; mlir::linalg::computeMultiTileSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>targetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>divisor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emitAssertions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits the IR computing the multi-sized tiling specification with two tile sizes not exceeding <code>targetSize</code>, each divisible by <code>sizeDivisor</code>, such that there exist numbers of tiles with these sizes that fully cover the given iteration space <code>dimension</code> of the structured <code>op</code>. </p>
<p>The computation is as follows:</p>
<p>b = originalTripCount floordiv sizeDivisor t = (targetSize + sizeDivisor - 1) floordiv sizeDivisor d = (b + t - 1) floordiv t s = (b floordiv d) * sizeDivisor v = b % d u = d - v</p>
<p>where the tile sizes are <code>s</code> and <code>s</code> + <code>sizeDivisor</code>, and the numbers of the corresponding tiles are <code>u</code> and <code>v</code>, respectively. Alternatively,</p>
<p>s * u + (s + sizeDivisor) * v == original size, where s mod sizeDivisor = 0.</p>
<p>Expects all values to be positive. In some cases with the target tile size sufficiently close to the dimension shape and non-unit divisor, it is impossible to compute such sizes. If <code>emitAssertion</code> is set, also emit the assertion that size computation succeeded.</p>
<p>Returns the specification consisting of both tile values and the number of tiles of each size. </p>

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00262">262</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tiling_8cpp_source.html#l00089">emitIsPositiveIndexAssertion()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00959">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="Builders_8cpp_source.html#l00363">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="Builders_8h_source.html#l00654">mlir::ImplicitLocOpBuilder::getLoc()</a>, <a class="el" href="Builders_8cpp_source.html#l00257">mlir::Builder::getStringAttr()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00940">mlir::linalg::detail::MultiSizeSpecificationBase&lt; T &gt;::lowTileSize</a>, <a class="el" href="AffineOps_8cpp_source.html#l01274">mlir::affine::makeComposedAffineApply()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01372">mlir::affine::makeComposedFoldedMultiResultAffineApply()</a>.</p>

</div>
</div>
<a id="a372334d0c7a18ff500631d618d77c495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372334d0c7a18ff500631d618d77c495">&#9670;&nbsp;</a></span>computePaddedShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::linalg::computePaddedShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a39768b5816332d4970911da09de5cec4">TypedValue</a>&lt; RankedTensorType &gt;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>indexingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>indexingSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to compute the padded shape of the given value <code>v</code> of <code>RankedTensorType</code> given: </p>
<p>Compute the padded shape of the given value <code>v</code> of <code>RankedTensorType</code> given.</p>
<ul>
<li>the <code>indexingSizes</code> as a list of <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>.</li>
<li>an <code>indexingMap</code> that encodes how the padded shape varies with increases in <code>indexingSizes</code>. The implementation iteratively combines increases from contributing using affine.apply operations. The <code>indexingMap</code> + <code>indexingSizes</code> encoding suits StructuredOps and provides a gentle portability path for Linalg-like ops with affine maps. The padded shape is computed by evaluating the maximum accessed index per dimension, which may involve multiplying by constant factors derived from the affine indexing expressions. Currently, only a limited set of projected permuation indexing maps are supported, such as</li>
</ul>
<p>affine_map&lt;(d0, d1, d2) -&gt; (d0, d1)&gt;</p><ul>
<li>affine_map&lt;(d0, d1, d2) -&gt; (d0, d1 + d2)&gt;</li>
<li>affine_map&lt;(d0, d1) -&gt; (d0 * 3 + d1)&gt; In the future, more general interfaces can be devised to encode similar shape evolutions and map between an op and its operands.<ul>
<li><code>indexingSizes</code> a list of <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>.</li>
<li>an <code>indexingMap</code> that encodes how the shape of varies with increases in <code>indexingSizes</code>. The <code>indexingMap</code> encodes how the shape of varies with <code>indexingSizes</code>. The <code>indexingMap</code> + <code>indexingSizes</code> encoding suits StructuredOps. The implementaiton below iteratively combines increases from contributing dimensions using affine.apply operations. The padded shape is computed by evaluating the maximum accessed index per dimension, which may involve multiplying by constant factors derived from the affine indexing expressions. Currently, only a limited set of projected permutation indexing maps are supported, such as</li>
</ul>
</li>
<li>affine_map&lt;(d0, d1, d2) -&gt; (d0, d1)&gt;</li>
<li>affine_map&lt;(d0, d1, d2) -&gt; (d0, d1 + d2)&gt;</li>
<li>affine_map&lt;(d0, d1) -&gt; (d0 * 3 + d1)&gt; In the future, more general interfaces can be devised to encode similar shape evolutions and map between an op and its operands. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="PadTilingInterface_8cpp_source.html#l00097">97</a> of file <a class="el" href="PadTilingInterface_8cpp_source.html">PadTilingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00316">mlir::bindDimsList()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01006">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">mlir::AffineMap::compose()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00104">createFoldedDimOp()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00031">DBGS</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00062">extractConstantMultiplier()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00036">getFullRankPaddingSizes()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">mlir::AffineMap::getSubMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00899">mlir::projectDims()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PadTilingInterface_8cpp_source.html#l00199">computeIndexingMapOpInterfacePaddedShape()</a>.</p>

</div>
</div>
<a id="afc396179b7b2aee5cfef868a42592c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc396179b7b2aee5cfef868a42592c60">&#9670;&nbsp;</a></span>computeSliceParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a> mlir::linalg::computeSliceParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>valueToTile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>subShapeSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>omitPartialTileCheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html" title="A struct containg offsets-sizes-strides arguments of the tiled shape.">SliceParameters</a> for a single <code>valueToTile</code> assuming that its user is being tiled with the given loop bounds <code>lbs</code> and <code>ubs</code> and the tile sizes <code>tileSizes</code>. </p>
<p><code>omitPartialTileCheck</code> controls whether to omit the partial/boundary tile condition check in cases where we statically know that it is unnecessary. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00626">626</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00104">createFoldedDimOp()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00629">mlir::getAffineSymbolExpr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">mlir::AffineMap::getSubMap()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">mlir::AffineMap::inferFromExprList()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00074">isTiled()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01430">mlir::affine::makeComposedFoldedAffineMin()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00156">mlir::linalg::SliceParameters::offsets</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00157">mlir::linalg::SliceParameters::sizes</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00158">mlir::linalg::SliceParameters::strides</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00811">computeAllSliceParameters()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00613">makeTiledShape()</a>.</p>

</div>
</div>
<a id="aa3cdafc77c113c1fa2db8782dc0bdb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3cdafc77c113c1fa2db8782dc0bdb29">&#9670;&nbsp;</a></span>computeStaticContinuousTileSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1StaticContinuousTileSizeSpecification.html">StaticContinuousTileSizeSpecification</a> &gt; mlir::linalg::computeStaticContinuousTileSizes </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>targetSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00106">106</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00948">mlir::linalg::detail::ContinuousTileSizeSpecificationBase&lt; T &gt;::tileSizes</a>, and <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00950">mlir::linalg::detail::ContinuousTileSizeSpecificationBase&lt; T &gt;::tripCounts</a>.</p>

</div>
</div>
<a id="a91c1fb37672289a396df9c95a9b1dd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c1fb37672289a396df9c95a9b1dd0b">&#9670;&nbsp;</a></span>computeStaticMultiTileSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1StaticMultiSizeSpecification.html">StaticMultiSizeSpecification</a> &gt; mlir::linalg::computeStaticMultiTileSizes </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>targetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00236">236</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00940">mlir::linalg::detail::MultiSizeSpecificationBase&lt; T &gt;::highTileSize</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00942">mlir::linalg::detail::MultiSizeSpecificationBase&lt; T &gt;::highTripCount</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00940">mlir::linalg::detail::MultiSizeSpecificationBase&lt; T &gt;::lowTileSize</a>, and <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00942">mlir::linalg::detail::MultiSizeSpecificationBase&lt; T &gt;::lowTripCount</a>.</p>

</div>
</div>
<a id="a358e4f52f7be98a79c9189eb82a42eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358e4f52f7be98a79c9189eb82a42eef">&#9670;&nbsp;</a></span>computeTileOffsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::linalg::computeTileOffsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes tile offsets, given a list of loop <code>ivs</code> and <code>tileSizes</code>. </p>
<p>In case a tile size is zero (i.e., no tiling), the corresponding offset is also zero. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00743">743</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00074">isTiled()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00018">mlir::isZeroInteger()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00811">computeAllSliceParameters()</a>.</p>

</div>
</div>
<a id="a29aed62cd711098f063d5a628905c074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29aed62cd711098f063d5a628905c074">&#9670;&nbsp;</a></span>computeTileSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::linalg::computeTileSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizeBounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes tile sizes, given a list of <code>tileSizes</code> and dimension sizes (<code>sizeBounds</code>). </p>
<p>In case a tile size is zero (i.e., no tiling), the corresponding result size is the corresponding value from <code>sizeBounds</code>. Note: The returned tile sizes are closed intervals. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00757">757</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00619">mlir::getAffineDimExpr()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00074">isTiled()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00018">mlir::isZeroInteger()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00811">computeAllSliceParameters()</a>.</p>

</div>
</div>
<a id="a4f8ea0aae80d24eeffa3fef8f1f08c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8ea0aae80d24eeffa3fef8f1f08c43">&#9670;&nbsp;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the vector that is the concatenation of <code>a</code> and <code>b</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02454">2454</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00362">convertOperationImpl()</a>, <a class="el" href="Simplex_8cpp_source.html#l01498">mlir::presburger::Simplex::makeProduct()</a>, and <a class="el" href="Namespace_8h_source.html#l00120">mlir::Namespace::newName()</a>.</p>

</div>
</div>
<a id="a88359f69353831d971485ff6b6b86dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88359f69353831d971485ff6b6b86dc1">&#9670;&nbsp;</a></span>copyToGPUPrivateMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::copyToGPUPrivateMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normal copy to between src and dst. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00504">504</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00024">mlir::Value::getLoc()</a>.</p>

</div>
</div>
<a id="a72fb3984f986840e0dc914c1ab90dc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fb3984f986840e0dc914c1ab90dc3b">&#9670;&nbsp;</a></span>copyToWorkgroupMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::copyToWorkgroupMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create Memref copy operations and add gpu barrier guards before and after the copy operation to ensure data integrity. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00487">487</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, and <a class="el" href="Value_8cpp_source.html#l00024">mlir::Value::getLoc()</a>.</p>

</div>
</div>
<a id="a3f801aa72135899ae36567a9c78c5b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f801aa72135899ae36567a9c78c5b3b">&#9670;&nbsp;</a></span>createAdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::createAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00031">31</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a503baeef1328177c20af2c28710f0066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503baeef1328177c20af2c28710f0066">&#9670;&nbsp;</a></span>createAllReduceForResultsWithoutPartialShardings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::linalg::createAllReduceForResultsWithoutPartialShardings </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>unshardedOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a9f513853f0b1d301ba8269c1d38a2a16">GridAxis</a> &gt;&#160;</td>
          <td class="paramname"><em>opReductionGridAxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4c4ef4fd46eecd339c2489be75f16729">Sharding</a> &gt;&#160;</td>
          <td class="paramname"><em>resultShardings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>partitionMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00188">188</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00086">getReductionKindOfLinalgOp()</a>, <a class="el" href="IRMapping_8h_source.html#l00072">mlir::IRMapping::lookup()</a>, and <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00204">partitionLinalgOpWithShardedReduction()</a>.</p>

</div>
</div>
<a id="a491060ab8a250d42c9650c00ef3fc571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491060ab8a250d42c9650c00ef3fc571">&#9670;&nbsp;</a></span>createDestinationPassingStyleInitOperand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::createDestinationPassingStyleInitOperand </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>operandNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>partitionedOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a9f513853f0b1d301ba8269c1d38a2a16">GridAxis</a> &gt;&#160;</td>
          <td class="paramname"><em>reductionGridAxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1linalg.html#a5f4c3fb63365bf26fe671663cd4d6d57">GridOp</a>&#160;</td>
          <td class="paramname"><em>gridOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00126">126</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="Shard_2Transforms_2Transforms_8cpp_source.html#l00228">mlir::shard::createProcessLinearIndex()</a>, <a class="el" href="Builders_8cpp_source.html#l00052">mlir::Builder::getI1Type()</a>, <a class="el" href="Builders_8h_source.html#l00654">mlir::ImplicitLocOpBuilder::getLoc()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00070">mlir::tensor::getMixedSizes()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02726">mlir::arith::getNeutralElement()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00288">mlir::matchReduction()</a>, and <a class="el" href="Builders_8h_source.html#l00434">mlir::OpBuilder::setInsertionPointToEnd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00172">createDestinationPassingStyleInitOperands()</a>.</p>

</div>
</div>
<a id="a68d07489064352e1b6957afc5ecfd575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d07489064352e1b6957afc5ecfd575">&#9670;&nbsp;</a></span>createDestinationPassingStyleInitOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; mlir::linalg::createDestinationPassingStyleInitOperands </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1linalg.html#a5f4c3fb63365bf26fe671663cd4d6d57">GridOp</a>&#160;</td>
          <td class="paramname"><em>gridOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>partitionedOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a9f513853f0b1d301ba8269c1d38a2a16">GridAxis</a> &gt;&#160;</td>
          <td class="paramname"><em>reductionGridAxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>partitionMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00172">172</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00126">createDestinationPassingStyleInitOperand()</a>, and <a class="el" href="IRMapping_8h_source.html#l00072">mlir::IRMapping::lookup()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00204">partitionLinalgOpWithShardedReduction()</a>.</p>

</div>
</div>
<a id="a6dac633b692c130881f315320220fcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dac633b692c130881f315320220fcce">&#9670;&nbsp;</a></span>createFoldedDimOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::linalg::createFoldedDimOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create one memref::DimOp or tensor::DimOp depending on the type of <code>val</code>. </p>
<p>This is a polymorphic convenience function to abstract away the rank and concrete type of <code>val</code>. Asserts that <code>val</code> is a memref or tensor type. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l00104">104</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp_source.html#l00095">createOrFoldDimOp()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PadTilingInterface_8cpp_source.html#l00097">computePaddedShape()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00626">computeSliceParameters()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00103">fuse()</a>.</p>

</div>
</div>
<a id="a80e6451d40cef8244025d03bc83cfdad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e6451d40cef8244025d03bc83cfdad">&#9670;&nbsp;</a></span>createMul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::createMul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>accType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00039">39</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00238">mlir::convertScalarToDtype()</a>.</p>

</div>
</div>
<a id="aaf73bb051fb347d6519cdcb174ba230e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf73bb051fb347d6519cdcb174ba230e">&#9670;&nbsp;</a></span>createOrFoldDimOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::createOrFoldDimOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create one memref::DimOp or tensor::DimOp depending on the type of <code>val</code>. </p>
<p>This is a polymorphic convenience function to abstract away the rank and concrete type of <code>val</code>. Asserts that <code>val</code> is a memref or tensor type. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l00095">95</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00517">mlir::OpBuilder::createOrFold()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00185">concatSizesFromInputs()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00104">createFoldedDimOp()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00412">mlir::sparse_tensor::sizesFromSrc()</a>.</p>

</div>
</div>
<a id="a487d4430e8217b1dabc50cb28bb93342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487d4430e8217b1dabc50cb28bb93342">&#9670;&nbsp;</a></span>deallocateGPUPrivateMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::deallocateGPUPrivateMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In case of GPU private memory there is no need to deallocate since the memory is freed when going outside of the scope. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00512">512</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

</div>
</div>
<a id="ad6babd80190e8df26f441fca7d2fbe31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6babd80190e8df26f441fca7d2fbe31">&#9670;&nbsp;</a></span>deallocateWorkgroupMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::deallocateWorkgroupMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In case of GPU group memory there is no need to deallocate. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00480">480</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

</div>
</div>
<a id="a22cf4ae6a6c9f8d82a3d3f13e55100c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cf4ae6a6c9f8d82a3d3f13e55100c3">&#9670;&nbsp;</a></span>decomposeWinogradFilterTransformOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::decomposeWinogradFilterTransformOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::WinogradFilterTransformOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite linalg.winograd_filter_transform. </p>
<p>The data layout of the filter is FHWC. The transformation matrix is 2-dimension. We need to extract H x W from FHWC first. We generate 2 levels of loops to iterate on F and C. After the rewriting, we get</p>
<p>scf.for f = lo_f to hi_f step 1 scf.for c = lo_c to hi_c step 1 extracted = extract filter&lt;h x w&gt; from filter&lt;f x h x w x c&gt; ret = linalg.matmul G, extracted ret = linalg.matmul ret, GT inserted = insert ret into filter&lt;h x w x c x f&gt; </p>

<p class="definition">Definition at line <a class="el" href="WinogradConv2D_8cpp_source.html#l01192">1192</a> of file <a class="el" href="WinogradConv2D_8cpp_source.html">WinogradConv2D.cpp</a>.</p>

</div>
</div>
<a id="ae75908ded36f97719f77c8b56ed859ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75908ded36f97719f77c8b56ed859ef">&#9670;&nbsp;</a></span>decomposeWinogradInputTransformOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::decomposeWinogradInputTransformOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::WinogradInputTransformOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite linalg.winograd_input_transform. </p>
<p>The data layout of the input is NHWC. The transformation matrix is 2-dimension. We need to extract H x W from NHWC first. We generate 4 levels of loops to iterate on N, C, tileH, and tileW. After the rewriting, we get</p>
<p>scf.for h = 0 to tileH step 1 scf.for w = 0 to tileW step 1 scf.for n = 0 to N step 1 scf.for c = 0 to C step 1 extracted = extract extracted&lt;alphaH x alphaW&gt; from input&lt;N x H x W x C&gt; at [n, (h x m), (w x m), c] ret = linalg.matmul BT, extracted ret = linalg.matmul ret, B inserted = insert ret&lt;alphaH x alphaW&gt; into output&lt;alphaH x alphaW x tileH x tileW x N x C&gt; at [0, 0, h, w, n, c] </p>

<p class="definition">Definition at line <a class="el" href="WinogradConv2D_8cpp_source.html#l01198">1198</a> of file <a class="el" href="WinogradConv2D_8cpp_source.html">WinogradConv2D.cpp</a>.</p>

</div>
</div>
<a id="a49f2f00a0e17dbbec5198127ee3151ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f2f00a0e17dbbec5198127ee3151ba">&#9670;&nbsp;</a></span>decomposeWinogradOutputTransformOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::decomposeWinogradOutputTransformOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::WinogradOutputTransformOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite linalg.winograd_output_transform. </p>
<p>The data layout of the output is HWNF. The transformation matrix is 2-dimension. We need to extract H x W from HWNF first. We generate 4 levels of loops to iterate on N, F, tileH, and tileW. After the transformation, we get</p>
<p>scf.for h = 0 to tileH step 1 scf.for w = 0 to tileW step 1 scf.for n = 0 to N step 1 scf.for f = 0 to F step 1 extracted = extract extracted&lt;alphaH x alphaW&gt; from input&lt;alphaH x alphaW x tileH x tileW x N x F&gt; at [0, 0, h, w, n, f] ret = linalg.matmul AT, extracted ret = linalg.matmul ret, A inserted = insert ret&lt;alphaH x alphaW&gt; into output&lt;N x H x W x F&gt; at [n, (h x m), (w x m), f] </p>

<p class="definition">Definition at line <a class="el" href="WinogradConv2D_8cpp_source.html#l01204">1204</a> of file <a class="el" href="WinogradConv2D_8cpp_source.html">WinogradConv2D.cpp</a>.</p>

</div>
</div>
<a id="a88467664ee2ebeb70bc1a2c3d5876a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88467664ee2ebeb70bc1a2c3d5876a9c">&#9670;&nbsp;</a></span>deduplicateOperandsAndRemoveDeadResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; linalg::GenericOp &gt; mlir::linalg::deduplicateOperandsAndRemoveDeadResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::GenericOp&#160;</td>
          <td class="paramname"><em>genericOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeOutputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to deduplicate operands and remove dead results of <code>linalg.generic</code> operations. </p>
<p>This is effectively DCE for a linalg.generic op. If there is deduplication of operands orremoval of results, replaces the <code>genericOp</code> with a new op and returns it. Returns the same operation if there is no deduplication/removal. </p>

<p class="definition">Definition at line <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00231">231</a> of file <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html">EraseUnusedOperandsAndResults.cpp</a>.</p>

<p class="reference">References <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00063">deduplicateInputOperands()</a>, <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00106">deduplicateOutputOperands()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="Builders_8cpp_source.html#l00313">mlir::Builder::getAffineMapArrayAttr()</a>, <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00172">populateOpPayload()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>.</p>

</div>
</div>
<a id="a5b6d6c0f10b756281634aebb9f69d5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6d6c0f10b756281634aebb9f69d5dd">&#9670;&nbsp;</a></span>dropUnitDims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1DropUnitDimsResult.html">DropUnitDimsResult</a> &gt; mlir::linalg::dropUnitDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>genericOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00539">539</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="DropUnitDims_8cpp_source.html#l00384">dropUnitDims()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00227">replaceUnitDimIndexOps()</a>.</p>

</div>
</div>
<a id="ac980878e4ea40184d0a2183288fd0f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac980878e4ea40184d0a2183288fd0f61">&#9670;&nbsp;</a></span>dropUnitDims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1DropUnitDimsResult.html">DropUnitDimsResult</a> &gt; mlir::linalg::dropUnitDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexingMapOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a2f38324ff992b8ceebc6e3f0c01a57d1">DroppedUnitDimsBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>droppedUnitDimsBuilder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00384">384</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="DropUnitDims_8cpp_source.html#l00278">collapseValue()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00829">mlir::concatAffineMaps()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00334">dropUnitExtentFromOperandMetadata()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00251">expandValue()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00643">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00619">mlir::getAffineDimExpr()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00496">mlir::AffineMap::replaceDimsAndSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DropUnitDims_8cpp_source.html#l00539">dropUnitDims()</a>.</p>

</div>
</div>
<a id="a956959faad992424aaa215510e50e618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956959faad992424aaa215510e50e618">&#9670;&nbsp;</a></span>extractOrIdentityMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::linalg::extractOrIdentityMap </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maybeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code><a class="el" href="namespacemlir.html#ab4871db68c59a176135e0e35a3625e73" title="Helper method that injects context only if needed, this helps unify some of the attribute constructio...">maybeMap.get()</a></code> if <code>maybeMap</code> is set, otherwise returns the symbol-less identity map of <code>rank</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02434">2434</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>.</p>

</div>
</div>
<a id="a4ceec493e0b40673125a0402c3cf78e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ceec493e0b40673125a0402c3cf78e4">&#9670;&nbsp;</a></span>fuseElementwiseOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html">mlir::linalg::ElementwiseOpFusionResult</a> &gt; mlir::linalg::fuseElementwiseOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&#160;</td>
          <td class="paramname"><em>fusedOperand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the results of the producer that have uses outside of the consumer, after the fusion.</p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00339">339</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00139">areElementwiseOpsFusable()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">mlir::AffineMap::compose()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00562">mlir::linalg::ElementwiseOpFusionResult::fusedOp</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00218">generateFusedElementwiseOpRegion()</a>, <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00313">mlir::Builder::getAffineMapArrayAttr()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00047">getIndexingMapOfProducerOperandsInCoordinatesOfFusedOp()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00112">getPreservedProducerResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00563">mlir::linalg::ElementwiseOpFusionResult::replacements</a>.</p>

</div>
</div>
<a id="a13c5cf1a47f0bf5b6405224845ff8d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c5cf1a47f0bf5b6405224845ff8d83">&#9670;&nbsp;</a></span>fuseProducerOfTensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt; mlir::linalg::fuseProducerOfTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>consumerOpOperand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implements the fusion part of the "tileAndFuse on tensors" transformation and thus requires the <code>consumerOpOperand</code> to be a <code>extract_slice</code> op (generally obtained by applying the tiling transformation). </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00217">217</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00192">getProducerOfTensor()</a>.</p>

</div>
</div>
<a id="aa7195637d33a1cf8133bc32a219adf6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7195637d33a1cf8133bc32a219adf6b">&#9670;&nbsp;</a></span>fuseProducerOfTensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt; mlir::linalg::fuseProducerOfTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>producerOpResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>consumerOpOperand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implements the fusion part of the "tileAndFuse on tensors" transformation and thus requires the <code>consumerOpOperand</code> to be a <code>extract_slice</code> op (generally obtained by applying the tiling transformation). </p>
<p>Assumes <code>producerOfTensor</code> is a Linalg op that produces <code>consumerOpOperand</code>. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00229">229</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00095">mlir::tensor::dropGivenUnitDims()</a>, <a class="el" href="Fusion_8cpp_source.html#l00103">fuse()</a>, <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Value_8h_source.html#l00456">mlir::OpResult::getOwner()</a>, <a class="el" href="Value_8cpp_source.html#l00046">mlir::Value::getParentBlock()</a>, <a class="el" href="Value_8h_source.html#l00459">mlir::OpResult::getResultNumber()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="UseDefLists_8h_source.html#l00163">mlir::IROperand&lt; DerivedT, IRValueT &gt;::set()</a>, and <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a7fc28f76b6a2798611e0008260ae388d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc28f76b6a2798611e0008260ae388d">&#9670;&nbsp;</a></span>generalizeNamedOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; GenericOp &gt; mlir::linalg::generalizeNamedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a GenericOp from the given named operation <code>linalgOp</code> and replace the given <code>linalgOp</code>. </p>
<p>Return failure if <code>linalgOp</code> is a GenericOp or misses a region builder. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00048">48</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Generalization_8cpp_source.html#l00033">generalizeNamedOpPrecondition()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00376">mlir::RewriterBase::inlineRegionBefore()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00766">packMatmulGreedily()</a>, and <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01601">mlir::linalg::LinalgGeneralizationPattern::returningMatchAndRewrite()</a>.</p>

</div>
</div>
<a id="a754ec5c5960c640563ddcd9727b77d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754ec5c5960c640563ddcd9727b77d87">&#9670;&nbsp;</a></span>generateLibraryCallName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::linalg::generateLibraryCallName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name mangled library call name to disambiguate between different overloads at the C level. </p>
<p>The name mangling scheme is basic and uses MLIR type names:</p><ol type="1">
<li>form a string which is the concatenation of the linalg op name with all the operand type names, separate by underscores;</li>
<li>drop the <code>linalg.</code> prefix, and the <code>&lt;</code>, <code>&gt;</code>, <code>?</code> symbols from the type. Assumes <code>op</code> is a LinalgOp.</li>
</ol>
<p>Examples:</p>
<ol type="1">
<li>linalg.fill(f, A) : f32, memref&lt;f32&gt; name mangles into <code>linalg_fill_f32_viewf32</code></li>
<li>linalg.dot A, B, C : (memref&lt;?xf32, stride_specification&gt;, memref&lt;?xf32, stride_specification&gt;, memref&lt;f32&gt;) name mangles into <code>linalg_dot_viewxf32_viewxf32_viewf32</code></li>
<li>linalg.matmul(...) : memref&lt;?x?xf32, stride_specification&gt;, memref&lt;?x?xf32, stride_specification&gt;, memref&lt;?x?xf32, stride_specification&gt; name mangles into <code>linalg_matmul_viewxxf32_viewxxf32_viewxxf32</code> </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02495">2495</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp_source.html#l02462">appendMangledType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00512">mlir::Operation::getAttrs()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00397">mlir::Operation::getOperandTypes()</a>, and <a class="el" href="OperationSupport_8h_source.html#l00473">mlir::OperationName::getStringRef()</a>.</p>

</div>
</div>
<a id="a330275ee0b8daf6e838a8bce3d70a331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330275ee0b8daf6e838a8bce3d70a331">&#9670;&nbsp;</a></span>generateParallelLoopNest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::linalg::generateParallelLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt;&#160;</td>
          <td class="paramname"><em>iteratorTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">linalg::ProcInfo</a> &gt;&#160;</td>
          <td class="paramname"><em>procInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ivStorage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a loop nest consisting of scf.parallel and scf.for, depending on the <code>iteratorTypes. </code></p>
<p>Consecutive parallel loops create a single scf.parallel operation; each sequential loop creates a new scf.for operation. The body of the innermost loop is populated by <code>bodyBuilderFn</code> that accepts a range of induction variables for all loops. <code>ivStorage</code> is used to store the partial list of induction variables. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00431">431</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00311">mlir::ArithBuilder::_and()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00697">mlir::scf::buildLoopNest()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00312">mlir::linalg::ProcInfo::distributionMethod</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00235">isParallelIterator()</a>, <a class="el" href="MlirTblgenMain_8cpp_source.html#l00027">None</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00334">mlir::ArithBuilder::slt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>.</p>

</div>
</div>
<a id="a61f099443ddafc2ff4b45a9788b324d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f099443ddafc2ff4b45a9788b324d0">&#9670;&nbsp;</a></span>getArityGroupAndKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ArityGroupAndKind mlir::linalg::getArityGroupAndKind </td>
          <td>(</td>
          <td class="paramtype">ElementwiseKind&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l04311">4311</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp.html#a28955b1aca39affb65f8316b45796bfa">kind</a>.</p>

</div>
</div>
<a id="a3a87e6c5c97ba109109f352407d323b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a87e6c5c97ba109109f352407d323b3">&#9670;&nbsp;</a></span>getCombinerOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; mlir::linalg::getCombinerOp </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00076">76</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00288">mlir::matchReduction()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00086">getReductionKindOfLinalgOp()</a>.</p>

</div>
</div>
<a id="ae27267a4634c46beba8c9f55c14cdfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27267a4634c46beba8c9f55c14cdfa1">&#9670;&nbsp;</a></span>getCombinerOpKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; vector::CombiningKind &gt; mlir::linalg::getCombinerOpKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>combinerOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return vector::CombiningKind for the given op. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00604">604</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="SparseTensorIterator_8cpp_source.html#l00037">MINUI</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00668">buildMultiDimReduce()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02031">reductionPreconditions()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l02317">vectorizeConvOpPrecondition()</a>.</p>

</div>
</div>
<a id="ab90b3b862ac8de64b21095282e64305c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90b3b862ac8de64b21095282e64305c">&#9670;&nbsp;</a></span>getConvolvedIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::getConvolvedIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>oIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>fIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00069">69</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01274">mlir::affine::makeComposedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00078">rewriteInIm2Col()</a>.</p>

</div>
</div>
<a id="a990df5d31f0a65352b97528ace830ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990df5d31f0a65352b97528ace830ad2">&#9670;&nbsp;</a></span>getDimAndTileMappingImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt;int64_t, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; mlir::linalg::getDimAndTileMappingImpl </td>
          <td>(</td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l04599">4599</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

</div>
</div>
<a id="acc482eff5fffe862c02f038c2a9d20f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc482eff5fffe862c02f038c2a9d20f9">&#9670;&nbsp;</a></span>getFmrFromWinogradConv2DFmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int64_t, int64_t &gt; mlir::linalg::getFmrFromWinogradConv2DFmr </td>
          <td>(</td>
          <td class="paramtype">WinogradConv2DFmr&#160;</td>
          <td class="paramname"><em>fmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given WinogradConv2DFmr enumeration value to a pair of m and r parameters. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l03737">3737</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

</div>
</div>
<a id="affb58b5d5caada44bf94cd80eb843637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb58b5d5caada44bf94cd80eb843637">&#9670;&nbsp;</a></span>getGrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacemlir_1_1linalg.html#a5f4c3fb63365bf26fe671663cd4d6d57">GridOp</a> mlir::linalg::getGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4c4ef4fd46eecd339c2489be75f16729">Sharding</a> &gt;&#160;</td>
          <td class="paramname"><em>operandShardings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4c4ef4fd46eecd339c2489be75f16729">Sharding</a> &gt;&#160;</td>
          <td class="paramname"><em>resultShardings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> &amp;&#160;</td>
          <td class="paramname"><em>symbolTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00100">100</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="ShardOps_8h_source.html#l00121">mlir::shard::getGrid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00204">partitionLinalgOpWithShardedReduction()</a>.</p>

</div>
</div>
<a id="ae61503376ad6b88f0c35f8ce358dbc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61503376ad6b88f0c35f8ce358dbc9e">&#9670;&nbsp;</a></span>getLinalgTilingCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> mlir::linalg::getLinalgTilingCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalization patterns relevant to apply after tiling patterns. </p>
<p>These are applied automatically by the tiling pass but need to be applied manually when tiling is called programmatically. </p>

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00851">851</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, and <a class="el" href="Tiling_8cpp_source.html#l00857">populateLinalgTilingCanonicalizationPatterns()</a>.</p>

</div>
</div>
<a id="ace20474dce44d818ee4be3dabe7b4214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace20474dce44d818ee4be3dabe7b4214">&#9670;&nbsp;</a></span>getMixedTilesImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; mlir::linalg::getMixedTilesImpl </td>
          <td>(</td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l04614">4614</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00107">mlir::Builder::getI64IntegerAttr()</a>.</p>

</div>
</div>
<a id="aa0e0dc6ea28e24238e24a08da62df847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e0dc6ea28e24238e24a08da62df847">&#9670;&nbsp;</a></span>getNewMixedTileSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; mlir::linalg::getNewMixedTileSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>newPackedTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedTiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l04555">4555</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>, <a class="el" href="Builders_8cpp_source.html#l00050">mlir::Builder::getIndexType()</a>, <a class="el" href="Builders_8cpp_source.html#l00223">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="Traits_8cpp_source.html#l00117">getShape()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01282">mlir::tile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l05275">mlir::linalg::FoldTensorCastPackOp::matchAndRewrite()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l05591">mlir::linalg::FoldTensorCastUnPackOp::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="af36b73b6c38d09eef01a3ab1bde4438f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36b73b6c38d09eef01a3ab1bde4438f">&#9670;&nbsp;</a></span>getPackedOuterShapeWithoutTransposition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy , typename  = std::enable_if_t&lt;std::is_same_v&lt;OpTy, linalg::PackOp&gt; ||                                      std::is_same_v&lt;OpTy, linalg::UnPackOp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; mlir::linalg::getPackedOuterShapeWithoutTransposition </td>
          <td>(</td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>packOrUnPack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the outer shape in the packed domain before applying the transposition. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l04527">4527</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00226">mlir::applyPermutationToVector()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00206">mlir::invertPermutationVector()</a>.</p>

</div>
</div>
<a id="a0be24276582fa9397d22611b0c2eb7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be24276582fa9397d22611b0c2eb7e2">&#9670;&nbsp;</a></span>getPackedOuterShapeWithoutTransposition&lt; PackOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; <a class="el" href="namespacemlir_1_1linalg.html#af36b73b6c38d09eef01a3ab1bde4438f">mlir::linalg::getPackedOuterShapeWithoutTransposition</a>&lt; PackOp &gt; </td>
          <td>(</td>
          <td class="paramtype">PackOp&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0e0bcac8732b719caf9a733c3713f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e0bcac8732b719caf9a733c3713f1b">&#9670;&nbsp;</a></span>getPackedOuterShapeWithoutTransposition&lt; UnPackOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; <a class="el" href="namespacemlir_1_1linalg.html#af36b73b6c38d09eef01a3ab1bde4438f">mlir::linalg::getPackedOuterShapeWithoutTransposition</a>&lt; UnPackOp &gt; </td>
          <td>(</td>
          <td class="paramtype">UnPackOp&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c34dd63bd77acc711bdf98d6e2c7b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c34dd63bd77acc711bdf98d6e2c7b75">&#9670;&nbsp;</a></span>getPackInverseDestPerm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; mlir::linalg::getPackInverseDestPerm </td>
          <td>(</td>
          <td class="paramtype">linalg::PackOp&#160;</td>
          <td class="paramname"><em>packOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shell function to compute the Destination Permutation of PackOp This function uses the helper function <code>computePackUnPackPerm</code> to get the permutation vector. </p>
<p>Only major difference between UnPack and Pack is that packOp uses destination rank whereas unpack Uses source rank. </p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01535">getTiledPackShape()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00219">lowerPack()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01765">vectorizeAsTensorPackOp()</a>.</p>

</div>
</div>
<a id="a8880fcb816f23c0198e5c6153cc57dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8880fcb816f23c0198e5c6153cc57dcf">&#9670;&nbsp;</a></span>getPackInverseDestPerm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; mlir::linalg::getPackInverseDestPerm </td>
          <td>(</td>
          <td class="paramtype">PackOp&#160;</td>
          <td class="paramname"><em>packOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00174">174</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00150">computePackUnPackPerm()</a>.</p>

</div>
</div>
<a id="a347ae9bce651afd1c1a37679c4127e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347ae9bce651afd1c1a37679c4127e5e">&#9670;&nbsp;</a></span>getPackOpResultTypeShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; mlir::linalg::getPackOpResultTypeShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sourceShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>innerTileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>innerDimsPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>outerDimsPerm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for PackOp::{getResultShape,inferPackedType}. </p>
<p>Returns the shape of the packed type. Having a shared helper helps implement these two methods in a way that ensures that they agree on which dimensions are dynamic. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l04925">4925</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00226">mlir::applyPermutationToVector()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l04747">innerDimsPos</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l04749">outerDimsPerm</a>.</p>

</div>
</div>
<a id="a4f70173e3ee102c2077ef5cdf5908001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f70173e3ee102c2077ef5cdf5908001">&#9670;&nbsp;</a></span>getPreservedProducerResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallDenseSet&lt; int &gt; mlir::linalg::getPreservedProducerResults </td>
          <td>(</td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&#160;</td>
          <td class="paramname"><em>fusedOperand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a set of indices of the producer's results which would be preserved after the fusion. </p>
<ul>
<li>There is a chance that the implementation of the transformation does not agree with the result of this method. This function gives a prediction based on an optimized fusion. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00112">112</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00079">isOpOperandCanBeDroppedAfterFusedLinalgs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00339">fuseElementwiseOps()</a>.</p>

</div>
</div>
<a id="a6a3c6ebbcb16507e55a2f5c07542b312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3c6ebbcb16507e55a2f5c07542b312">&#9670;&nbsp;</a></span>getPrunedAttributeList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a>&gt; mlir::linalg::getPrunedAttributeList </td>
          <td>(</td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an attribute list that excludes pre-defined attributes. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00385">385</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="NamedOpConversions_8cpp_source.html#l00036">matchAndReplaceDepthwiseConv()</a>.</p>

</div>
</div>
<a id="a6c303f22e35937f101dc36b676ef8861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c303f22e35937f101dc36b676ef8861">&#9670;&nbsp;</a></span>getReassociationMapForFoldingUnitDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; &gt; mlir::linalg::getReassociationMapForFoldingUnitDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedSizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the reassociation maps to fold the result of a extract_slice (or source of a insert_slice) operation with given offsets, and sizes to its rank-reduced version. </p>
<p>This is only done for the cases where the size is 1 and offset is 0. Strictly speaking the offset 0 is not required in general, but non-zero offsets are not handled by SPIR-V backend at this point (and potentially cannot be handled). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00920">920</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>.</p>

</div>
</div>
<a id="a351f651dd2a55b2a452b56d68c2e2c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351f651dd2a55b2a452b56d68c2e2c4c">&#9670;&nbsp;</a></span>getReductionKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacemlir_1_1linalg.html#a5dc368615dd2afa818f751044efd890c">ReductionKind</a> mlir::linalg::getReductionKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00046">46</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00086">getReductionKindOfLinalgOp()</a>.</p>

</div>
</div>
<a id="ada28e3e4bc6c8c677652c60e01bf2b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada28e3e4bc6c8c677652c60e01bf2b6a">&#9670;&nbsp;</a></span>getReductionKindOfLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacemlir_1_1linalg.html#a5dc368615dd2afa818f751044efd890c">ReductionKind</a> mlir::linalg::getReductionKindOfLinalgOp </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00086">86</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00076">getCombinerOp()</a>, and <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00046">getReductionKind()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00188">createAllReduceForResultsWithoutPartialShardings()</a>.</p>

</div>
</div>
<a id="a281819e7457a7c85a98d5f2ee490b89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281819e7457a7c85a98d5f2ee490b89c">&#9670;&nbsp;</a></span>getStaticTilesImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; mlir::linalg::getStaticTilesImpl </td>
          <td>(</td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l04630">4630</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00070">mlir::dispatchIndexOpFoldResults()</a>.</p>

</div>
</div>
<a id="af2da35587b12f700693b151c166fee34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2da35587b12f700693b151c166fee34">&#9670;&nbsp;</a></span>getTensorOutputTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; mlir::linalg::getTensorOutputTypes </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of tensor output types produced when the given structured operation <code>op</code> is applied to the given <code>operands</code>. </p>
<p>Note that <code>operands</code> are not necessarily the actual operands of <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00773">773</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="aa9d51592527f88974d4540b6dd73a59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d51592527f88974d4540b6dd73a59d">&#9670;&nbsp;</a></span>getUnPackInverseSrcPerm() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; mlir::linalg::getUnPackInverseSrcPerm </td>
          <td>(</td>
          <td class="paramtype">linalg::UnPackOp&#160;</td>
          <td class="paramname"><em>unpackOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shell function to compute the Source Permutation of unPackOp. </p>
<p>This function, like the getPackInverseDestPerm uses the helper function computePackUnPackPerm` to get the permutation vector. Only major difference between UnPack and Pack is that packOp uses destination rank whereas unpack Uses source rank. </p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00354">lowerUnPack()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01891">vectorizeAsTensorUnpackOp()</a>.</p>

</div>
</div>
<a id="a8c342405201492a414de9f5804310f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c342405201492a414de9f5804310f0b">&#9670;&nbsp;</a></span>getUnPackInverseSrcPerm() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; mlir::linalg::getUnPackInverseSrcPerm </td>
          <td>(</td>
          <td class="paramtype">linalg::UnPackOp&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PackingMetadata &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shell function to compute the Source rank permutation for unpackOp Unpack requires some packing metadata data information, so created another function where this value is passed by reference. </p>

</div>
</div>
<a id="a788b113d5f6e96cc0d7753009f759ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788b113d5f6e96cc0d7753009f759ef3">&#9670;&nbsp;</a></span>getUnPackInverseSrcPerm() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; mlir::linalg::getUnPackInverseSrcPerm </td>
          <td>(</td>
          <td class="paramtype">UnPackOp&#160;</td>
          <td class="paramname"><em>unpackOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00185">185</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00190">getUnPackInverseSrcPerm()</a>.</p>

</div>
</div>
<a id="ac0c0bfe9542727e64fb90f729f53657c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c0bfe9542727e64fb90f729f53657c">&#9670;&nbsp;</a></span>getUnPackInverseSrcPerm() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; mlir::linalg::getUnPackInverseSrcPerm </td>
          <td>(</td>
          <td class="paramtype">UnPackOp&#160;</td>
          <td class="paramname"><em>unpackOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PackingMetadata &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00190">190</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00150">computePackUnPackPerm()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00185">getUnPackInverseSrcPerm()</a>.</p>

</div>
</div>
<a id="ae474be1b8e656c231ec447b79d2d5e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae474be1b8e656c231ec447b79d2d5e8d">&#9670;&nbsp;</a></span>getWinogradConv2DFmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; WinogradConv2DFmr &gt; mlir::linalg::getWinogradConv2DFmr </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given <code>m</code> and <code>r</code> parameters to a WinogradConv2DFmr enumeration value. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l03727">3727</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

</div>
</div>
<a id="ab874160ec1bdc15b5c867c4799391a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab874160ec1bdc15b5c867c4799391a03">&#9670;&nbsp;</a></span>hasAllOneValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::linalg::hasAllOneValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00026">26</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00078">rewriteInIm2Col()</a>.</p>

</div>
</div>
<a id="a5473845890c7e81fc544f7bfce900d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5473845890c7e81fc544f7bfce900d81">&#9670;&nbsp;</a></span>hasOnlyScalarElementwiseOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::hasOnlyScalarElementwiseOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect whether <code>r</code> has only ConstantOp, ElementwiseMappable and YieldOp. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00206">206</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01397">mlir::OpTrait::hasElementwiseMappableTraits()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00068">mlir::Region::hasOneBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00220">isElementwise()</a>.</p>

</div>
</div>
<a id="abe3de4bb45fd63e06339cb0ba92533fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3de4bb45fd63e06339cb0ba92533fa">&#9670;&nbsp;</a></span>hasSameInnerOuterAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::linalg::hasSameInnerOuterAttribute </td>
          <td>(</td>
          <td class="paramtype">PackOp&#160;</td>
          <td class="paramname"><em>packOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnPackOp&#160;</td>
          <td class="paramname"><em>unPackOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05076">5076</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00216">mlir::isIdentityPermutation()</a>.</p>

</div>
</div>
<a id="a142a09c03dbaa0d795e44f62d4b6b395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142a09c03dbaa0d795e44f62d4b6b395">&#9670;&nbsp;</a></span>hasVectorizationImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::hasVectorizationImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if there's dedicated logic in the Linalg Vectorizer to vectorize this <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a>, false otherwise. </p>
<p>Note that this helper merely implements a very high level check and that the vectorizer also requires various additional pre-conditions to be met for it to work (these are checked by the vectorizer itself). </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l02671">2671</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l02623">vectorizeOpPrecondition()</a>.</p>

</div>
</div>
<a id="aa603d3bdb590cef7749279812bd8e11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa603d3bdb590cef7749279812bd8e11a">&#9670;&nbsp;</a></span>haveSameTiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::linalg::haveSameTiles </td>
          <td>(</td>
          <td class="paramtype">PackOp&#160;</td>
          <td class="paramname"><em>packOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnPackOp&#160;</td>
          <td class="paramname"><em>unPackOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05090">5090</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00165">mlir::isEqualConstantIntOrValue()</a>.</p>

</div>
</div>
<a id="a344a0fa8893af22df90d795e19c1a713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344a0fa8893af22df90d795e19c1a713">&#9670;&nbsp;</a></span>hoistPaddingOnTensors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::hoistPaddingOnTensors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp&#160;</td>
          <td class="paramname"><em>opToHoist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>numLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>transposeVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp &amp;&#160;</td>
          <td class="paramname"><em>hoistedOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; TransposeOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>transposeOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mechanically hoist padding operations on tensors by <code>numLoops</code> into a new, generally larger tensor. </p>
<p>This achieves packing of multiple padding ops into a larger tensor. On success, <code>opToHoist</code> is replaced by the cloned version in the packing loop so the caller can continue reasoning about the padding operation. If <code>transposeVector</code> is non-empty, hoist padding introduces a TransposeOp to transpose the padded tensor before inserting it into the packed tensor. A <code>transposeVector</code> can change the storage order of the padded tensor but does not change the order of the pack or compute loops.</p>
<p>TODO: In the future, we should consider rewriting as a <a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a> after hoisting since this abstraction is now available.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Example in pseudo-mlir:</h1>
<p>If hoistPaddingOnTensors is called with <code>nLoops</code> = 2 on the following IR. </p><div class="fragment"><div class="line">scf.for (%i, %<a class="code" href="unionj.html">j</a>, %k)</div>
<div class="line">  %st0 = tensor.extract_slice f(%i, %k) : ... to tensor&lt;?x?xf32&gt;</div>
<div class="line">  %0 = tensor.pad %st0 low[0, 0] high[...] {</div>
<div class="line">  ^bb0( ... ):</div>
<div class="line">    linalg.yield %pad</div>
<div class="line">  } : tensor&lt;?x?xf32&gt; to tensor&lt;4x8xf32&gt;</div>
<div class="line">  compute(%0)</div>
<div class="ttc" id="aunionj_html"><div class="ttname"><a href="unionj.html">j</a></div><div class="ttdoc">Eliminates variable at the specified position using Fourier-Motzkin variable elimination.</div></div>
</div><!-- fragment --><p>IR resembling the following is produced:</p>
<div class="fragment"><div class="line">scf.for (%i) {</div>
<div class="line">  %packed_init = tensor.empty range(%<a class="code" href="unionj.html">j</a>) : tensor&lt;?x4x8xf32&gt;</div>
<div class="line">  %packed = scf.for (%k) iter_args(%p : %packed_init) {</div>
<div class="line">    %st0 = tensor.extract_slice f(%i, %k) : ... to tensor&lt;?x?xf32&gt;</div>
<div class="line">    %0 = tensor.pad %st0 low[0, 0] high[...] {</div>
<div class="line">    ^bb0( ... ):</div>
<div class="line">      linalg.yield %pad</div>
<div class="line">    } : tensor&lt;?x?xf32&gt; to tensor&lt;4x8xf32&gt;</div>
<div class="line">    %1 = tensor.insert_slice %0 ...</div>
<div class="line">        : tensor&lt;4x8xf32&gt; to tensor&lt;?x4x8xf32&gt;</div>
<div class="line">    scf.yield %1: tensor&lt;?x4x8xf32&gt;</div>
<div class="line">  } -&gt; tensor&lt;?x4x8xf32&gt;</div>
<div class="line">  scf.for (%<a class="code" href="unionj.html">j</a>, %k) {</div>
<div class="line">    %st0 = tensor.extract_slice %packed [%k, 0, 0][1, 4, 8][1, 1, 1] :</div>
<div class="line">             tensor&lt;?x4x8xf32&gt; to tensor&lt;4x8xf32&gt;</div>
<div class="line">    compute(%st0)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> <p>Construct the packing loop nest.</p>

<p class="definition">Definition at line <a class="el" href="HoistPadding_8cpp_source.html#l00942">942</a> of file <a class="el" href="HoistPadding_8cpp_source.html">HoistPadding.cpp</a>.</p>

<p class="reference">References <a class="el" href="HoistPadding_8cpp_source.html#l00545">buildPackingLoopNestImpl()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00076">mlir::tensor::computeTransposedType()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00035">DBGS</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00238">mlir::Operation::getParentOfType()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00879">replaceByPackingResult()</a>, and <a class="el" href="Builders_8h_source.html#l00410">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HoistPadding_8cpp_source.html#l01007">hoistPaddingOnTensors()</a>, and <a class="el" href="Padding_8cpp_source.html#l00355">padAndHoistLinalgOp()</a>.</p>

</div>
</div>
<a id="ac1d7ae638195a0c07357a33d4b8cfec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d7ae638195a0c07357a33d4b8cfec0">&#9670;&nbsp;</a></span>hoistPaddingOnTensors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::hoistPaddingOnTensors </td>
          <td>(</td>
          <td class="paramtype">tensor::PadOp&#160;</td>
          <td class="paramname"><em>opToHoist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>numLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>transposeVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp &amp;&#160;</td>
          <td class="paramname"><em>hoistedOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; TransposeOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>transposeOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls into <code>hoistPaddingOnTensors</code> with a local <a class="el" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ...">IRRewriter</a>. </p>

<p class="definition">Definition at line <a class="el" href="HoistPadding_8cpp_source.html#l01007">1007</a> of file <a class="el" href="HoistPadding_8cpp_source.html">HoistPadding.cpp</a>.</p>

<p class="reference">References <a class="el" href="HoistPadding_8cpp_source.html#l00942">hoistPaddingOnTensors()</a>.</p>

</div>
</div>
<a id="ab283416b78913b7c9bb7f322758d98c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab283416b78913b7c9bb7f322758d98c9">&#9670;&nbsp;</a></span>hoistRedundantVectorBroadcasts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::hoistRedundantVectorBroadcasts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist vector.extract/vector.broadcast pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are met: </p>
<ol type="1">
<li>The vector.extract operation is applied on an iter_argument, and no other operator is using this argument in the body of the loop.</li>
<li>The position of the vector.extract is either a static value, or defined outside of the loop.</li>
<li>The vector.broadcast operation is yielded by the loop. To improve hoisting opportunities, call the <code>moveLoopInvariantCode</code> helper function on the candidate loop above which to hoist. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Hoisting_8cpp_source.html#l00088">88</a> of file <a class="el" href="Hoisting_8cpp_source.html">Hoisting.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00148">broadcast()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00285">mlir::changed</a>, <a class="el" href="Hoisting_8cpp_source.html#l00032">DBGS</a>, <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8h_source.html#l00197">mlir::Value::hasOneUse()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00628">mlir::RewriterBase::modifyOpInPlace()</a>, <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00059">mlir::moveLoopInvariantCode()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00421">mlir::RewriterBase::moveOpAfter()</a>, <a class="el" href="PatternMatch_8h_source.html#l00636">mlir::RewriterBase::replaceAllUsesWith()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00043">replaceWithDifferentYield()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="ae6b3914ef0f129c2145a4c6512cdac8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b3914ef0f129c2145a4c6512cdac8c">&#9670;&nbsp;</a></span>hoistRedundantVectorTransfers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::hoistRedundantVectorTransfers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verifyNonZeroTrip</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist vector.transfer_read/vector.transfer_write on buffers pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are true: </p>
<ol type="1">
<li>The two ops access the same memref with the same indices.</li>
<li>All operands are invariant under the enclosing scf::ForOp.</li>
<li>No uses of the memref either dominate the transfer_read or are dominated by the transfer_write (i.e. no aliasing between the write and the read across the loop)</li>
<li>The source operands for vector.transfer_{read|write} do not originate from Ops implementing ViewLikeOpInterface (to reduce the risk of aliasing).</li>
<li>If <code>verifyNonZeroTrip</code> is true, then the lower bound of the loop must be statically smaller than the upper bound of the loop, guaranteeing that the loop body will execute at least once. To improve hoisting opportunities, call the <code>moveLoopInvariantCode</code> helper function on the candidate loop above which to hoist. Hoisting the transfers results in scf::ForOp yielding the value that originally transited through memory.</li>
</ol>
<p>TODO: To further improve hoisting opportunities, fold aliasing memref operations into respective vector.transfer{read|write} operations and avoid using ops implementing ViewLikeOpInterface as the source for transfer Ops.</p>
<p>WARNING: This hoisting does not model parallelism and is generally incorrect when used on distributed loops with memref semantics! NOTE: Setting <code>verifyNonZeroTrip = true</code> makes this more stable for distributed loops with memref semantics, but there could still be some issues when loops are executed a different number of times for different threads. </p>

<p class="definition">Definition at line <a class="el" href="Hoisting_8cpp_source.html#l00192">192</a> of file <a class="el" href="Hoisting_8cpp_source.html">Hoisting.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00285">mlir::changed</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00630">mlir::ValueBoundsConstraintSet::computeConstantBound()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00032">DBGS</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00074">mlir::getForwardSlice()</a>, <a class="el" href="Value_8h_source.html#l00197">mlir::Value::hasOneUse()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00314">mlir::vector::isDisjointTransferSet()</a>, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841dac951270e425b15fc20c64da4341c1d89">mlir::presburger::LB</a>, <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00059">mlir::moveLoopInvariantCode()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00163">noAliasingUseInLoop()</a>, <a class="el" href="Dominance_8cpp_source.html#l00323">mlir::DominanceInfo::properlyDominates()</a>, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841da9d02262ac7b9cb33f0c3a8c2f9cf6edc">mlir::presburger::UB</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a6cc6445c80fee3f958456e7e94740557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc6445c80fee3f958456e7e94740557">&#9670;&nbsp;</a></span>inferContractionDims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContractionDimensions.html">ContractionDimensions</a> &gt; mlir::linalg::inferContractionDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>indexingMaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00495">495</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00444">inferContractionDimsImpl()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00422">inferIteratorsFromOutMap()</a>.</p>

</div>
</div>
<a id="aa2fe10e20900f7c49da8d51805f9e9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fe10e20900f7c49da8d51805f9e9f0">&#9670;&nbsp;</a></span>inferContractionDims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContractionDimensions.html">ContractionDimensions</a> &gt; mlir::linalg::inferContractionDims </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find at least 2 parallel (m and n) and 1 reduction (k) dimension candidates that form a matmul subcomputation within <code>linalgOp</code>. </p>
<p>These dimensions are such that:</p><ol type="1">
<li>The m dimension is involved in an outer-product along LHS (i.e. it is a permutation on RES and LHS and does not appear in RHS).</li>
<li>The n dimension is involved in an outer-product along RHS (i.e. it is a permutation on RES and RHS and does not appear in LHS).</li>
<li>The k dimension appears as a permutation on LHS and RHS.</li>
<li>m, n and k appear only once in any given indexing.</li>
<li>Optional batch dimensions that appear in all operands are captured. This allows e.g. detecting that some contraction is embedded within <code>linalgOp</code> with some orthogonal heuristic. When multiple dimension occurrences exist that match <code>batch</code>, <code>m</code>, <code>n</code>, or <code>k</code>, indices are returned in sorted order. Returns a failure if any of <code>m</code>, <code>n</code> or <code>k</code> is empty. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00487">487</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00444">inferContractionDimsImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BlockPackMatmul_8cpp_source.html#l00138">blockPackMatmul()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00516">mlir::linalg::detail::isContractionInterfaceImpl()</a>, <a class="el" href="Linalg_8cpp_source.html#l00051">mlirLinalgInferContractionDimensions()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00766">packMatmulGreedily()</a>, and <a class="el" href="BlockPackMatmul_8cpp_source.html#l00043">validateFullTilesOnDims()</a>.</p>

</div>
</div>
<a id="a63f1beb2cf9d6935a346b2e4b4d3c7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f1beb2cf9d6935a346b2e4b4d3c7f5">&#9670;&nbsp;</a></span>inferConvolutionDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ConvolutionDimensions.html">ConvolutionDimensions</a> &gt; mlir::linalg::inferConvolutionDims </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find at least 1 parallel (output_image) and reduction (filter_loop) dimension candidates that form a convolution subcomputation within <code>linalgOp</code>. </p>
<p>The LHS is assumed to be the convolution input while the RHS is assumed as the filter. These dimensions are such that:</p><ol type="1">
<li>Optional batch dimensions that appear in the input and filter.</li>
<li>The output_image dimension is involved in a cross-correlation along LHS (i.e. it is a permutation on RES and LHS and has an associated filter_loop in RHS).</li>
<li>Optional output_channel dimension is involved in an outer-product along RHS (i.e. it is a permutation on RES and RHS and does not appear in LHS).</li>
<li>Optional input_channel dimension appears as a permutation on LHS and RHS.</li>
<li>The filter_loop dimension appears as a permutation on the RHS and represents the shape of the kernel cross-correlated along a corresponding output_image dim.</li>
<li>The input_channel dimension appears as a permutation on LHS and RHS.</li>
<li>All dimensions appear only once in any given indexing map. This allows e.g. detecting that some convolution is embedded within <code>linalgOp</code> with some orthogonal heuristic. When multiple dimension occurrences exist that match any classification indices are returned in sorted order. Returns a failure if <code>output_image</code> (and implicitly <code>filter_loop</code>) is empty. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00856">856</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00744">inferConvolutionDimsImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_8cpp_source.html#l00087">mlirLinalgInferConvolutionDimensions()</a>.</p>

</div>
</div>
<a id="a19f85ff360bf1a176189d8a29a349623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f85ff360bf1a176189d8a29a349623">&#9670;&nbsp;</a></span>inferStaticShape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::linalg::inferStaticShape </td>
          <td>(</td>
          <td class="paramtype">PackOp&#160;</td>
          <td class="paramname"><em>packOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>destShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <code>srcShape</code> or <code>destShape</code> is different from the one in <code>packOp</code> and populates each with the inferred static shape. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05117">5117</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00206">mlir::invertPermutationVector()</a>.</p>

</div>
</div>
<a id="af8bfb7adf709f8802dfc47a8e602ecb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bfb7adf709f8802dfc47a8e602ecb0">&#9670;&nbsp;</a></span>inferStaticShape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::linalg::inferStaticShape </td>
          <td>(</td>
          <td class="paramtype">UnPackOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>destShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <code>srcShape</code> or <code>destShape</code> is different from the one in <code>op</code> and populates each with the inferred static shape. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05432">5432</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00206">mlir::invertPermutationVector()</a>.</p>

</div>
</div>
<a id="a78f9038823afe23e270d5bdc0734bc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f9038823afe23e270d5bdc0734bc3e">&#9670;&nbsp;</a></span>insertSlicesBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::insertSlicesBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates <code>insert_slice</code> ops that insert <code>results</code> back into larger tensors they were originally extracted from with <code>extract_slice</code> before being passed as <code>operands</code> to the given structured operation <code>op</code> or its clone. </p>
<p>Note that <code>operands</code> are not necessarily the actual operands of <code>op</code>, the operation serves only as metadata container for operand types and positions. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00782">782</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="a8dcc62e199cdb1863a3d6f30e4dc317a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcc62e199cdb1863a3d6f30e4dc317a">&#9670;&nbsp;</a></span>interchangeGenericOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; GenericOp &gt; mlir::linalg::interchangeGenericOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>genericOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>interchangeVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interchange the <code>iterator_types</code> and <code>iterator_maps</code> dimensions and adapts the index accesses of <code>op</code>. </p>
<p>This is an in-place transformation controlled by <code>interchangeVector</code>. An empty vector is interpreted as the identity permutation and the transformation returns early.</p>
<p>E.g. the permutation <code>(i,j,k) -&gt; (j,k,i)</code> is expressed with <code>interchangeVector = [1,2,0]</code>. All values in <code>interchangeVector</code> must be integers, in the range 0..<code>op.rank</code> without duplications (i.e. <code>[1,1,2]</code> is an invalid permutation).</p>
<p>Return failure if the permutation is not valid. </p>

<p class="definition">Definition at line <a class="el" href="Interchange_8cpp_source.html#l00045">45</a> of file <a class="el" href="Interchange_8cpp_source.html">Interchange.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00226">mlir::applyPermutationToVector()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">mlir::AffineMap::compose()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00247">mlir::RewriterBase::finalizeOpModification()</a>, <a class="el" href="Builders_8cpp_source.html#l00313">mlir::Builder::getAffineMapArrayAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00261">mlir::Builder::getArrayAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00260">mlir::AffineMap::getPermutationMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">mlir::AffineMap::getSubMap()</a>, <a class="el" href="Interchange_8cpp_source.html#l00031">interchangeGenericOpPrecondition()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00365">mlir::AffineMap::isEmpty()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8h_source.html#l00519">mlir::RewriterBase::replaceOpWithNewOp()</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00612">mlir::RewriterBase::startOpModification()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00766">packMatmulGreedily()</a>.</p>

</div>
</div>
<a id="a9fdf6fd72d97540e86680857176b705e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fdf6fd72d97540e86680857176b705e">&#9670;&nbsp;</a></span>isaBroadcastOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; &gt; mlir::linalg::isaBroadcastOpInterface </td>
          <td>(</td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>genericOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <code>genericOp</code> is semantically equivalent to a <code>linalg.broadcast</code>. </p>
<p>Returns broadcast dimensions if true. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00141">141</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Specialize_8cpp_source.html#l00258">specializeGenericOp()</a>.</p>

</div>
</div>
<a id="ab5277093c168682f123f1e99d90461f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5277093c168682f123f1e99d90461f0">&#9670;&nbsp;</a></span>isaContractionOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isaContractionOpInterface </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <code>linalgOp</code> conforms to ContractionOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00568">568</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00516">mlir::linalg::detail::isContractionInterfaceImpl()</a>, and <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a2884106fc260b44792b7e9be2ec8c1f8a505a83f220c02df2f85c3810cd9ceb38">mlir::linalg::detail::Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldAddIntoDest_8cpp_source.html#l00058">FoldAddIntoDest::matchAndRewrite()</a>, <a class="el" href="Linalg_8cpp_source.html#l00044">mlirLinalgIsAContractionOp()</a>, and <a class="el" href="Specialize_8cpp_source.html#l00258">specializeGenericOp()</a>.</p>

</div>
</div>
<a id="a7c76ee8dee2d6cb36fd4c974c60463f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c76ee8dee2d6cb36fd4c974c60463f3">&#9670;&nbsp;</a></span>isaConvolutionOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isaConvolutionOpInterface </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowEmptyConvolvedDims</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <code>linalgOp</code> conforms to ConvolutionOpInterface. </p>
<p>By default, we require the <code>linalgOp</code> to have non-empty convolved dims (implicitly non-empty <code>output_image</code> and <code>filter_loop</code>). Users can loosen the constraint by setting <code>allowEmptyConvolvedDims</code> to true </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l01045">1045</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00887">mlir::linalg::detail::isConvolutionInterfaceImpl()</a>, and <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009a505a83f220c02df2f85c3810cd9ceb38">mlir::linalg::detail::Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_8cpp_source.html#l00078">mlirLinalgIsAConvolutionOp()</a>.</p>

</div>
</div>
<a id="a171ae143026d28b2e6954c74bb535831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171ae143026d28b2e6954c74bb535831">&#9670;&nbsp;</a></span>isaCopyOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isaCopyOpInterface </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <code>linalgOp</code> is semantically equivalent to a <code>linalg.copyOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00061">61</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00152">mlir::Block::back()</a>, <a class="el" href="Block_8h_source.html#l00129">mlir::Block::getArgument()</a>, and <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Specialize_8cpp_source.html#l00258">specializeGenericOp()</a>.</p>

</div>
</div>
<a id="afc247b3bd43d4462293e09845b698e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc247b3bd43d4462293e09845b698e7a">&#9670;&nbsp;</a></span>isaElemwiseSingleBinaryOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isaElemwiseSingleBinaryOpInterface </td>
          <td>(</td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>genericOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <code>genericOp</code> is semantically equivalent to a single linalg elementwise binary op e.g. </p>
<p>linalg.sub. </p>

<p class="reference">Referenced by <a class="el" href="Specialize_8cpp_source.html#l00258">specializeGenericOp()</a>.</p>

</div>
</div>
<a id="a14eec3edd7d29c8980b155ed0dee1a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14eec3edd7d29c8980b155ed0dee1a0c">&#9670;&nbsp;</a></span>isaElemwiseSingleUnaryOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isaElemwiseSingleUnaryOpInterface </td>
          <td>(</td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>genericOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a given <code>genericOp</code> is semantically equivalent to a single linalgelementwise unary op. </p>
<p>e.g. linalg.exp. A linalg.generic body could be a series of unary elementwise ops e.g. <code>exp(neg(x))</code>, such as formed by linalg op fusion. Here we restrict it to detecting cases where body is is a single computation op. </p>

<p class="reference">Referenced by <a class="el" href="Specialize_8cpp_source.html#l00258">specializeGenericOp()</a>.</p>

</div>
</div>
<a id="aea1ca69a91110433c24e13af5c4ae3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1ca69a91110433c24e13af5c4ae3a9">&#9670;&nbsp;</a></span>isaFillOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::isaFillOpInterface </td>
          <td>(</td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>genericOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <code>genericOp</code> is semantically equivalent to a <code>linalg.fill</code>. </p>
<p>Supports two patterns:</p><ol type="1">
<li>External: linalg.generic ins(scalar) outs(tensor) { yield scalar }</li>
<li>Inlined: linalg.generic outs(tensor) { yield constant } Returns the scalar fill value if true. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00131">131</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00114">isaExternalFillOp()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00087">isaInlinedFillOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Specialize_8cpp_source.html#l00258">specializeGenericOp()</a>.</p>

</div>
</div>
<a id="a03e0016d67ebca76011c67253b093af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e0016d67ebca76011c67253b093af0">&#9670;&nbsp;</a></span>isaTransposeOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; &gt; mlir::linalg::isaTransposeOpInterface </td>
          <td>(</td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>genericOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <code>genericOp</code> is semantically equivalent to a <code>linalg.transpose</code>. </p>
<p>Returns permuted dimensions if true. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00191">191</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Specialize_8cpp_source.html#l00258">specializeGenericOp()</a>.</p>

</div>
</div>
<a id="a31426a6a1dc69e5819138ba53c6e7ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31426a6a1dc69e5819138ba53c6e7ef9">&#9670;&nbsp;</a></span>isDimSequencePreserved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isDimSequencePreserved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>indexingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a7ed845b40509fa999492a04654211321">ReassociationIndicesRef</a>&#160;</td>
          <td class="paramname"><em>dimSequence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if a given sequence of dimensions are contiguous in the range of the specified indexing map. </p>
<p>For a given <code>dimSequence</code>, check if the sequence is conserved in the <code>indexingMap</code>.</p>
<p><code>indexingMap</code> is expected to be a projected permutation. Non-existence of the sequence returns true as well. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01200">1200</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">mlir::AffineMap::isProjectedPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01241">areDimSequencesPreserved()</a>.</p>

</div>
</div>
<a id="a8b1c347bc995910212c197f9f8728b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1c347bc995910212c197f9f8728b12">&#9670;&nbsp;</a></span>isElementwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isElementwise </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a LinalgOp is an element-wise operation. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00220">220</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00200">allIndexingsAreProjectedPermutation()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00206">hasOnlyScalarElementwiseOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l02079">vectorizeDynamicLinalgOpPrecondition()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02362">vectorizeLinalgOpPrecondition()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l02505">vectorizeScalableVectorPrecondition()</a>.</p>

</div>
</div>
<a id="a258a284dc398c6d6510840831132df77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258a284dc398c6d6510840831132df77">&#9670;&nbsp;</a></span>isInvalidPackingPosSpecification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::linalg::isInvalidPackingPosSpecification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>dimsPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>dimsPos</code> is invalid. </p>
<p>It is invalid when: a) It contains duplicate. b) At least one dimension is out of bound (<code>dimPos</code> is &gt;= 0 and &lt; rank). c) The number of elements in <code>dimsPos</code> is &gt; than <code>rank</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l04643">4643</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l04657">commonVerifierPackAndUnPackOp()</a>.</p>

</div>
</div>
<a id="a20d84aa10cc5bda416b75ff65007c677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d84aa10cc5bda416b75ff65007c677">&#9670;&nbsp;</a></span>isLikePadUnPad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PackOrUnpackOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::linalg::isLikePadUnPad </td>
          <td>(</td>
          <td class="paramtype">PackOrUnpackOp&#160;</td>
          <td class="paramname"><em>packOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>packedTensorType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05209">5209</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp_source.html#l04747">innerDimsPos</a>.</p>

</div>
</div>
<a id="a24909cfdf87977961b71f1ca78a25919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24909cfdf87977961b71f1ca78a25919">&#9670;&nbsp;</a></span>isParallelIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isParallelIterator </td>
          <td>(</td>
          <td class="paramtype">utils::IteratorType&#160;</td>
          <td class="paramname"><em>iteratorType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if iterator type has "parallel" semantics. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00235">235</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00431">generateParallelLoopNest()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01297">getCollapsableIterationSpaceDims()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="a5377722f56e02541897c157260bd1eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5377722f56e02541897c157260bd1eee">&#9670;&nbsp;</a></span>isReductionIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isReductionIterator </td>
          <td>(</td>
          <td class="paramtype">utils::IteratorType&#160;</td>
          <td class="paramname"><em>iteratorType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if iterator type has "reduction" semantics. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00239">239</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01297">getCollapsableIterationSpaceDims()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00677">getDimsToReduce()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00684">hasReductionIterator()</a>, <a class="el" href="CodegenEnv_8cpp_source.html#l00135">mlir::sparse_tensor::CodegenEnv::isAdmissibleTensorExp()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l02031">reductionPreconditions()</a>.</p>

</div>
</div>
<a id="a7b7f777c5538e35bbdd3aaabdb07e6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7f777c5538e35bbdd3aaabdb07e6f7">&#9670;&nbsp;</a></span>linalgOpAnchoredEmptyTensorEliminationStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::linalgOpAnchoredEmptyTensorEliminationStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">bufferization::OneShotAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to eliminate tensor::EmptyOps inside <code>op</code> that are anchored on a LinalgOp. </p>
<p>This transforms looks for LinalgOps that have an unused output operand and an input operand that is rooted in a tensor::EmptyOp. The tensor::EmptyOp uses are replaced with the output operand and the two operands of the LinalgOp are swapped.</p>
<p>Example: %0 = tensor.empty() %1 = linalg.matmul ins(...) outs(%0) %2 = linalg.generic ins(%1) outs(dest) { ^bb0(in: f32, out: f32): // out not used }</p>
<p>The IR is transformed as follows: %0 = tensor.empty() %1 = linalg.matmul ins(...) outs(dest) %2 = linalg.generic ins(%0) outs(%1) { ^bb0(in: f32, out: f32): // Use out instead of in }</p>
<p>The "ins" operand has no uses inside the body of the LinalgOp and can be folded away with existing cleanup patterns. Afterwards, the tensor::EmptyOp can also fold away. </p>

<p class="definition">Definition at line <a class="el" href="EliminateEmptyTensors_8cpp_source.html#l00039">39</a> of file <a class="el" href="EliminateEmptyTensors_8cpp_source.html">EliminateEmptyTensors.cpp</a>.</p>

</div>
</div>
<a id="a95f289e066dcbb7844bd444c0880fc36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f289e066dcbb7844bd444c0880fc36">&#9670;&nbsp;</a></span>linalgOpToAffineLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt; mlir::linalg::linalgOpToAffineLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a loop nest of <code>affine.for</code> with the proper body for <code>linalgOp</code>. </p>
<p>Emits a loop nest of <code>affine.for</code> with the proper body for <code>linalgOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00363">363</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

</div>
</div>
<a id="a7edd4be30bfb8af9bc8e486f8368c1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7edd4be30bfb8af9bc8e486f8368c1e2">&#9670;&nbsp;</a></span>linalgOpToLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt; mlir::linalg::linalgOpToLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a loop nest of <code>scf.for</code> with the proper body for <code>linalgOp</code>. </p>
<p>Emits a loop nest of <code>scf.for</code> with the proper body for <code>linalgOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00368">368</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

</div>
</div>
<a id="aff809877c1d119dae06d06a8bad953e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff809877c1d119dae06d06a8bad953e4">&#9670;&nbsp;</a></span>linalgOpToParallelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt; mlir::linalg::linalgOpToParallelLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a loop nest of <code>scf.parallel</code> with the proper body for <code>linalgOp</code>. </p>
<p>Emits a loop nest of <code>scf.parallel</code> with the proper body for <code>linalgOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00375">375</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

</div>
</div>
<a id="afebe4a9f3b87bb8f196bf2d577511a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afebe4a9f3b87bb8f196bf2d577511a05">&#9670;&nbsp;</a></span>lowerPack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1LowerPackResult.html">LowerPackResult</a> &gt; mlir::linalg::lowerPack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::PackOp&#160;</td>
          <td class="paramname"><em>packOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lowerPadLikeWithInsertSlice</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite pack as pad + reshape + transpose. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00219">219</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00226">mlir::applyPermutationToVector()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00041">DBGS</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00042">DBGSNL</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00023">mlir::getElementTypeOrSelf()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00061">mlir::tensor::getMixedSize()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00070">mlir::tensor::getMixedSizes()</a>, <a class="el" href="namespacemlir_1_1linalg.html#a5c34dd63bd77acc711bdf98d6e2c7b75">getPackInverseDestPerm()</a>, <a class="el" href="Builders_8cpp_source.html#l00319">mlir::Builder::getZeroAttr()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00206">mlir::invertPermutationVector()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00451">mlir::isRankReducedType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00241">mlir::RankedTensorType::Builder::setShape()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00095">stringifyReassocIndices()</a>, and <a class="el" href="namespacemlir.html#a11353e6611651b85531ad95629c57d75a505a83f220c02df2f85c3810cd9ceb38">mlir::Success</a>.</p>

</div>
</div>
<a id="a3cea34f55211c79271dff09bb07c3279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cea34f55211c79271dff09bb07c3279">&#9670;&nbsp;</a></span>lowerUnPack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1LowerUnPackOpResult.html">LowerUnPackOpResult</a> &gt; mlir::linalg::lowerUnPack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::UnPackOp&#160;</td>
          <td class="paramname"><em>unPackOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lowerUnpadLikeWithExtractSlice</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite pack as empty + transpose + reshape + extract_slice. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00354">354</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00226">mlir::applyPermutationToVector()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00041">DBGS</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00042">DBGSNL</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00070">mlir::tensor::getMixedSizes()</a>, <a class="el" href="namespacemlir_1_1linalg.html#aa9d51592527f88974d4540b6dd73a59d">getUnPackInverseSrcPerm()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00241">mlir::RankedTensorType::Builder::setShape()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00095">stringifyReassocIndices()</a>.</p>

</div>
</div>
<a id="a962a46fba2ac497e30bb6d23fef35d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962a46fba2ac497e30bb6d23fef35d1a">&#9670;&nbsp;</a></span>makeAffineDimExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::makeAffineDimExprs </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>num</code> <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> dimensions at positions [startIdx, startIdx + num) and increments <code>startIdx</code> to <code>startIdx + num</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02445">2445</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00619">mlir::getAffineDimExpr()</a>.</p>

</div>
</div>
<a id="ad11bd07c6a72404260df26efdd0ba069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11bd07c6a72404260df26efdd0ba069">&#9670;&nbsp;</a></span>makeComposedPadHighOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::makeComposedPadHighOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>padding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nofold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>typeDynDims</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a tensor::PadOp that pads <code>source</code> to the shape of <code>type</code> whose sizes are assumed to be greater than the dynamic <code>source</code> size. </p>
<p>If <code>typeDynDims</code> is specified, then it must contain the sizes of all the dynamic dimensions in order of appearance in <code>type</code>, otherwise the function will pad those values to <code>0</code>. The padding introduces trailing <code>pad</code> values until the target size is met. If <code>source</code> is defined by one or more LinalgOps that have been padded with the same value and sizes, return their padded result instead of creating a tensor::PadOp.</p>
<p>Example: </p><div class="fragment"><div class="line">%0 = tensor.extract_slice %arg0 [%iv0, %iv1] [%sz0, %sz1]</div>
<div class="line">%1 = tensor.pad %0 low[0, 0] high[...] { tensor.yield %cst }</div>
<div class="line">%2 = linalg.matmul ins(...) outs(%1)</div>
<div class="line">%3 = tensor.extract_slice %2 [0, 0] [%sz0, %sz1]</div>
</div><!-- fragment --><p> makeComposedPadHighOp(source=%3, pad=cst) returns %2 makeComposedPadHighOp(source=%3, pad=other_cst) returns %4 </p><div class="fragment"><div class="line">%4 = tensor.pad %3 low[0, 0] high[...] { tensor.yield %other_cst }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00243">243</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00023">mlir::tensor::createPadHighOp()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00459">mlir::OpResult::getResultNumber()</a>, <a class="el" href="Matchers_8h_source.html#l00369">mlir::m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PadTilingInterface_8cpp_source.html#l00226">padOperand()</a>, and <a class="el" href="Padding_8cpp_source.html#l00187">padOperandToSmallestStaticBoundingBox()</a>.</p>

</div>
</div>
<a id="a30703b58e97c9678d9ee3d95c1b31f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30703b58e97c9678d9ee3d95c1b31f5d">&#9670;&nbsp;</a></span>makeMemRefCopyOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GenericOp mlir::linalg::makeMemRefCopyOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns GenericOp that copies an n-D memref. </p>
<p>Unlike the current implementation of memref::CopyOp, this op can further tile, lower to loops or vectorize. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00311">311</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a8144efefcad502e511c24aa5ce5b36e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8144efefcad502e511c24aa5ce5b36e8">&#9670;&nbsp;</a></span>makeTiledLoopRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 4 &gt;, <a class="el" href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">LoopIndexToRangeIndexMap</a> &gt; mlir::linalg::makeTiledLoopRanges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>allShapeSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>allTileSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00044">44</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01372">mlir::affine::makeComposedFoldedMultiResultAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="aa568a297670d2eb8609fa6df9849a449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa568a297670d2eb8609fa6df9849a449">&#9670;&nbsp;</a></span>makeTiledShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::linalg::makeTiledShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>valueToTile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>subShapeSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>omitPartialTileCheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an extract_slice/subview op for a single <code>valueToTile</code> with <code>builder</code>. </p>
<p>This new operation extracts a tile of <code>valueToTile</code>, starting at offsets <code>lbs</code> and with sizes <code>subShapeSizes</code>. <code>omitPartialTileCheck</code> controls whether to omit the partial/boundary tile condition check in cases where we statically know that it is unnecessary. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00613">613</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00626">computeSliceParameters()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00592">materializeTiledShape()</a>.</p>

</div>
</div>
<a id="a1a5fecbf19090f24723800d371f08271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5fecbf19090f24723800d371f08271">&#9670;&nbsp;</a></span>makeTiledShapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::makeTiledShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>valuesToTile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizeBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>omitPartialTileCheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates extract_slice/subview ops for all <code>valuesToTile</code> of the given <code>linalgOp</code> with <code>builder</code>, assuming <code>linalgOp</code> is being fused into a loop nest for tiling with the given induction variables <code>ivs</code> and tile sizes <code>tileSizes</code>. </p>
<p><code>sizeBounds</code> are the iteration space bounds for <em>all</em> the implicit loops in <code>linalgOp</code>. <code>omitPartialTileCheck</code> controls whether to omit the partial/boundary tile condition check in cases where we statically know that it is unnecessary.</p>
<p>Note that a constant zero in <code>tileSizes</code> means no tiling at that implicit loop. The number of non-zero values in <code>tileSizes</code> should be equal to the number of values in <code>ivs</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00862">862</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00811">computeAllSliceParameters()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00592">materializeTiledShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00103">fuse()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="a58aa52677e896e295c5fed98e9789f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58aa52677e896e295c5fed98e9789f94">&#9670;&nbsp;</a></span>materializeTiledShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Operation.html">Operation</a>* mlir::linalg::materializeTiledShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>valueToTile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>sliceParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00592">592</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00156">mlir::linalg::SliceParameters::offsets</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00157">mlir::linalg::SliceParameters::sizes</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00158">mlir::linalg::SliceParameters::strides</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00613">makeTiledShape()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00862">makeTiledShapes()</a>.</p>

</div>
</div>
<a id="a917a655a236200d3202b07fb842561b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917a655a236200d3202b07fb842561b8">&#9670;&nbsp;</a></span>offsetIndices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::offsetIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>offests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the specified offsets to any <code>linalg.index</code> ops contained in the given <code>linalgOp</code>. </p>
<p>The offsets are provided in the same order as iteration space dimensions. Null offests are assumed to be zero. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00884">884</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00103">fuse()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00073">transformIndexOps()</a>.</p>

</div>
</div>
<a id="a34bed319cb33ba0b063edefa38e27309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bed319cb33ba0b063edefa38e27309">&#9670;&nbsp;</a></span>offsetIndices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::offsetIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>offests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00890">890</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00261">mlir::RewriterBase::replaceUsesWithIf()</a>, and <a class="el" href="Builders_8h_source.html#l00410">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

</div>
</div>
<a id="abd29d6299d2891ae1d092974bc1c4e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd29d6299d2891ae1d092974bc1c4e30">&#9670;&nbsp;</a></span>pack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt; mlir::linalg::pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>packedSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement packing of a single LinalgOp by <code>packedSizes</code>. </p>
<p>Implement packing of a single LinalgOp by performing packing by <code>packedSizes</code>.</p>
<p>There must be one packedSizes entry per <code>linalgOp</code> iterator. Return the packed Linalg op on success, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00477">477</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00041">DBGS</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00023">mlir::getElementTypeOrSelf()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="classmlir_1_1ValueRange.html#ab8f3a1aeea4da0acfaad1bc71b072017">mlir::ValueRange::getTypes()</a>, <a class="el" href="Builders_8cpp_source.html#l00319">mlir::Builder::getZeroAttr()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00149">packLinalgMetadataOnce()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01282">mlir::tile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00766">packMatmulGreedily()</a>.</p>

</div>
</div>
<a id="ab3567489d885b34059aa8286957de564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3567489d885b34059aa8286957de564">&#9670;&nbsp;</a></span>packMatmulGreedily()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt; mlir::linalg::packMatmulGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mnkPackedSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>mnkPaddedSizesNextMultipleOf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>mnkOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack a LinalgOp by greedily inferring matmul dimensions (m, n, k) where m and n are proper parallel dimensions and k is a proper reduction dimension. </p>
<p>Packing occurs by rewriting the op as a linalg.generic and calling <a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg::pack</a> by <code>mnkPackedSizes</code>. The order of the packed dimensions is customizable: the <code>mnkOrder</code> is a permutation of {0, 1, 2} to reorder {m, n, k} into one of the 8 possible forms. The outer dimensions of the operands are not permuted at this time, this is left for future work. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00766">766</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01006">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00236">mlir::computePermutationVector()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00041">DBGS</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00042">DBGSNL</a>, <a class="el" href="Generalization_8cpp_source.html#l00048">generalizeNamedOp()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00487">inferContractionDims()</a>, <a class="el" href="Interchange_8cpp_source.html#l00045">interchangeGenericOp()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00223">mlir::isPermutationVector()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00477">pack()</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00037">mlir::Range::size</a>.</p>

<p class="reference">Referenced by <a class="el" href="BlockPackMatmul_8cpp_source.html#l00138">blockPackMatmul()</a>.</p>

</div>
</div>
<a id="a26e3825819b0563bb199218baf11ca73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e3825819b0563bb199218baf11ca73">&#9670;&nbsp;</a></span>packTranspose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackTransposeResult.html">PackTransposeResult</a> &gt; mlir::linalg::packTranspose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::PackOp&#160;</td>
          <td class="paramname"><em>packOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::UnPackOp&#160;</td>
          <td class="paramname"><em>maybeUnPackOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>outerPerm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>innerPerm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose a single PackOp -&gt; LinalgOp -&gt; UnPackOp chain and return the transposed PackOp -&gt; LinalgOp -&gt; UnPackOp chain after replacements. </p>
<p>Return failure if either:</p><ol type="1">
<li>the <code>packOp</code> does not have the <code>linalgOp</code> as its unique use.</li>
<li>the <code>maybeUnPackOp</code>, if specified must be a consumer of the result tied to the unique <code>packOp</code> use.</li>
<li><code>outerPerm</code> (resp. <code>innerPerm</code>) must be valid permutations of <code>packOp.getOuterDimsPerm</code> (resp. <code>packOp.getInnerDimsPerm</code>) or empty. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00675">675</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00226">mlir::OpOperand::getOperandNumber()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00223">mlir::isPermutationVector()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00629">transposeOneLinalgOperandAndReplace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BlockPackMatmul_8cpp_source.html#l00089">transposePackedMatmul()</a>.</p>

</div>
</div>
<a id="aad04f1a354ddbbdec275dd9afd45bdce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad04f1a354ddbbdec275dd9afd45bdce">&#9670;&nbsp;</a></span>padAndHoistLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; LinalgOp &gt; mlir::linalg::padAndHoistLinalgOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply padding and hoisting to <code>linalgOp</code> according to the configuration specified in <code>options</code>. </p>

<p class="definition">Definition at line <a class="el" href="Padding_8cpp_source.html#l00355">355</a> of file <a class="el" href="Padding_8cpp_source.html">Padding.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00942">hoistPaddingOnTensors()</a>, <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html#a0bb964c0ac97b344abe7f245952882f1a6adf97f83acf6453d4a6a4b1070f3754">mlir::linalg::LinalgPaddingOptions::None</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Padding_8cpp_source.html#l00244">rewriteAsPaddedOp()</a>.</p>

</div>
</div>
<a id="a8f2b11de8cf430259d6ed044bfd270dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2b11de8cf430259d6ed044bfd270dd">&#9670;&nbsp;</a></span>paddingIsNotNeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::linalg::paddingIsNotNeeded </td>
          <td>(</td>
          <td class="paramtype">PackOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the pack op does not need a padding value. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05103">5103</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

</div>
</div>
<a id="af20da6e40bc32581f1b98bfbdf172eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20da6e40bc32581f1b98bfbdf172eed">&#9670;&nbsp;</a></span>parseIndexingMapsAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;ArrayAttr&gt; mlir::linalg::parseIndexingMapsAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l03839">3839</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a7850fe0a2961f835384adb372758d58b">mlir::AsmParser::getCurrentLocation()</a>, <a class="el" href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a5f240da7e00c4072d9f268efe1179b1d">mlir::AsmParser::parseEqual()</a>, and <a class="el" href="classmlir_1_1AsmParser.html#a305f6334c61eb92a164bd865851f55f4">mlir::AsmParser::parseOptionalKeyword()</a>.</p>

</div>
</div>
<a id="a68dadb214c30b3c13050c631d03070a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dadb214c30b3c13050c631d03070a9">&#9670;&nbsp;</a></span>partitionLinalgOpWithShardedReduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::linalg::partitionLinalgOpWithShardedReduction </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>partitionedOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4c4ef4fd46eecd339c2489be75f16729">Sharding</a> &gt;&#160;</td>
          <td class="paramname"><em>operandShardings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4c4ef4fd46eecd339c2489be75f16729">Sharding</a> &gt;&#160;</td>
          <td class="paramname"><em>resultShardings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt;&#160;</td>
          <td class="paramname"><em>loopIteratorTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a9f513853f0b1d301ba8269c1d38a2a16">GridAxis</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>gridAxisAssignmentForLoopIterators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>partitionMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> &amp;&#160;</td>
          <td class="paramname"><em>symbolTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00204">204</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00188">createAllReduceForResultsWithoutPartialShardings()</a>, <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00172">createDestinationPassingStyleInitOperands()</a>, <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00100">getGrid()</a>, <a class="el" href="ShardingInterface_8cpp_source.html#l00624">mlir::shard::getReductionGridAxes()</a>, <a class="el" href="IRMapping_8h_source.html#l00072">mlir::IRMapping::lookup()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, and <a class="el" href="ShardingInterface_8cpp_source.html#l00637">mlir::shard::partitionTriviallyShardableOperation()</a>.</p>

</div>
</div>
<a id="ae273bd1d7e48f4503eefba4f1487fa56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae273bd1d7e48f4503eefba4f1487fa56">&#9670;&nbsp;</a></span>peelLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::peelLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to peel and canonicalize loop <code>op</code> and return the new result. </p>
<p>Also applies affine_min/max bounds simplification on the fly where relevant. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00055">55</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, and <a class="el" href="namespacemlir_1_1scf.html#a55e793e622ecb45a3c5ff79b66939191">mlir::scf::peelForLoopAndSimplifyBounds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00071">peelLoops()</a>.</p>

</div>
</div>
<a id="a5faa18744febf8ff36b38176ca04d8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5faa18744febf8ff36b38176ca04d8fc">&#9670;&nbsp;</a></span>peelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::peelLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peel 'loops' and applies affine_min/max bounds simplification on the fly where relevant. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00071">71</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00055">peelLoop()</a>.</p>

</div>
</div>
<a id="a1bf177055be0ddc8558b82cfbf4f8df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf177055be0ddc8558b82cfbf4f8df7">&#9670;&nbsp;</a></span>populateBlockPackMatmulPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateBlockPackMatmulPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#ae020263d273fb7b7f80c4970556da5f8">ControlBlockPackMatmulFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to block pack Linalg matmul ops. </p>

<p class="definition">Definition at line <a class="el" href="BlockPackMatmul_8cpp_source.html#l00319">319</a> of file <a class="el" href="BlockPackMatmul_8cpp_source.html">BlockPackMatmul.cpp</a>.</p>

</div>
</div>
<a id="a18fce962e3d12d2dfc3b467076c71f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18fce962e3d12d2dfc3b467076c71f39">&#9670;&nbsp;</a></span>populateBubbleUpExtractSliceOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateBubbleUpExtractSliceOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns that are used to bubble up extract slice op above linalg op. </p>

<p class="definition">Definition at line <a class="el" href="BubbleUpExtractSlice_8cpp_source.html#l00131">131</a> of file <a class="el" href="BubbleUpExtractSlice_8cpp_source.html">BubbleUpExtractSlice.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a8ef1d681922add4fcf065a64d713c3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef1d681922add4fcf065a64d713c3b5">&#9670;&nbsp;</a></span>populateCollapseDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateCollapseDimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#ac1d01335b6fc341e4b908d9ea5df7482">GetCollapsableDimensionsFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlCollapseDimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to collapse dimensions in a linalg.generic op. </p>
<p>This will collapse tensor operands when needed and expand back the result tensors. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l02267">2267</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ad0b142daa69f3f2b8986960b726ba2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b142daa69f3f2b8986960b726ba2eb">&#9670;&nbsp;</a></span>populateConstantFoldLinalgOperations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateConstantFoldLinalgOperations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to constant fold Linalg operations. </p>

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l00304">304</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

</div>
</div>
<a id="a08373cf12e45f28268db4e84f038f6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08373cf12e45f28268db4e84f038f6ca">&#9670;&nbsp;</a></span>populateContractionOpRankReducingPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateContractionOpRankReducingPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds patterns that reduce the rank of named contraction ops that have unit dimensions in the operand(s) by converting to a sequence of <code>collapse_shape</code>, <code>&lt;corresponding linalg named op&gt;</code>, <code>expand_shape</code> (if on tensors). </p>
<p>For example a <code>linalg.batch_matmul</code> with unit batch size will convert to <code>linalg.matmul</code> and a <code>linalg.matvec</code> with with unit spatial dim in lhs will convert to a <code>linalg.dot</code>. </p>

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l01111">1111</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a1e349c4f7a13b98a31f89dec948c5533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e349c4f7a13b98a31f89dec948c5533">&#9670;&nbsp;</a></span>populateConvertConv2DToImg2ColPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateConvertConv2DToImg2ColPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns to transform linalg.conv_2d_xxx operations into linalg.generic (for img2col packing) and linalg.matmul. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemlir_1_1linalg.html#a0e2c1f265ce47a53398eab6e8f18b30c" title="Convert linalg.conv_2d_nhwc_hwcf into linalg.generic (for img2col packing) and linalg....">rewriteInIm2Col</a> for more details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00687">687</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a68f8e903a075470f95fa853892083469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f8e903a075470f95fa853892083469">&#9670;&nbsp;</a></span>populateConvertToDestinationStylePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateConvertToDestinationStylePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that convert non-destination-style ops to destination style ops. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00615">615</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a891b8f2d145dcc3327ba55c7a49d44e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891b8f2d145dcc3327ba55c7a49d44e4">&#9670;&nbsp;</a></span>populateConvolutionVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateConvolutionVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns for vectorizing low-D convolution ops. </p>
<p>This is a step in progressive lowering for convolution ops, it assume high-D convolution ops were decomposed previously. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l04275">4275</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a3e0c4216814c93fb83b999f3f4923f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0c4216814c93fb83b999f3f4923f7d">&#9670;&nbsp;</a></span>populateDataLayoutPropagationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateDataLayoutPropagationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#ab145fd297a4850ad34e09aab2f669e65">ControlPropagationFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlPackUnPackPropagation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to bubble up or down data layout ops across other operations. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutPropagation_8cpp_source.html#l01241">1241</a> of file <a class="el" href="DataLayoutPropagation_8cpp_source.html">DataLayoutPropagation.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a887c3b461640ae2783747a1c89726203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887c3b461640ae2783747a1c89726203">&#9670;&nbsp;</a></span>populateDecomposeConvolutionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateDecomposeConvolutionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linalg decompose convolutions patterns. </p>
<p>Populates patterns to decompose high-D convolution ops into low-D ones. This is a step in progressive lowering for convolution ops, afterwards we can vectorize the low-D convolution ops. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01655">1655</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="aad6f59ca20a1e8ce21c3c29916aec917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6f59ca20a1e8ce21c3c29916aec917">&#9670;&nbsp;</a></span>populateDecomposeLinalgOpsPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateDecomposeLinalgOpsPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeDeadArgsAndResults</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns for splitting a <code>LinalgOp</code> with multiple statements within its payload into multiple <code>GenericOp</code> that have a single statement. </p>
<p>The option <code>removeDeadArgsAndResults</code> adds patterns to remove dead arguments and results from the generated decomposed ops. This is default <code>true</code> since the core decomposition patterns relies on these clean up patterns. It is set to false only for testing purposes. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00384">384</a> of file <a class="el" href="DecomposeLinalgOps_8cpp_source.html">DecomposeLinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, and <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00431">populateEraseUnusedOperandsAndResultsPatterns()</a>.</p>

</div>
</div>
<a id="a96851c32371159549c91211e266f3f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96851c32371159549c91211e266f3f0e">&#9670;&nbsp;</a></span>populateDecomposePackUnpackPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateDecomposePackUnpackPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns to decompose <a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a> and linalg.unpack Ops into e.g. </p>
<p>tensor.pad, linalg.transpose, tensor.{insert|extract}_slice. Require all outer dims to be unit. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01676">1676</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ae93e7e4b8d10bb895e935d0b4799f3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93e7e4b8d10bb895e935d0b4799f3a9">&#9670;&nbsp;</a></span>populateDecomposePadPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateDecomposePadPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns to decompose tensor.pad into e.g. </p>
<p>tensor.empty, linalg.fill, tensor.insert_slice. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01681">1681</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a3a1d8a95a9bec4041581a35ce791a503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1d8a95a9bec4041581a35ce791a503">&#9670;&nbsp;</a></span>populateDecomposeProjectedPermutationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateDecomposeProjectedPermutationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add patterns to make explicit broadcasts and transforms in the input operands of a genericOp. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeGenericByUnfoldingPermutation_8cpp_source.html#l00245">245</a> of file <a class="el" href="DecomposeGenericByUnfoldingPermutation_8cpp_source.html">DecomposeGenericByUnfoldingPermutation.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a88f5ef52c3bd7a0c67503bb7b5f97ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f5ef52c3bd7a0c67503bb7b5f97ae7">&#9670;&nbsp;</a></span>populateDecomposeWinogradOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateDecomposeWinogradOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to decompose Winograd operators. </p>

<p class="definition">Definition at line <a class="el" href="WinogradConv2D_8cpp_source.html#l01216">1216</a> of file <a class="el" href="WinogradConv2D_8cpp_source.html">WinogradConv2D.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="af537f75332b531f2f627083684c201e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af537f75332b531f2f627083684c201e4">&#9670;&nbsp;</a></span>populateElementwiseOpsFusionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateElementwiseOpsFusionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlElementwiseOpFusion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns for fusing linalg operation on tensors. </p>
<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to fuse <code>linalg.generic</code> -&gt; <code>linalg.generic</code> operations when both operations are fusable elementwise operations. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l02256">2256</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, and <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00431">populateEraseUnusedOperandsAndResultsPatterns()</a>.</p>

</div>
</div>
<a id="a7a49133ef595966377878adc42196f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a49133ef595966377878adc42196f47">&#9670;&nbsp;</a></span>populateElementwiseToLinalgConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateElementwiseToLinalgConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that convert <code>ElementwiseMappable</code> ops to linalg parallel loops. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00114">114</a> of file <a class="el" href="ElementwiseToLinalg_8cpp_source.html">ElementwiseToLinalg.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="abe6e2c64c65b1a22b1794d731be0c612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6e2c64c65b1a22b1794d731be0c612">&#9670;&nbsp;</a></span>populateEraseUnnecessaryInputsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateEraseUnnecessaryInputsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to promote inputs to outputs and remove unused inputs of <code>linalg.generic</code> ops. </p>

<p class="definition">Definition at line <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00438">438</a> of file <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html">EraseUnusedOperandsAndResults.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a9cbdbb9ec2d0ed200d6a679ffd803c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbdbb9ec2d0ed200d6a679ffd803c7e">&#9670;&nbsp;</a></span>populateEraseUnusedOperandsAndResultsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateEraseUnusedOperandsAndResultsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to remove dead operands and results of <code>linalg.generic</code> operations. </p>
<p>This is a pattern wrapper for <code>deduplicateOperandsAndRemoveDeadResults</code>. </p>

<p class="definition">Definition at line <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00431">431</a> of file <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html">EraseUnusedOperandsAndResults.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00384">populateDecomposeLinalgOpsPattern()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l02256">populateElementwiseOpsFusionPatterns()</a>.</p>

</div>
</div>
<a id="aeb6bcda20dbb76f4b453abfc31adcc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6bcda20dbb76f4b453abfc31adcc98">&#9670;&nbsp;</a></span>populateFoldAddIntoDestPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateFoldAddIntoDestPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to replace <code>linalg.add</code> when destination passing on a contraction op suffices for achieving the sum. </p>

<p class="definition">Definition at line <a class="el" href="FoldAddIntoDest_8cpp_source.html#l00147">147</a> of file <a class="el" href="FoldAddIntoDest_8cpp_source.html">FoldAddIntoDest.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ab23b572eea62b16b1020bd964dc67d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23b572eea62b16b1020bd964dc67d36">&#9670;&nbsp;</a></span>populateFoldIntoPackAndUnpackPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateFoldIntoPackAndUnpackPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a8978399adc7b5ab6a4574123f59d1f52">ControlFoldIntoPackUnpackFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlFn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns that fold operations like <code>tensor.pad</code> and <code>tensor.extract_slice</code> into <code>tensor.pack</code> and <code>tensor.unpack</code> operations respectively. </p>

<p class="definition">Definition at line <a class="el" href="PackAndUnpackPatterns_8cpp_source.html#l00609">609</a> of file <a class="el" href="PackAndUnpackPatterns_8cpp_source.html">PackAndUnpackPatterns.cpp</a>.</p>

</div>
</div>
<a id="aac248e317eae5124cbaad8bbb832a806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac248e317eae5124cbaad8bbb832a806">&#9670;&nbsp;</a></span>populateFoldPackUnpackIntoTensorEmptyPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateFoldPackUnpackIntoTensorEmptyPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns that fold operations like <code><a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a></code> and <code>linalg.unpack</code> into <code>tensor.empty</code>. </p>

<p class="definition">Definition at line <a class="el" href="PackAndUnpackPatterns_8cpp_source.html#l00624">624</a> of file <a class="el" href="PackAndUnpackPatterns_8cpp_source.html">PackAndUnpackPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a3c8bdabd42dfb2f3617cc87eccfa4199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8bdabd42dfb2f3617cc87eccfa4199">&#9670;&nbsp;</a></span>populateFoldReshapeOpsByCollapsingPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateFoldReshapeOpsByCollapsingPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlFoldingReshapes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold an expanding tensor.expand_shape operation with its producer generic operation by collapsing the dimensions of the generic op. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l02245">2245</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ac73f0e4d33b9691f06d722f2146c4a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73f0e4d33b9691f06d722f2146c4a66">&#9670;&nbsp;</a></span>populateFoldReshapeOpsByExpansionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateFoldReshapeOpsByExpansionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlFoldingReshapes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold an expanding (collapsing) tensor_reshape operation with its producer (consumer) generic operation by expanding the dimensionality of the loop in the generic op. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l02234">2234</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a7134894ce50357a7e8fefe7c379acac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7134894ce50357a7e8fefe7c379acac7">&#9670;&nbsp;</a></span>populateFoldUnitExtentDimsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateFoldUnitExtentDimsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">linalg::ControlDropUnitDims</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold unit-extent dimensions in operands/results of linalg ops on tensors via reassociative reshape ops. </p>

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00837">837</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html#a3f80bde3032c3481886057c6eb3247a4afc30205fc8c37633384b7dc675e58e25">mlir::linalg::ControlDropUnitDims::ExtractInsertSlice</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00804">populateFoldUnitExtentDimsViaReshapesPatterns()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00824">populateFoldUnitExtentDimsViaSlicesPatterns()</a>.</p>

</div>
</div>
<a id="a0e0b4c454598e4be0bd0fcde89783a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0b4c454598e4be0bd0fcde89783a20">&#9670;&nbsp;</a></span>populateFuseTensorPadWithProducerLinalgOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateFuseTensorPadWithProducerLinalgOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to fuse a <code>tensor.pad</code> operation with the producer of its source, if the producer is a <code>linalg</code> operation with all parallel iterator types. </p>

<p class="definition">Definition at line <a class="el" href="FusePadOpWithLinalgProducer_8cpp_source.html#l00120">120</a> of file <a class="el" href="FusePadOpWithLinalgProducer_8cpp_source.html">FusePadOpWithLinalgProducer.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="acc64a8c8a9ecf3de84383893d8e4ddc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc64a8c8a9ecf3de84383893d8e4ddc2">&#9670;&nbsp;</a></span>populateInlineConstantOperandsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateInlineConstantOperandsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns that are used to inline constant operands into linalg generic ops. </p>

<p class="definition">Definition at line <a class="el" href="InlineScalarOperands_8cpp_source.html#l00098">98</a> of file <a class="el" href="InlineScalarOperands_8cpp_source.html">InlineScalarOperands.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a479c320b2d7a71b7d9c50d04047eba8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479c320b2d7a71b7d9c50d04047eba8f">&#9670;&nbsp;</a></span>populateLinalgFoldIntoElementwisePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateLinalgFoldIntoElementwisePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns that fold operations like <code>linalg.transform</code> into elementwise op map. </p>

<p class="definition">Definition at line <a class="el" href="FoldIntoElementwise_8cpp_source.html#l00084">84</a> of file <a class="el" href="FoldIntoElementwise_8cpp_source.html">FoldIntoElementwise.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="adc9ad663f56317f953958cb9434bd8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9ad663f56317f953958cb9434bd8fc">&#9670;&nbsp;</a></span>populateLinalgGenericOpsSpecializationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateLinalgGenericOpsSpecializationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns to convert linalg.generic ops to named ops where possible. </p>
<p>A linalg.generic can represent wide range and complex computations for which equivalent linalg named op may not exist e.g. linalg.generic that takes a tensor and computes a polynomial such as: p(x) = an*x^n + ... + a1x + a0 There is no equivalent named op to convert to. Many such cases exist. </p>

<p class="definition">Definition at line <a class="el" href="Specialize_8cpp_source.html#l00355">355</a> of file <a class="el" href="Specialize_8cpp_source.html">Specialize.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a0419b15db70f16465aec05d8f86f6e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0419b15db70f16465aec05d8f86f6e4e">&#9670;&nbsp;</a></span>populateLinalgNamedOpConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateLinalgNamedOpConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to convert from one named op to another. </p>
<p>These can be seen as canonicalizations of named ops into another named op. </p>

<p class="definition">Definition at line <a class="el" href="NamedOpConversions_8cpp_source.html#l00162">162</a> of file <a class="el" href="NamedOpConversions_8cpp_source.html">NamedOpConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ada9bb5c9c8ef1aadbbc563431443b5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9bb5c9c8ef1aadbbc563431443b5e2">&#9670;&nbsp;</a></span>populateLinalgNamedOpsGeneralizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateLinalgNamedOpsGeneralizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linalg generalization patterns. </p>
<p>Populates <code>patterns</code> with patterns to convert spec-generated named ops to linalg.generic ops. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00091">91</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a4701ad0fa2e34da0089a80135935f02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4701ad0fa2e34da0089a80135935f02e">&#9670;&nbsp;</a></span>populateLinalgTilingCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateLinalgTilingCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00857">857</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00851">getLinalgTilingCanonicalizationPatterns()</a>.</p>

</div>
</div>
<a id="a703d4f21c6f57b8c680dc20dd6928a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703d4f21c6f57b8c680dc20dd6928a61">&#9670;&nbsp;</a></span>populateLinalgToStandardConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateLinalgToStandardConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Linalg to Standard. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToStandard_8cpp_source.html#l00126">126</a> of file <a class="el" href="LinalgToStandard_8cpp_source.html">LinalgToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a042bb54cd9155ed1ca8818a16ab5110a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042bb54cd9155ed1ca8818a16ab5110a">&#9670;&nbsp;</a></span>populateMoveInitOperandsToInputPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateMoveInitOperandsToInputPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pattern that converts init operands to input operands. </p>

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00849">849</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a43c2ef8a778a33a17885475c11b50bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c2ef8a778a33a17885475c11b50bdd">&#9670;&nbsp;</a></span>populatePadOpVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populatePadOpVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>baseBenefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns that vectorize tensor.pad. </p>
<p>These patterns are meant to apply in a complementary fashion. Benefits are used to encode a certain ordering of pattern application. To avoid scattering magic constants throughout the code base, the patterns must be added with this function. <code>baseBenefit</code> can be used to offset the benefit of all tensor::PadOp vectorization patterns by a certain value. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l03248">3248</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00025">mlir::PatternBenefit::getBenefit()</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="aab3e6438bd84e7e76e5352c0c54fb5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3e6438bd84e7e76e5352c0c54fb5b7">&#9670;&nbsp;</a></span>populateSimplifyPackAndUnpackPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateSimplifyPackAndUnpackPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns that simplify <code>tensor.pack</code> and <code>tensor.unpack</code> operations. </p>

<p class="definition">Definition at line <a class="el" href="PackAndUnpackPatterns_8cpp_source.html#l00619">619</a> of file <a class="el" href="PackAndUnpackPatterns_8cpp_source.html">PackAndUnpackPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a49366865f5ce183ae19888eceb6667e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49366865f5ce183ae19888eceb6667e5">&#9670;&nbsp;</a></span>populateSparseTensorRewriting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateSparseTensorRewriting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that are only useful in the context of sparse tensors. </p>

</div>
</div>
<a id="a0c26bb1f203c97b9d5bcf9b8ae6ea102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c26bb1f203c97b9d5bcf9b8ae6ea102">&#9670;&nbsp;</a></span>populateSplitReductionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateSplitReductionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlSplitReductionFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlloc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to apply <code>splitReduction</code> below. </p>

<p class="definition">Definition at line <a class="el" href="SplitReduction_8cpp_source.html#l00448">448</a> of file <a class="el" href="SplitReduction_8cpp_source.html">SplitReduction.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ac8003a713f74f7a32cc681c245ae9708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8003a713f74f7a32cc681c245ae9708">&#9670;&nbsp;</a></span>populateSwapExtractSliceWithFillPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateSwapExtractSliceWithFillPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds patterns that waps tensor.extract_slice(linalg.fill(cst, init)) into linalg.fill(cst, tensor.extract_slice(init)). </p>

<p class="definition">Definition at line <a class="el" href="SwapExtractSliceWithFillPatterns_8cpp_source.html#l00042">42</a> of file <a class="el" href="SwapExtractSliceWithFillPatterns_8cpp_source.html">SwapExtractSliceWithFillPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a90bd97b279b588f6e57a048d72a69a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bd97b279b588f6e57a048d72a69a9c">&#9670;&nbsp;</a></span>populateTransposeConv2DPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateTransposeConv2DPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TransposeConv2D_8cpp_source.html#l00134">134</a> of file <a class="el" href="TransposeConv2D_8cpp_source.html">TransposeConv2D.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a0786aed514452424d437b02ff9816dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0786aed514452424d437b02ff9816dce">&#9670;&nbsp;</a></span>populateTransposeMatmulPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateTransposeMatmulPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposeLHS</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to convert Linalg matmul ops to transposed variants. </p>

<p class="definition">Definition at line <a class="el" href="TransposeMatmul_8cpp_source.html#l00168">168</a> of file <a class="el" href="TransposeMatmul_8cpp_source.html">TransposeMatmul.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a4a5263d91b36edf98bda8c609f486214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5263d91b36edf98bda8c609f486214">&#9670;&nbsp;</a></span>populateWinogradConv2DPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::populateWinogradConv2DPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WinogradConv2DFmr&#160;</td>
          <td class="paramname"><em>fmr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to apply Winograd Conv2D algorithm F(m x m, r x r). </p>

<p class="definition">Definition at line <a class="el" href="WinogradConv2D_8cpp_source.html#l01209">1209</a> of file <a class="el" href="WinogradConv2D_8cpp_source.html">WinogradConv2D.cpp</a>.</p>

</div>
</div>
<a id="a4ed54a24fbd0044060290027188db5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed54a24fbd0044060290027188db5c0">&#9670;&nbsp;</a></span>promoteSubviewAsNewBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a> &gt; mlir::linalg::promoteSubviewAsNewBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::SubViewOp&#160;</td>
          <td class="paramname"><em>subView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useOriginalSubviewSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a1bcbad447f843c9b98886ad6f49469a9">AllocBufferCallbackFn</a> &amp;&#160;</td>
          <td class="paramname"><em>allocationFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00237">237</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00517">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Promotion_8cpp_source.html#l00288">promoteSubViews()</a>.</p>

</div>
</div>
<a id="acd639dc165f0ab64ec7afbac992c4d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd639dc165f0ab64ec7afbac992c4d65">&#9670;&nbsp;</a></span>promoteSubViews()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; LinalgOp &gt; mlir::linalg::promoteSubViews </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote the <code>subViews</code> into a new buffer allocated at the insertion point <code>b</code>. </p>
<p>Promotion occurs in 3 steps:</p><ol type="1">
<li>Create a new buffer for a full tile (i.e. not clipped at the boundary).</li>
<li>Take a full view on the buffer.</li>
<li>Take a partial slice of the full view in step 2. and copy into it.</li>
</ol>
<p>Return the modified linalg op (the modification happens in place) as well as all the copy ops created. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00422">422</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="Promotion_8cpp_source.html#l00288">promoteSubViews()</a>.</p>

</div>
</div>
<a id="a850b9fd11404efe17bca02011aff2e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850b9fd11404efe17bca02011aff2e88">&#9670;&nbsp;</a></span>promoteSubviewsPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::promoteSubviewsPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote memref.subviews feeding linalg-on-buffers operations. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00400">400</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a688a83ed3c19e68f4acfed8486771451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688a83ed3c19e68f4acfed8486771451">&#9670;&nbsp;</a></span>registerAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... OpTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::linalg::registerAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variadic helper function. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00328">328</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00332">registerShardingInterfaceExternalModels()</a>.</p>

</div>
</div>
<a id="a0ae5e64320c923f94446d6b60153fee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae5e64320c923f94446d6b60153fee4">&#9670;&nbsp;</a></span>registerAllDialectInterfaceImplementations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::registerAllDialectInterfaceImplementations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AllInterfaces_8cpp_source.html#l00017">17</a> of file <a class="el" href="AllInterfaces_8cpp_source.html">AllInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Arith_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00215">mlir::arith::registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Arith_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00098">mlir::arith::registerShardingInterfaceExternalModels()</a>, <a class="el" href="Linalg_2Transforms_2SubsetInsertionOpInterfaceImpl_8cpp_source.html#l00072">registerSubsetOpInterfaceExternalModels()</a>, <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l01407">registerTilingInterfaceExternalModels()</a>, and <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00155">mlir::affine::registerValueBoundsOpInterfaceExternalModels()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00107">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ab570ed1db81a641eb5b3d9948775e517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab570ed1db81a641eb5b3d9948775e517">&#9670;&nbsp;</a></span>registerBufferizableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::registerBufferizableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00196">196</a> of file <a class="el" href="Linalg_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html">BufferizableOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

</div>
</div>
<a id="a645065016a10ad2397796861ba5b8c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645065016a10ad2397796861ba5b8c3e">&#9670;&nbsp;</a></span>registerOne()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::linalg::registerOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00322">322</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

</div>
</div>
<a id="a34d52ce7a6266192f3f98587b7c6575b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d52ce7a6266192f3f98587b7c6575b">&#9670;&nbsp;</a></span>registerRuntimeVerifiableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::registerRuntimeVerifiableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2RuntimeOpVerification_8cpp_source.html#l00122">122</a> of file <a class="el" href="Linalg_2Transforms_2RuntimeOpVerification_8cpp_source.html">RuntimeOpVerification.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="MLIRContext_8h_source.html#l00107">mlir::MLIRContext::loadDialect()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00107">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ac6ef5d2a9e63222d223b416027377828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ef5d2a9e63222d223b416027377828">&#9670;&nbsp;</a></span>registerShardingInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::registerShardingInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00332">332</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00394">mlir::MLIRContext::appendDialectRegistry()</a>, <a class="el" href="DialectRegistry_8h_source.html#l00200">mlir::DialectRegistry::getDialectNames()</a>, <a class="el" href="MLIRContext_8h_source.html#l00097">mlir::MLIRContext::getOrLoadDialect()</a>, <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>, and <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00328">registerAll()</a>.</p>

</div>
</div>
<a id="ac973b30789682417b95981a6ea093fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac973b30789682417b95981a6ea093fb3">&#9670;&nbsp;</a></span>registerSubsetOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::registerSubsetOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2SubsetInsertionOpInterfaceImpl_8cpp_source.html#l00072">72</a> of file <a class="el" href="Linalg_2Transforms_2SubsetInsertionOpInterfaceImpl_8cpp_source.html">SubsetInsertionOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AllInterfaces_8cpp_source.html#l00017">registerAllDialectInterfaceImplementations()</a>, and <a class="el" href="RegisterAllDialects_8cpp_source.html#l00107">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ae430d8314310084f3bfae3c0de4081dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae430d8314310084f3bfae3c0de4081dd">&#9670;&nbsp;</a></span>registerTilingInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::registerTilingInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l01407">1407</a> of file <a class="el" href="TilingInterfaceImpl_8cpp_source.html">TilingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l01401">registerAll()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AllInterfaces_8cpp_source.html#l00017">registerAllDialectInterfaceImplementations()</a>, and <a class="el" href="RegisterAllDialects_8cpp_source.html#l00107">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a61ea527040089116cd00f5fec9802ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ea527040089116cd00f5fec9802ad8">&#9670;&nbsp;</a></span>registerTilingInterfaceExternalModelsForPackUnPackOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::registerTilingInterfaceExternalModelsForPackUnPackOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the above registeration, but it is only for <code>tensor.pack</code> and <code>tensor.unpack</code> ops. </p>

<p class="definition">Definition at line <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l01419">1419</a> of file <a class="el" href="TilingInterfaceImpl_8cpp_source.html">TilingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

</div>
</div>
<a id="ae64270d2058ef5fd99281df6e7de4464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64270d2058ef5fd99281df6e7de4464">&#9670;&nbsp;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::nvgpu::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectExtension_8cpp_source.html#l00058">58</a> of file <a class="el" href="DialectExtension_8cpp_source.html">DialectExtension.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00222">mlir::DialectRegistry::addExtensions()</a>.</p>

</div>
</div>
<a id="a5e756b2e152d167af6823f8fb6298933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e756b2e152d167af6823f8fb6298933">&#9670;&nbsp;</a></span>registerValueBoundsOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::registerValueBoundsOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00054">54</a> of file <a class="el" href="Linalg_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

</div>
</div>
<a id="a0369f798f7a1803f0c897c0f33edb5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0369f798f7a1803f0c897c0f33edb5e5">&#9670;&nbsp;</a></span>reifyResultShapesImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::linalg::reifyResultShapesImpl </td>
          <td>(</td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0a5ee68dc80640e6ac9c4a6011d18bc1">ReifiedRankedShapedTypeDims</a> &amp;&#160;</td>
          <td class="paramname"><em>reifiedReturnShapes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l04587">4587</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00070">mlir::tensor::getMixedSizes()</a>.</p>

</div>
</div>
<a id="a08d1dafbd1447fdcbad0e11434292563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d1dafbd1447fdcbad0e11434292563">&#9670;&nbsp;</a></span>rewriteAsPaddedOp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::rewriteAsPaddedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>opToPad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp &amp;&#160;</td>
          <td class="paramname"><em>paddedOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; tensor::PadOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>padOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pad the iterator dimensions <code>options.paddingDimensions</code> of all <code>opToPad</code> operands to a static bounding box. </p>
<p>The original <code>opToPad</code> is cloned and operates on the padded tensors.</p>
<ul>
<li>"options.padToMultipleOf" indicates that each padding dimension should be padded to the specified multiple.</li>
<li>Use "options.paddingValues" and "options.nofoldFlags" to set padding value and nofold attribute of the created tensor::PadOps, respectively.</li>
<li>The unpadded results (extracted slice of the cloned operation) are returned via <code>replacements</code>.</li>
<li>The tensor::PadOps are returned via <code>padOps</code>.</li>
<li>"options.copyBackOp" specifies the op type for copying back the unpadded result to the original destination tensor. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Padding_8cpp_source.html#l00244">244</a> of file <a class="el" href="Padding_8cpp_source.html">Padding.cpp</a>.</p>

<p class="reference">References <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00197">mlir::clone()</a>, <a class="el" href="Padding_8cpp_source.html#l00023">DBGS</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00023">mlir::getElementTypeOrSelf()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="classmlir_1_1ValueRange.html#ab8f3a1aeea4da0acfaad1bc71b072017">mlir::ValueRange::getTypes()</a>, <a class="el" href="Builders_8cpp_source.html#l00319">mlir::Builder::getZeroAttr()</a>, <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html#a0bb964c0ac97b344abe7f245952882f1aa2cb215f91a0fc3791c22a870940f877">mlir::linalg::LinalgPaddingOptions::LinalgCopy</a>, <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html#a0bb964c0ac97b344abe7f245952882f1a6adf97f83acf6453d4a6a4b1070f3754">mlir::linalg::LinalgPaddingOptions::None</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="Padding_8cpp_source.html#l00187">padOperandToSmallestStaticBoundingBox()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00027">mlir::reifyResultShapes()</a>, and <a class="el" href="Builders_8h_source.html#l00410">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Padding_8cpp_source.html#l00355">padAndHoistLinalgOp()</a>.</p>

</div>
</div>
<a id="ae0bb7dd79e2a9d97a336bbd51ac947a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0bb7dd79e2a9d97a336bbd51ac947a4">&#9670;&nbsp;</a></span>rewriteAsPaddedOp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; TilingInterface &gt; mlir::linalg::rewriteAsPaddedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>opToPad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>constOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; tensor::PadOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>padOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1linalg.html#ac636a02565dd1c1bdcb8eb5982bd07c1">PadSizeComputationFunction</a>&#160;</td>
          <td class="paramname"><em>computePaddingSizeFun</em> = <code>&amp;<a class="el" href="namespacemlir_1_1linalg.html#a8cf886d8eb4668c4b2ad34db3a2d4bad">computeIndexingMapOpInterfacePaddedShape</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pad the iterator dimensions <code>options.paddingDimensions</code> of <code>opToPad</code>. </p>
<ul>
<li>"options.paddingSizes" indicates that each padding dimension should be padded to the specified padding size.</li>
<li>"options.padToMultipleOf" indicates that the paddingSizes should be</li>
<li>Use "options.paddingValues" to set the padding value of the created</li>
<li>The tensor::PadOp is returned on success. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="PadTilingInterface_8cpp_source.html#l00261">261</a> of file <a class="el" href="PadTilingInterface_8cpp_source.html">PadTilingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00197">mlir::clone()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00031">DBGS</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00023">mlir::getElementTypeOrSelf()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="classmlir_1_1ValueRange.html#ab8f3a1aeea4da0acfaad1bc71b072017">mlir::ValueRange::getTypes()</a>, <a class="el" href="Builders_8cpp_source.html#l00319">mlir::Builder::getZeroAttr()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00226">padOperand()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00027">mlir::reifyResultShapes()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Builders_8h_source.html#l00410">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

</div>
</div>
<a id="a5a579fdd0e468c7aec96f84d016c829e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a579fdd0e468c7aec96f84d016c829e">&#9670;&nbsp;</a></span>rewriteInDestinationPassingStyle() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::rewriteInDestinationPassingStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::FromElementsOp&#160;</td>
          <td class="paramname"><em>fromElementsOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite tensor.from_elements to linalg.generic. </p>
<p>Lower tensor.from_elements to a sequence of chained tensor.insert. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00350">350</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00032">createInserts()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00519">mlir::RewriterBase::replaceOpWithNewOp()</a>.</p>

</div>
</div>
<a id="ab2e500c4bf906d65572af9b3d2982852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e500c4bf906d65572af9b3d2982852">&#9670;&nbsp;</a></span>rewriteInDestinationPassingStyle() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::rewriteInDestinationPassingStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::GenerateOp&#160;</td>
          <td class="paramname"><em>generateOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite tensor.generate to linalg.generic. </p>
<p>Lower tensor.generate to linalg.generic. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00388">388</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00425">mlir::OpBuilder::createBlock()</a>, <a class="el" href="Builders_8cpp_source.html#l00382">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00343">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00519">mlir::RewriterBase::replaceOpWithNewOp()</a>, and <a class="el" href="Builders_8h_source.html#l00429">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="acf3e743297fd7a20a30c7c4e39608fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3e743297fd7a20a30c7c4e39608fbc">&#9670;&nbsp;</a></span>rewriteInDestinationPassingStyle() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::rewriteInDestinationPassingStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp&#160;</td>
          <td class="paramname"><em>padOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite tensor.pad to linalg.generic + tensor.insert_slice. </p>
<p>Lower tensor.pad to linalg.generic + tensor.insert_slice. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00429">429</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00070">mlir::tensor::getMixedSizes()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00018">mlir::isZeroInteger()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00093">movePaddingToFillOrGenericOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00027">mlir::reifyResultShapes()</a>, <a class="el" href="PatternMatch_8h_source.html#l00519">mlir::RewriterBase::replaceOpWithNewOp()</a>, and <a class="el" href="Builders_8h_source.html#l00410">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

</div>
</div>
<a id="ad43dfb86d76bed86ecd1117849e5b6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43dfb86d76bed86ecd1117849e5b6f4">&#9670;&nbsp;</a></span>rewriteInIm2Col() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt; mlir::linalg::rewriteInIm2Col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::Conv2DNchwFchwOp&#160;</td>
          <td class="paramname"><em>convOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to rewriteInIm2Col with linalg::Conv2DNhwcHwcfOp except because the channels are to the left of the image shape dimensions, the position of the contraction dimension in the resulting matmul is reversed. </p>
<p>This swaps the LHS and RHS of the matmul when compared with nhwc (i.e. (D, C x Kh x Kw) * (C x Kh x Kw, Ho x Wo)) </p>

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00365">365</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00069">getConvolvedIndex()</a>, <a class="el" href="Value_8cpp_source.html#l00024">mlir::Value::getLoc()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00026">hasAllOneValues()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00054">unrollIndex()</a>.</p>

</div>
</div>
<a id="a7efbd1a00187259d6074a842842175c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7efbd1a00187259d6074a842842175c2">&#9670;&nbsp;</a></span>rewriteInIm2Col() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt; mlir::linalg::rewriteInIm2Col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::Conv2DNhwcFhwcOp&#160;</td>
          <td class="paramname"><em>convOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as the above but for Fhwc channel orderings in the filter. </p>
<p>In this case the matrix multiplication is actually a row-wise dot-product rather than a row-column dot-product. This is to avoid transposing the filter matrix which would be required for a regular matrix multiplication to produce the correct output dimensions. </p>

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00498">498</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00069">getConvolvedIndex()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00026">hasAllOneValues()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00054">unrollIndex()</a>.</p>

</div>
</div>
<a id="a0e2c1f265ce47a53398eab6e8f18b30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2c1f265ce47a53398eab6e8f18b30c">&#9670;&nbsp;</a></span>rewriteInIm2Col() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt; mlir::linalg::rewriteInIm2Col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::Conv2DNhwcHwcfOp&#160;</td>
          <td class="paramname"><em>convOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert linalg.conv_2d_nhwc_hwcf into linalg.generic (for img2col packing) and linalg.matmul. </p>
<p>A convolution operation can be written as a matrix-matrix multiplication by unfolding the cross-correlation between input and filter and explicitly copy overlapped sliding window inputs.</p>
<p>Consider 2D input X with single channel input and output and 2x2 filter W: [x(0, 0) , x(0, 1) , ..., x(0, n) ] [x(1, 0) , x(1, 1) , ..., x(1, n) ] [. , . ,. , . ] [w(0, 0), w(0, 1)] [. , . , . , . ] (conv) [w(1, 0), w(1, 1)] [. , . , ., . ] [x(n-1, 0), x(n-1, 1), ..., x(n-1, n-1)]</p>
<p>The packed input data (img2col) is a matrix with |rows| = output spatial size, |columns| = filter spatial size. To compute the output Y(i, j) we need to calculate the dot product between filter window at input X(x, y)) and the filter which will look like the following where r.h.s is the img2col matrix and l.h.s is the flattened filter:</p>
<p>[x(0,0), x(0,1), x(1,0), x(1,1)] [x(0,1), x(1,1), x(0,2), x(1,2)] (matmul) [w(0,0), w(0,1), w(1,0), w(1,1)] [x(0,1), x(1,1), x(0,2), x(1,2)] [ . , . , . , . ]</p>
<p>In general for 2D case with (N, H, W, C) input and (Kh, Kw, C, D) filter and output (N, Ho, Wo, D) the convolution is the following matrix-matrix multiplication (Ho x Wo, Kh x Kw x C) * (Kh x Kw x C, D) for each input in the N input. For the case where N &gt; 1 its a batched matrix-matrix multiplication.</p>
<p>On success, return both the operation that produces the img2col tensor and the final operation of the sequence that replaces the original convolution. </p>

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00078">78</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00069">getConvolvedIndex()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00026">hasAllOneValues()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00054">unrollIndex()</a>.</p>

</div>
</div>
<a id="a49f61511bb9ed963c3eeb360bfdb1a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f61511bb9ed963c3eeb360bfdb1a6a">&#9670;&nbsp;</a></span>rewriteInIm2Col() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt; mlir::linalg::rewriteInIm2Col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::DepthwiseConv2DNhwcHwcOp&#160;</td>
          <td class="paramname"><em>convOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to rewriteInIm2Col with linalg::Conv2DNhwcHwcfOp except there is no reduction among the input channels so each convolution can be a matrix-vector product and by transposing both input filter so channels are outer most the computation is a batched matrix-vector product. </p>

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00213">213</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00367">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00359">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00026">hasAllOneValues()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>.</p>

</div>
</div>
<a id="a3be344205769eaea42d412b4c0fae11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be344205769eaea42d412b4c0fae11a">&#9670;&nbsp;</a></span>specializeGenericOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; LinalgOp &gt; mlir::linalg::specializeGenericOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>genericOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a namedOp from the given GenericOp and replace the GenericOp. </p>
<p>Currently we can specialize only trivial linalg copy operations. </p>

<p class="definition">Definition at line <a class="el" href="Specialize_8cpp_source.html#l00258">258</a> of file <a class="el" href="Specialize_8cpp_source.html">Specialize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Specialize_8cpp_source.html#l00056">areBinOpsSwapped()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00141">isaBroadcastOpInterface()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00568">isaContractionOpInterface()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00061">isaCopyOpInterface()</a>, <a class="el" href="namespacemlir_1_1linalg.html#afc247b3bd43d4462293e09845b698e7a">isaElemwiseSingleBinaryOpInterface()</a>, <a class="el" href="namespacemlir_1_1linalg.html#a14eec3edd7d29c8980b155ed0dee1a0c">isaElemwiseSingleUnaryOpInterface()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00131">isaFillOpInterface()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00191">isaTransposeOpInterface()</a>, <a class="el" href="Specialize_8cpp_source.html#l00030">REPLACE_BINARY_OP</a>, <a class="el" href="Specialize_8cpp_source.html#l00037">REPLACE_UNARY_OP</a>, and <a class="el" href="PatternMatch_8h_source.html#l00519">mlir::RewriterBase::replaceOpWithNewOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01615">mlir::linalg::LinalgSpecializationPattern::returningMatchAndRewrite()</a>.</p>

</div>
</div>
<a id="af025e45095e64f984901c4f65fa3c72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af025e45095e64f984901c4f65fa3c72f">&#9670;&nbsp;</a></span>splitOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; TilingInterface, TilingInterface &gt; mlir::linalg::splitOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>splitPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given <code>op</code> into two parts along the given iteration space <code>dimension</code> at the specified <code>splitPoint</code>, and return the two parts. </p>
<p>If the second part is statically known to be empty, do not create it and return nullptr instead. Error state is signalled by returning a pair of nullptrs.</p>
<p>For example, the following op:</p>
<p>linalg.matmul ins(%0, %1 : tensor&lt;128x32xf32&gt;, tensor&lt;32x64xf32&gt;) outs(%2 : tensor&lt;128x64xf32&gt;)</p>
<p>split along the first dimension at position 42 will result in:</p>
<p>%3 = tensor.extract_slice %0[0, 0][42, 32][1, 1] %4 = tensor.extract_slice %2[0, 0][42, 64][1, 1] %5 = linalg.matmul ins(%3, %1 : tensor&lt;42x32xf32&gt;, tensor&lt;32x64xf32&gt;) outs(%5 : tensor&lt;42x64xf32&gt;) %6 = tensor.insert_slice %5 into %2[0, 0][42, 64][1, 1]</p>
<p>%7 = tensor.extract_slice %0[42, 0][86, 32][1, 1] %8 = tensor.extract_slice %6[42, 0][86, 64][1, 1] %9 = linalg.matmul ins(%7, %1 : tensor&lt;86x32xf32&gt;, tensor&lt;32x64xf32&gt;) outs(%8 : tensor&lt;86x64xf32&gt;) tensor.insert_slice %5 into %6[42, 0][86, 64][1, 1]</p>
<p>Note that there is no simplification other than constant propagation applied to slice extraction and insertion. </p>

<p class="definition">Definition at line <a class="el" href="Split_8cpp_source.html#l00067">67</a> of file <a class="el" href="Split_8cpp_source.html">Split.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="Split_8cpp_source.html#l00032">createSplitPart()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00114">mlir::tensor::getOrCreateDestinations()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">mlir::AffineMap::inferFromExprList()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01430">mlir::affine::makeComposedFoldedAffineMin()</a>, <a class="el" href="PatternMatch_8h_source.html#l00628">mlir::RewriterBase::modifyOpInPlace()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00036">mlir::Range::offset</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00037">mlir::Range::size</a>.</p>

</div>
</div>
<a id="aaa4f58f6a18fb7c9af60fb15122e0994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4f58f6a18fb7c9af60fb15122e0994">&#9670;&nbsp;</a></span>splitReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a> &gt; mlir::linalg::splitReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlSplitReductionFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlloc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SplitReduction_8cpp_source.html#l00030">30</a> of file <a class="el" href="SplitReduction_8cpp_source.html">SplitReduction.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00359">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00411">mlir::AffineMap::getDimPosition()</a>, <a class="el" href="Builders_8cpp_source.html#l00382">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02726">mlir::arith::getNeutralElement()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00482">mlir::linalg::SplitReductionOptions::index</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00376">mlir::RewriterBase::inlineRegionBefore()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00484">mlir::linalg::SplitReductionOptions::innerParallel</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00288">mlir::matchReduction()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00479">mlir::linalg::SplitReductionOptions::ratio</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="af87c3f5c965b8e271579136775d51ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87c3f5c965b8e271579136775d51ffc">&#9670;&nbsp;</a></span>splitReductionByScaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a> &gt; mlir::linalg::splitReductionByScaling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlSplitReductionFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlloc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scaling-based implementation of the split reduction transformation. </p>
<p>Core rewrite implementation.</p>
<p>Instead of introducing an ExpandShapeOp, this rewrites a reduction dimension <code>k</code> into <code>k * scale + kk</code>.</p>
<p>Example: ``` %0 = linalg.matmul ins(A, B: tensor&lt;16x256xf32&gt;, tensor&lt;256x32xf32&gt;) outs(C: tensor&lt;16x32xf32&gt;) -&gt; tensor&lt;16x32xf32&gt; ```</p>
<p>Is transformed to:</p>
<p>``` #map0 = affine_map&lt;(d0, d1, d2, d3) -&gt; (d0, d2 * 4 + d3)&gt; #map1 = affine_map&lt;(d0, d1, d2, d3) -&gt; (d2 * 4 + d3, d1)&gt; #map2 = affine_map&lt;(d0, d1, d2, d3) -&gt; (d2, d3)&gt; #map3 = affine_map&lt;(d0, d1, d2, d3) -&gt; (d0, d1, d2)&gt; #map4 = affine_map&lt;(d0, d1, d2) -&gt; (d0, d1, d2)&gt; #map5 = affine_map&lt;(d0, d1, d2) -&gt; (d0, d1)&gt; %0 = tensor.empty [16, 32, 64] : tensor&lt;16x32x64xf32&gt; cst = arith.constant 0.000000e+00 : f32 %1 = linalg.fill ins(cst : f32) outs(%0 : tensor&lt;16x32x64xf32&gt;) -&gt; tensor&lt;16x32x64xf32&gt; %2 = tensor.empty [64, 4] : tensor&lt;64x4xi1&gt;</p>
<p>%3 = linalg.generic {indexing_maps = [#map0, #map1, #map2, #map3], iterator_types = ["parallel", "parallel", "parallel", "reduction"]} ins(A, B, %2 : tensor&lt;16x256xf32&gt;, tensor&lt;256x32xf32&gt;, tensor&lt;64x4xi1&gt;) outs(%1 : tensor&lt;16x32x64xf32&gt;) { ^bb0(arg3: f32, arg4: f32, arg5: i1, arg6: f32): %5 = arith.mulf arg3, arg4 : f32 %6 = arith.addf arg6, %5 : f32 linalg.yield %6 : f32 } -&gt; tensor&lt;16x32x64xf32&gt;</p>
<p>%4 = linalg.generic {indexing_maps = [#map4, #map5], iterator_types = ["parallel", "parallel", "reduction"]} */ // ins(%3 : tensor&lt;16x32x64xf32&gt;) /** outs(C : tensor&lt;16x32xf32&gt;) { ^bb0(arg3: f32, arg4: f32): %5 = arith.addf arg3, arg4 : f32 linalg.yield %5 : f32 } -&gt; tensor&lt;16x32xf32&gt;</p>
<p>return %4 : tensor&lt;16x32xf32&gt; ``` </p>

<p class="definition">Definition at line <a class="el" href="SplitReduction_8cpp_source.html#l00241">241</a> of file <a class="el" href="SplitReduction_8cpp_source.html">SplitReduction.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00548">mlir::OpBuilder::clone()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00062">mlir::tensor::createDynamicDimValues()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00293">mlir::AffineMap::dropResult()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00619">mlir::getAffineDimExpr()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Builders_8cpp_source.html#l00066">mlir::Builder::getIntegerType()</a>, <a class="el" href="Builders_8cpp_source.html#l00382">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02726">mlir::arith::getNeutralElement()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00482">mlir::linalg::SplitReductionOptions::index</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00376">mlir::RewriterBase::inlineRegionBefore()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00484">mlir::linalg::SplitReductionOptions::innerParallel</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00264">mlir::RankedTensorType::Builder::insertDim()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00230">insertParallelDim()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00288">mlir::matchReduction()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00479">mlir::linalg::SplitReductionOptions::ratio</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00215">scaleReductionDim()</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00351">mlir::Operation::setOperand()</a>.</p>

</div>
</div>
<a id="ac13050e75a64a26bf82a80b19006d0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13050e75a64a26bf82a80b19006d0e9">&#9670;&nbsp;</a></span>tileLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt; mlir::linalg::tileLinalgOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00817">817</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="ab3085a8dbbf3c572b3279bdcc53dbe72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3085a8dbbf3c572b3279bdcc53dbe72">&#9670;&nbsp;</a></span>tileReductionUsingForall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html">linalg::ForallReductionTilingResult</a> &gt; mlir::linalg::tileReductionUsingForall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartialReductionOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; ArrayAttr &gt;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to tile a reduction to parallel iterations computing partial reductions. </p>
<p>After the loop all the partial reduction are merged into a final reduction. For example for the following sequence</p>
<div class="fragment"><div class="line">%0 = linalg.generic %in [&quot;parallel&quot;, &quot;reduction&quot;]</div>
<div class="line">  : tensor&lt;7x9xf32&gt; -&gt; tensor&lt;7xf32&gt;</div>
</div><!-- fragment --><p>into:</p>
<div class="fragment"><div class="line">%0 = linalg.fill ... : tensor&lt;7x4xf32&gt;</div>
<div class="line">%1 = scf.forall (%iv) in (%c4) shared_outs(%arg0 = %0)</div>
<div class="line">  -&gt; (tensor&lt;7x4xf32&gt;) {</div>
<div class="line">  %2 = tensor.extract_slice %arg3 : tensor&lt;7x4xf32&gt; to tensor&lt;7xf32&gt;</div>
<div class="line">  %3 = tensor.extract_slice %in : tensor&lt;7x9xf32&gt; -&gt; tensor&lt;7x?xf32&gt;</div>
<div class="line">  %4 = linalg.generic %2, %3 [&quot;parallel&quot;, &quot;reduction&quot;]</div>
<div class="line">    : tensor&lt;7x?xf32&gt; -&gt; tensor&lt;7xf32&gt;</div>
<div class="line">  %5 = tensor.insert_slice %3, %arg0[0, %iv] : tensor&lt;7x4xf32&gt;</div>
<div class="line">}</div>
<div class="line">%6 = linalg.generic %1 [&quot;parallel&quot;, &quot;reduction&quot;]</div>
<div class="line">  : tensor&lt;7x4xf32&gt; -&gt; tensor&lt;7xf32&gt;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00589">589</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tiling_8cpp_source.html#l00362">calculateTileOffsetsAndSizes()</a>, <a class="el" href="Builders_8cpp_source.html#l00548">mlir::OpBuilder::clone()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00267">mlir::Operation::emitError()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00079">mlir::getAsOpFoldResult()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00114">mlir::tensor::getOrCreateDestinations()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01018">mlir::linalg::ForallReductionTilingResult::initialValues</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00018">mlir::isZeroInteger()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01020">mlir::linalg::ForallReductionTilingResult::loops</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01709">mlir::affine::mapLoopToProcessorIds()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01016">mlir::linalg::ForallReductionTilingResult::mergeOps</a>, <a class="el" href="PatternMatch_8h_source.html#l00628">mlir::RewriterBase::modifyOpInPlace()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01014">mlir::linalg::ForallReductionTilingResult::parallelTiledOps</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00410">mlir::OpBuilder::setInsertionPointAfter()</a>, and <a class="el" href="Builders_8h_source.html#l00434">mlir::OpBuilder::setInsertionPointToEnd()</a>.</p>

</div>
</div>
<a id="a1b2368f6f815597fcf395106e8978e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2368f6f815597fcf395106e8978e44">&#9670;&nbsp;</a></span>transformIndexOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::transformIndexOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">LoopIndexToRangeIndexMap</a> &amp;&#160;</td>
          <td class="paramname"><em>loopIndexToRangeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All indices returned by IndexOp should be invariant with respect to tiling. </p>
<p>Therefore, if an operation is tiled, we have to transform the indices accordingly, i.e. offset them by the values of the corresponding induction variables that are captured implicitly in the body of the op.</p>
<p>Example. <code>linalg.generic</code> before tiling:</p>
<p>#id_2d = (i, j) -&gt; (i, j) #pointwise_2d_trait = { indexing_maps = [#id_2d, #id_2d], iterator_types = ["parallel", "parallel"] } linalg.generic #pointwise_2d_trait operand, result { ^bb0(operand_in: f32, result_in: f32): i = linalg.index 0 : index j = linalg.index 1 : index &lt;some operations that use i, j&gt; }: memref&lt;50x100xf32&gt;, memref&lt;50x100xf32&gt;</p>
<p>After tiling pass with tiles sizes 10 and 25:</p>
<p>#strided = (i, j)[s0, s1, s2] -&gt; (i * s1 + s0 + j * s2)</p>
<p>c1 = arith.constant 1 : index c0 = arith.constant 0 : index c25 = arith.constant 25 : index c10 = arith.constant 10 : index operand_dim_0 = dim operand, 0 : memref&lt;50x100xf32&gt; operand_dim_1 = dim operand, 1 : memref&lt;50x100xf32&gt; scf.for k = c0 to operand_dim_0 step c10 { scf.for l = c0 to operand_dim_1 step c25 { %4 = memref.subview operand[k, l][c10, c25][c1, c1] : memref&lt;50x100xf32&gt; to memref&lt;?x?xf32, #strided&gt; %5 = memref.subview result[k, l][c10, c25][c1, c1] : memref&lt;50x100xf32&gt; to memref&lt;?x?xf32, #strided&gt; linalg.generic pointwise_2d_trait %4, %5 { ^bb0(operand_in: f32, result_in: f32): i = linalg.index 0 : index j = linalg.index 1 : index // Indices <code>k</code> and <code>l</code> are implicitly captured in the body. transformed_i = arith.addi i, k : index // index <code>i</code> is offset by k transformed_j = arith.addi j, l : index // index <code>j</code> is offset by l // Every use of i, j is replaced with transformed_i, transformed_j &lt;some operations that use transformed_i, transformed_j&gt; }: memref&lt;?x?xf32, #strided&gt;, memref&lt;?x?xf32, #strided&gt; } }</p>
<p>TODO: Investigate whether mixing implicit and explicit indices does not lead to losing information. </p>

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00073">73</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00079">mlir::getAsOpFoldResult()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00884">offsetIndices()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="a816f67d5546592d18de9ec5de0e791f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816f67d5546592d18de9ec5de0e791f3">&#9670;&nbsp;</a></span>transposeBatchMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::transposeBatchMatmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::BatchMatmulOp&#160;</td>
          <td class="paramname"><em>batchMatmulOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposeLHS</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to replace. </p>
<p>linalg.batch_matmul(a, b)</p>
<p>with</p>
<p>linalg.batch_matmul_transpose_a(linalg.transpose(a), b)</p>
<p>Only the non-batch dimensions are transposed. By default the LHS is transposed. Set <code>transposeLHS=false</code> to transpose RHS instead. </p>

<p class="definition">Definition at line <a class="el" href="TransposeMatmul_8cpp_source.html#l00087">87</a> of file <a class="el" href="TransposeMatmul_8cpp_source.html">TransposeMatmul.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>.</p>

</div>
</div>
<a id="a6ea35f9b824fbdf551b76ddf974fc418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea35f9b824fbdf551b76ddf974fc418">&#9670;&nbsp;</a></span>transposeConv2D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::transposeConv2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::Conv2DNhwcFhwcOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert linalg.conv_2d_nhwc_fhwc(_q) to linalg.conv_2d_nhwc_hwcf(_q) by materializing transpose. </p>

<p class="definition">Definition at line <a class="el" href="TransposeConv2D_8cpp_source.html#l00120">120</a> of file <a class="el" href="TransposeConv2D_8cpp_source.html">TransposeConv2D.cpp</a>.</p>

</div>
</div>
<a id="ada14eab9218f7ff7f15f695a980fb717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada14eab9218f7ff7f15f695a980fb717">&#9670;&nbsp;</a></span>transposeConv2D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::transposeConv2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::Conv2DNhwcFhwcQOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TransposeConv2D_8cpp_source.html#l00127">127</a> of file <a class="el" href="TransposeConv2D_8cpp_source.html">TransposeConv2D.cpp</a>.</p>

</div>
</div>
<a id="ad8836bfb07ad8fc4f7bda9aa174da988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8836bfb07ad8fc4f7bda9aa174da988">&#9670;&nbsp;</a></span>transposeMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::transposeMatmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::MatmulOp&#160;</td>
          <td class="paramname"><em>matmulOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposeLHS</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert Linalg matmul ops to transposed variants. </p>
<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to replace.</p>
<p>linalg.matmul(a, b)</p>
<p>with</p>
<p>linalg.matmul_transpose_a(linalg.transpose(a), b)</p>
<p>By default the LHS is transposed. Set <code>transposeLHS=false</code> to transpose RHS instead. </p>

<p class="definition">Definition at line <a class="el" href="TransposeMatmul_8cpp_source.html#l00030">30</a> of file <a class="el" href="TransposeMatmul_8cpp_source.html">TransposeMatmul.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>.</p>

</div>
</div>
<a id="a0a0775243640f0e58d6cce7f49809b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0775243640f0e58d6cce7f49809b13">&#9670;&nbsp;</a></span>unrollIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; mlir::linalg::unrollIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00054">54</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01967">mlir::affine::delinearizeIndex()</a>, and <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00078">rewriteInIm2Col()</a>.</p>

</div>
</div>
<a id="aeb173d5edf56a08ed3610924312dd364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb173d5edf56a08ed3610924312dd364">&#9670;&nbsp;</a></span>updateBoundsForCyclicDistribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::updateBoundsForCyclicDistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>procId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>nprocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the <code>lb</code>, <code>ub</code> and <code>step</code> to get per processor <code>lb</code>, <code>ub</code> and <code>step</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00410">410</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00629">mlir::getAffineSymbolExpr()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01274">mlir::affine::makeComposedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>.</p>

</div>
</div>
<a id="a303bb59c046a82276569e6b906002997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303bb59c046a82276569e6b906002997">&#9670;&nbsp;</a></span>vectorize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1VectorizationResult.html">VectorizationResult</a> &gt; mlir::linalg::vectorize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputVectorSizes</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>inputScalableVecDims</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>vectorizeNDExtract</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flatten1DDepthwiseConv</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>assumeDynamicDimsMatchVecSizes</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createNamedContraction</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code><a class="el" href="structmlir_1_1linalg_1_1VectorizationResult.html" title="Transformation information returned after vectorizing.">VectorizationResult</a></code> containing the results of the vectorized op, or failure if the transformation fails. </p>
<p>If provided, <code>inputVectorSizes</code> are used to vectorize this operation. <code>inputVectorSizes</code> must match the rank of the iteration space of the operation and the input vector sizes must be greater than or equal to their counterpart iteration space sizes, if static. <code>inputVectorShapes</code> also allows the vectorization of operations with dynamic shapes. Optionally, <code>createNamedContraction</code> can force compatible contractions to be vectorized directly to vector.contract operation. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l02676">2676</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorization_8cpp_source.html#l02623">vectorizeOpPrecondition()</a>.</p>

</div>
</div>
<a id="a8c63bc9239511b70751c238a12f5b1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c63bc9239511b70751c238a12f5b1da">&#9670;&nbsp;</a></span>vectorizeCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::vectorizeCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::CopyOp&#160;</td>
          <td class="paramname"><em>copyOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a suitable vector form for a Copy op with fully static shape. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l02769">2769</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00023">mlir::getElementTypeOrSelf()</a>, <a class="el" href="Builders_8cpp_source.html#l00382">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="File_8h_source.html#l00043">mlir::sparse_tensor::detail::readValue()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00916">mlir::linalg::CopyVectorizationPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a8d0310adee4f127279f9147a71db0181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0310adee4f127279f9147a71db0181">&#9670;&nbsp;</a></span>vectorizeOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::vectorizeOpPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inputVectorSizes</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>inputScalableVecDims</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>vectorizeNDExtract</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flatten1DDepthwiseConv</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return success if the operation can be vectorized. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l02623">2623</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorization_8cpp_source.html#l02671">hasVectorizationImpl()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02121">vectorizeInsertSliceOpPrecondition()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02362">vectorizeLinalgOpPrecondition()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02431">vectorizePackOpPrecondition()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02464">vectorizePadOpPrecondition()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02505">vectorizeScalableVectorPrecondition()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l02100">vectorizeUnPackOpPrecondition()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l02676">vectorize()</a>.</p>

</div>
</div>
<a id="aebfaca7f9267827abf1cddb266e44e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebfaca7f9267827abf1cddb266e44e64">&#9670;&nbsp;</a></span>winogradConv2D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; mlir::linalg::winogradConv2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::Conv2DNhwcFhwcOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::WinogradConv2DFmr&#160;</td>
          <td class="paramname"><em>fmr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="WinogradConv2D_8cpp_source.html#l01185">1185</a> of file <a class="el" href="WinogradConv2D_8cpp_source.html">WinogradConv2D.cpp</a>.</p>

</div>
</div>
<a id="a8c00031d476aa3ea451687f117fabde7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c00031d476aa3ea451687f117fabde7">&#9670;&nbsp;</a></span>winogradConv2D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; mlir::linalg::winogradConv2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::Conv2DNhwcFhwcOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WinogradConv2DFmr&#160;</td>
          <td class="paramname"><em>fmr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert linalg.conv_2d_nhwc_fhwc to Winograd Conv2D algorithm F(m x m, r x r). </p>
<p>m is the dimension size of output and r is the dimension size of filter. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:31 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
