<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::linalg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="namespacemlir_1_1linalg.html">linalg</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mlir::linalg Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:detail" id="r_detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1detail.html">detail</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:BatchMatmulTransposeAOp" id="r_BatchMatmulTransposeAOp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1BatchMatmulTransposeAOp.html">BatchMatmulTransposeAOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <span class="tt">linalg.batch_matmul</span> op that has a transpose map on A.  <a href="classmlir_1_1linalg_1_1BatchMatmulTransposeAOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:BatchMatmulTransposeBOp" id="r_BatchMatmulTransposeBOp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1BatchMatmulTransposeBOp.html">BatchMatmulTransposeBOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <span class="tt">linalg.batch_matmul</span> op that has a transpose map on B.  <a href="classmlir_1_1linalg_1_1BatchMatmulTransposeBOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:BlockPackMatmulOptions" id="r_BlockPackMatmulOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1BlockPackMatmulOptions.html">BlockPackMatmulOptions</a></td></tr>
<tr class="memitem:BufferizeToAllocationOptions" id="r_BufferizeToAllocationOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a></td></tr>
<tr class="memitem:CollapseResult" id="r_CollapseResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1CollapseResult.html">CollapseResult</a></td></tr>
<tr class="memitem:ContinuousTileSizeSpecification" id="r_ContinuousTileSizeSpecification"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ContinuousTileSizeSpecification.html">ContinuousTileSizeSpecification</a></td></tr>
<tr class="memitem:ContractionDimensions" id="r_ContractionDimensions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ContractionDimensions.html">ContractionDimensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions of a Linalg op loops that correspond to different kinds of a contraction dimension.  <a href="structmlir_1_1linalg_1_1ContractionDimensions.html#details">More...</a><br /></td></tr>
<tr class="memitem:ControlDropUnitDims" id="r_ControlDropUnitDims"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation to drop unit-extent dimensions from <span class="tt">linalg.generic</span> operations.  <a href="structmlir_1_1linalg_1_1ControlDropUnitDims.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConvMatcherBuilder" id="r_ConvMatcherBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1ConvMatcherBuilder.html">ConvMatcherBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for building convolution op matchers with minimal boilerplate.  <a href="classmlir_1_1linalg_1_1ConvMatcherBuilder.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConvolutionDimensions" id="r_ConvolutionDimensions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ConvolutionDimensions.html">ConvolutionDimensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions of a Linalg op loops that correspond to different kinds of a convolution dimension.  <a href="structmlir_1_1linalg_1_1ConvolutionDimensions.html#details">More...</a><br /></td></tr>
<tr class="memitem:CopyVectorizationPattern" id="r_CopyVectorizationPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1CopyVectorizationPattern.html">CopyVectorizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorization pattern for memref::CopyOp.  <a href="structmlir_1_1linalg_1_1CopyVectorizationPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:DecomposeOuterUnitDimsPackOpPattern" id="r_DecomposeOuterUnitDimsPackOpPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DecomposeOuterUnitDimsPackOpPattern.html">DecomposeOuterUnitDimsPackOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites a linalg::PackOp into a sequence of:  <a href="structmlir_1_1linalg_1_1DecomposeOuterUnitDimsPackOpPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:DecomposeOuterUnitDimsUnPackOpPattern" id="r_DecomposeOuterUnitDimsUnPackOpPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DecomposeOuterUnitDimsUnPackOpPattern.html">DecomposeOuterUnitDimsUnPackOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites a linalg::UnPackOp into a sequence of:  <a href="structmlir_1_1linalg_1_1DecomposeOuterUnitDimsUnPackOpPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:DecomposePadOpPattern" id="r_DecomposePadOpPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DecomposePadOpPattern.html">DecomposePadOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a tensor::PadOp into a sequence of EmptyOp, FillOp and InsertSliceOp.  <a href="structmlir_1_1linalg_1_1DecomposePadOpPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:DownscaleConv2DOp" id="r_DownscaleConv2DOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DownscaleConv2DOp.html">DownscaleConv2DOp</a></td></tr>
<tr class="memitem:DownscaleDepthwiseConv2DNhwcHwcOp" id="r_DownscaleDepthwiseConv2DNhwcHwcOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DownscaleDepthwiseConv2DNhwcHwcOp.html">DownscaleDepthwiseConv2DNhwcHwcOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites 2-D depthwise convolution ops with size-1 (w, kw) or (h, kh) dimensions into 1-D depthwise convolution ops.  <a href="structmlir_1_1linalg_1_1DownscaleDepthwiseConv2DNhwcHwcOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:DownscaleSizeOneWindowed2DConvolution" id="r_DownscaleSizeOneWindowed2DConvolution"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DownscaleSizeOneWindowed2DConvolution.html">DownscaleSizeOneWindowed2DConvolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites 2-D convolution ops with size-1 window dimensions into 1-D convolution ops.  <a href="structmlir_1_1linalg_1_1DownscaleSizeOneWindowed2DConvolution.html#details">More...</a><br /></td></tr>
<tr class="memitem:DropUnitDimsResult" id="r_DropUnitDimsResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DropUnitDimsResult.html">DropUnitDimsResult</a></td></tr>
<tr class="memitem:ElementwiseOpFusionResult" id="r_ElementwiseOpFusionResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html">ElementwiseOpFusionResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse two <span class="tt">linalg.generic</span> operations that have a producer-consumer relationship captured through <span class="tt">fusedOperand</span>.  <a href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExtractSliceOfPadTensorSwapPattern" id="r_ExtractSliceOfPadTensorSwapPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ExtractSliceOfPadTensorSwapPattern.html">ExtractSliceOfPadTensorSwapPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite extract_slice(tensor.pad(x)) into tensor.pad(extract_slice(x)).  <a href="structmlir_1_1linalg_1_1ExtractSliceOfPadTensorSwapPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:FoldTensorCastPackOp" id="r_FoldTensorCastPackOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1FoldTensorCastPackOp.html">FoldTensorCastPackOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds a tensor.cast op into a consuming PackOp op if the <span class="tt">tensor.cast</span> has source that is more static than the consuming op.  <a href="structmlir_1_1linalg_1_1FoldTensorCastPackOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:FoldTensorCastUnPackOp" id="r_FoldTensorCastUnPackOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1FoldTensorCastUnPackOp.html">FoldTensorCastUnPackOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds a tensor.cast op into a consuming UnPackOp op if the <span class="tt">tensor.cast</span> has source that is more static than the consuming op.  <a href="structmlir_1_1linalg_1_1FoldTensorCastUnPackOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:ForallReductionTilingResult" id="r_ForallReductionTilingResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html">ForallReductionTilingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after reduction tiling.  <a href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:FusionInfo" id="r_FusionInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing the Linalg producer before and after fusion.  <a href="structmlir_1_1linalg_1_1FusionInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:GenerateLoopNest" id="r_GenerateLoopNest"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1GenerateLoopNest.html">GenerateLoopNest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class used to generate nested loops with ranges described by <span class="tt">loopRanges</span> and loop type described by the <span class="tt">iteratorTypes</span>.  <a href="structmlir_1_1linalg_1_1GenerateLoopNest.html#details">More...</a><br /></td></tr>
<tr class="memitem:Im2ColToInputDimsExprs" id="r_Im2ColToInputDimsExprs"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Im2ColToInputDimsExprs.html">Im2ColToInputDimsExprs</a></td></tr>
<tr class="memitem:Im2ColToOperandsExprs" id="r_Im2ColToOperandsExprs"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Im2ColToOperandsExprs.html">Im2ColToOperandsExprs</a></td></tr>
<tr class="memitem:LinalgCopyVTRForwardingPattern" id="r_LinalgCopyVTRForwardingPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html">LinalgCopyVTRForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern:  <a href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinalgCopyVTWForwardingPattern" id="r_LinalgCopyVTWForwardingPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html">LinalgCopyVTWForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern:  <a href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinalgGeneralizationPattern" id="r_LinalgGeneralizationPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgGeneralizationPattern.html">LinalgGeneralizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg generalization pattern.  <a href="structmlir_1_1linalg_1_1LinalgGeneralizationPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinalgLoopDistributionOptions" id="r_LinalgLoopDistributionOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgLoopDistributionOptions.html">LinalgLoopDistributionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options that allow distribution of loops generated in Linalg transforms to processors while generating the loops.  <a href="structmlir_1_1linalg_1_1LinalgLoopDistributionOptions.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinalgOpToLibraryCallRewrite" id="r_LinalgOpToLibraryCallRewrite"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1LinalgOpToLibraryCallRewrite.html">LinalgOpToLibraryCallRewrite</a></td></tr>
<tr class="memitem:LinalgPaddingOptions" id="r_LinalgPaddingOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a></td></tr>
<tr class="memitem:LinalgPromotionOptions" id="r_LinalgPromotionOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a></td></tr>
<tr class="memitem:LinalgSpecializationPattern" id="r_LinalgSpecializationPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgSpecializationPattern.html">LinalgSpecializationPattern</a></td></tr>
<tr class="memitem:LinalgTilingAndFusionOptions" id="r_LinalgTilingAndFusionOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingAndFusionOptions.html">LinalgTilingAndFusionOptions</a></td></tr>
<tr class="memitem:LinalgTilingOptions" id="r_LinalgTilingOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a></td></tr>
<tr class="memitem:LowerPackResult" id="r_LowerPackResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LowerPackResult.html">LowerPackResult</a></td></tr>
<tr class="memitem:LowerUnPackOpResult" id="r_LowerUnPackOpResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LowerUnPackOpResult.html">LowerUnPackOpResult</a></td></tr>
<tr class="memitem:MatmulTransposeAOp" id="r_MatmulTransposeAOp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1MatmulTransposeAOp.html">MatmulTransposeAOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <span class="tt">linalg.matmul</span> op that has a transpose map on A.  <a href="classmlir_1_1linalg_1_1MatmulTransposeAOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:MatmulTransposeBOp" id="r_MatmulTransposeBOp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1MatmulTransposeBOp.html">MatmulTransposeBOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <span class="tt">linalg.matmul</span> op that has a transpose map on B.  <a href="classmlir_1_1linalg_1_1MatmulTransposeBOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:MultiSizeSpecification" id="r_MultiSizeSpecification"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1MultiSizeSpecification.html">MultiSizeSpecification</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A description of a multi-size tiling comprising tile sizes and numbers of tiles, expressed as Values which may or may not be constant.  <a href="structmlir_1_1linalg_1_1MultiSizeSpecification.html#details">More...</a><br /></td></tr>
<tr class="memitem:PackResult" id="r_PackResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold the result of a <span class="tt">pack</span> call.  <a href="structmlir_1_1linalg_1_1PackResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:PackTransposeResult" id="r_PackTransposeResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PackTransposeResult.html">PackTransposeResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold the result of a <span class="tt">packTranspose</span> call.  <a href="structmlir_1_1linalg_1_1PackTransposeResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:PadTilingInterfaceOptions" id="r_PadTilingInterfaceOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a></td></tr>
<tr class="memitem:PadTilingInterfaceResult" id="r_PadTilingInterfaceResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceResult.html">PadTilingInterfaceResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations and values created in the process of padding a TilingInterface operation.  <a href="structmlir_1_1linalg_1_1PadTilingInterfaceResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:ProcInfo" id="r_ProcInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to get processor ID, and number of processors used for distribution for all parallel loops generated.  <a href="structmlir_1_1linalg_1_1ProcInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:PromotionInfo" id="r_PromotionInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer using the <span class="tt">allocationFn</span> provided.  <a href="structmlir_1_1linalg_1_1PromotionInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:RegionMatcher" id="r_RegionMatcher"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1RegionMatcher.html">RegionMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing common matchers over linalg op's region.  <a href="structmlir_1_1linalg_1_1RegionMatcher.html#details">More...</a><br /></td></tr>
<tr class="memitem:SliceParameters" id="r_SliceParameters"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containg offsets-sizes-strides arguments of the tiled shape.  <a href="structmlir_1_1linalg_1_1SliceParameters.html#details">More...</a><br /></td></tr>
<tr class="memitem:SplitReductionOptions" id="r_SplitReductionOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1SplitReductionOptions.html">SplitReductionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split Reduction options.  <a href="structmlir_1_1linalg_1_1SplitReductionOptions.html#details">More...</a><br /></td></tr>
<tr class="memitem:SplitReductionResult" id="r_SplitReductionResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply transformation to split the single linalg op reduction into a parallel and reduction dimension.  <a href="structmlir_1_1linalg_1_1SplitReductionResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:StaticContinuousTileSizeSpecification" id="r_StaticContinuousTileSizeSpecification"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1StaticContinuousTileSizeSpecification.html">StaticContinuousTileSizeSpecification</a></td></tr>
<tr class="memitem:StaticMultiSizeSpecification" id="r_StaticMultiSizeSpecification"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1StaticMultiSizeSpecification.html">StaticMultiSizeSpecification</a></td></tr>
<tr class="memitem:TiledLinalgOp" id="r_TiledLinalgOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform standalone tiling of a single LinalgOp by <span class="tt">tileSizes</span>.  <a href="structmlir_1_1linalg_1_1TiledLinalgOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:VectorizationResult" id="r_VectorizationResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1VectorizationResult.html">VectorizationResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after vectorizing.  <a href="structmlir_1_1linalg_1_1VectorizationResult.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a71a7fe9b3e7ece0cd20b6d4d11e08f6c" id="r_a71a7fe9b3e7ece0cd20b6d4d11e08f6c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71a7fe9b3e7ece0cd20b6d4d11e08f6c">TileSizeComputationFunction</a></td></tr>
<tr class="memitem:a9ada278f74ee670af18b6bfd04271e3b" id="r_a9ada278f74ee670af18b6bfd04271e3b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ada278f74ee670af18b6bfd04271e3b">AllocBufferCallbackFn</a></td></tr>
<tr class="memdesc:a9ada278f74ee670af18b6bfd04271e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to perform the allocation for the promoted <span class="tt">subView</span>.  <br /></td></tr>
<tr class="memitem:abaf9a66d9ea1e1ccf22b88fd5f1446dc" id="r_abaf9a66d9ea1e1ccf22b88fd5f1446dc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abaf9a66d9ea1e1ccf22b88fd5f1446dc">DeallocBufferCallbackFn</a></td></tr>
<tr class="memdesc:abaf9a66d9ea1e1ccf22b88fd5f1446dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to deallocate the buffers used to hold the promoted subview.  <br /></td></tr>
<tr class="memitem:ae5b803f6d2ca1c42dc889264b80b690e" id="r_ae5b803f6d2ca1c42dc889264b80b690e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5b803f6d2ca1c42dc889264b80b690e">CopyCallbackFn</a></td></tr>
<tr class="memdesc:ae5b803f6d2ca1c42dc889264b80b690e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to insert copy from original subview to subview of the promoted region for the read operands/subview of promoted region to original subview for the results.  <br /></td></tr>
<tr class="memitem:a505f71c7a182531357360cb2151dc1f3" id="r_a505f71c7a182531357360cb2151dc1f3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a505f71c7a182531357360cb2151dc1f3">ControlSplitReductionFn</a></td></tr>
<tr class="memdesc:a505f71c7a182531357360cb2151dc1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function signature to control reduction splitting.  <br /></td></tr>
<tr class="memitem:a193831e3afcf32c859a980c17c8c276b" id="r_a193831e3afcf32c859a980c17c8c276b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a193831e3afcf32c859a980c17c8c276b">LinalgLoops</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, 4&gt;</td></tr>
<tr class="memitem:a0752c7523022c2c98068a86865e35096" id="r_a0752c7523022c2c98068a86865e35096"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0752c7523022c2c98068a86865e35096">DroppedUnitDimsBuilder</a></td></tr>
<tr class="memitem:a1f5ce0fcb27f388f81435ec80109e7c6" id="r_a1f5ce0fcb27f388f81435ec80109e7c6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f5ce0fcb27f388f81435ec80109e7c6">PadSizeComputationFunction</a></td></tr>
<tr class="memitem:ac63ef3b10f63a46b5d07ad3cbf2ed19d" id="r_ac63ef3b10f63a46b5d07ad3cbf2ed19d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac63ef3b10f63a46b5d07ad3cbf2ed19d">LoopIndexToRangeIndexMap</a> = <a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt;int, int&gt;</td></tr>
<tr class="memdesc:ac63ef3b10f63a46b5d07ad3cbf2ed19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a number of ranges equal to the number of non-zero in <span class="tt">tileSizes</span>.  <br /></td></tr>
<tr class="memitem:a41903a6655e9be09920ce399e3e71865" id="r_a41903a6655e9be09920ce399e3e71865"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41903a6655e9be09920ce399e3e71865">ControlBlockPackMatmulFn</a></td></tr>
<tr class="memdesc:a41903a6655e9be09920ce399e3e71865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control matmul packing.  <br /></td></tr>
<tr class="memitem:aa58f7a4c578e94b49e8c3f62f968d7b4" id="r_aa58f7a4c578e94b49e8c3f62f968d7b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa58f7a4c578e94b49e8c3f62f968d7b4">OptimizeCopyFn</a></td></tr>
<tr class="memitem:a9f4136d97cdab12f0760756f1adc1721" id="r_a9f4136d97cdab12f0760756f1adc1721"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f4136d97cdab12f0760756f1adc1721">ControlFusionFn</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)&gt;</td></tr>
<tr class="memdesc:a9f4136d97cdab12f0760756f1adc1721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control when to stop fusion.  <br /></td></tr>
<tr class="memitem:ac7e80c46fd448c104f6709b43c315755" id="r_ac7e80c46fd448c104f6709b43c315755"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7e80c46fd448c104f6709b43c315755">ControlPropagationFn</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *opOperand)&gt;</td></tr>
<tr class="memdesc:ac7e80c46fd448c104f6709b43c315755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control propagation of <a class="el" href="#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a>/unpack ops.  <br /></td></tr>
<tr class="memitem:a56475069e4631a3e7e54964a3fc576bb" id="r_a56475069e4631a3e7e54964a3fc576bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56475069e4631a3e7e54964a3fc576bb">GetCollapsableDimensionsFn</a></td></tr>
<tr class="memdesc:a56475069e4631a3e7e54964a3fc576bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type to control generic op dimension collapsing.  <br /></td></tr>
<tr class="memitem:abf9a441fc28af495ff61ceedd25694d2" id="r_abf9a441fc28af495ff61ceedd25694d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf9a441fc28af495ff61ceedd25694d2">ControlFoldIntoPackUnpackFn</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *opOperand)&gt;</td></tr>
<tr class="memdesc:abf9a441fc28af495ff61ceedd25694d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control folding operations like <span class="tt">tensor.pad</span> and <span class="tt">tensor.extract_slice</span> into <a class="el" href="#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a>/unpack ops.  <br /></td></tr>
<tr class="memitem:aa9d0bb3427f7842586f487adf8b1c892" id="r_aa9d0bb3427f7842586f487adf8b1c892"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9d0bb3427f7842586f487adf8b1c892">ProcInfoCallBackFn</a></td></tr>
<tr class="memitem:aa3c699ae89529032fd3f3dc9ef8fe839" id="r_aa3c699ae89529032fd3f3dc9ef8fe839"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3c699ae89529032fd3f3dc9ef8fe839">GridAxis</a> = <a class="el" href="namespacemlir_1_1shard.html#a7b2656e48e0e6a3a5732246fac941372">shard::GridAxis</a></td></tr>
<tr class="memitem:a9aed87a08c001b3ef7e0fcbd273041aa" id="r_a9aed87a08c001b3ef7e0fcbd273041aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9aed87a08c001b3ef7e0fcbd273041aa">ReductionKind</a> = shard::ReductionKind</td></tr>
<tr class="memitem:a03c57ac3b7bfa817f644e03dcf9a5de2" id="r_a03c57ac3b7bfa817f644e03dcf9a5de2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03c57ac3b7bfa817f644e03dcf9a5de2">Sharding</a> = <a class="el" href="classmlir_1_1shard_1_1Sharding.html">shard::Sharding</a></td></tr>
<tr class="memitem:a410e0d11b6ec42849c958eea40544eb7" id="r_a410e0d11b6ec42849c958eea40544eb7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a410e0d11b6ec42849c958eea40544eb7">ShardingArray</a> = <a class="el" href="namespacemlir_1_1shard.html#afb6ca6cc654847b5555ebca3a999679f">shard::ShardingArray</a></td></tr>
<tr class="memitem:a5b2e5401a45d4e16070ebd5dcaef36b2" id="r_a5b2e5401a45d4e16070ebd5dcaef36b2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b2e5401a45d4e16070ebd5dcaef36b2">GridOp</a> = shard::GridOp</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3cdd229e1459c7e6ed2f9c7ee7168325" id="r_a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cdd229e1459c7e6ed2f9c7ee7168325">LinalgTilingLoopType</a> { <a class="el" href="#a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8">Loops</a> = 0
, <a class="el" href="#a3cdd229e1459c7e6ed2f9c7ee7168325a6d8bf0bdeaca5ef4693524bf04c4c877">AffineLoops</a> = 1
, <a class="el" href="#a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7">ParallelLoops</a> = 2
 }</td></tr>
<tr class="memdesc:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of loops to be generated during tiling.  <a href="#a3cdd229e1459c7e6ed2f9c7ee7168325">More...</a><br /></td></tr>
<tr class="memitem:a7382d59369873eb3a9a9ddd571056982" id="r_a7382d59369873eb3a9a9ddd571056982"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7382d59369873eb3a9a9ddd571056982">DistributionMethod</a> { <a class="el" href="#a7382d59369873eb3a9a9ddd571056982ad71670d62b238eaf063979407361034e">Cyclic</a> = 0
, <a class="el" href="#a7382d59369873eb3a9a9ddd571056982abab54876ff518ecd2d59b46fd3be9c0e">CyclicNumProcsGeNumIters</a> = 1
, <a class="el" href="#a7382d59369873eb3a9a9ddd571056982ad93606014b9a6b479ba0e6faa948540b">CyclicNumProcsEqNumIters</a> = 2
, <a class="el" href="#a7382d59369873eb3a9a9ddd571056982a6adf97f83acf6453d4a6a4b1070f3754">None</a> = 3
 }</td></tr>
<tr class="memdesc:a7382d59369873eb3a9a9ddd571056982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheme used to distribute loops to processors.  <a href="#a7382d59369873eb3a9a9ddd571056982">More...</a><br /></td></tr>
<tr class="memitem:a40d13c577df4b312d3ad45984304cb44" id="r_a40d13c577df4b312d3ad45984304cb44"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40d13c577df4b312d3ad45984304cb44">PoolingType</a> { <br />
&#160;&#160;<a class="el" href="#a40d13c577df4b312d3ad45984304cb44a6adf97f83acf6453d4a6a4b1070f3754">None</a>
, <a class="el" href="#a40d13c577df4b312d3ad45984304cb44a583477bac684bf3bb33dc235e42b2917">MaxSigned</a>
, <a class="el" href="#a40d13c577df4b312d3ad45984304cb44ac2ccac122a6f900a003c02f50e20d192">MaxUnsigned</a>
, <a class="el" href="#a40d13c577df4b312d3ad45984304cb44a4140dce47c9b4d749f275f08b3da30f3">MinSigned</a>
, <br />
&#160;&#160;<a class="el" href="#a40d13c577df4b312d3ad45984304cb44a70bbf81e0c89983c0da9482b2cd24936">MinUnsigned</a>
, <a class="el" href="#a40d13c577df4b312d3ad45984304cb44aa0ec87054b5e5b7847d0d8780a01a3d5">Sum</a>
<br />
 }</td></tr>
<tr class="memdesc:a40d13c577df4b312d3ad45984304cb44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum representing pooling operation types used by <a class="el" href="classmlir_1_1linalg_1_1ConvMatcherBuilder.html" title="Helper class for building convolution op matchers with minimal boilerplate.">ConvMatcherBuilder</a>.  <a href="#a40d13c577df4b312d3ad45984304cb44">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a703d4f21c6f57b8c680dc20dd6928a61" id="r_a703d4f21c6f57b8c680dc20dd6928a61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a703d4f21c6f57b8c680dc20dd6928a61">populateLinalgToStandardConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a703d4f21c6f57b8c680dc20dd6928a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Linalg to Standard.  <br /></td></tr>
<tr class="memitem:a754ec5c5960c640563ddcd9727b77d87" id="r_a754ec5c5960c640563ddcd9727b77d87"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a754ec5c5960c640563ddcd9727b77d87">generateLibraryCallName</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a754ec5c5960c640563ddcd9727b77d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name mangled library call name to disambiguate between different overloads at the C level.  <br /></td></tr>
<tr class="memitem:a962a46fba2ac497e30bb6d23fef35d1a" id="r_a962a46fba2ac497e30bb6d23fef35d1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a962a46fba2ac497e30bb6d23fef35d1a">makeAffineDimExprs</a> (<a class="el" href="classunsigned.html">unsigned</a> num, <a class="el" href="classunsigned.html">unsigned</a> &amp;startIdx, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a962a46fba2ac497e30bb6d23fef35d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">num</span> <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> dimensions at positions [startIdx, startIdx + num) and increments <span class="tt">startIdx</span> to <span class="tt">startIdx + num</span>.  <br /></td></tr>
<tr class="memitem:a956959faad992424aaa215510e50e618" id="r_a956959faad992424aaa215510e50e618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a956959faad992424aaa215510e50e618">extractOrIdentityMap</a> (std::optional&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maybeMap, <a class="el" href="classunsigned.html">unsigned</a> rank, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a956959faad992424aaa215510e50e618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">maybeMap.get()</span> if <span class="tt">maybeMap</span> is set, otherwise returns the symbol-less identity map of <span class="tt">rank</span>.  <br /></td></tr>
<tr class="memitem:a4f8ea0aae80d24eeffa3fef8f1f08c43" id="r_a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f8ea0aae80d24eeffa3fef8f1f08c43">concat</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; a, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; <a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>)</td></tr>
<tr class="memdesc:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector that is the concatenation of <span class="tt">a</span> and <span class="tt">b</span>.  <br /></td></tr>
<tr class="memitem:aaf73bb051fb347d6519cdcb174ba230e" id="r_aaf73bb051fb347d6519cdcb174ba230e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf73bb051fb347d6519cdcb174ba230e">createOrFoldDimOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> val, <a class="el" href="classint64__t.html">int64_t</a> dim)</td></tr>
<tr class="memdesc:aaf73bb051fb347d6519cdcb174ba230e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create one memref::DimOp or tensor::DimOp depending on the type of <span class="tt">val</span>.  <br /></td></tr>
<tr class="memitem:a6dac633b692c130881f315320220fcce" id="r_a6dac633b692c130881f315320220fcce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dac633b692c130881f315320220fcce">createFoldedDimOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> val, <a class="el" href="classint64__t.html">int64_t</a> dim)</td></tr>
<tr class="memdesc:a6dac633b692c130881f315320220fcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create one memref::DimOp or tensor::DimOp depending on the type of <span class="tt">val</span>.  <br /></td></tr>
<tr class="memitem:ae474be1b8e656c231ec447b79d2d5e8d" id="r_ae474be1b8e656c231ec447b79d2d5e8d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; WinogradConv2DFmr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae474be1b8e656c231ec447b79d2d5e8d">getWinogradConv2DFmr</a> (<a class="el" href="classint64__t.html">int64_t</a> m, <a class="el" href="classint64__t.html">int64_t</a> r)</td></tr>
<tr class="memdesc:ae474be1b8e656c231ec447b79d2d5e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given <span class="tt">m</span> and <span class="tt">r</span> parameters to a WinogradConv2DFmr enumeration value.  <br /></td></tr>
<tr class="memitem:acc482eff5fffe862c02f038c2a9d20f9" id="r_acc482eff5fffe862c02f038c2a9d20f9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classint64__t.html">int64_t</a>, <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc482eff5fffe862c02f038c2a9d20f9">getFmrFromWinogradConv2DFmr</a> (WinogradConv2DFmr fmr)</td></tr>
<tr class="memdesc:acc482eff5fffe862c02f038c2a9d20f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given WinogradConv2DFmr enumeration value to a pair of m and r parameters.  <br /></td></tr>
<tr class="memitem:af36b73b6c38d09eef01a3ab1bde4438f" id="r_af36b73b6c38d09eef01a3ab1bde4438f"><td class="memTemplParams" colspan="2">template&lt;typename OpTy, typename = std::enable_if_t&lt;std::is_same_v&lt;OpTy, linalg::PackOp&gt; ||                                      std::is_same_v&lt;OpTy, linalg::UnPackOp&gt;&gt;&gt; </td></tr>
<tr class="memitem:af36b73b6c38d09eef01a3ab1bde4438f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af36b73b6c38d09eef01a3ab1bde4438f">getPackedOuterShapeWithoutTransposition</a> (OpTy packOrUnPack)</td></tr>
<tr class="memdesc:af36b73b6c38d09eef01a3ab1bde4438f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outer shape in the packed domain before applying the transposition.  <br /></td></tr>
<tr class="memitem:aa2fe10e20900f7c49da8d51805f9e9f0" id="r_aa2fe10e20900f7c49da8d51805f9e9f0"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContractionDimensions.html">ContractionDimensions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2fe10e20900f7c49da8d51805f9e9f0">inferContractionDims</a> (LinalgOp linalgOp)</td></tr>
<tr class="memdesc:aa2fe10e20900f7c49da8d51805f9e9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find at least 2 parallel (m and n) and 1 reduction (k) dimension candidates that form a matmul subcomputation within <span class="tt">linalgOp</span>.  <br /></td></tr>
<tr class="memitem:a6cc6445c80fee3f958456e7e94740557" id="r_a6cc6445c80fee3f958456e7e94740557"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContractionDimensions.html">ContractionDimensions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cc6445c80fee3f958456e7e94740557">inferContractionDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; indexingMaps)</td></tr>
<tr class="memitem:ab5277093c168682f123f1e99d90461f0" id="r_ab5277093c168682f123f1e99d90461f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5277093c168682f123f1e99d90461f0">isaContractionOpInterface</a> (LinalgOp linalgOp)</td></tr>
<tr class="memdesc:ab5277093c168682f123f1e99d90461f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <span class="tt">linalgOp</span> conforms to ContractionOpInterface.  <br /></td></tr>
<tr class="memitem:a63f1beb2cf9d6935a346b2e4b4d3c7f5" id="r_a63f1beb2cf9d6935a346b2e4b4d3c7f5"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ConvolutionDimensions.html">ConvolutionDimensions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63f1beb2cf9d6935a346b2e4b4d3c7f5">inferConvolutionDims</a> (LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a63f1beb2cf9d6935a346b2e4b4d3c7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find at least 1 parallel (output_image) and reduction (filter_loop) dimension candidates that form a convolution subcomputation within <span class="tt">linalgOp</span>.  <br /></td></tr>
<tr class="memitem:a7c76ee8dee2d6cb36fd4c974c60463f3" id="r_a7c76ee8dee2d6cb36fd4c974c60463f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c76ee8dee2d6cb36fd4c974c60463f3">isaConvolutionOpInterface</a> (LinalgOp linalgOp, <a class="el" href="classbool.html">bool</a> allowEmptyConvolvedDims=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a7c76ee8dee2d6cb36fd4c974c60463f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <span class="tt">linalgOp</span> conforms to ConvolutionOpInterface.  <br /></td></tr>
<tr class="memitem:a171ae143026d28b2e6954c74bb535831" id="r_a171ae143026d28b2e6954c74bb535831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a171ae143026d28b2e6954c74bb535831">isaCopyOpInterface</a> (LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a171ae143026d28b2e6954c74bb535831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <span class="tt">linalgOp</span> is semantically equivalent to a <span class="tt">linalg.copyOp</span>.  <br /></td></tr>
<tr class="memitem:a9fdf6fd72d97540e86680857176b705e" id="r_a9fdf6fd72d97540e86680857176b705e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fdf6fd72d97540e86680857176b705e">isaBroadcastOpInterface</a> (GenericOp genericOp)</td></tr>
<tr class="memdesc:a9fdf6fd72d97540e86680857176b705e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <span class="tt">genericOp</span> is semantically equivalent to a <span class="tt">linalg.broadcast</span>.  <br /></td></tr>
<tr class="memitem:a03e0016d67ebca76011c67253b093af0" id="r_a03e0016d67ebca76011c67253b093af0"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03e0016d67ebca76011c67253b093af0">isaTransposeOpInterface</a> (GenericOp genericOp)</td></tr>
<tr class="memdesc:a03e0016d67ebca76011c67253b093af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <span class="tt">genericOp</span> is semantically equivalent to a <span class="tt">linalg.transpose</span>.  <br /></td></tr>
<tr class="memitem:a14eec3edd7d29c8980b155ed0dee1a0c" id="r_a14eec3edd7d29c8980b155ed0dee1a0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14eec3edd7d29c8980b155ed0dee1a0c">isaElemwiseSingleUnaryOpInterface</a> (GenericOp genericOp)</td></tr>
<tr class="memdesc:a14eec3edd7d29c8980b155ed0dee1a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a given <span class="tt">genericOp</span> is semantically equivalent to a single linalgelementwise unary op.  <br /></td></tr>
<tr class="memitem:afc247b3bd43d4462293e09845b698e7a" id="r_afc247b3bd43d4462293e09845b698e7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc247b3bd43d4462293e09845b698e7a">isaElemwiseSingleBinaryOpInterface</a> (GenericOp genericOp)</td></tr>
<tr class="memdesc:afc247b3bd43d4462293e09845b698e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <span class="tt">genericOp</span> is semantically equivalent to a single linalg elementwise binary op e.g.  <br /></td></tr>
<tr class="memitem:aea1ca69a91110433c24e13af5c4ae3a9" id="r_aea1ca69a91110433c24e13af5c4ae3a9"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea1ca69a91110433c24e13af5c4ae3a9">isaFillOpInterface</a> (GenericOp genericOp)</td></tr>
<tr class="memdesc:aea1ca69a91110433c24e13af5c4ae3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <span class="tt">genericOp</span> is semantically equivalent to a <span class="tt">linalg.fill</span>.  <br /></td></tr>
<tr class="memitem:a5e756b2e152d167af6823f8fb6298933" id="r_a5e756b2e152d167af6823f8fb6298933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e756b2e152d167af6823f8fb6298933">registerValueBoundsOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:ae64270d2058ef5fd99281df6e7de4464" id="r_ae64270d2058ef5fd99281df6e7de4464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae64270d2058ef5fd99281df6e7de4464">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a0ae5e64320c923f94446d6b60153fee4" id="r_a0ae5e64320c923f94446d6b60153fee4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ae5e64320c923f94446d6b60153fee4">registerAllDialectInterfaceImplementations</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:ab570ed1db81a641eb5b3d9948775e517" id="r_ab570ed1db81a641eb5b3d9948775e517"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab570ed1db81a641eb5b3d9948775e517">registerBufferizableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:ae6b3914ef0f129c2145a4c6512cdac8c" id="r_ae6b3914ef0f129c2145a4c6512cdac8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6b3914ef0f129c2145a4c6512cdac8c">hoistRedundantVectorTransfers</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *root, <a class="el" href="classbool.html">bool</a> verifyNonZeroTrip=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:ae6b3914ef0f129c2145a4c6512cdac8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist vector.transfer_read/vector.transfer_write on buffers pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are true:  <br /></td></tr>
<tr class="memitem:ab283416b78913b7c9bb7f322758d98c9" id="r_ab283416b78913b7c9bb7f322758d98c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab283416b78913b7c9bb7f322758d98c9">hoistRedundantVectorBroadcasts</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *root)</td></tr>
<tr class="memdesc:ab283416b78913b7c9bb7f322758d98c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist vector.extract/vector.broadcast pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are met:  <br /></td></tr>
<tr class="memitem:a34d52ce7a6266192f3f98587b7c6575b" id="r_a34d52ce7a6266192f3f98587b7c6575b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34d52ce7a6266192f3f98587b7c6575b">registerRuntimeVerifiableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:ac6ef5d2a9e63222d223b416027377828" id="r_ac6ef5d2a9e63222d223b416027377828"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6ef5d2a9e63222d223b416027377828">registerShardingInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:ac973b30789682417b95981a6ea093fb3" id="r_ac973b30789682417b95981a6ea093fb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac973b30789682417b95981a6ea093fb3">registerSubsetOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:ae430d8314310084f3bfae3c0de4081dd" id="r_ae430d8314310084f3bfae3c0de4081dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae430d8314310084f3bfae3c0de4081dd">registerTilingInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a61ea527040089116cd00f5fec9802ad8" id="r_a61ea527040089116cd00f5fec9802ad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61ea527040089116cd00f5fec9802ad8">registerTilingInterfaceExternalModelsForPackUnPackOps</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a61ea527040089116cd00f5fec9802ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the above registeration, but it is only for <span class="tt">tensor.pack</span> and <span class="tt">tensor.unpack</span> ops.  <br /></td></tr>
<tr class="memitem:ae27267a4634c46beba8c9f55c14cdfa1" id="r_ae27267a4634c46beba8c9f55c14cdfa1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; vector::CombiningKind &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae27267a4634c46beba8c9f55c14cdfa1">getCombinerOpKind</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *combinerOp)</td></tr>
<tr class="memdesc:ae27267a4634c46beba8c9f55c14cdfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return vector::CombiningKind for the given op.  <br /></td></tr>
<tr class="memitem:a300387e92135ddafe3e8fcb45a1d0f4c" id="r_a300387e92135ddafe3e8fcb45a1d0f4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a300387e92135ddafe3e8fcb45a1d0f4c">bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, tensor::PadOp padOp, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a300387e92135ddafe3e8fcb45a1d0f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a buffer allocation for the given tensor.pad op and lower the op to linalg.fill/linalg.generic + bufferization.materialize_in_destination.  <br /></td></tr>
<tr class="memitem:a2b6184483164da0417ac58d1d5086bbc" id="r_a2b6184483164da0417ac58d1d5086bbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b6184483164da0417ac58d1d5086bbc">bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, vector::MaskOp maskOp, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a2b6184483164da0417ac58d1d5086bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a buffer allocation for the given vector.mask op and bufferize the op, including its region.  <br /></td></tr>
<tr class="memitem:a73274fcc2e8e228f5f44c6336b96e7b7" id="r_a73274fcc2e8e228f5f44c6336b96e7b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73274fcc2e8e228f5f44c6336b96e7b7">bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, bufferization::AllocTensorOp allocTensorOp, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a73274fcc2e8e228f5f44c6336b96e7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a buffer allocation for the given bufferization.alloc_tensor op and lower the op to memref.alloc + memref.tensor_store.  <br /></td></tr>
<tr class="memitem:a72d0ebe64f6077953145c8111cc3d955" id="r_a72d0ebe64f6077953145c8111cc3d955"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72d0ebe64f6077953145c8111cc3d955">bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a72d0ebe64f6077953145c8111cc3d955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize the given op with tensor semantics and materialize the result in a newly allocated buffer.  <br /></td></tr>
<tr class="memitem:a7b7f777c5538e35bbdd3aaabdb07e6f7" id="r_a7b7f777c5538e35bbdd3aaabdb07e6f7"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b7f777c5538e35bbdd3aaabdb07e6f7">linalgOpAnchoredEmptyTensorEliminationStep</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">bufferization::OneShotAnalysisState</a> &amp;state)</td></tr>
<tr class="memdesc:a7b7f777c5538e35bbdd3aaabdb07e6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to eliminate tensor::EmptyOps inside <span class="tt">op</span> that are anchored on a LinalgOp.  <br /></td></tr>
<tr class="memitem:a8fa220da60546acce7c4a8b3635d5b21" id="r_a8fa220da60546acce7c4a8b3635d5b21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fa220da60546acce7c4a8b3635d5b21">areElementwiseOpsFusable</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)</td></tr>
<tr class="memdesc:a8fa220da60546acce7c4a8b3635d5b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if two <span class="tt">linalg.generic</span> operations with producer/consumer relationship through <span class="tt">fusedOperand</span> can be fused using elementwise op fusion.  <br /></td></tr>
<tr class="memitem:a850b9fd11404efe17bca02011aff2e88" id="r_a850b9fd11404efe17bca02011aff2e88"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a850b9fd11404efe17bca02011aff2e88">promoteSubviewsPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:a850b9fd11404efe17bca02011aff2e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote memref.subviews feeding linalg-on-buffers operations.  <br /></td></tr>
<tr class="memitem:a8d0310adee4f127279f9147a71db0181" id="r_a8d0310adee4f127279f9147a71db0181"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d0310adee4f127279f9147a71db0181">vectorizeOpPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; inputVectorSizes={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; inputScalableVecDims={}, <a class="el" href="classbool.html">bool</a> vectorizeNDExtract=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classbool.html">bool</a> flatten1DDepthwiseConv=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a8d0310adee4f127279f9147a71db0181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return success if the operation can be vectorized.  <br /></td></tr>
<tr class="memitem:ac980878e4ea40184d0a2183288fd0f61" id="r_ac980878e4ea40184d0a2183288fd0f61"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1DropUnitDimsResult.html">DropUnitDimsResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac980878e4ea40184d0a2183288fd0f61">dropUnitDims</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, IndexingMapOpInterface op, const <a class="el" href="#a0752c7523022c2c98068a86865e35096">DroppedUnitDimsBuilder</a> &amp;droppedUnitDimsBuilder, const <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a5b6d6c0f10b756281634aebb9f69d5dd" id="r_a5b6d6c0f10b756281634aebb9f69d5dd"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1DropUnitDimsResult.html">DropUnitDimsResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b6d6c0f10b756281634aebb9f69d5dd">dropUnitDims</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, GenericOp genericOp, const <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a4ceec493e0b40673125a0402c3cf78e4" id="r_a4ceec493e0b40673125a0402c3cf78e4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html">ElementwiseOpFusionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ceec493e0b40673125a0402c3cf78e4">fuseElementwiseOps</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)</td></tr>
<tr class="memitem:a4f70173e3ee102c2077ef5cdf5908001" id="r_a4f70173e3ee102c2077ef5cdf5908001"><td class="memItemLeft" align="right" valign="top">llvm::SmallDenseSet&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f70173e3ee102c2077ef5cdf5908001">getPreservedProducerResults</a> (GenericOp producer, GenericOp consumer, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)</td></tr>
<tr class="memdesc:a4f70173e3ee102c2077ef5cdf5908001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set of indices of the producer's results which would be preserved after the fusion.  <br /></td></tr>
<tr class="memitem:ae273bd1d7e48f4503eefba4f1487fa56" id="r_ae273bd1d7e48f4503eefba4f1487fa56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae273bd1d7e48f4503eefba4f1487fa56">peelLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ae273bd1d7e48f4503eefba4f1487fa56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to peel and canonicalize loop <span class="tt">op</span> and return the new result.  <br /></td></tr>
<tr class="memitem:a5faa18744febf8ff36b38176ca04d8fc" id="r_a5faa18744febf8ff36b38176ca04d8fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5faa18744febf8ff36b38176ca04d8fc">peelLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; loops)</td></tr>
<tr class="memdesc:a5faa18744febf8ff36b38176ca04d8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peel 'loops' and applies affine_min/max bounds simplification on the fly where relevant.  <br /></td></tr>
<tr class="memitem:a08d1dafbd1447fdcbad0e11434292563" id="r_a08d1dafbd1447fdcbad0e11434292563"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08d1dafbd1447fdcbad0e11434292563">rewriteAsPaddedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp opToPad, const <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, LinalgOp &amp;paddedOp, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;replacements, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; tensor::PadOp &gt; &amp;padOps)</td></tr>
<tr class="memdesc:a08d1dafbd1447fdcbad0e11434292563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the iterator dimensions <span class="tt">options.paddingDimensions</span> of all <span class="tt">opToPad</span> operands to a static bounding box.  <br /></td></tr>
<tr class="memitem:a629d4548e517e8d9bfcdadacbc4d91fe" id="r_a629d4548e517e8d9bfcdadacbc4d91fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a629d4548e517e8d9bfcdadacbc4d91fe">computePaddedShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="namespacemlir.html#a864cb5eb1fea4a548c28cda535ba7213">TypedValue</a>&lt; RankedTensorType &gt; v, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexingMap, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; indexingSizes, const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:a629d4548e517e8d9bfcdadacbc4d91fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to compute the padded shape of the given value <span class="tt">v</span> of <span class="tt">RankedTensorType</span> given:  <br /></td></tr>
<tr class="memitem:aa357f78e61caac5bae1dad723393734a" id="r_aa357f78e61caac5bae1dad723393734a"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa357f78e61caac5bae1dad723393734a">computeIndexingMapOpInterfacePaddedShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;operandToPad, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; iterationDomain, const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;)</td></tr>
<tr class="memdesc:aa357f78e61caac5bae1dad723393734a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specific helper for Linalg ops.  <br /></td></tr>
<tr class="memitem:a402b2b94588021b9d4c088f351c35c69" id="r_a402b2b94588021b9d4c088f351c35c69"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceResult.html">PadTilingInterfaceResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a402b2b94588021b9d4c088f351c35c69">rewriteAsPaddedOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, TilingInterface toPad, <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, const <a class="el" href="#a1f5ce0fcb27f388f81435ec80109e7c6">PadSizeComputationFunction</a> &amp;=&amp;<a class="el" href="#aa357f78e61caac5bae1dad723393734a">computeIndexingMapOpInterfacePaddedShape</a>)</td></tr>
<tr class="memdesc:a402b2b94588021b9d4c088f351c35c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the iterator dimensions of <span class="tt">toPad</span>.  <br /></td></tr>
<tr class="memitem:a344a0fa8893af22df90d795e19c1a713" id="r_a344a0fa8893af22df90d795e19c1a713"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a344a0fa8893af22df90d795e19c1a713">hoistPaddingOnTensors</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PadOp opToHoist, <a class="el" href="classint64__t.html">int64_t</a> numLoops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; transposeVector, tensor::PadOp &amp;hoistedOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; TransposeOp &gt; &amp;transposeOps)</td></tr>
<tr class="memdesc:a344a0fa8893af22df90d795e19c1a713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mechanically hoist padding operations on tensors by <span class="tt">numLoops</span> into a new, generally larger tensor.  <br /></td></tr>
<tr class="memitem:ac1d7ae638195a0c07357a33d4b8cfec0" id="r_ac1d7ae638195a0c07357a33d4b8cfec0"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1d7ae638195a0c07357a33d4b8cfec0">hoistPaddingOnTensors</a> (tensor::PadOp opToHoist, <a class="el" href="classint64__t.html">int64_t</a> numLoops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; transposeVector, tensor::PadOp &amp;hoistedOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; TransposeOp &gt; &amp;transposeOps)</td></tr>
<tr class="memdesc:ac1d7ae638195a0c07357a33d4b8cfec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls into <span class="tt">hoistPaddingOnTensors</span> with a local <a class="el" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ...">IRRewriter</a>.  <br /></td></tr>
<tr class="memitem:aad04f1a354ddbbdec275dd9afd45bdce" id="r_aad04f1a354ddbbdec275dd9afd45bdce"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad04f1a354ddbbdec275dd9afd45bdce">padAndHoistLinalgOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp, const <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:aad04f1a354ddbbdec275dd9afd45bdce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply padding and hoisting to <span class="tt">linalgOp</span> according to the configuration specified in <span class="tt">options</span>.  <br /></td></tr>
<tr class="memitem:af025e45095e64f984901c4f65fa3c72f" id="r_af025e45095e64f984901c4f65fa3c72f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; TilingInterface, TilingInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af025e45095e64f984901c4f65fa3c72f">splitOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, <a class="el" href="classunsigned.html">unsigned</a> dimension, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> splitPoint)</td></tr>
<tr class="memdesc:af025e45095e64f984901c4f65fa3c72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given <span class="tt">op</span> into two parts along the given iteration space <span class="tt">dimension</span> at the specified <span class="tt">splitPoint</span>, and return the two parts.  <br /></td></tr>
<tr class="memitem:ac13050e75a64a26bf82a80b19006d0e9" id="r_ac13050e75a64a26bf82a80b19006d0e9"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac13050e75a64a26bf82a80b19006d0e9">tileLinalgOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, LinalgOp op, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a8dcc62e199cdb1863a3d6f30e4dc317a" id="r_a8dcc62e199cdb1863a3d6f30e4dc317a"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; GenericOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dcc62e199cdb1863a3d6f30e4dc317a">interchangeGenericOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, GenericOp genericOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; interchangeVector)</td></tr>
<tr class="memdesc:a8dcc62e199cdb1863a3d6f30e4dc317a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interchange the <span class="tt">iterator_types</span> and <span class="tt">iterator_maps</span> dimensions and adapts the index accesses of <span class="tt">op</span>.  <br /></td></tr>
<tr class="memitem:a7fc28f76b6a2798611e0008260ae388d" id="r_a7fc28f76b6a2798611e0008260ae388d"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; GenericOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fc28f76b6a2798611e0008260ae388d">generalizeNamedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a7fc28f76b6a2798611e0008260ae388d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a GenericOp from the given named operation <span class="tt">linalgOp</span> and replace the given <span class="tt">linalgOp</span>.  <br /></td></tr>
<tr class="memitem:a3be344205769eaea42d412b4c0fae11a" id="r_a3be344205769eaea42d412b4c0fae11a"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3be344205769eaea42d412b4c0fae11a">specializeGenericOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, GenericOp genericOp)</td></tr>
<tr class="memdesc:a3be344205769eaea42d412b4c0fae11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a namedOp from the given GenericOp and replace the GenericOp.  <br /></td></tr>
<tr class="memitem:a4ed54a24fbd0044060290027188db5c0" id="r_a4ed54a24fbd0044060290027188db5c0"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ed54a24fbd0044060290027188db5c0">promoteSubviewAsNewBuffer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, memref::SubViewOp subView, <a class="el" href="classbool.html">bool</a> useOriginalSubviewSize, const <a class="el" href="#a9ada278f74ee670af18b6bfd04271e3b">AllocBufferCallbackFn</a> &amp;allocationFn, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)</td></tr>
<tr class="memitem:acd639dc165f0ab64ec7afbac992c4d65" id="r_acd639dc165f0ab64ec7afbac992c4d65"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd639dc165f0ab64ec7afbac992c4d65">promoteSubViews</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, LinalgOp op, const <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:acd639dc165f0ab64ec7afbac992c4d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the <span class="tt">subViews</span> into a new buffer allocated at the insertion point <span class="tt">b</span>.  <br /></td></tr>
<tr class="memitem:a266200755192d09deb827c799e59277b" id="r_a266200755192d09deb827c799e59277b"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a266200755192d09deb827c799e59277b">allocateWorkgroupMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, memref::SubViewOp subview, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizeBounds, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;)</td></tr>
<tr class="memdesc:a266200755192d09deb827c799e59277b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the subview in the GPU workgroup memory.  <br /></td></tr>
<tr class="memitem:ad6babd80190e8df26f441fca7d2fbe31" id="r_ad6babd80190e8df26f441fca7d2fbe31"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6babd80190e8df26f441fca7d2fbe31">deallocateWorkgroupMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a>)</td></tr>
<tr class="memdesc:ad6babd80190e8df26f441fca7d2fbe31"><td class="mdescLeft">&#160;</td><td class="mdescRight">In case of GPU group memory there is no need to deallocate.  <br /></td></tr>
<tr class="memitem:a72fb3984f986840e0dc914c1ab90dc3b" id="r_a72fb3984f986840e0dc914c1ab90dc3b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72fb3984f986840e0dc914c1ab90dc3b">copyToWorkgroupMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)</td></tr>
<tr class="memdesc:a72fb3984f986840e0dc914c1ab90dc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Memref copy operations and add gpu barrier guards before and after the copy operation to ensure data integrity.  <br /></td></tr>
<tr class="memitem:a5606dfca8a9078fc6bc9b74972f15fdc" id="r_a5606dfca8a9078fc6bc9b74972f15fdc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5606dfca8a9078fc6bc9b74972f15fdc">allocateGPUPrivateMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, memref::SubViewOp subview, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizeBounds, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;)</td></tr>
<tr class="memdesc:a5606dfca8a9078fc6bc9b74972f15fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the subview in the GPU private memory.  <br /></td></tr>
<tr class="memitem:a88359f69353831d971485ff6b6b86dc1" id="r_a88359f69353831d971485ff6b6b86dc1"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88359f69353831d971485ff6b6b86dc1">copyToGPUPrivateMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)</td></tr>
<tr class="memdesc:a88359f69353831d971485ff6b6b86dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal copy to between src and dst.  <br /></td></tr>
<tr class="memitem:a487d4430e8217b1dabc50cb28bb93342" id="r_a487d4430e8217b1dabc50cb28bb93342"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a487d4430e8217b1dabc50cb28bb93342">deallocateGPUPrivateMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a>)</td></tr>
<tr class="memdesc:a487d4430e8217b1dabc50cb28bb93342"><td class="mdescLeft">&#160;</td><td class="mdescRight">In case of GPU private memory there is no need to deallocate since the memory is freed when going outside of the scope.  <br /></td></tr>
<tr class="memitem:a142a09c03dbaa0d795e44f62d4b6b395" id="r_a142a09c03dbaa0d795e44f62d4b6b395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a142a09c03dbaa0d795e44f62d4b6b395">hasVectorizationImpl</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)</td></tr>
<tr class="memdesc:a142a09c03dbaa0d795e44f62d4b6b395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there's dedicated logic in the Linalg Vectorizer to vectorize this <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a>, false otherwise.  <br /></td></tr>
<tr class="memitem:a303bb59c046a82276569e6b906002997" id="r_a303bb59c046a82276569e6b906002997"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1VectorizationResult.html">VectorizationResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a303bb59c046a82276569e6b906002997">vectorize</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; inputVectorSizes={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; inputScalableVecDims={}, <a class="el" href="classbool.html">bool</a> vectorizeNDExtract=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classbool.html">bool</a> flatten1DDepthwiseConv=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classbool.html">bool</a> assumeDynamicDimsMatchVecSizes=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classbool.html">bool</a> createNamedContraction=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a303bb59c046a82276569e6b906002997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <span class="tt"><a class="el" href="structmlir_1_1linalg_1_1VectorizationResult.html" title="Transformation information returned after vectorizing.">VectorizationResult</a></span> containing the results of the vectorized op, or failure if the transformation fails.  <br /></td></tr>
<tr class="memitem:a8c63bc9239511b70751c238a12f5b1da" id="r_a8c63bc9239511b70751c238a12f5b1da"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c63bc9239511b70751c238a12f5b1da">vectorizeCopy</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;builder, memref::CopyOp copyOp)</td></tr>
<tr class="memdesc:a8c63bc9239511b70751c238a12f5b1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a suitable vector form for a Copy op with fully static shape.  <br /></td></tr>
<tr class="memitem:a7edd4be30bfb8af9bc8e486f8368c1e2" id="r_a7edd4be30bfb8af9bc8e486f8368c1e2"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="#a193831e3afcf32c859a980c17c8c276b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7edd4be30bfb8af9bc8e486f8368c1e2">linalgOpToLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a7edd4be30bfb8af9bc8e486f8368c1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a loop nest of <span class="tt">scf.for</span> with the proper body for <span class="tt">linalgOp</span>.  <br /></td></tr>
<tr class="memitem:aff809877c1d119dae06d06a8bad953e4" id="r_aff809877c1d119dae06d06a8bad953e4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="#a193831e3afcf32c859a980c17c8c276b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff809877c1d119dae06d06a8bad953e4">linalgOpToParallelLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:aff809877c1d119dae06d06a8bad953e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a loop nest of <span class="tt">scf.parallel</span> with the proper body for <span class="tt">linalgOp</span>.  <br /></td></tr>
<tr class="memitem:a95f289e066dcbb7844bd444c0880fc36" id="r_a95f289e066dcbb7844bd444c0880fc36"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="#a193831e3afcf32c859a980c17c8c276b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95f289e066dcbb7844bd444c0880fc36">linalgOpToAffineLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a95f289e066dcbb7844bd444c0880fc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a loop nest of <span class="tt">affine.for</span> with the proper body for <span class="tt">linalgOp</span>.  <br /></td></tr>
<tr class="memitem:a8144efefcad502e511c24aa5ce5b36e8" id="r_a8144efefcad502e511c24aa5ce5b36e8"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 4 &gt;, <a class="el" href="#ac63ef3b10f63a46b5d07ad3cbf2ed19d">LoopIndexToRangeIndexMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8144efefcad502e511c24aa5ce5b36e8">makeTiledLoopRanges</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; allShapeSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; allTileSizes)</td></tr>
<tr class="memitem:af8ef5fd09c3c79a47b8c4732ace79928" id="r_af8ef5fd09c3c79a47b8c4732ace79928"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1MultiSizeSpecification.html">MultiSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8ef5fd09c3c79a47b8c4732ace79928">computeMultiTileSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, LinalgOp op, <a class="el" href="classunsigned.html">unsigned</a> dimension, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> targetSize, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> divisor, <a class="el" href="classbool.html">bool</a> emitAssertions=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:af8ef5fd09c3c79a47b8c4732ace79928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits the IR computing the multi-sized tiling specification with two tile sizes not exceeding <span class="tt">targetSize</span>, each divisible by <span class="tt">sizeDivisor</span>, such that there exist numbers of tiles with these sizes that fully cover the given iteration space <span class="tt">dimension</span> of the structured <span class="tt">op</span>.  <br /></td></tr>
<tr class="memitem:a91c1fb37672289a396df9c95a9b1dd0b" id="r_a91c1fb37672289a396df9c95a9b1dd0b"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1StaticMultiSizeSpecification.html">StaticMultiSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91c1fb37672289a396df9c95a9b1dd0b">computeStaticMultiTileSizes</a> (LinalgOp op, <a class="el" href="classunsigned.html">unsigned</a> dimension, <a class="el" href="classint64__t.html">int64_t</a> targetSize, <a class="el" href="classint64__t.html">int64_t</a> divisor)</td></tr>
<tr class="memitem:aa3cdafc77c113c1fa2db8782dc0bdb29" id="r_aa3cdafc77c113c1fa2db8782dc0bdb29"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1StaticContinuousTileSizeSpecification.html">StaticContinuousTileSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3cdafc77c113c1fa2db8782dc0bdb29">computeStaticContinuousTileSizes</a> (LinalgOp op, <a class="el" href="classunsigned.html">unsigned</a> dimension, <a class="el" href="classunsigned.html">unsigned</a> targetSize)</td></tr>
<tr class="memitem:aa18c5afa193d9ff81a24877f1087fec4" id="r_aa18c5afa193d9ff81a24877f1087fec4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContinuousTileSizeSpecification.html">ContinuousTileSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa18c5afa193d9ff81a24877f1087fec4">computeContinuousTileSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, TilingInterface op, <a class="el" href="classunsigned.html">unsigned</a> dimension, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> targetSize, <a class="el" href="classbool.html">bool</a> emitAssertions)</td></tr>
<tr class="memitem:ab3085a8dbbf3c572b3279bdcc53dbe72" id="r_ab3085a8dbbf3c572b3279bdcc53dbe72"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html">ForallReductionTilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3085a8dbbf3c572b3279bdcc53dbe72">tileReductionUsingForall</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, PartialReductionOpInterface op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes={}, std::optional&lt; <a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> &gt; mapping=std::nullopt)</td></tr>
<tr class="memdesc:ab3085a8dbbf3c572b3279bdcc53dbe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to tile a reduction to parallel iterations computing partial reductions.  <br /></td></tr>
<tr class="memitem:a1b2368f6f815597fcf395106e8978e44" id="r_a1b2368f6f815597fcf395106e8978e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b2368f6f815597fcf395106e8978e44">transformIndexOps</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, LinalgOp op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivs, const <a class="el" href="#ac63ef3b10f63a46b5d07ad3cbf2ed19d">LoopIndexToRangeIndexMap</a> &amp;loopIndexToRangeIndex)</td></tr>
<tr class="memdesc:a1b2368f6f815597fcf395106e8978e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">All indices returned by IndexOp should be invariant with respect to tiling.  <br /></td></tr>
<tr class="memitem:aaa4f58f6a18fb7c9af60fb15122e0994" id="r_aaa4f58f6a18fb7c9af60fb15122e0994"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa4f58f6a18fb7c9af60fb15122e0994">splitReduction</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, LinalgOp op, const <a class="el" href="#a505f71c7a182531357360cb2151dc1f3">ControlSplitReductionFn</a> &amp;controlSplitReductionFn, <a class="el" href="classbool.html">bool</a> useAlloc=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memitem:af87c3f5c965b8e271579136775d51ffc" id="r_af87c3f5c965b8e271579136775d51ffc"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af87c3f5c965b8e271579136775d51ffc">splitReductionByScaling</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, LinalgOp op, const <a class="el" href="#a505f71c7a182531357360cb2151dc1f3">ControlSplitReductionFn</a> &amp;controlSplitReductionFn, <a class="el" href="classbool.html">bool</a> useAlloc=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:af87c3f5c965b8e271579136775d51ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling-based implementation of the split reduction transformation.  <br /></td></tr>
<tr class="memitem:a31426a6a1dc69e5819138ba53c6e7ef9" id="r_a31426a6a1dc69e5819138ba53c6e7ef9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31426a6a1dc69e5819138ba53c6e7ef9">isDimSequencePreserved</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="namespacemlir.html#a11a02d1f78682e704d9aa4a6ef3cb364">ReassociationIndicesRef</a> dimSequence)</td></tr>
<tr class="memdesc:a31426a6a1dc69e5819138ba53c6e7ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <span class="tt">true</span> if a given sequence of dimensions are contiguous in the range of the specified indexing map.  <br /></td></tr>
<tr class="memitem:a133a3ec0d7cd50a886d2cd558fdc9030" id="r_a133a3ec0d7cd50a886d2cd558fdc9030"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a133a3ec0d7cd50a886d2cd558fdc9030">areDimSequencesPreserved</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; dimSequences)</td></tr>
<tr class="memdesc:a133a3ec0d7cd50a886d2cd558fdc9030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <span class="tt">true</span> if all sequences of dimensions specified in <span class="tt">dimSequences</span> are contiguous in all the ranges of the <span class="tt">maps</span>.  <br /></td></tr>
<tr class="memitem:ae6a3be2f9306a873810377797b78bfc6" id="r_ae6a3be2f9306a873810377797b78bfc6"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1CollapseResult.html">CollapseResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6a3be2f9306a873810377797b78bfc6">collapseOpIterationDims</a> (LinalgOp op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; foldedIterationDims, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter)</td></tr>
<tr class="memdesc:ae6a3be2f9306a873810377797b78bfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapses dimensions of linalg.generic/linalg.copy operation.  <br /></td></tr>
<tr class="memitem:afebe4a9f3b87bb8f196bf2d577511a05" id="r_afebe4a9f3b87bb8f196bf2d577511a05"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1LowerPackResult.html">LowerPackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afebe4a9f3b87bb8f196bf2d577511a05">lowerPack</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::PackOp packOp, <a class="el" href="classbool.html">bool</a> lowerPadLikeWithInsertSlice=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:afebe4a9f3b87bb8f196bf2d577511a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite pack as pad + reshape + transpose.  <br /></td></tr>
<tr class="memitem:a3cea34f55211c79271dff09bb07c3279" id="r_a3cea34f55211c79271dff09bb07c3279"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1LowerUnPackOpResult.html">LowerUnPackOpResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cea34f55211c79271dff09bb07c3279">lowerUnPack</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::UnPackOp unPackOp, <a class="el" href="classbool.html">bool</a> lowerUnpadLikeWithExtractSlice=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:a3cea34f55211c79271dff09bb07c3279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite pack as empty + transpose + reshape + extract_slice.  <br /></td></tr>
<tr class="memitem:abd29d6299d2891ae1d092974bc1c4e30" id="r_abd29d6299d2891ae1d092974bc1c4e30"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd29d6299d2891ae1d092974bc1c4e30">pack</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; packedSizes)</td></tr>
<tr class="memdesc:abd29d6299d2891ae1d092974bc1c4e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement packing of a single LinalgOp by <span class="tt">packedSizes</span>.  <br /></td></tr>
<tr class="memitem:a26e3825819b0563bb199218baf11ca73" id="r_a26e3825819b0563bb199218baf11ca73"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackTransposeResult.html">PackTransposeResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26e3825819b0563bb199218baf11ca73">packTranspose</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::PackOp packOp, linalg::LinalgOp linalgOp, linalg::UnPackOp maybeUnPackOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; outerPerm, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; innerPerm)</td></tr>
<tr class="memdesc:a26e3825819b0563bb199218baf11ca73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose a single PackOp -&gt; LinalgOp -&gt; UnPackOp chain and return the transposed PackOp -&gt; LinalgOp -&gt; UnPackOp chain after replacements.  <br /></td></tr>
<tr class="memitem:ab3567489d885b34059aa8286957de564" id="r_ab3567489d885b34059aa8286957de564"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3567489d885b34059aa8286957de564">packMatmulGreedily</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mnkPackedSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mnkPaddedSizesNextMultipleOf, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mnkOrder)</td></tr>
<tr class="memdesc:ab3567489d885b34059aa8286957de564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a LinalgOp by greedily inferring matmul dimensions (m, n, k) where m and n are proper parallel dimensions and k is a proper reduction dimension.  <br /></td></tr>
<tr class="memitem:a5ca967d8e0b6ff895d26faaf60a79263" id="r_a5ca967d8e0b6ff895d26faaf60a79263"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ca967d8e0b6ff895d26faaf60a79263">blockPackMatmul</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::LinalgOp linalgOp, const <a class="el" href="#a41903a6655e9be09920ce399e3e71865">ControlBlockPackMatmulFn</a> &amp;controlPackMatmul)</td></tr>
<tr class="memdesc:a5ca967d8e0b6ff895d26faaf60a79263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a matmul operation into blocked 4D layout.  <br /></td></tr>
<tr class="memitem:a5a579fdd0e468c7aec96f84d016c829e" id="r_a5a579fdd0e468c7aec96f84d016c829e"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a579fdd0e468c7aec96f84d016c829e">rewriteInDestinationPassingStyle</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::FromElementsOp fromElementsOp)</td></tr>
<tr class="memdesc:a5a579fdd0e468c7aec96f84d016c829e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite tensor.from_elements to linalg.generic.  <br /></td></tr>
<tr class="memitem:ab2e500c4bf906d65572af9b3d2982852" id="r_ab2e500c4bf906d65572af9b3d2982852"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2e500c4bf906d65572af9b3d2982852">rewriteInDestinationPassingStyle</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::GenerateOp generateOp)</td></tr>
<tr class="memdesc:ab2e500c4bf906d65572af9b3d2982852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite tensor.generate to linalg.generic.  <br /></td></tr>
<tr class="memitem:acf3e743297fd7a20a30c7c4e39608fbc" id="r_acf3e743297fd7a20a30c7c4e39608fbc"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf3e743297fd7a20a30c7c4e39608fbc">rewriteInDestinationPassingStyle</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PadOp padOp)</td></tr>
<tr class="memdesc:acf3e743297fd7a20a30c7c4e39608fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite tensor.pad to linalg.generic + tensor.insert_slice.  <br /></td></tr>
<tr class="memitem:a0e2c1f265ce47a53398eab6e8f18b30c" id="r_a0e2c1f265ce47a53398eab6e8f18b30c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e2c1f265ce47a53398eab6e8f18b30c">rewriteInIm2Col</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcHwcfOp convOp)</td></tr>
<tr class="memdesc:a0e2c1f265ce47a53398eab6e8f18b30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linalg.conv_2d_nhwc_hwcf into linalg.generic (for img2col packing) and linalg.matmul.  <br /></td></tr>
<tr class="memitem:a7efbd1a00187259d6074a842842175c2" id="r_a7efbd1a00187259d6074a842842175c2"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7efbd1a00187259d6074a842842175c2">rewriteInIm2Col</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcFhwcOp convOp)</td></tr>
<tr class="memdesc:a7efbd1a00187259d6074a842842175c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the above but for Fhwc channel orderings in the filter.  <br /></td></tr>
<tr class="memitem:a49f61511bb9ed963c3eeb360bfdb1a6a" id="r_a49f61511bb9ed963c3eeb360bfdb1a6a"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49f61511bb9ed963c3eeb360bfdb1a6a">rewriteInIm2Col</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::DepthwiseConv2DNhwcHwcOp convOp)</td></tr>
<tr class="memdesc:a49f61511bb9ed963c3eeb360bfdb1a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to rewriteInIm2Col with linalg::Conv2DNhwcHwcfOp except there is no reduction among the input channels so each convolution can be a matrix-vector product and by transposing both input filter so channels are outer most the computation is a batched matrix-vector product.  <br /></td></tr>
<tr class="memitem:ad43dfb86d76bed86ecd1117849e5b6f4" id="r_ad43dfb86d76bed86ecd1117849e5b6f4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad43dfb86d76bed86ecd1117849e5b6f4">rewriteInIm2Col</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNchwFchwOp convOp)</td></tr>
<tr class="memdesc:ad43dfb86d76bed86ecd1117849e5b6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to rewriteInIm2Col with linalg::Conv2DNhwcHwcfOp except because the channels are to the left of the image shape dimensions, the position of the contraction dimension in the resulting matmul is reversed.  <br /></td></tr>
<tr class="memitem:a6ea35f9b824fbdf551b76ddf974fc418" id="r_a6ea35f9b824fbdf551b76ddf974fc418"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ea35f9b824fbdf551b76ddf974fc418">transposeConv2D</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcFhwcOp op)</td></tr>
<tr class="memdesc:a6ea35f9b824fbdf551b76ddf974fc418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linalg.conv_2d_nhwc_fhwc(_q) to linalg.conv_2d_nhwc_hwcf(_q) by materializing transpose.  <br /></td></tr>
<tr class="memitem:ada14eab9218f7ff7f15f695a980fb717" id="r_ada14eab9218f7ff7f15f695a980fb717"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada14eab9218f7ff7f15f695a980fb717">transposeConv2D</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcFhwcQOp op)</td></tr>
<tr class="memitem:ad8836bfb07ad8fc4f7bda9aa174da988" id="r_ad8836bfb07ad8fc4f7bda9aa174da988"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8836bfb07ad8fc4f7bda9aa174da988">transposeMatmul</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::MatmulOp op, <a class="el" href="classbool.html">bool</a> transposeLHS=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:ad8836bfb07ad8fc4f7bda9aa174da988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Linalg matmul ops to transposed variants.  <br /></td></tr>
<tr class="memitem:a816f67d5546592d18de9ec5de0e791f3" id="r_a816f67d5546592d18de9ec5de0e791f3"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a816f67d5546592d18de9ec5de0e791f3">transposeBatchMatmul</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::BatchMatmulOp op, <a class="el" href="classbool.html">bool</a> transposeLHS=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:a816f67d5546592d18de9ec5de0e791f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to replace.  <br /></td></tr>
<tr class="memitem:a6e047772994b241ad2de48dfc28d7340" id="r_a6e047772994b241ad2de48dfc28d7340"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e047772994b241ad2de48dfc28d7340">winogradConv2D</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcFhwcOp op, WinogradConv2DFmr fmr)</td></tr>
<tr class="memdesc:a6e047772994b241ad2de48dfc28d7340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linalg.conv_2d_nhwc_fhwc to Winograd Conv2D algorithm F(m x m, r x r).  <br /></td></tr>
<tr class="memitem:a22cf4ae6a6c9f8d82a3d3f13e55100c3" id="r_a22cf4ae6a6c9f8d82a3d3f13e55100c3"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22cf4ae6a6c9f8d82a3d3f13e55100c3">decomposeWinogradFilterTransformOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::WinogradFilterTransformOp op)</td></tr>
<tr class="memdesc:a22cf4ae6a6c9f8d82a3d3f13e55100c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite linalg.winograd_filter_transform.  <br /></td></tr>
<tr class="memitem:ae75908ded36f97719f77c8b56ed859ef" id="r_ae75908ded36f97719f77c8b56ed859ef"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae75908ded36f97719f77c8b56ed859ef">decomposeWinogradInputTransformOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::WinogradInputTransformOp op)</td></tr>
<tr class="memdesc:ae75908ded36f97719f77c8b56ed859ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite linalg.winograd_input_transform.  <br /></td></tr>
<tr class="memitem:a49f2f00a0e17dbbec5198127ee3151ba" id="r_a49f2f00a0e17dbbec5198127ee3151ba"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49f2f00a0e17dbbec5198127ee3151ba">decomposeWinogradOutputTransformOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::WinogradOutputTransformOp op)</td></tr>
<tr class="memdesc:a49f2f00a0e17dbbec5198127ee3151ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite linalg.winograd_output_transform.  <br /></td></tr>
<tr class="memitem:a88467664ee2ebeb70bc1a2c3d5876a9c" id="r_a88467664ee2ebeb70bc1a2c3d5876a9c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; linalg::GenericOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88467664ee2ebeb70bc1a2c3d5876a9c">deduplicateOperandsAndRemoveDeadResults</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::GenericOp genericOp, <a class="el" href="classbool.html">bool</a> removeOutputs)</td></tr>
<tr class="memdesc:a88467664ee2ebeb70bc1a2c3d5876a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to deduplicate operands and remove dead results of <span class="tt">linalg.generic</span> operations.  <br /></td></tr>
<tr class="memitem:ae61503376ad6b88f0c35f8ce358dbc9e" id="r_ae61503376ad6b88f0c35f8ce358dbc9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae61503376ad6b88f0c35f8ce358dbc9e">getLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalization patterns relevant to apply after tiling patterns.  <br /></td></tr>
<tr class="memitem:a4701ad0fa2e34da0089a80135935f02e" id="r_a4701ad0fa2e34da0089a80135935f02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4701ad0fa2e34da0089a80135935f02e">populateLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:ada9bb5c9c8ef1aadbbc563431443b5e2" id="r_ada9bb5c9c8ef1aadbbc563431443b5e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada9bb5c9c8ef1aadbbc563431443b5e2">populateLinalgNamedOpsGeneralizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ada9bb5c9c8ef1aadbbc563431443b5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg generalization patterns.  <br /></td></tr>
<tr class="memitem:adc9ad663f56317f953958cb9434bd8fc" id="r_adc9ad663f56317f953958cb9434bd8fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc9ad663f56317f953958cb9434bd8fc">populateLinalgGenericOpsSpecializationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:adc9ad663f56317f953958cb9434bd8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns to convert linalg.generic ops to named ops where possible.  <br /></td></tr>
<tr class="memitem:ae12537adb2614537d3d6d5db2612629f" id="r_ae12537adb2614537d3d6d5db2612629f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae12537adb2614537d3d6d5db2612629f">populateLinalgNamedToElementwisePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ae12537adb2614537d3d6d5db2612629f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> that convert linalg named ops e.g.  <br /></td></tr>
<tr class="memitem:a479c320b2d7a71b7d9c50d04047eba8f" id="r_a479c320b2d7a71b7d9c50d04047eba8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a479c320b2d7a71b7d9c50d04047eba8f">populateLinalgFoldIntoElementwisePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a479c320b2d7a71b7d9c50d04047eba8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns that fold operations like <span class="tt">linalg.transform</span> into elementwise op map.  <br /></td></tr>
<tr class="memitem:a887c3b461640ae2783747a1c89726203" id="r_a887c3b461640ae2783747a1c89726203"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a887c3b461640ae2783747a1c89726203">populateDecomposeConvolutionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a887c3b461640ae2783747a1c89726203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg decompose convolutions patterns.  <br /></td></tr>
<tr class="memitem:a96851c32371159549c91211e266f3f0e" id="r_a96851c32371159549c91211e266f3f0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96851c32371159549c91211e266f3f0e">populateDecomposePackUnpackPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a96851c32371159549c91211e266f3f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns to decompose <a class="el" href="#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a> and linalg.unpack Ops into e.g.  <br /></td></tr>
<tr class="memitem:ae93e7e4b8d10bb895e935d0b4799f3a9" id="r_ae93e7e4b8d10bb895e935d0b4799f3a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae93e7e4b8d10bb895e935d0b4799f3a9">populateDecomposePadPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ae93e7e4b8d10bb895e935d0b4799f3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns to decompose tensor.pad into e.g.  <br /></td></tr>
<tr class="memitem:a1e349c4f7a13b98a31f89dec948c5533" id="r_a1e349c4f7a13b98a31f89dec948c5533"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e349c4f7a13b98a31f89dec948c5533">populateConvertConv2DToImg2ColPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a1e349c4f7a13b98a31f89dec948c5533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns to transform linalg.conv_2d_xxx operations into linalg.generic (for img2col packing) and linalg.matmul.  <br /></td></tr>
<tr class="memitem:a43c2ef8a778a33a17885475c11b50bdd" id="r_a43c2ef8a778a33a17885475c11b50bdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43c2ef8a778a33a17885475c11b50bdd">populatePadOpVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> baseBenefit=1)</td></tr>
<tr class="memdesc:a43c2ef8a778a33a17885475c11b50bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns that vectorize tensor.pad.  <br /></td></tr>
<tr class="memitem:aad6f59ca20a1e8ce21c3c29916aec917" id="r_aad6f59ca20a1e8ce21c3c29916aec917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad6f59ca20a1e8ce21c3c29916aec917">populateDecomposeLinalgOpsPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classbool.html">bool</a> removeDeadArgsAndResults=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:aad6f59ca20a1e8ce21c3c29916aec917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for splitting a <span class="tt">LinalgOp</span> with multiple statements within its payload into multiple <span class="tt">GenericOp</span> that have a single statement.  <br /></td></tr>
<tr class="memitem:a68f8e903a075470f95fa853892083469" id="r_a68f8e903a075470f95fa853892083469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68f8e903a075470f95fa853892083469">populateConvertToDestinationStylePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a68f8e903a075470f95fa853892083469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that convert non-destination-style ops to destination style ops.  <br /></td></tr>
<tr class="memitem:a891b8f2d145dcc3327ba55c7a49d44e4" id="r_a891b8f2d145dcc3327ba55c7a49d44e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a891b8f2d145dcc3327ba55c7a49d44e4">populateConvolutionVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a891b8f2d145dcc3327ba55c7a49d44e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for vectorizing low-D convolution ops.  <br /></td></tr>
<tr class="memitem:a7a49133ef595966377878adc42196f47" id="r_a7a49133ef595966377878adc42196f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a49133ef595966377878adc42196f47">populateElementwiseToLinalgConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a7a49133ef595966377878adc42196f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that convert <span class="tt">ElementwiseMappable</span> ops to linalg parallel loops.  <br /></td></tr>
<tr class="memitem:a49366865f5ce183ae19888eceb6667e5" id="r_a49366865f5ce183ae19888eceb6667e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49366865f5ce183ae19888eceb6667e5">populateSparseTensorRewriting</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a49366865f5ce183ae19888eceb6667e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that are only useful in the context of sparse tensors.  <br /></td></tr>
<tr class="memitem:af537f75332b531f2f627083684c201e4" id="r_af537f75332b531f2f627083684c201e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af537f75332b531f2f627083684c201e4">populateElementwiseOpsFusionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="#a9f4136d97cdab12f0760756f1adc1721">ControlFusionFn</a> &amp;controlElementwiseOpFusion)</td></tr>
<tr class="memdesc:af537f75332b531f2f627083684c201e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns for fusing linalg operation on tensors.  <br /></td></tr>
<tr class="memitem:a01a1d26266bdb81ec39619dde149ceda" id="r_a01a1d26266bdb81ec39619dde149ceda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01a1d26266bdb81ec39619dde149ceda">populateDataLayoutPropagationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="#ac7e80c46fd448c104f6709b43c315755">ControlPropagationFn</a> &amp;controlPackUnPackPropagation, <a class="el" href="classbool.html">bool</a> PoisonPaddingOk=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a01a1d26266bdb81ec39619dde149ceda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to bubble up or down data layout ops across other operations.  <br /></td></tr>
<tr class="memitem:a170a7562074760f0aa1786f1d3d1db3b" id="r_a170a7562074760f0aa1786f1d3d1db3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a170a7562074760f0aa1786f1d3d1db3b">populateExtractSliceSinkingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="#ac7e80c46fd448c104f6709b43c315755">ControlPropagationFn</a> &amp;controlPackUnPackPropagation)</td></tr>
<tr class="memdesc:a170a7562074760f0aa1786f1d3d1db3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to sink extract slice across other operations.  <br /></td></tr>
<tr class="memitem:a9cbdbb9ec2d0ed200d6a679ffd803c7e" id="r_a9cbdbb9ec2d0ed200d6a679ffd803c7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cbdbb9ec2d0ed200d6a679ffd803c7e">populateEraseUnusedOperandsAndResultsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a9cbdbb9ec2d0ed200d6a679ffd803c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to remove dead operands and results of <span class="tt">linalg.generic</span> operations.  <br /></td></tr>
<tr class="memitem:abe6e2c64c65b1a22b1794d731be0c612" id="r_abe6e2c64c65b1a22b1794d731be0c612"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe6e2c64c65b1a22b1794d731be0c612">populateEraseUnnecessaryInputsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:abe6e2c64c65b1a22b1794d731be0c612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to promote inputs to outputs and remove unused inputs of <span class="tt">linalg.generic</span> ops.  <br /></td></tr>
<tr class="memitem:a8ef1d681922add4fcf065a64d713c3b5" id="r_a8ef1d681922add4fcf065a64d713c3b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ef1d681922add4fcf065a64d713c3b5">populateCollapseDimensions</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="#a56475069e4631a3e7e54964a3fc576bb">GetCollapsableDimensionsFn</a> &amp;controlCollapseDimensions)</td></tr>
<tr class="memdesc:a8ef1d681922add4fcf065a64d713c3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to collapse dimensions in a linalg.generic op.  <br /></td></tr>
<tr class="memitem:ac73f0e4d33b9691f06d722f2146c4a66" id="r_ac73f0e4d33b9691f06d722f2146c4a66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac73f0e4d33b9691f06d722f2146c4a66">populateFoldReshapeOpsByExpansionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="#a9f4136d97cdab12f0760756f1adc1721">ControlFusionFn</a> &amp;controlFoldingReshapes)</td></tr>
<tr class="memdesc:ac73f0e4d33b9691f06d722f2146c4a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold an expanding (collapsing) tensor_reshape operation with its producer (consumer) generic operation by expanding the dimensionality of the loop in the generic op.  <br /></td></tr>
<tr class="memitem:a3c8bdabd42dfb2f3617cc87eccfa4199" id="r_a3c8bdabd42dfb2f3617cc87eccfa4199"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c8bdabd42dfb2f3617cc87eccfa4199">populateFoldReshapeOpsByCollapsingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="#a9f4136d97cdab12f0760756f1adc1721">ControlFusionFn</a> &amp;controlFoldingReshapes)</td></tr>
<tr class="memdesc:a3c8bdabd42dfb2f3617cc87eccfa4199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold an expanding tensor.expand_shape operation with its producer generic operation by collapsing the dimensions of the generic op.  <br /></td></tr>
<tr class="memitem:ad0b142daa69f3f2b8986960b726ba2eb" id="r_ad0b142daa69f3f2b8986960b726ba2eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0b142daa69f3f2b8986960b726ba2eb">populateConstantFoldLinalgOperations</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="#a9f4136d97cdab12f0760756f1adc1721">ControlFusionFn</a> &amp;controlFn)</td></tr>
<tr class="memdesc:ad0b142daa69f3f2b8986960b726ba2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to constant fold Linalg operations.  <br /></td></tr>
<tr class="memitem:aeb6bcda20dbb76f4b453abfc31adcc98" id="r_aeb6bcda20dbb76f4b453abfc31adcc98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb6bcda20dbb76f4b453abfc31adcc98">populateFoldAddIntoDestPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aeb6bcda20dbb76f4b453abfc31adcc98"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to replace <span class="tt">linalg.add</span> when destination passing on a contraction op suffices for achieving the sum.  <br /></td></tr>
<tr class="memitem:a0e0b4c454598e4be0bd0fcde89783a20" id="r_a0e0b4c454598e4be0bd0fcde89783a20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e0b4c454598e4be0bd0fcde89783a20">populateFuseTensorPadWithProducerLinalgOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a0e0b4c454598e4be0bd0fcde89783a20"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to fuse a <span class="tt">tensor.pad</span> operation with the producer of its source, if the producer is a <span class="tt">linalg</span> operation with all parallel iterator types.  <br /></td></tr>
<tr class="memitem:a588c1b33d58eb56f528112cfef47bffb" id="r_a588c1b33d58eb56f528112cfef47bffb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a588c1b33d58eb56f528112cfef47bffb">populateSimplifyDepthwiseConvPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a588c1b33d58eb56f528112cfef47bffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to simplify depthwise convolutions.  <br /></td></tr>
<tr class="memitem:a7134894ce50357a7e8fefe7c379acac7" id="r_a7134894ce50357a7e8fefe7c379acac7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7134894ce50357a7e8fefe7c379acac7">populateFoldUnitExtentDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:a7134894ce50357a7e8fefe7c379acac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold unit-extent dimensions in operands/results of linalg ops on tensors via reassociative reshape ops.  <br /></td></tr>
<tr class="memitem:a042bb54cd9155ed1ca8818a16ab5110a" id="r_a042bb54cd9155ed1ca8818a16ab5110a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a042bb54cd9155ed1ca8818a16ab5110a">populateMoveInitOperandsToInputPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a042bb54cd9155ed1ca8818a16ab5110a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern that converts init operands to input operands.  <br /></td></tr>
<tr class="memitem:acc64a8c8a9ecf3de84383893d8e4ddc2" id="r_acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc64a8c8a9ecf3de84383893d8e4ddc2">populateInlineConstantOperandsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns that are used to inline constant operands into linalg generic ops.  <br /></td></tr>
<tr class="memitem:a18fce962e3d12d2dfc3b467076c71f39" id="r_a18fce962e3d12d2dfc3b467076c71f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18fce962e3d12d2dfc3b467076c71f39">populateBubbleUpExtractSliceOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a18fce962e3d12d2dfc3b467076c71f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns that are used to bubble up extract slice op above linalg op.  <br /></td></tr>
<tr class="memitem:ac8003a713f74f7a32cc681c245ae9708" id="r_ac8003a713f74f7a32cc681c245ae9708"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8003a713f74f7a32cc681c245ae9708">populateSwapExtractSliceWithFillPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ac8003a713f74f7a32cc681c245ae9708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds patterns that waps tensor.extract_slice(linalg.fill(cst, init)) into linalg.fill(cst, tensor.extract_slice(init)).  <br /></td></tr>
<tr class="memitem:a3a1d8a95a9bec4041581a35ce791a503" id="r_a3a1d8a95a9bec4041581a35ce791a503"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a1d8a95a9bec4041581a35ce791a503">populateDecomposeProjectedPermutationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a3a1d8a95a9bec4041581a35ce791a503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add patterns to make explicit broadcasts and transforms in the input operands of a genericOp.  <br /></td></tr>
<tr class="memitem:a0c26bb1f203c97b9d5bcf9b8ae6ea102" id="r_a0c26bb1f203c97b9d5bcf9b8ae6ea102"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c26bb1f203c97b9d5bcf9b8ae6ea102">populateSplitReductionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="#a505f71c7a182531357360cb2151dc1f3">ControlSplitReductionFn</a> &amp;controlSplitReductionFn, <a class="el" href="classbool.html">bool</a> useAlloc=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a0c26bb1f203c97b9d5bcf9b8ae6ea102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to apply <span class="tt">splitReduction</span> below.  <br /></td></tr>
<tr class="memitem:a0786aed514452424d437b02ff9816dce" id="r_a0786aed514452424d437b02ff9816dce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0786aed514452424d437b02ff9816dce">populateTransposeMatmulPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classbool.html">bool</a> transposeLHS=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:a0786aed514452424d437b02ff9816dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to convert Linalg matmul ops to transposed variants.  <br /></td></tr>
<tr class="memitem:a1bf177055be0ddc8558b82cfbf4f8df7" id="r_a1bf177055be0ddc8558b82cfbf4f8df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bf177055be0ddc8558b82cfbf4f8df7">populateBlockPackMatmulPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="#a41903a6655e9be09920ce399e3e71865">ControlBlockPackMatmulFn</a> &amp;controlFn)</td></tr>
<tr class="memdesc:a1bf177055be0ddc8558b82cfbf4f8df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to block pack Linalg matmul ops.  <br /></td></tr>
<tr class="memitem:a4a5263d91b36edf98bda8c609f486214" id="r_a4a5263d91b36edf98bda8c609f486214"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a5263d91b36edf98bda8c609f486214">populateWinogradConv2DPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, WinogradConv2DFmr fmr)</td></tr>
<tr class="memdesc:a4a5263d91b36edf98bda8c609f486214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to apply Winograd Conv2D algorithm F(m x m, r x r).  <br /></td></tr>
<tr class="memitem:a88f5ef52c3bd7a0c67503bb7b5f97ae7" id="r_a88f5ef52c3bd7a0c67503bb7b5f97ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88f5ef52c3bd7a0c67503bb7b5f97ae7">populateDecomposeWinogradOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a88f5ef52c3bd7a0c67503bb7b5f97ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to decompose Winograd operators.  <br /></td></tr>
<tr class="memitem:a08373cf12e45f28268db4e84f038f6ca" id="r_a08373cf12e45f28268db4e84f038f6ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08373cf12e45f28268db4e84f038f6ca">populateContractionOpRankReducingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a08373cf12e45f28268db4e84f038f6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds patterns that reduce the rank of named contraction ops that have unit dimensions in the operand(s) by converting to a sequence of <span class="tt">collapse_shape</span>, <span class="tt">&lt;corresponding linalg named op&gt;</span>, <span class="tt">expand_shape</span> (if on tensors).  <br /></td></tr>
<tr class="memitem:ab23b572eea62b16b1020bd964dc67d36" id="r_ab23b572eea62b16b1020bd964dc67d36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab23b572eea62b16b1020bd964dc67d36">populateFoldIntoPackAndUnpackPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="#abf9a441fc28af495ff61ceedd25694d2">ControlFoldIntoPackUnpackFn</a> &amp;controlFn=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:ab23b572eea62b16b1020bd964dc67d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns that fold operations like <span class="tt">tensor.pad</span> and <span class="tt">tensor.extract_slice</span> into <span class="tt">tensor.pack</span> and <span class="tt">tensor.unpack</span> operations respectively.  <br /></td></tr>
<tr class="memitem:aac248e317eae5124cbaad8bbb832a806" id="r_aac248e317eae5124cbaad8bbb832a806"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac248e317eae5124cbaad8bbb832a806">populateFoldPackUnpackIntoTensorEmptyPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aac248e317eae5124cbaad8bbb832a806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns that fold operations like <span class="tt"><a class="el" href="#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a></span> and <span class="tt">linalg.unpack</span> into <span class="tt">tensor.empty</span>.  <br /></td></tr>
<tr class="memitem:aab3e6438bd84e7e76e5352c0c54fb5b7" id="r_aab3e6438bd84e7e76e5352c0c54fb5b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab3e6438bd84e7e76e5352c0c54fb5b7">populateSimplifyPackAndUnpackPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aab3e6438bd84e7e76e5352c0c54fb5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns that simplify <span class="tt">tensor.pack</span> and <span class="tt">tensor.unpack</span> operations.  <br /></td></tr>
<tr class="memitem:a92b42ab91002d8c468cb54eaebdb3989" id="r_a92b42ab91002d8c468cb54eaebdb3989"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92b42ab91002d8c468cb54eaebdb3989">getPackInverseDestPerm</a> (linalg::PackOp packOp, PackingMetadata &amp;metadata)</td></tr>
<tr class="memdesc:a92b42ab91002d8c468cb54eaebdb3989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute inverse permutation for the destination tensor (i.e.  <br /></td></tr>
<tr class="memitem:a1a3bb0a48c5e2778ea2bfd81a41db65d" id="r_a1a3bb0a48c5e2778ea2bfd81a41db65d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a3bb0a48c5e2778ea2bfd81a41db65d">getUnPackInverseSrcPerm</a> (linalg::UnPackOp, PackingMetadata &amp;metadata)</td></tr>
<tr class="memdesc:a1a3bb0a48c5e2778ea2bfd81a41db65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute inverse permutation for the source tensor (i.e.  <br /></td></tr>
<tr class="memitem:a1eda2843cbf0dc5507bc64ec67f46f22" id="r_a1eda2843cbf0dc5507bc64ec67f46f22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1eda2843cbf0dc5507bc64ec67f46f22">allIndexingsAreProjectedPermutation</a> (LinalgOp op)</td></tr>
<tr class="memdesc:a1eda2843cbf0dc5507bc64ec67f46f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all indexing maps are projected permutations.  <br /></td></tr>
<tr class="memitem:a5473845890c7e81fc544f7bfce900d81" id="r_a5473845890c7e81fc544f7bfce900d81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5473845890c7e81fc544f7bfce900d81">hasOnlyScalarElementwiseOp</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;r)</td></tr>
<tr class="memdesc:a5473845890c7e81fc544f7bfce900d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether <span class="tt">r</span> has only ConstantOp, ElementwiseMappable and YieldOp.  <br /></td></tr>
<tr class="memitem:a8b1c347bc995910212c197f9f8728b12" id="r_a8b1c347bc995910212c197f9f8728b12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b1c347bc995910212c197f9f8728b12">isElementwise</a> (LinalgOp op)</td></tr>
<tr class="memdesc:a8b1c347bc995910212c197f9f8728b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a LinalgOp is an element-wise operation.  <br /></td></tr>
<tr class="memitem:a24909cfdf87977961b71f1ca78a25919" id="r_a24909cfdf87977961b71f1ca78a25919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24909cfdf87977961b71f1ca78a25919">isParallelIterator</a> (utils::IteratorType iteratorType)</td></tr>
<tr class="memdesc:a24909cfdf87977961b71f1ca78a25919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if iterator type has "parallel" semantics.  <br /></td></tr>
<tr class="memitem:a5377722f56e02541897c157260bd1eee" id="r_a5377722f56e02541897c157260bd1eee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5377722f56e02541897c157260bd1eee">isReductionIterator</a> (utils::IteratorType iteratorType)</td></tr>
<tr class="memdesc:a5377722f56e02541897c157260bd1eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if iterator type has "reduction" semantics.  <br /></td></tr>
<tr class="memitem:ad11bd07c6a72404260df26efdd0ba069" id="r_ad11bd07c6a72404260df26efdd0ba069"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad11bd07c6a72404260df26efdd0ba069">makeComposedPadHighOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, RankedTensorType type, <a class="el" href="classmlir_1_1Value.html">Value</a> source, <a class="el" href="classmlir_1_1Value.html">Value</a> padding, <a class="el" href="classbool.html">bool</a> nofold, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> typeDynDims={})</td></tr>
<tr class="memdesc:ad11bd07c6a72404260df26efdd0ba069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a tensor::PadOp that pads <span class="tt">source</span> to the shape of <span class="tt">type</span> whose sizes are assumed to be greater than the dynamic <span class="tt">source</span> size.  <br /></td></tr>
<tr class="memitem:a30703b58e97c9678d9ee3d95c1b31f5d" id="r_a30703b58e97c9678d9ee3d95c1b31f5d"><td class="memItemLeft" align="right" valign="top">GenericOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30703b58e97c9678d9ee3d95c1b31f5d">makeMemRefCopyOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> from, <a class="el" href="classmlir_1_1Value.html">Value</a> to)</td></tr>
<tr class="memdesc:a30703b58e97c9678d9ee3d95c1b31f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns GenericOp that copies an n-D memref.  <br /></td></tr>
<tr class="memitem:a6c303f22e35937f101dc36b676ef8861" id="r_a6c303f22e35937f101dc36b676ef8861"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c303f22e35937f101dc36b676ef8861">getReassociationMapForFoldingUnitDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedSizes)</td></tr>
<tr class="memdesc:a6c303f22e35937f101dc36b676ef8861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reassociation maps to fold the result of a extract_slice (or source of a insert_slice) operation with given offsets, and sizes to its rank-reduced version.  <br /></td></tr>
<tr class="memitem:ad5cf6cfb2d2c8ac100efa843033bc4b7" id="r_ad5cf6cfb2d2c8ac100efa843033bc4b7"><td class="memTemplParams" colspan="2">template&lt;typename ConvOpTy&gt; </td></tr>
<tr class="memitem:ad5cf6cfb2d2c8ac100efa843033bc4b7 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">isaConvolutionOpOfType</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memdesc:ad5cf6cfb2d2c8ac100efa843033bc4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a linalg <span class="tt">op</span> this function returns true if it is a convolution op of type <span class="tt">ConvOpTy</span> and populates <span class="tt">dilations</span> and <span class="tt">strides</span> with values inferred from the indexing maps.  <br /></td></tr>
<tr class="memitem:a358e4f52f7be98a79c9189eb82a42eef" id="r_a358e4f52f7be98a79c9189eb82a42eef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a358e4f52f7be98a79c9189eb82a42eef">computeTileOffsets</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes)</td></tr>
<tr class="memdesc:a358e4f52f7be98a79c9189eb82a42eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes tile offsets, given a list of loop <span class="tt">ivs</span> and <span class="tt">tileSizes</span>.  <br /></td></tr>
<tr class="memitem:a29aed62cd711098f063d5a628905c074" id="r_a29aed62cd711098f063d5a628905c074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29aed62cd711098f063d5a628905c074">computeTileSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizeBounds)</td></tr>
<tr class="memdesc:a29aed62cd711098f063d5a628905c074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes tile sizes, given a list of <span class="tt">tileSizes</span> and dimension sizes (<span class="tt">sizeBounds</span>).  <br /></td></tr>
<tr class="memitem:af2da35587b12f700693b151c166fee34" id="r_af2da35587b12f700693b151c166fee34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2da35587b12f700693b151c166fee34">getTensorOutputTypes</a> (LinalgOp op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memdesc:af2da35587b12f700693b151c166fee34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of tensor output types produced when the given structured operation <span class="tt">op</span> is applied to the given <span class="tt">operands</span>.  <br /></td></tr>
<tr class="memitem:a78f9038823afe23e270d5bdc0734bc3e" id="r_a78f9038823afe23e270d5bdc0734bc3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78f9038823afe23e270d5bdc0734bc3e">insertSlicesBack</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, LinalgOp op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> results)</td></tr>
<tr class="memdesc:a78f9038823afe23e270d5bdc0734bc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <span class="tt">insert_slice</span> ops that insert <span class="tt">results</span> back into larger tensors they were originally extracted from with <span class="tt">extract_slice</span> before being passed as <span class="tt">operands</span> to the given structured operation <span class="tt">op</span> or its clone.  <br /></td></tr>
<tr class="memitem:afc396179b7b2aee5cfef868a42592c60" id="r_afc396179b7b2aee5cfef868a42592c60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc396179b7b2aee5cfef868a42592c60">computeSliceParameters</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> valueToTile, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; lbs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; subShapeSizes, <a class="el" href="classbool.html">bool</a> omitPartialTileCheck)</td></tr>
<tr class="memdesc:afc396179b7b2aee5cfef868a42592c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html" title="A struct containg offsets-sizes-strides arguments of the tiled shape.">SliceParameters</a> for a single <span class="tt">valueToTile</span> assuming that its user is being tiled with the given loop bounds <span class="tt">lbs</span> and <span class="tt">ubs</span> and the tile sizes <span class="tt">tileSizes</span>.  <br /></td></tr>
<tr class="memitem:aa06c54273304b8d82c1b239db2b7db90" id="r_aa06c54273304b8d82c1b239db2b7db90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; std::optional&lt; <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa06c54273304b8d82c1b239db2b7db90">computeAllSliceParameters</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, LinalgOp linalgOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> valuesToTile, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizeBounds, <a class="el" href="classbool.html">bool</a> omitPartialTileCheck)</td></tr>
<tr class="memdesc:aa06c54273304b8d82c1b239db2b7db90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes SliceParamaters for all <span class="tt">valuesToTile</span> of the given <span class="tt">linalgOp</span>, assuming <span class="tt">linalgOp</span> is being fused into a loop nest.  <br /></td></tr>
<tr class="memitem:aa568a297670d2eb8609fa6df9849a449" id="r_aa568a297670d2eb8609fa6df9849a449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa568a297670d2eb8609fa6df9849a449">makeTiledShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> valueToTile, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; lbs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; subShapeSizes, <a class="el" href="classbool.html">bool</a> omitPartialTileCheck)</td></tr>
<tr class="memdesc:aa568a297670d2eb8609fa6df9849a449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an extract_slice/subview op for a single <span class="tt">valueToTile</span> with <span class="tt">builder</span>.  <br /></td></tr>
<tr class="memitem:a1a5fecbf19090f24723800d371f08271" id="r_a1a5fecbf19090f24723800d371f08271"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a5fecbf19090f24723800d371f08271">makeTiledShapes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, LinalgOp linalgOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> valuesToTile, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizeBounds, <a class="el" href="classbool.html">bool</a> omitPartialTileCheck)</td></tr>
<tr class="memdesc:a1a5fecbf19090f24723800d371f08271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates extract_slice/subview ops for all <span class="tt">valuesToTile</span> of the given <span class="tt">linalgOp</span> with <span class="tt">builder</span>, assuming <span class="tt">linalgOp</span> is being fused into a loop nest for tiling with the given induction variables <span class="tt">ivs</span> and tile sizes <span class="tt">tileSizes</span>.  <br /></td></tr>
<tr class="memitem:a917a655a236200d3202b07fb842561b8" id="r_a917a655a236200d3202b07fb842561b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a917a655a236200d3202b07fb842561b8">offsetIndices</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; offests)</td></tr>
<tr class="memdesc:a917a655a236200d3202b07fb842561b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the specified offsets to any <span class="tt">linalg.index</span> ops contained in the given <span class="tt">linalgOp</span>.  <br /></td></tr>
<tr class="memitem:a34bed319cb33ba0b063edefa38e27309" id="r_a34bed319cb33ba0b063edefa38e27309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34bed319cb33ba0b063edefa38e27309">offsetIndices</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; offests)</td></tr>
<tr class="memitem:a13c5cf1a47f0bf5b6405224845ff8d83" id="r_a13c5cf1a47f0bf5b6405224845ff8d83"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13c5cf1a47f0bf5b6405224845ff8d83">fuseProducerOfTensor</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumerOpOperand)</td></tr>
<tr class="memdesc:a13c5cf1a47f0bf5b6405224845ff8d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implements the fusion part of the "tileAndFuse on tensors" transformation and thus requires the <span class="tt">consumerOpOperand</span> to be a <span class="tt">extract_slice</span> op (generally obtained by applying the tiling transformation).  <br /></td></tr>
<tr class="memitem:aa7195637d33a1cf8133bc32a219adf6b" id="r_aa7195637d33a1cf8133bc32a219adf6b"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7195637d33a1cf8133bc32a219adf6b">fuseProducerOfTensor</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> producerOpResult, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumerOpOperand)</td></tr>
<tr class="memdesc:aa7195637d33a1cf8133bc32a219adf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implements the fusion part of the "tileAndFuse on tensors" transformation and thus requires the <span class="tt">consumerOpOperand</span> to be a <span class="tt">extract_slice</span> op (generally obtained by applying the tiling transformation).  <br /></td></tr>
<tr class="memitem:aeb173d5edf56a08ed3610924312dd364" id="r_aeb173d5edf56a08ed3610924312dd364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb173d5edf56a08ed3610924312dd364">updateBoundsForCyclicDistribution</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> procId, <a class="el" href="classmlir_1_1Value.html">Value</a> nprocs, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;lb, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;ub, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;step)</td></tr>
<tr class="memdesc:aeb173d5edf56a08ed3610924312dd364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the <span class="tt">lb</span>, <span class="tt">ub</span> and <span class="tt">step</span> to get per processor <span class="tt">lb</span>, <span class="tt">ub</span> and <span class="tt">step</span>.  <br /></td></tr>
<tr class="memitem:af1aae248ee953a6fbfb303c090499f77" id="r_af1aae248ee953a6fbfb303c090499f77"><td class="memTemplParams" colspan="2">template&lt;typename OpTy&gt; </td></tr>
<tr class="memitem:af1aae248ee953a6fbfb303c090499f77 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1aae248ee953a6fbfb303c090499f77">getPrunedAttributeList</a> (OpTy op)</td></tr>
<tr class="memdesc:af1aae248ee953a6fbfb303c090499f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an attribute list that excludes pre-defined attributes.  <br /></td></tr>
<tr class="memitem:a9ff863e16e260bf9475bda668a896737" id="r_a9ff863e16e260bf9475bda668a896737"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ff863e16e260bf9475bda668a896737">getAffineResultPositions</a> (<a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> maps)</td></tr>
<tr class="memitem:af003de5775138c2f4af68e820e46c856" id="r_af003de5775138c2f4af68e820e46c856"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af003de5775138c2f4af68e820e46c856">parseIndexingMapsAttr</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser)</td></tr>
<tr class="memitem:a61f099443ddafc2ff4b45a9788b324d0" id="r_a61f099443ddafc2ff4b45a9788b324d0"><td class="memItemLeft" align="right" valign="top">static ArityGroupAndKind&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61f099443ddafc2ff4b45a9788b324d0">getArityGroupAndKind</a> (ElementwiseKind kind)</td></tr>
<tr class="memitem:ac247eeed2a533c7ace799fd5b9c50b8d" id="r_ac247eeed2a533c7ace799fd5b9c50b8d"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac247eeed2a533c7ace799fd5b9c50b8d">getPackedOuterShapeWithoutTransposition&lt; PackOp &gt;</a> (PackOp)</td></tr>
<tr class="memitem:a799fb205c9451cc54d83e002d1c9bc09" id="r_a799fb205c9451cc54d83e002d1c9bc09"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a799fb205c9451cc54d83e002d1c9bc09">getPackedOuterShapeWithoutTransposition&lt; UnPackOp &gt;</a> (UnPackOp)</td></tr>
<tr class="memitem:af5828de2a3f61427e6a01bbaa121901a" id="r_af5828de2a3f61427e6a01bbaa121901a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5828de2a3f61427e6a01bbaa121901a">getNewMixedTileSizes</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Type.html">Type</a> newPackedTy, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedTiles)</td></tr>
<tr class="memitem:a0369f798f7a1803f0c897c0f33edb5e5" id="r_a0369f798f7a1803f0c897c0f33edb5e5"><td class="memTemplParams" colspan="2">template&lt;typename OpTy&gt; </td></tr>
<tr class="memitem:a0369f798f7a1803f0c897c0f33edb5e5 template"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0369f798f7a1803f0c897c0f33edb5e5">reifyResultShapesImpl</a> (OpTy op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="namespacemlir.html#a676bc3fbf14bd5dba33f962b259d2034">ReifiedRankedShapedTypeDims</a> &amp;reifiedReturnShapes)</td></tr>
<tr class="memitem:a452649ff168e997865fbea4d06890b29" id="r_a452649ff168e997865fbea4d06890b29"><td class="memTemplParams" colspan="2">template&lt;typename OpTy&gt; </td></tr>
<tr class="memitem:a452649ff168e997865fbea4d06890b29 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="classint64__t.html">int64_t</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a452649ff168e997865fbea4d06890b29">getDimAndTileMappingImpl</a> (OpTy op)</td></tr>
<tr class="memitem:a41950140c9f81b74b3bdcf1747160ed1" id="r_a41950140c9f81b74b3bdcf1747160ed1"><td class="memTemplParams" colspan="2">template&lt;typename OpTy&gt; </td></tr>
<tr class="memitem:a41950140c9f81b74b3bdcf1747160ed1 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41950140c9f81b74b3bdcf1747160ed1">getMixedTilesImpl</a> (OpTy op)</td></tr>
<tr class="memitem:a22ac062da6f15e8f1e328b24ded2109e" id="r_a22ac062da6f15e8f1e328b24ded2109e"><td class="memTemplParams" colspan="2">template&lt;typename OpTy&gt; </td></tr>
<tr class="memitem:a22ac062da6f15e8f1e328b24ded2109e template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22ac062da6f15e8f1e328b24ded2109e">getStaticTilesImpl</a> (OpTy op)</td></tr>
<tr class="memitem:a258a284dc398c6d6510840831132df77" id="r_a258a284dc398c6d6510840831132df77"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a258a284dc398c6d6510840831132df77">isInvalidPackingPosSpecification</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; dimsPos, size_t rank)</td></tr>
<tr class="memdesc:a258a284dc398c6d6510840831132df77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <span class="tt">dimsPos</span> is invalid.  <br /></td></tr>
<tr class="memitem:aedf3c885687f3ae6238ad0c1106e6af8" id="r_aedf3c885687f3ae6238ad0c1106e6af8"><td class="memTemplParams" colspan="2">template&lt;typename OpTy&gt; </td></tr>
<tr class="memitem:aedf3c885687f3ae6238ad0c1106e6af8 template"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedf3c885687f3ae6238ad0c1106e6af8">commonVerifierPackAndUnPackOp</a> (OpTy packOrUnPack)</td></tr>
<tr class="memitem:a6cdc3ac4dd00e8808043082728373fd6" id="r_a6cdc3ac4dd00e8808043082728373fd6"><td class="memTemplParams" colspan="2">template&lt;typename OpTy&gt; </td></tr>
<tr class="memitem:a6cdc3ac4dd00e8808043082728373fd6 template"><td class="memItemLeft" align="right" valign="top">static PackOrUnPackTransposeResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cdc3ac4dd00e8808043082728373fd6">commonPermutationOfPackAndUnPackOp</a> (OpTy packOrUnPackOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; innerPermutation, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; outerPermutation)</td></tr>
<tr class="memitem:a02ee241a4bb22b8a6b72bff3cbabc365" id="r_a02ee241a4bb22b8a6b72bff3cbabc365"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02ee241a4bb22b8a6b72bff3cbabc365">asShapeWithAnyValueAsDynamic</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; ofrs)</td></tr>
<tr class="memdesc:a02ee241a4bb22b8a6b72bff3cbabc365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts OpFoldResults to <a class="el" href="classint64__t.html">int64_t</a> shape entries, unconditionally mapping all <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>'s to kDynamic, even if they are arith.constant values.  <br /></td></tr>
<tr class="memitem:af17100c1511fdc6b92fdbf9bd5aeb36c" id="r_af17100c1511fdc6b92fdbf9bd5aeb36c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af17100c1511fdc6b92fdbf9bd5aeb36c">getPackOpResultTypeShape</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; sourceShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; innerTileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; innerDimsPos, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; outerDimsPerm)</td></tr>
<tr class="memdesc:af17100c1511fdc6b92fdbf9bd5aeb36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for PackOp::{getResultShape,inferPackedType}.  <br /></td></tr>
<tr class="memitem:a74ddf9b40207216c2561bf0bd807a1df" id="r_a74ddf9b40207216c2561bf0bd807a1df"><td class="memTemplParams" colspan="2">template&lt;typename OpTy&gt; </td></tr>
<tr class="memitem:a74ddf9b40207216c2561bf0bd807a1df template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74ddf9b40207216c2561bf0bd807a1df">areTilesAndTiledDimsAllConstant</a> (OpTy op)</td></tr>
<tr class="memdesc:a74ddf9b40207216c2561bf0bd807a1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the tiles and the tiled dims are constant.  <br /></td></tr>
<tr class="memitem:abe3de4bb45fd63e06339cb0ba92533fa" id="r_abe3de4bb45fd63e06339cb0ba92533fa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe3de4bb45fd63e06339cb0ba92533fa">hasSameInnerOuterAttribute</a> (PackOp packOp, UnPackOp unPackOp)</td></tr>
<tr class="memitem:aa603d3bdb590cef7749279812bd8e11a" id="r_aa603d3bdb590cef7749279812bd8e11a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa603d3bdb590cef7749279812bd8e11a">haveSameTiles</a> (PackOp packOp, UnPackOp unPackOp)</td></tr>
<tr class="memitem:a8f2b11de8cf430259d6ed044bfd270dd" id="r_a8f2b11de8cf430259d6ed044bfd270dd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f2b11de8cf430259d6ed044bfd270dd">paddingIsNotNeeded</a> (PackOp op)</td></tr>
<tr class="memdesc:a8f2b11de8cf430259d6ed044bfd270dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pack op does not need a padding value.  <br /></td></tr>
<tr class="memitem:a19f85ff360bf1a176189d8a29a349623" id="r_a19f85ff360bf1a176189d8a29a349623"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19f85ff360bf1a176189d8a29a349623">inferStaticShape</a> (PackOp packOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;srcShape, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;destShape)</td></tr>
<tr class="memdesc:a19f85ff360bf1a176189d8a29a349623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <span class="tt">srcShape</span> or <span class="tt">destShape</span> is different from the one in <span class="tt">packOp</span> and populates each with the inferred static shape.  <br /></td></tr>
<tr class="memitem:a20d84aa10cc5bda416b75ff65007c677" id="r_a20d84aa10cc5bda416b75ff65007c677"><td class="memTemplParams" colspan="2">template&lt;typename PackOrUnpackOp&gt; </td></tr>
<tr class="memitem:a20d84aa10cc5bda416b75ff65007c677 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20d84aa10cc5bda416b75ff65007c677">isLikePadUnPad</a> (PackOrUnpackOp packOp, RankedTensorType packedTensorType)</td></tr>
<tr class="memitem:af8bfb7adf709f8802dfc47a8e602ecb0" id="r_af8bfb7adf709f8802dfc47a8e602ecb0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8bfb7adf709f8802dfc47a8e602ecb0">inferStaticShape</a> (UnPackOp op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;srcShape, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;destShape)</td></tr>
<tr class="memdesc:af8bfb7adf709f8802dfc47a8e602ecb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <span class="tt">srcShape</span> or <span class="tt">destShape</span> is different from the one in <span class="tt">op</span> and populates each with the inferred static shape.  <br /></td></tr>
<tr class="memitem:ab874160ec1bdc15b5c867c4799391a03" id="r_ab874160ec1bdc15b5c867c4799391a03"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab874160ec1bdc15b5c867c4799391a03">hasAllOneValues</a> (<a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a> attr)</td></tr>
<tr class="memitem:a3f801aa72135899ae36567a9c78c5b3b" id="r_a3f801aa72135899ae36567a9c78c5b3b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f801aa72135899ae36567a9c78c5b3b">createAdd</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> x, <a class="el" href="classmlir_1_1Value.html">Value</a> y, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memitem:a80e6451d40cef8244025d03bc83cfdad" id="r_a80e6451d40cef8244025d03bc83cfdad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80e6451d40cef8244025d03bc83cfdad">createMul</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> x, <a class="el" href="classmlir_1_1Value.html">Value</a> y, <a class="el" href="classmlir_1_1Type.html">Type</a> accType, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memitem:adacf5e0254e7596246d56037bab384ec" id="r_adacf5e0254e7596246d56037bab384ec"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adacf5e0254e7596246d56037bab384ec">getConvolvedExpr</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classint64__t.html">int64_t</a> stride, <a class="el" href="classbool.html">bool</a> useSymbols=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memitem:a88f5597fa9ab33dcc1e4270e6af512ca" id="r_a88f5597fa9ab33dcc1e4270e6af512ca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1linalg_1_1Im2ColToInputDimsExprs.html">Im2ColToInputDimsExprs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88f5597fa9ab33dcc1e4270e6af512ca">getIm2ColInputExpressions</a> (<a class="el" href="structmlir_1_1linalg_1_1Im2ColToOperandsExprs.html">Im2ColToOperandsExprs</a> exprs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; strides, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter)</td></tr>
<tr class="memdesc:a88f5597fa9ab33dcc1e4270e6af512ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the affine expressions that map the indices of the im2col matrix to the corresponding input tensor indices for a 2D convolution with the the provided strides.  <br /></td></tr>
<tr class="memitem:a351f651dd2a55b2a452b56d68c2e2c4c" id="r_a351f651dd2a55b2a452b56d68c2e2c4c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a9aed87a08c001b3ef7e0fcbd273041aa">ReductionKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a351f651dd2a55b2a452b56d68c2e2c4c">getReductionKind</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a0f875e0531bfb0cf383ff1ca108092b0" id="r_a0f875e0531bfb0cf383ff1ca108092b0"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f875e0531bfb0cf383ff1ca108092b0">getCombinerOp</a> (LinalgOp op)</td></tr>
<tr class="memitem:ada28e3e4bc6c8c677652c60e01bf2b6a" id="r_ada28e3e4bc6c8c677652c60e01bf2b6a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a9aed87a08c001b3ef7e0fcbd273041aa">ReductionKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada28e3e4bc6c8c677652c60e01bf2b6a">getReductionKindOfLinalgOp</a> (LinalgOp op)</td></tr>
<tr class="memitem:affb58b5d5caada44bf94cd80eb843637" id="r_affb58b5d5caada44bf94cd80eb843637"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a5b2e5401a45d4e16070ebd5dcaef36b2">GridOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affb58b5d5caada44bf94cd80eb843637">getGrid</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#a03c57ac3b7bfa817f644e03dcf9a5de2">Sharding</a> &gt; operandShardings, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#a03c57ac3b7bfa817f644e03dcf9a5de2">Sharding</a> &gt; resultShardings, <a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> &amp;symbolTable)</td></tr>
<tr class="memitem:a491060ab8a250d42c9650c00ef3fc571" id="r_a491060ab8a250d42c9650c00ef3fc571"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a491060ab8a250d42c9650c00ef3fc571">createDestinationPassingStyleInitOperand</a> (LinalgOp op, int operandNumber, <a class="el" href="classmlir_1_1Value.html">Value</a> partitionedOperand, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#aa3c699ae89529032fd3f3dc9ef8fe839">GridAxis</a> &gt; reductionGridAxes, <a class="el" href="#a5b2e5401a45d4e16070ebd5dcaef36b2">GridOp</a> gridOp, <a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;builder)</td></tr>
<tr class="memitem:ac06fb8c7958f744e2ed23f25c4da79ba" id="r_ac06fb8c7958f744e2ed23f25c4da79ba"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac06fb8c7958f744e2ed23f25c4da79ba">createDestinationPassingStyleInitOperands</a> (LinalgOp op, <a class="el" href="#a5b2e5401a45d4e16070ebd5dcaef36b2">GridOp</a> gridOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; partitionedOperands, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#aa3c699ae89529032fd3f3dc9ef8fe839">GridAxis</a> &gt; reductionGridAxes, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;partitionMap, <a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;builder)</td></tr>
<tr class="memitem:a503baeef1328177c20af2c28710f0066" id="r_a503baeef1328177c20af2c28710f0066"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a503baeef1328177c20af2c28710f0066">createAllReduceForResultsWithoutPartialShardings</a> (LinalgOp unshardedOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#aa3c699ae89529032fd3f3dc9ef8fe839">GridAxis</a> &gt; opReductionGridAxes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#a03c57ac3b7bfa817f644e03dcf9a5de2">Sharding</a> &gt; resultShardings, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;partitionMap, <a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;builder)</td></tr>
<tr class="memitem:a1ef94144fa6cebafabf150478f750ff9" id="r_a1ef94144fa6cebafabf150478f750ff9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ef94144fa6cebafabf150478f750ff9">partitionLinalgOpWithShardedReduction</a> (LinalgOp op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; partitionedOperands, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#a03c57ac3b7bfa817f644e03dcf9a5de2">Sharding</a> &gt; operandShardings, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#a03c57ac3b7bfa817f644e03dcf9a5de2">Sharding</a> &gt; resultShardings, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt; loopIteratorTypes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="#aa3c699ae89529032fd3f3dc9ef8fe839">GridAxis</a> &gt; &gt; gridAxisAssignmentForLoopIterators, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;partitionMap, <a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> &amp;symbolTable, <a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;builder)</td></tr>
<tr class="memitem:a645065016a10ad2397796861ba5b8c3e" id="r_a645065016a10ad2397796861ba5b8c3e"><td class="memTemplParams" colspan="2">template&lt;typename OpType&gt; </td></tr>
<tr class="memitem:a645065016a10ad2397796861ba5b8c3e template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a645065016a10ad2397796861ba5b8c3e">registerOne</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memitem:a688a83ed3c19e68f4acfed8486771451" id="r_a688a83ed3c19e68f4acfed8486771451"><td class="memTemplParams" colspan="2">template&lt;typename... OpTypes&gt; </td></tr>
<tr class="memitem:a688a83ed3c19e68f4acfed8486771451 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a688a83ed3c19e68f4acfed8486771451">registerAll</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:a688a83ed3c19e68f4acfed8486771451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic helper function.  <br /></td></tr>
<tr class="memitem:a90bd97b279b588f6e57a048d72a69a9c" id="r_a90bd97b279b588f6e57a048d72a69a9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90bd97b279b588f6e57a048d72a69a9c">populateTransposeConv2DPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:ad12a26862a648652876cc38d26ddcd23" id="r_ad12a26862a648652876cc38d26ddcd23"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad12a26862a648652876cc38d26ddcd23">winogradConv2D</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcFhwcOp op, linalg::WinogradConv2DFmr fmr)</td></tr>
<tr class="memitem:a1d5a2792af9c24eb321985a0f4442464" id="r_a1d5a2792af9c24eb321985a0f4442464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d5a2792af9c24eb321985a0f4442464">getPackInverseDestPerm</a> (PackOp packOp, PackingMetadata &amp;metadata)</td></tr>
<tr class="memitem:a61460bb1ec0632288e4f52ee867278a8" id="r_a61460bb1ec0632288e4f52ee867278a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61460bb1ec0632288e4f52ee867278a8">getUnPackInverseSrcPerm</a> (UnPackOp unpackOp, PackingMetadata &amp;metadata)</td></tr>
<tr class="memitem:a57e3e50fb10350b034260d4b714368a9" id="r_a57e3e50fb10350b034260d4b714368a9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57e3e50fb10350b034260d4b714368a9">getBlockArgumentWithOptionalCastOps</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a57e3e50fb10350b034260d4b714368a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a> that leads to <span class="tt">val</span>, if any.  <br /></td></tr>
<tr class="memitem:a4803ab5c8ab6d8f92fcdec833a265820" id="r_a4803ab5c8ab6d8f92fcdec833a265820"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4803ab5c8ab6d8f92fcdec833a265820">bodyMatcherForZeroPointOffsets</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *addOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *mulOp, <a class="el" href="classmlir_1_1Block.html">Block</a> *body)</td></tr>
<tr class="memdesc:a4803ab5c8ab6d8f92fcdec833a265820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to match the zero point offset body of quantized convolution ops.  <br /></td></tr>
<tr class="memitem:a1f177bab21bc6c0f3a1e1c14eb03807c" id="r_a1f177bab21bc6c0f3a1e1c14eb03807c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f177bab21bc6c0f3a1e1c14eb03807c">bodyMatcherForConvolutionOps</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> yieldVal, <a class="el" href="classmlir_1_1Block.html">Block</a> *body, <a class="el" href="classbool.html">bool</a> containsZeroPointOffset=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a1f177bab21bc6c0f3a1e1c14eb03807c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to match block body for convolution ops.  <br /></td></tr>
<tr class="memitem:a5a01a296ec108f04defef07ea3072e7c" id="r_a5a01a296ec108f04defef07ea3072e7c"><td class="memTemplParams" colspan="2">template&lt;typename... OpTypes&gt; </td></tr>
<tr class="memitem:a5a01a296ec108f04defef07ea3072e7c template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a01a296ec108f04defef07ea3072e7c">bodyMatcherForPoolOps</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> yieldVal, <a class="el" href="classmlir_1_1Block.html">Block</a> *body)</td></tr>
<tr class="memdesc:a5a01a296ec108f04defef07ea3072e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to match block body for linalg.pool* ops.  <br /></td></tr>
<tr class="memitem:a493d6854d6211cfea0a8dbf213466725" id="r_a493d6854d6211cfea0a8dbf213466725"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a493d6854d6211cfea0a8dbf213466725">bodyMatcherForMaxSignedPoolOps</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> yieldVal, <a class="el" href="classmlir_1_1Block.html">Block</a> *body)</td></tr>
<tr class="memitem:a785f8dbd31d36a780420ddb4a05529e2" id="r_a785f8dbd31d36a780420ddb4a05529e2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a785f8dbd31d36a780420ddb4a05529e2">bodyMatcherForMaxUnsignedPoolOps</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> yieldVal, <a class="el" href="classmlir_1_1Block.html">Block</a> *body)</td></tr>
<tr class="memitem:aacb2a57b81339e20de0ece0eca140dc9" id="r_aacb2a57b81339e20de0ece0eca140dc9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacb2a57b81339e20de0ece0eca140dc9">bodyMatcherForMinSignedPoolOps</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> yieldVal, <a class="el" href="classmlir_1_1Block.html">Block</a> *body)</td></tr>
<tr class="memitem:a451b80c8bf7f4d00bb04aa5cfea90dc5" id="r_a451b80c8bf7f4d00bb04aa5cfea90dc5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a451b80c8bf7f4d00bb04aa5cfea90dc5">bodyMatcherForMinUnsignedPoolOps</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> yieldVal, <a class="el" href="classmlir_1_1Block.html">Block</a> *body)</td></tr>
<tr class="memitem:a92375e22f376341bdf10ce63737dfad3" id="r_a92375e22f376341bdf10ce63737dfad3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92375e22f376341bdf10ce63737dfad3">bodyMatcherForSumPoolOps</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> yieldVal, <a class="el" href="classmlir_1_1Block.html">Block</a> *body)</td></tr>
<tr class="memitem:a57c1353b2da290a69434399a04a994fa" id="r_a57c1353b2da290a69434399a04a994fa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57c1353b2da290a69434399a04a994fa">getAffineMapDim</a> (<a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> indexingMaps, uint32_t mapIndex, uint32_t dimIndex)</td></tr>
<tr class="memitem:adc256f0d611f6f167955a5fc0d35c542" id="r_adc256f0d611f6f167955a5fc0d35c542"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc256f0d611f6f167955a5fc0d35c542">isDimTimesConstantOrDimOnly</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;dim)</td></tr>
<tr class="memdesc:adc256f0d611f6f167955a5fc0d35c542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <span class="tt">expr</span> is either:  <br /></td></tr>
<tr class="memitem:aaccfb97ed7b794263563cb312b75c0ca" id="r_aaccfb97ed7b794263563cb312b75c0ca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaccfb97ed7b794263563cb312b75c0ca">matchConvDimAddExprPattern</a> (<a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> indexingMaps, <a class="el" href="classunsigned.html">unsigned</a> iDim, <a class="el" href="classunsigned.html">unsigned</a> fDim, <a class="el" href="classunsigned.html">unsigned</a> oDim, <a class="el" href="classint64__t.html">int64_t</a> &amp;dilation, <a class="el" href="classint64__t.html">int64_t</a> &amp;stride)</td></tr>
<tr class="memdesc:aaccfb97ed7b794263563cb312b75c0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array of AffineMaps <span class="tt">indexingMaps</span> verify the following commutatively:- indexingMaps[0].getResult(iDim) == indexingMaps[1].getResult(fDim) * &lt;c0&gt; + indexingMaps[n-1].getResult(oDim) * &lt;c1&gt; where,.  <br /></td></tr>
<tr class="memitem:aa9b5e5d8f840f9cd69a9257bec9d1b55" id="r_aa9b5e5d8f840f9cd69a9257bec9d1b55"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9b5e5d8f840f9cd69a9257bec9d1b55">convLayoutMatches</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &gt; mapListExpected, <a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> indexingMaps, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:aa9b5e5d8f840f9cd69a9257bec9d1b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given indexing maps matches with the expected indexing maps.  <br /></td></tr>
<tr class="memitem:a1ffbd632e2d58f582f3e675ed4961d11" id="r_a1ffbd632e2d58f582f3e675ed4961d11"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1ffbd632e2d58f582f3e675ed4961d11 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ffbd632e2d58f582f3e675ed4961d11">isaConvolutionOpOfType&lt; linalg::Conv1DOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:ac72c2d9c21aeb5f939e149892ccd4f1d" id="r_ac72c2d9c21aeb5f939e149892ccd4f1d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac72c2d9c21aeb5f939e149892ccd4f1d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac72c2d9c21aeb5f939e149892ccd4f1d">isaConvolutionOpOfType&lt; linalg::Conv1DNwcWcfOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a2ccd13eed8b4883288fff8e4ddb70550" id="r_a2ccd13eed8b4883288fff8e4ddb70550"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2ccd13eed8b4883288fff8e4ddb70550 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ccd13eed8b4883288fff8e4ddb70550">isaConvolutionOpOfType&lt; linalg::Conv1DNcwFcwOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a3652d880723e9fe9030efc75b4796b75" id="r_a3652d880723e9fe9030efc75b4796b75"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3652d880723e9fe9030efc75b4796b75 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3652d880723e9fe9030efc75b4796b75">isaConvolutionOpOfType&lt; linalg::Conv2DOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:ab72cb2343a00a08b64eba22a8b3ff3ed" id="r_ab72cb2343a00a08b64eba22a8b3ff3ed"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab72cb2343a00a08b64eba22a8b3ff3ed template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab72cb2343a00a08b64eba22a8b3ff3ed">isaConvolutionOpOfType&lt; linalg::Conv2DNhwcHwcfOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a05a4ead0e9693a4d927e7945ba01a6c7" id="r_a05a4ead0e9693a4d927e7945ba01a6c7"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a05a4ead0e9693a4d927e7945ba01a6c7 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05a4ead0e9693a4d927e7945ba01a6c7">isaConvolutionOpOfType&lt; linalg::Conv2DNhwcHwcfQOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:ab65bfad16b799f7b843af5496c3a3d5a" id="r_ab65bfad16b799f7b843af5496c3a3d5a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab65bfad16b799f7b843af5496c3a3d5a template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab65bfad16b799f7b843af5496c3a3d5a">isaConvolutionOpOfType&lt; linalg::Conv2DNhwcFhwcOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:ab73b5e645b8a1bcde0c85ca92eaaf5f2" id="r_ab73b5e645b8a1bcde0c85ca92eaaf5f2"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab73b5e645b8a1bcde0c85ca92eaaf5f2 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab73b5e645b8a1bcde0c85ca92eaaf5f2">isaConvolutionOpOfType&lt; linalg::Conv2DNhwcFhwcQOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a44d5c7a263e7866b254d3345b76606a5" id="r_a44d5c7a263e7866b254d3345b76606a5"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a44d5c7a263e7866b254d3345b76606a5 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44d5c7a263e7866b254d3345b76606a5">isaConvolutionOpOfType&lt; linalg::Conv2DNchwFchwOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a9f2abec2f144cdaa94c9ec88a7fa811d" id="r_a9f2abec2f144cdaa94c9ec88a7fa811d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9f2abec2f144cdaa94c9ec88a7fa811d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f2abec2f144cdaa94c9ec88a7fa811d">isaConvolutionOpOfType&lt; linalg::Conv2DNchwFchwQOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a444a777a6371ee3853783c0eb66498a9" id="r_a444a777a6371ee3853783c0eb66498a9"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a444a777a6371ee3853783c0eb66498a9 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a444a777a6371ee3853783c0eb66498a9">isaConvolutionOpOfType&lt; linalg::Conv2DNgchwFgchwOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a565f6703ec3f519ad23e0dbf21ad4133" id="r_a565f6703ec3f519ad23e0dbf21ad4133"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a565f6703ec3f519ad23e0dbf21ad4133 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a565f6703ec3f519ad23e0dbf21ad4133">isaConvolutionOpOfType&lt; linalg::Conv2DNgchwGfchwOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a93e4e48b0b9d958118b8bc858f7b0c8a" id="r_a93e4e48b0b9d958118b8bc858f7b0c8a"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a93e4e48b0b9d958118b8bc858f7b0c8a template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93e4e48b0b9d958118b8bc858f7b0c8a">isaConvolutionOpOfType&lt; linalg::Conv2DNgchwGfchwQOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:aaad1dedfd1a75b6b22eaf5832074aa71" id="r_aaad1dedfd1a75b6b22eaf5832074aa71"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aaad1dedfd1a75b6b22eaf5832074aa71 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaad1dedfd1a75b6b22eaf5832074aa71">isaConvolutionOpOfType&lt; linalg::Conv2DNhwgcGfhwcOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a3389d7d40ab4e152d42551834ddaef96" id="r_a3389d7d40ab4e152d42551834ddaef96"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3389d7d40ab4e152d42551834ddaef96 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3389d7d40ab4e152d42551834ddaef96">isaConvolutionOpOfType&lt; linalg::Conv2DNhwgcGfhwcQOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a467dc274a8b53da6d8f2fc0e3652996d" id="r_a467dc274a8b53da6d8f2fc0e3652996d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a467dc274a8b53da6d8f2fc0e3652996d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a467dc274a8b53da6d8f2fc0e3652996d">isaConvolutionOpOfType&lt; linalg::Conv3DOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a7e34b5813ebc19922109bf642c603ee5" id="r_a7e34b5813ebc19922109bf642c603ee5"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7e34b5813ebc19922109bf642c603ee5 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e34b5813ebc19922109bf642c603ee5">isaConvolutionOpOfType&lt; linalg::DepthwiseConv1DNcwCwOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a4118447711892cbf3b2a3abec5c2acaa" id="r_a4118447711892cbf3b2a3abec5c2acaa"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a4118447711892cbf3b2a3abec5c2acaa template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4118447711892cbf3b2a3abec5c2acaa">isaConvolutionOpOfType&lt; linalg::DepthwiseConv1DNwcWcOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a9ad1d94837e0b166307a48e35c1b25f4" id="r_a9ad1d94837e0b166307a48e35c1b25f4"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9ad1d94837e0b166307a48e35c1b25f4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ad1d94837e0b166307a48e35c1b25f4">isaConvolutionOpOfType&lt; linalg::DepthwiseConv1DNwcWcmOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a1393714f9958cd16212c282bdf4282b4" id="r_a1393714f9958cd16212c282bdf4282b4"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1393714f9958cd16212c282bdf4282b4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1393714f9958cd16212c282bdf4282b4">isaConvolutionOpOfType&lt; linalg::DepthwiseConv2DNchwChwOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a602bb8a7a014244bddf1ff52238a94fe" id="r_a602bb8a7a014244bddf1ff52238a94fe"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a602bb8a7a014244bddf1ff52238a94fe template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a602bb8a7a014244bddf1ff52238a94fe">isaConvolutionOpOfType&lt; linalg::DepthwiseConv2DNhwcHwcOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:ab522e1456b3cde1c1ae05e4c42ccab3b" id="r_ab522e1456b3cde1c1ae05e4c42ccab3b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab522e1456b3cde1c1ae05e4c42ccab3b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab522e1456b3cde1c1ae05e4c42ccab3b">isaConvolutionOpOfType&lt; linalg::DepthwiseConv2DNhwcHwcQOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a8ac1ea88c5d05743ee23ef4c1ff0a657" id="r_a8ac1ea88c5d05743ee23ef4c1ff0a657"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8ac1ea88c5d05743ee23ef4c1ff0a657 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ac1ea88c5d05743ee23ef4c1ff0a657">isaConvolutionOpOfType&lt; linalg::DepthwiseConv2DNhwcHwcmOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a2e4917139f8f69e658ac803b391b0402" id="r_a2e4917139f8f69e658ac803b391b0402"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2e4917139f8f69e658ac803b391b0402 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e4917139f8f69e658ac803b391b0402">isaConvolutionOpOfType&lt; linalg::DepthwiseConv2DNhwcHwcmQOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a00054ed9c16213133183f0e6801e242b" id="r_a00054ed9c16213133183f0e6801e242b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a00054ed9c16213133183f0e6801e242b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00054ed9c16213133183f0e6801e242b">isaConvolutionOpOfType&lt; linalg::DepthwiseConv3DNdhwcDhwcmOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a47691e1a880347f57af5d61024168165" id="r_a47691e1a880347f57af5d61024168165"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a47691e1a880347f57af5d61024168165 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47691e1a880347f57af5d61024168165">isaConvolutionOpOfType&lt; linalg::PoolingNhwcMaxOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a9d73360b6d362ef7f9bd9477f8a7143c" id="r_a9d73360b6d362ef7f9bd9477f8a7143c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9d73360b6d362ef7f9bd9477f8a7143c template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d73360b6d362ef7f9bd9477f8a7143c">isaConvolutionOpOfType&lt; linalg::PoolingNhwcMinOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a04acf2f26e9a2817f7396b1f1f9409d4" id="r_a04acf2f26e9a2817f7396b1f1f9409d4"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a04acf2f26e9a2817f7396b1f1f9409d4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04acf2f26e9a2817f7396b1f1f9409d4">isaConvolutionOpOfType&lt; linalg::PoolingNhwcSumOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:afeffd7f1f218aa2f2c95d31622bac954" id="r_afeffd7f1f218aa2f2c95d31622bac954"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:afeffd7f1f218aa2f2c95d31622bac954 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afeffd7f1f218aa2f2c95d31622bac954">isaConvolutionOpOfType&lt; linalg::PoolingNhwcMaxUnsignedOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:aaf7d1b8633cd2c58c411b273567a686f" id="r_aaf7d1b8633cd2c58c411b273567a686f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aaf7d1b8633cd2c58c411b273567a686f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf7d1b8633cd2c58c411b273567a686f">isaConvolutionOpOfType&lt; linalg::PoolingNhwcMinUnsignedOp &gt;</a> (LinalgOp op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *dilations, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *strides)</td></tr>
<tr class="memitem:a330275ee0b8daf6e838a8bce3d70a331" id="r_a330275ee0b8daf6e838a8bce3d70a331"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a330275ee0b8daf6e838a8bce3d70a331">generateParallelLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt; iteratorTypes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">linalg::ProcInfo</a> &gt; procInfo, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivStorage)</td></tr>
<tr class="memdesc:a330275ee0b8daf6e838a8bce3d70a331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a loop nest consisting of scf.parallel and scf.for, depending on the <span class="tt">iteratorTypes.
</span> <br /></td></tr>
<tr class="memitem:abfc10c8ca9e8968a650ca511956358ab" id="r_abfc10c8ca9e8968a650ca511956358ab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfc10c8ca9e8968a650ca511956358ab">materializeTiledShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> valueToTile, const <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a> &amp;sliceParams)</td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a9ada278f74ee670af18b6bfd04271e3b" name="a9ada278f74ee670af18b6bfd04271e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ada278f74ee670af18b6bfd04271e3b">&#9670;&#160;</a></span>AllocBufferCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9ada278f74ee670af18b6bfd04271e3b">mlir::linalg::AllocBufferCallbackFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;std::optional&lt;Value&gt;(</div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, memref::SubViewOp subView,</div>
<div class="line">    <a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Value&gt;</a> boundingSubViewSize, <a class="code hl_class" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)&gt;</div>
<div class="ttc" id="aLinalgTransformOps_8cpp_html_a21ad0bd836b90d08f4cf640b4c298e7c"><div class="ttname"><a href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a></div><div class="ttdeci">b</div><div class="ttdoc">Return true if permutation is a valid permutation of the outer_dims_perm (case OuterOrInnerPerm::Oute...</div><div class="ttdef"><b>Definition</b> <a href="LinalgTransformOps_8cpp_source.html#l02097">LinalgTransformOps.cpp:2097</a></div></div>
<div class="ttc" id="aclassllvm_1_1ArrayRef_html"><div class="ttname"><a href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a></div><div class="ttdef"><b>Definition</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00048">LLVM.h:48</a></div></div>
<div class="ttc" id="aclassmlir_1_1DataLayout_html"><div class="ttname"><a href="classmlir_1_1DataLayout.html">mlir::DataLayout</a></div><div class="ttdoc">The main mechanism for performing data layout queries.</div><div class="ttdef"><b>Definition</b> <a href="DataLayoutInterfaces_8h_source.html#l00220">DataLayoutInterfaces.h:220</a></div></div>
<div class="ttc" id="aclassmlir_1_1OpBuilder_html"><div class="ttname"><a href="classmlir_1_1OpBuilder.html">mlir::OpBuilder</a></div><div class="ttdoc">This class helps build Operations.</div><div class="ttdef"><b>Definition</b> <a href="Builders_8h_source.html#l00207">Builders.h:207</a></div></div>
</div><!-- fragment -->
<p>Callback function type used to perform the allocation for the promoted <span class="tt">subView</span>. </p>
<p>In <span class="tt">boundingSubViewsize</span> a best attempt is made to find the smallest constant value for the size of the buffer needed for each dimension. If that is not possible, contains the dynamic size of the subview. The call back should return the buffer to use. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00378">378</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a41903a6655e9be09920ce399e3e71865" name="a41903a6655e9be09920ce399e3e71865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41903a6655e9be09920ce399e3e71865">&#9670;&#160;</a></span>ControlBlockPackMatmulFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a41903a6655e9be09920ce399e3e71865">mlir::linalg::ControlBlockPackMatmulFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;std::optional&lt;BlockPackMatmulOptions&gt;(linalg::LinalgOp)&gt;</div>
</div><!-- fragment -->
<p>Function type which is used to control matmul packing. </p>
<p>It is expected to return valid packing configuration for each operation. Lack of packing options indicates that no valid configuration could be assigned and the operation will not be packed. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01348">1348</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="abf9a441fc28af495ff61ceedd25694d2" name="abf9a441fc28af495ff61ceedd25694d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9a441fc28af495ff61ceedd25694d2">&#9670;&#160;</a></span>ControlFoldIntoPackUnpackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abf9a441fc28af495ff61ceedd25694d2">mlir::linalg::ControlFoldIntoPackUnpackFn</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *opOperand)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type which is used to control folding operations like <span class="tt">tensor.pad</span> and <span class="tt">tensor.extract_slice</span> into <a class="el" href="#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a>/unpack ops. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l02048">2048</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a9f4136d97cdab12f0760756f1adc1721" name="a9f4136d97cdab12f0760756f1adc1721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4136d97cdab12f0760756f1adc1721">&#9670;&#160;</a></span>ControlFusionFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9f4136d97cdab12f0760756f1adc1721">mlir::linalg::ControlFusionFn</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type which is used to control when to stop fusion. </p>
<p>It is expected that <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> is not modified in the callback. The <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> is not marked as const to allow callers to use non-const methods. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01920">1920</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="ac7e80c46fd448c104f6709b43c315755" name="ac7e80c46fd448c104f6709b43c315755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e80c46fd448c104f6709b43c315755">&#9670;&#160;</a></span>ControlPropagationFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac7e80c46fd448c104f6709b43c315755">mlir::linalg::ControlPropagationFn</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *opOperand)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type which is used to control propagation of <a class="el" href="#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a>/unpack ops. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01932">1932</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a505f71c7a182531357360cb2151dc1f3" name="a505f71c7a182531357360cb2151dc1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505f71c7a182531357360cb2151dc1f3">&#9670;&#160;</a></span>ControlSplitReductionFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a505f71c7a182531357360cb2151dc1f3">mlir::linalg::ControlSplitReductionFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;<a class="code hl_struct" href="structmlir_1_1linalg_1_1SplitReductionOptions.html">SplitReductionOptions</a>(LinalgOp op)&gt;</div>
<div class="ttc" id="astructmlir_1_1linalg_1_1SplitReductionOptions_html"><div class="ttname"><a href="structmlir_1_1linalg_1_1SplitReductionOptions.html">mlir::linalg::SplitReductionOptions</a></div><div class="ttdoc">Split Reduction options.</div><div class="ttdef"><b>Definition</b> <a href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00475">Transforms.h:475</a></div></div>
</div><!-- fragment -->
<p>Function signature to control reduction splitting. </p>
<p>This returns <span class="tt"><a class="el" href="structmlir_1_1linalg_1_1SplitReductionOptions.html" title="Split Reduction options.">SplitReductionOptions</a></span>. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00489">489</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="ae5b803f6d2ca1c42dc889264b80b690e" name="ae5b803f6d2ca1c42dc889264b80b690e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b803f6d2ca1c42dc889264b80b690e">&#9670;&#160;</a></span>CopyCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae5b803f6d2ca1c42dc889264b80b690e">mlir::linalg::CopyCallbackFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;LogicalResult(<a class="code hl_class" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="code hl_class" href="classmlir_1_1Value.html">Value</a> src, <a class="code hl_class" href="classmlir_1_1Value.html">Value</a> dst)&gt;</div>
<div class="ttc" id="aclassmlir_1_1Value_html"><div class="ttname"><a href="classmlir_1_1Value.html">mlir::Value</a></div><div class="ttdoc">This class represents an instance of an SSA value in the MLIR system, representing a computable value...</div><div class="ttdef"><b>Definition</b> <a href="Value_8h_source.html#l00096">Value.h:96</a></div></div>
</div><!-- fragment -->
<p>Callback function type used to insert copy from original subview to subview of the promoted region for the read operands/subview of promoted region to original subview for the results. </p>
<p>The copy has to happen from <span class="tt">src</span> to <span class="tt">dst</span>. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00391">391</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="abaf9a66d9ea1e1ccf22b88fd5f1446dc" name="abaf9a66d9ea1e1ccf22b88fd5f1446dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf9a66d9ea1e1ccf22b88fd5f1446dc">&#9670;&#160;</a></span>DeallocBufferCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abaf9a66d9ea1e1ccf22b88fd5f1446dc">mlir::linalg::DeallocBufferCallbackFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;LogicalResult(<a class="code hl_class" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="code hl_class" href="classmlir_1_1Value.html">Value</a> buffer)&gt;</div>
</div><!-- fragment -->
<p>Callback function type used to deallocate the buffers used to hold the promoted subview. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00384">384</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a0752c7523022c2c98068a86865e35096" name="a0752c7523022c2c98068a86865e35096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0752c7523022c2c98068a86865e35096">&#9670;&#160;</a></span>DroppedUnitDimsBuilder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0752c7523022c2c98068a86865e35096">mlir::linalg::DroppedUnitDimsBuilder</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;IndexingMapOpInterface(</div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1Location.html">Location</a> loc, <a class="code hl_class" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, IndexingMapOpInterface,</div>
<div class="line">    <a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Value&gt;</a> newOperands, <a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;AffineMap&gt;</a> newIndexingMaps,</div>
<div class="line">    <span class="keyword">const</span> llvm::SmallDenseSet&lt;unsigned&gt; &amp;droppedDims)&gt;</div>
<div class="ttc" id="aclassmlir_1_1Location_html"><div class="ttname"><a href="classmlir_1_1Location.html">mlir::Location</a></div><div class="ttdoc">This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...</div><div class="ttdef"><b>Definition</b> <a href="Location_8h_source.html#l00076">Location.h:76</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00544">544</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a56475069e4631a3e7e54964a3fc576bb" name="a56475069e4631a3e7e54964a3fc576bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56475069e4631a3e7e54964a3fc576bb">&#9670;&#160;</a></span>GetCollapsableDimensionsFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a56475069e4631a3e7e54964a3fc576bb">mlir::linalg::GetCollapsableDimensionsFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;SmallVector&lt;ReassociationIndices&gt;(linalg::LinalgOp)&gt;</div>
</div><!-- fragment -->
<p>Function type to control generic op dimension collapsing. </p>
<p>It is expected to return an array of <span class="tt"><a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a></span> representing dimensions that should be merged. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01958">1958</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="aa3c699ae89529032fd3f3dc9ef8fe839" name="aa3c699ae89529032fd3f3dc9ef8fe839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c699ae89529032fd3f3dc9ef8fe839">&#9670;&#160;</a></span>GridAxis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa3c699ae89529032fd3f3dc9ef8fe839">mlir::linalg::GridAxis</a> = <a class="el" href="namespacemlir_1_1shard.html#a7b2656e48e0e6a3a5732246fac941372">shard::GridAxis</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00039">39</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

</div>
</div>
<a id="a5b2e5401a45d4e16070ebd5dcaef36b2" name="a5b2e5401a45d4e16070ebd5dcaef36b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2e5401a45d4e16070ebd5dcaef36b2">&#9670;&#160;</a></span>GridOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5b2e5401a45d4e16070ebd5dcaef36b2">mlir::linalg::GridOp</a> = shard::GridOp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00043">43</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

</div>
</div>
<a id="a193831e3afcf32c859a980c17c8c276b" name="a193831e3afcf32c859a980c17c8c276b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193831e3afcf32c859a980c17c8c276b">&#9670;&#160;</a></span>LinalgLoops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a193831e3afcf32c859a980c17c8c276b">mlir::linalg::LinalgLoops</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00517">517</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="ac63ef3b10f63a46b5d07ad3cbf2ed19d" name="ac63ef3b10f63a46b5d07ad3cbf2ed19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63ef3b10f63a46b5d07ad3cbf2ed19d">&#9670;&#160;</a></span>LoopIndexToRangeIndexMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac63ef3b10f63a46b5d07ad3cbf2ed19d">mlir::linalg::LoopIndexToRangeIndexMap</a> = <a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt;int, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a number of ranges equal to the number of non-zero in <span class="tt">tileSizes</span>. </p>
<p>One for each loop of the LinalgOp that is tiled. The <span class="tt">tileSizes</span> argument has one entry per surrounding loop. It uses zero as the convention that a particular loop is not tiled. This convention simplifies implementations by avoiding affine map manipulations. The returned ranges correspond to the loop ranges, in the proper order, that are tiled and for which new loops will be created. Also the function returns a map from loop indices of the LinalgOp to the corresponding non-empty range indices of newly created loops. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00940">940</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="aa58f7a4c578e94b49e8c3f62f968d7b4" name="aa58f7a4c578e94b49e8c3f62f968d7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58f7a4c578e94b49e8c3f62f968d7b4">&#9670;&#160;</a></span>OptimizeCopyFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa58f7a4c578e94b49e8c3f62f968d7b4">mlir::linalg::OptimizeCopyFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;LogicalResult(<a class="code hl_class" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;, tensor::PadOp, <a class="code hl_class" href="classmlir_1_1Value.html">Value</a>)&gt;</div>
<div class="ttc" id="aclassmlir_1_1RewriterBase_html"><div class="ttname"><a href="classmlir_1_1RewriterBase.html">mlir::RewriterBase</a></div><div class="ttdoc">This class coordinates the application of a rewrite on a set of IR, providing a way for clients to tr...</div><div class="ttdef"><b>Definition</b> <a href="PatternMatch_8h_source.html#l00368">PatternMatch.h:368</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01643">1643</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a1f5ce0fcb27f388f81435ec80109e7c6" name="a1f5ce0fcb27f388f81435ec80109e7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5ce0fcb27f388f81435ec80109e7c6">&#9670;&#160;</a></span>PadSizeComputationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1f5ce0fcb27f388f81435ec80109e7c6">mlir::linalg::PadSizeComputationFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;FailureOr&lt;SmallVector&lt;OpFoldResult&gt;&gt;(</div>
<div class="line">        <a class="code hl_class" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="code hl_class" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;, <a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Range&gt;</a>,</div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_struct" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;)&gt;</div>
<div class="ttc" id="aclassmlir_1_1OpOperand_html"><div class="ttname"><a href="classmlir_1_1OpOperand.html">mlir::OpOperand</a></div><div class="ttdoc">This class represents an operand of an operation.</div><div class="ttdef"><b>Definition</b> <a href="Value_8h_source.html#l00257">Value.h:257</a></div></div>
<div class="ttc" id="astructmlir_1_1linalg_1_1PadTilingInterfaceOptions_html"><div class="ttname"><a href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">mlir::linalg::PadTilingInterfaceOptions</a></div><div class="ttdef"><b>Definition</b> <a href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00351">Transforms.h:351</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00627">627</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="aa9d0bb3427f7842586f487adf8b1c892" name="aa9d0bb3427f7842586f487adf8b1c892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d0bb3427f7842586f487adf8b1c892">&#9670;&#160;</a></span>ProcInfoCallBackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa9d0bb3427f7842586f487adf8b1c892">mlir::linalg::ProcInfoCallBackFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;SmallVector&lt;ProcInfo&gt;(</div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="code hl_class" href="classmlir_1_1Location.html">Location</a> loc, <a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Range&gt;</a> parallelLoopRanges)&gt;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00317">317</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a9aed87a08c001b3ef7e0fcbd273041aa" name="a9aed87a08c001b3ef7e0fcbd273041aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aed87a08c001b3ef7e0fcbd273041aa">&#9670;&#160;</a></span>ReductionKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9aed87a08c001b3ef7e0fcbd273041aa">mlir::linalg::ReductionKind</a> = shard::ReductionKind</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00040">40</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

</div>
</div>
<a id="a03c57ac3b7bfa817f644e03dcf9a5de2" name="a03c57ac3b7bfa817f644e03dcf9a5de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c57ac3b7bfa817f644e03dcf9a5de2">&#9670;&#160;</a></span>Sharding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a03c57ac3b7bfa817f644e03dcf9a5de2">mlir::linalg::Sharding</a> = <a class="el" href="classmlir_1_1shard_1_1Sharding.html">shard::Sharding</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00041">41</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

</div>
</div>
<a id="a410e0d11b6ec42849c958eea40544eb7" name="a410e0d11b6ec42849c958eea40544eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410e0d11b6ec42849c958eea40544eb7">&#9670;&#160;</a></span>ShardingArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a410e0d11b6ec42849c958eea40544eb7">mlir::linalg::ShardingArray</a> = <a class="el" href="namespacemlir_1_1shard.html#afb6ca6cc654847b5555ebca3a999679f">shard::ShardingArray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00042">42</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

</div>
</div>
<a id="a71a7fe9b3e7ece0cd20b6d4d11e08f6c" name="a71a7fe9b3e7ece0cd20b6d4d11e08f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a7fe9b3e7ece0cd20b6d4d11e08f6c">&#9670;&#160;</a></span>TileSizeComputationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a71a7fe9b3e7ece0cd20b6d4d11e08f6c">mlir::linalg::TileSizeComputationFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;SmallVector&lt;Value, 4&gt;(<a class="code hl_class" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</div>
<div class="ttc" id="aclassmlir_1_1Operation_html"><div class="ttname"><a href="classmlir_1_1Operation.html">mlir::Operation</a></div><div class="ttdoc">Operation is the basic unit of execution within MLIR.</div><div class="ttdef"><b>Definition</b> <a href="IR_2Operation_8h_source.html#l00084">Operation.h:88</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00187">187</a> of file <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a7382d59369873eb3a9a9ddd571056982" name="a7382d59369873eb3a9a9ddd571056982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7382d59369873eb3a9a9ddd571056982">&#9670;&#160;</a></span>DistributionMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a7382d59369873eb3a9a9ddd571056982">mlir::linalg::DistributionMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scheme used to distribute loops to processors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982ad71670d62b238eaf063979407361034e" name="a7382d59369873eb3a9a9ddd571056982ad71670d62b238eaf063979407361034e"></a>Cyclic&#160;</td><td class="fielddoc"><p>Cyclic distribution where no assumption is made about the dynamic relationship between number of processors and number of iterations of the distributed loop. </p>
<p>Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>scf.parallel(iv)= (lb + procId * step) to (ub) step (step * nprocs) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982abab54876ff518ecd2d59b46fd3be9c0e" name="a7382d59369873eb3a9a9ddd571056982abab54876ff518ecd2d59b46fd3be9c0e"></a>CyclicNumProcsGeNumIters&#160;</td><td class="fielddoc"><p>Cyclic distribution where the number of processors can be assumed to be more than or equal to the number of iterations of the distributed loop. </p>
<p>In such cases, a simple in-bounds check is enough (instead of materializing a loop). Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>iv = lb + procId * step cond = arith.cmpi "slt", iv, ub scf.if cond { ... } </p>
</td></tr>
<tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982ad93606014b9a6b479ba0e6faa948540b" name="a7382d59369873eb3a9a9ddd571056982ad93606014b9a6b479ba0e6faa948540b"></a>CyclicNumProcsEqNumIters&#160;</td><td class="fielddoc"><p>Cyclic distribution where the number of processors can be assumed to be equal to the number of iterations of the distributed loop. </p>
<p>In such cases, no bounds check is needed. Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>iv = lb + procId * step </p>
</td></tr>
<tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982a6adf97f83acf6453d4a6a4b1070f3754" name="a7382d59369873eb3a9a9ddd571056982a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>No Distribution. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00262">262</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a3cdd229e1459c7e6ed2f9c7ee7168325" name="a3cdd229e1459c7e6ed2f9c7ee7168325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdd229e1459c7e6ed2f9c7ee7168325">&#9670;&#160;</a></span>LinalgTilingLoopType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a3cdd229e1459c7e6ed2f9c7ee7168325">mlir::linalg::LinalgTilingLoopType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of loops to be generated during tiling. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8" name="a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8"></a>Loops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325a6d8bf0bdeaca5ef4693524bf04c4c877" name="a3cdd229e1459c7e6ed2f9c7ee7168325a6d8bf0bdeaca5ef4693524bf04c4c877"></a>AffineLoops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7" name="a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7"></a>ParallelLoops&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00121">121</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a40d13c577df4b312d3ad45984304cb44" name="a40d13c577df4b312d3ad45984304cb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d13c577df4b312d3ad45984304cb44">&#9670;&#160;</a></span>PoolingType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a40d13c577df4b312d3ad45984304cb44">mlir::linalg::PoolingType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum representing pooling operation types used by <a class="el" href="classmlir_1_1linalg_1_1ConvMatcherBuilder.html" title="Helper class for building convolution op matchers with minimal boilerplate.">ConvMatcherBuilder</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a40d13c577df4b312d3ad45984304cb44a6adf97f83acf6453d4a6a4b1070f3754" name="a40d13c577df4b312d3ad45984304cb44a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a40d13c577df4b312d3ad45984304cb44a583477bac684bf3bb33dc235e42b2917" name="a40d13c577df4b312d3ad45984304cb44a583477bac684bf3bb33dc235e42b2917"></a>MaxSigned&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a40d13c577df4b312d3ad45984304cb44ac2ccac122a6f900a003c02f50e20d192" name="a40d13c577df4b312d3ad45984304cb44ac2ccac122a6f900a003c02f50e20d192"></a>MaxUnsigned&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a40d13c577df4b312d3ad45984304cb44a4140dce47c9b4d749f275f08b3da30f3" name="a40d13c577df4b312d3ad45984304cb44a4140dce47c9b4d749f275f08b3da30f3"></a>MinSigned&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a40d13c577df4b312d3ad45984304cb44a70bbf81e0c89983c0da9482b2cd24936" name="a40d13c577df4b312d3ad45984304cb44a70bbf81e0c89983c0da9482b2cd24936"></a>MinUnsigned&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a40d13c577df4b312d3ad45984304cb44aa0ec87054b5e5b7847d0d8780a01a3d5" name="a40d13c577df4b312d3ad45984304cb44aa0ec87054b5e5b7847d0d8780a01a3d5"></a>Sum&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00501">501</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a1eda2843cbf0dc5507bc64ec67f46f22" name="a1eda2843cbf0dc5507bc64ec67f46f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eda2843cbf0dc5507bc64ec67f46f22">&#9670;&#160;</a></span>allIndexingsAreProjectedPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::allIndexingsAreProjectedPermutation </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if all indexing maps are projected permutations. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00195">195</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00215">isElementwise()</a>.</p>

</div>
</div>
<a id="a5606dfca8a9078fc6bc9b74972f15fdc" name="a5606dfca8a9078fc6bc9b74972f15fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5606dfca8a9078fc6bc9b74972f15fdc">&#9670;&#160;</a></span>allocateGPUPrivateMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::allocateGPUPrivateMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::SubViewOp</td>          <td class="paramname"><span class="paramname"><em>subview</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizeBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate the subview in the GPU private memory. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00496">496</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Promotion_8cpp_source.html#l00436">allocateSubviewGPUMemoryInAddressSpace()</a>.</p>

</div>
</div>
<a id="a266200755192d09deb827c799e59277b" name="a266200755192d09deb827c799e59277b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266200755192d09deb827c799e59277b">&#9670;&#160;</a></span>allocateWorkgroupMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::allocateWorkgroupMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::SubViewOp</td>          <td class="paramname"><span class="paramname"><em>subview</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizeBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate the subview in the GPU workgroup memory. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00471">471</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Promotion_8cpp_source.html#l00436">allocateSubviewGPUMemoryInAddressSpace()</a>.</p>

</div>
</div>
<a id="a133a3ec0d7cd50a886d2cd558fdc9030" name="a133a3ec0d7cd50a886d2cd558fdc9030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133a3ec0d7cd50a886d2cd558fdc9030">&#9670;&#160;</a></span>areDimSequencesPreserved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::areDimSequencesPreserved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>maps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dimSequences</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <span class="tt">true</span> if all sequences of dimensions specified in <span class="tt">dimSequences</span> are contiguous in all the ranges of the <span class="tt">maps</span>. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01347">1347</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01306">isDimSequencePreserved()</a>.</p>

</div>
</div>
<a id="a8fa220da60546acce7c4a8b3635d5b21" name="a8fa220da60546acce7c4a8b3635d5b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa220da60546acce7c4a8b3635d5b21">&#9670;&#160;</a></span>areElementwiseOpsFusable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::areElementwiseOpsFusable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *</td>          <td class="paramname"><span class="paramname"><em>fusedOperand</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if two <span class="tt">linalg.generic</span> operations with producer/consumer relationship through <span class="tt">fusedOperand</span> can be fused using elementwise op fusion. </p>
<p>Conditions for elementwise fusion of generic operations. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00139">139</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00047">getIndexingMapOfProducerOperandsInCoordinatesOfFusedOp()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00641">mlir::AffineMap::isPermutation()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00339">fuseElementwiseOps()</a>.</p>

</div>
</div>
<a id="a74ddf9b40207216c2561bf0bd807a1df" name="a74ddf9b40207216c2561bf0bd807a1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ddf9b40207216c2561bf0bd807a1df">&#9670;&#160;</a></span>areTilesAndTiledDimsAllConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::areTilesAndTiledDimsAllConstant </td>
          <td>(</td>
          <td class="paramtype">OpTy</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the tiles and the tiled dims are constant. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05512">5512</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01293">mlir::tile()</a>.</p>

</div>
</div>
<a id="a02ee241a4bb22b8a6b72bff3cbabc365" name="a02ee241a4bb22b8a6b72bff3cbabc365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ee241a4bb22b8a6b72bff3cbabc365">&#9670;&#160;</a></span>asShapeWithAnyValueAsDynamic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::linalg::asShapeWithAnyValueAsDynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ofrs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts OpFoldResults to <a class="el" href="classint64__t.html">int64_t</a> shape entries, unconditionally mapping all <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>'s to kDynamic, even if they are arith.constant values. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05377">5377</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="a5ca967d8e0b6ff895d26faaf60a79263" name="a5ca967d8e0b6ff895d26faaf60a79263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca967d8e0b6ff895d26faaf60a79263">&#9670;&#160;</a></span>blockPackMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt; mlir::linalg::blockPackMatmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a41903a6655e9be09920ce399e3e71865">ControlBlockPackMatmulFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>controlPackMatmul</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack a matmul operation into blocked 4D layout. </p>
<p>Relayout a matmul operation into blocked layout with two levels of subdivision:</p><ul>
<li>major 2D blocks - outer dimensions, consist of minor blocks</li>
<li>minor 2D blocks - inner dimensions, consist of scalar elements</li>
</ul>
<p>A 2D matmul MxNxK gets reshaped into blocked 4D representation as: [MB][NB][mb][nb] += [MB][KB][mb][kb] * [NB][KB][nb][kb] where the (MB, NB, KB) dimensions represent the major blocks, and the (mb, nb, kb) are the minor blocks of their respective original 2D dimensions (M, N, K).</p>
<p>Depending on the initial operands' data layout and the specified packing options, the major blocks dimensions might get transposed e.g., [MB][KB] -&gt; [KB][MB]. The minor blocks can also be transposed e.g., [mb][kb] -&gt; [kb][mb]. Any present batch dimensions remain unchanged. The final result is unpacked back to the original shape.</p>
<p>Return failure if no valid packing options are provided. </p>

<p class="definition">Definition at line <a class="el" href="BlockPackMatmul_8cpp_source.html#l00138">138</a> of file <a class="el" href="BlockPackMatmul_8cpp_source.html">BlockPackMatmul.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00081">mlir::getAsOpFoldResult()</a>, <a class="el" href="Builders_8cpp_source.html#l00281">mlir::Builder::getI64ArrayAttr()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00484">inferContractionDims()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00748">packMatmulGreedily()</a>, <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointAfter()</a>, <a class="el" href="BlockPackMatmul_8cpp_source.html#l00089">transposePackedMatmul()</a>, and <a class="el" href="BlockPackMatmul_8cpp_source.html#l00043">validateFullTilesOnDims()</a>.</p>

</div>
</div>
<a id="a1f177bab21bc6c0f3a1e1c14eb03807c" name="a1f177bab21bc6c0f3a1e1c14eb03807c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f177bab21bc6c0f3a1e1c14eb03807c">&#9670;&#160;</a></span>bodyMatcherForConvolutionOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::bodyMatcherForConvolutionOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>yieldVal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>containsZeroPointOffset</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility to match block body for convolution ops. </p>
<p>The body is thus expected to yield :- out + (lhs * rhs) where: lhs, rhs and out are block arguments and lhs and rhs can have optional upcast operation. NOTE: In case of zero point offset convolution ops lhs and rhs would be :- input - input_scalar where, input_scalar can have optional upcast operation. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00326">326</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00273">bodyMatcherForZeroPointOffsets()</a>, <a class="el" href="Value_8h_source.html#l00321">mlir::BlockArgument::getArgNumber()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00244">getBlockArgumentWithOptionalCastOps()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>, and <a class="el" href="Value_8h_source.html#l00318">mlir::BlockArgument::getOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00572">mlir::linalg::ConvMatcherBuilder::matchBody()</a>.</p>

</div>
</div>
<a id="a493d6854d6211cfea0a8dbf213466725" name="a493d6854d6211cfea0a8dbf213466725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493d6854d6211cfea0a8dbf213466725">&#9670;&#160;</a></span>bodyMatcherForMaxSignedPoolOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::bodyMatcherForMaxSignedPoolOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>yieldVal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>body</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00371">371</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00355">bodyMatcherForPoolOps()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00572">mlir::linalg::ConvMatcherBuilder::matchBody()</a>.</p>

</div>
</div>
<a id="a785f8dbd31d36a780420ddb4a05529e2" name="a785f8dbd31d36a780420ddb4a05529e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785f8dbd31d36a780420ddb4a05529e2">&#9670;&#160;</a></span>bodyMatcherForMaxUnsignedPoolOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::bodyMatcherForMaxUnsignedPoolOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>yieldVal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>body</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00378">378</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00355">bodyMatcherForPoolOps()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00572">mlir::linalg::ConvMatcherBuilder::matchBody()</a>.</p>

</div>
</div>
<a id="aacb2a57b81339e20de0ece0eca140dc9" name="aacb2a57b81339e20de0ece0eca140dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb2a57b81339e20de0ece0eca140dc9">&#9670;&#160;</a></span>bodyMatcherForMinSignedPoolOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::bodyMatcherForMinSignedPoolOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>yieldVal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>body</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00383">383</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00355">bodyMatcherForPoolOps()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00572">mlir::linalg::ConvMatcherBuilder::matchBody()</a>.</p>

</div>
</div>
<a id="a451b80c8bf7f4d00bb04aa5cfea90dc5" name="a451b80c8bf7f4d00bb04aa5cfea90dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451b80c8bf7f4d00bb04aa5cfea90dc5">&#9670;&#160;</a></span>bodyMatcherForMinUnsignedPoolOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::bodyMatcherForMinUnsignedPoolOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>yieldVal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>body</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00390">390</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00355">bodyMatcherForPoolOps()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00572">mlir::linalg::ConvMatcherBuilder::matchBody()</a>.</p>

</div>
</div>
<a id="a5a01a296ec108f04defef07ea3072e7c" name="a5a01a296ec108f04defef07ea3072e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a01a296ec108f04defef07ea3072e7c">&#9670;&#160;</a></span>bodyMatcherForPoolOps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... OpTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::bodyMatcherForPoolOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>yieldVal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>body</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility to match block body for linalg.pool* ops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00355">355</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00321">mlir::BlockArgument::getArgNumber()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00244">getBlockArgumentWithOptionalCastOps()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>, and <a class="el" href="Value_8h_source.html#l00318">mlir::BlockArgument::getOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00371">bodyMatcherForMaxSignedPoolOps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00378">bodyMatcherForMaxUnsignedPoolOps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00383">bodyMatcherForMinSignedPoolOps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00390">bodyMatcherForMinUnsignedPoolOps()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00395">bodyMatcherForSumPoolOps()</a>.</p>

</div>
</div>
<a id="a92375e22f376341bdf10ce63737dfad3" name="a92375e22f376341bdf10ce63737dfad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92375e22f376341bdf10ce63737dfad3">&#9670;&#160;</a></span>bodyMatcherForSumPoolOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::bodyMatcherForSumPoolOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>yieldVal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>body</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00395">395</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00355">bodyMatcherForPoolOps()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00572">mlir::linalg::ConvMatcherBuilder::matchBody()</a>.</p>

</div>
</div>
<a id="a4803ab5c8ab6d8f92fcdec833a265820" name="a4803ab5c8ab6d8f92fcdec833a265820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4803ab5c8ab6d8f92fcdec833a265820">&#9670;&#160;</a></span>bodyMatcherForZeroPointOffsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::bodyMatcherForZeroPointOffsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>addOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>mulOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>body</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to match the zero point offset body of quantized convolution ops. </p>
<p>Quantized convolutions have a body of the form: out + ((input - inputZp) * (filter - filterZp)) where:</p><ul>
<li>input is the input tensor element (block arg 0)</li>
<li>filter is the filter tensor element (block arg 1)</li>
<li>inputZp is the input zero-point scalar (block arg 2)</li>
<li>filterZp is the filter zero-point scalar (block arg 3)</li>
<li>out is the output accumulator (block arg 4)</li>
</ul>
<p>This function verifies that the multiplication operands are subtraction operations matching this pattern. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00273">273</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00321">mlir::BlockArgument::getArgNumber()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00244">getBlockArgumentWithOptionalCastOps()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>, and <a class="el" href="Value_8h_source.html#l00318">mlir::BlockArgument::getOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00326">bodyMatcherForConvolutionOps()</a>.</p>

</div>
</div>
<a id="a73274fcc2e8e228f5f44c6336b96e7b7" name="a73274fcc2e8e228f5f44c6336b96e7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73274fcc2e8e228f5f44c6336b96e7b7">&#9670;&#160;</a></span>bufferizeToAllocation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::bufferizeToAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bufferization::AllocTensorOp</td>          <td class="paramname"><span class="paramname"><em>allocTensorOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>memorySpace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>insertionPoint</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Materialize a buffer allocation for the given bufferization.alloc_tensor op and lower the op to memref.alloc + memref.tensor_store. </p>
<p>In addition to rewriting the IR, this function returns the newly allocated buffer. The <span class="tt">insertionPoint</span> parameter can be used to specify a custom insertion point for the buffer allocation. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00326">326</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00189">createAllocationForTensor()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a72d0ebe64f6077953145c8111cc3d955" name="a72d0ebe64f6077953145c8111cc3d955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d0ebe64f6077953145c8111cc3d955">&#9670;&#160;</a></span>bufferizeToAllocation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::bufferizeToAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>memorySpace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>insertionPoint</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize the given op with tensor semantics and materialize the result in a newly allocated buffer. </p>
<p>Only bufferizable ops that bufferize to a memory write or have an aliasing <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> (and do not themselves bufferize to an allocation) are supported. They are bufferized using their BufferizableOpInterface implementation.</p>
<p>Selected ops that bufferize to an allocation (or need special handling) are also supported:</p><ul>
<li>tensor.pad</li>
<li>vector.mask</li>
</ul>
<p>This function returns the newly allocated buffer. The <span class="tt">insertionPoint</span> parameter can be used to specify a custom insertion point for the buffer allocation. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00476">476</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a300387e92135ddafe3e8fcb45a1d0f4c">bufferizeToAllocation()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00189">createAllocationForTensor()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00056">createMemcpy()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="PatternMatch_8h_source.html#l00638">mlir::RewriterBase::modifyOpInPlace()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a300387e92135ddafe3e8fcb45a1d0f4c" name="a300387e92135ddafe3e8fcb45a1d0f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300387e92135ddafe3e8fcb45a1d0f4c">&#9670;&#160;</a></span>bufferizeToAllocation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::bufferizeToAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp</td>          <td class="paramname"><span class="paramname"><em>padOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>memorySpace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>insertionPoint</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Materialize a buffer allocation for the given tensor.pad op and lower the op to linalg.fill/linalg.generic + bufferization.materialize_in_destination. </p>
<p>E.g.:</p>
<p>%0 = tensor.pad low[l] high[h] t ...</p>
<p>is lowered to:</p>
<p>alloc = memref.alloc linalg.fill ... outs(alloc) subview = memref.subview alloc [l] [...] [1] bufferization.materialize_in_destination t in subview %0 = bufferization.to_tensor alloc restrict writable</p>
<p>In addition to rewriting the IR as shown above, this function returns the newly allocated buffer. The <span class="tt">insertionPoint</span> parameter can be used to specify a custom insertion point for the buffer allocation. </p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00476">bufferizeToAllocation()</a>, and <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00259">bufferizeToAllocation()</a>.</p>

</div>
</div>
<a id="a2b6184483164da0417ac58d1d5086bbc" name="a2b6184483164da0417ac58d1d5086bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6184483164da0417ac58d1d5086bbc">&#9670;&#160;</a></span>bufferizeToAllocation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::bufferizeToAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector::MaskOp</td>          <td class="paramname"><span class="paramname"><em>maskOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>memorySpace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>insertionPoint</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Materialize a buffer allocation for the given vector.mask op and bufferize the op, including its region. </p>
<p>E.g.:</p>
<p>%0 = vector.mask { vector.transfer_write v, t : <a class="el" href="namespacemlir_1_1vector.html">vector&lt;16xf32&gt;</a>, tensor&lt;?xf32&gt; } : <a class="el" href="namespacemlir_1_1vector.html">vector&lt;16xi1&gt;</a> -&gt; tensor&lt;?xf32&gt;</p>
<p>is lowered to:</p>
<p>alloc = memref.alloc bufferization.materialize_in_destination t in subview vector.mask { vector.transfer_write arg0, alloc : <a class="el" href="namespacemlir_1_1vector.html">vector&lt;16xf32&gt;</a>, memref&lt;?xf32&gt; } : <a class="el" href="namespacemlir_1_1vector.html">vector&lt;16xi1&gt;</a> %0 = bufferization.to_tensor alloc restrict writable</p>
<p>In addition to rewriting the IR as shown above, this function returns the newly allocated buffer. The <span class="tt">insertionPoint</span> parameter can be used to specify a custom insertion point for the buffer allocation. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00259">259</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a300387e92135ddafe3e8fcb45a1d0f4c">bufferizeToAllocation()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00638">mlir::RewriterBase::modifyOpInPlace()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="ae6a3be2f9306a873810377797b78bfc6" name="ae6a3be2f9306a873810377797b78bfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a3be2f9306a873810377797b78bfc6">&#9670;&#160;</a></span>collapseOpIterationDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1CollapseResult.html">CollapseResult</a> &gt; mlir::linalg::collapseOpIterationDims </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>foldedIterationDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collapses dimensions of linalg.generic/linalg.copy operation. </p>
<p>A precondition to calling this method is that for each list in <span class="tt">foldedIterationDim</span>, the sequence of dimensions is contiguous in domains of all <span class="tt">indexing_maps</span> of the <span class="tt">linalgOp</span>. This can be checked using <span class="tt">areDimSequencePreserved</span> method. When valid, the method also collapses the operands of the op. Returns replacement values of the results of the original <span class="tt">linalgOp</span> by inserting reshapes to get back values of compatible types. </p>

</div>
</div>
<a id="a6cdc3ac4dd00e8808043082728373fd6" name="a6cdc3ac4dd00e8808043082728373fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdc3ac4dd00e8808043082728373fd6">&#9670;&#160;</a></span>commonPermutationOfPackAndUnPackOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PackOrUnPackTransposeResult mlir::linalg::commonPermutationOfPackAndUnPackOp </td>
          <td>(</td>
          <td class="paramtype">OpTy</td>          <td class="paramname"><span class="paramname"><em>packOrUnPackOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>innerPermutation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>outerPermutation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05189">5189</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00226">mlir::applyPermutationToVector()</a>, and <a class="el" href="IndexingUtils_8cpp_source.html#l00204">mlir::isPermutationVector()</a>.</p>

</div>
</div>
<a id="aedf3c885687f3ae6238ad0c1106e6af8" name="aedf3c885687f3ae6238ad0c1106e6af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf3c885687f3ae6238ad0c1106e6af8">&#9670;&#160;</a></span>commonVerifierPackAndUnPackOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::commonVerifierPackAndUnPackOp </td>
          <td>(</td>
          <td class="paramtype">OpTy</td>          <td class="paramname"><span class="paramname"><em>packOrUnPack</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05091">5091</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05077">isInvalidPackingPosSpecification()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">mlir::isZeroInteger()</a>.</p>

</div>
</div>
<a id="aa06c54273304b8d82c1b239db2b7db90" name="aa06c54273304b8d82c1b239db2b7db90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06c54273304b8d82c1b239db2b7db90">&#9670;&#160;</a></span>computeAllSliceParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; std::optional&lt; <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a> &gt; &gt; mlir::linalg::computeAllSliceParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>valuesToTile</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ivs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizeBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>omitPartialTileCheck</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes SliceParamaters for all <span class="tt">valuesToTile</span> of the given <span class="tt">linalgOp</span>, assuming <span class="tt">linalgOp</span> is being fused into a loop nest. </p>
<p>Calls <span class="tt">computeSliceParameters</span> for every individual value.</p>
<p>Note that a constant zero in <span class="tt">tileSizes</span> means no tiling at that implicit loop. The number of non-zero values in <span class="tt">tileSizes</span> should be equal to the number of values in <span class="tt">ivs</span>.</p>
<p>Some of the <span class="tt">valuesToTile</span> won't be affected by tiling. For these values, std::nullopt will be returned. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02076">2076</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01891">computeSliceParameters()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02008">computeTileOffsets()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02022">computeTileSizes()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00074">isTiled()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02127">makeTiledShapes()</a>.</p>

</div>
</div>
<a id="aa18c5afa193d9ff81a24877f1087fec4" name="aa18c5afa193d9ff81a24877f1087fec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18c5afa193d9ff81a24877f1087fec4">&#9670;&#160;</a></span>computeContinuousTileSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContinuousTileSizeSpecification.html">ContinuousTileSizeSpecification</a> &gt; mlir::linalg::computeContinuousTileSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dimension</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>targetSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>emitAssertions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00156">156</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Builders_8h_source.html#l00526">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Tiling_8cpp_source.html#l00089">emitIsPositiveIndexAssertion()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00959">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01416">mlir::affine::makeComposedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00958">mlir::linalg::detail::ContinuousTileSizeSpecificationBase&lt; T &gt;::tileSizes</a>, and <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00960">mlir::linalg::detail::ContinuousTileSizeSpecificationBase&lt; T &gt;::tripCounts</a>.</p>

</div>
</div>
<a id="aa357f78e61caac5bae1dad723393734a" name="aa357f78e61caac5bae1dad723393734a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa357f78e61caac5bae1dad723393734a">&#9670;&#160;</a></span>computeIndexingMapOpInterfacePaddedShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; mlir::linalg::computeIndexingMapOpInterfacePaddedShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>operandToPad</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>iterationDomain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specific helper for Linalg ops. </p>

<p class="definition">Definition at line <a class="el" href="PadTilingInterface_8cpp_source.html#l00200">200</a> of file <a class="el" href="PadTilingInterface_8cpp_source.html">PadTilingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="PadTilingInterface_8cpp_source.html#l00099">computePaddedShape()</a>, <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00036">mlir::Range::offset</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00038">mlir::Range::stride</a>.</p>

</div>
</div>
<a id="af8ef5fd09c3c79a47b8c4732ace79928" name="af8ef5fd09c3c79a47b8c4732ace79928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ef5fd09c3c79a47b8c4732ace79928">&#9670;&#160;</a></span>computeMultiTileSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1MultiSizeSpecification.html">MultiSizeSpecification</a> &gt; mlir::linalg::computeMultiTileSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dimension</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>targetSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>emitAssertions</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits the IR computing the multi-sized tiling specification with two tile sizes not exceeding <span class="tt">targetSize</span>, each divisible by <span class="tt">sizeDivisor</span>, such that there exist numbers of tiles with these sizes that fully cover the given iteration space <span class="tt">dimension</span> of the structured <span class="tt">op</span>. </p>
<p>The computation is as follows:</p>
<p>b = originalTripCount floordiv sizeDivisor t = (targetSize + sizeDivisor - 1) floordiv sizeDivisor d = (b + t - 1) floordiv t s = (b floordiv d) * sizeDivisor v = b % d u = d - v</p>
<p>where the tile sizes are <span class="tt">s</span> and <span class="tt">s</span> + <span class="tt">sizeDivisor</span>, and the numbers of the corresponding tiles are <span class="tt">u</span> and <span class="tt">v</span>, respectively. Alternatively,</p>
<p>s * u + (s + sizeDivisor) * v == original size, where s mod sizeDivisor = 0.</p>
<p>Expects all values to be positive. In some cases with the target tile size sufficiently close to the dimension shape and non-unit divisor, it is impossible to compute such sizes. If <span class="tt">emitAssertion</span> is set, also emit the assertion that size computation succeeded.</p>
<p>Returns the specification consisting of both tile values and the number of tiles of each size. </p>

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00262">262</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Tiling_8cpp_source.html#l00089">emitIsPositiveIndexAssertion()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00959">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="Builders_8cpp_source.html#l00368">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00262">mlir::Builder::getStringAttr()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00950">mlir::linalg::detail::MultiSizeSpecificationBase&lt; T &gt;::lowTileSize</a>, <a class="el" href="AffineOps_8cpp_source.html#l01416">mlir::affine::makeComposedAffineApply()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01514">mlir::affine::makeComposedFoldedMultiResultAffineApply()</a>.</p>

</div>
</div>
<a id="a629d4548e517e8d9bfcdadacbc4d91fe" name="a629d4548e517e8d9bfcdadacbc4d91fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629d4548e517e8d9bfcdadacbc4d91fe">&#9670;&#160;</a></span>computePaddedShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::linalg::computePaddedShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a864cb5eb1fea4a548c28cda535ba7213">TypedValue</a>&lt; RankedTensorType &gt;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>indexingMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>indexingSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to compute the padded shape of the given value <span class="tt">v</span> of <span class="tt">RankedTensorType</span> given: </p>
<p>Compute the padded shape of the given value <span class="tt">v</span> of <span class="tt">RankedTensorType</span> given.</p>
<ul>
<li>the <span class="tt">indexingSizes</span> as a list of <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>.</li>
<li>an <span class="tt">indexingMap</span> that encodes how the padded shape varies with increases in <span class="tt">indexingSizes</span>. The implementation iteratively combines increases from contributing using affine.apply operations. The <span class="tt">indexingMap</span> + <span class="tt">indexingSizes</span> encoding suits StructuredOps and provides a gentle portability path for Linalg-like ops with affine maps. The padded shape is computed by evaluating the maximum accessed index per dimension, which may involve multiplying by constant factors derived from the affine indexing expressions. Currently, only a limited set of projected permuation indexing maps are supported, such as</li>
</ul>
<p>affine_map&lt;(d0, d1, d2) -&gt; (d0, d1)&gt;</p><ul>
<li>affine_map&lt;(d0, d1, d2) -&gt; (d0, d1 + d2)&gt;</li>
<li>affine_map&lt;(d0, d1) -&gt; (d0 * 3 + d1)&gt; In the future, more general interfaces can be devised to encode similar shape evolutions and map between an op and its operands.<ul>
<li><span class="tt">indexingSizes</span> a list of <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a>.</li>
<li>an <span class="tt">indexingMap</span> that encodes how the shape of varies with increases in <span class="tt">indexingSizes</span>. The <span class="tt">indexingMap</span> encodes how the shape of varies with <span class="tt">indexingSizes</span>. The <span class="tt">indexingMap</span> + <span class="tt">indexingSizes</span> encoding suits StructuredOps. The implementaiton below iteratively combines increases from contributing dimensions using affine.apply operations. The padded shape is computed by evaluating the maximum accessed index per dimension, which may involve multiplying by constant factors derived from the affine indexing expressions. Currently, only a limited set of projected permutation indexing maps are supported, such as</li>
</ul>
</li>
<li>affine_map&lt;(d0, d1, d2) -&gt; (d0, d1)&gt;</li>
<li>affine_map&lt;(d0, d1, d2) -&gt; (d0, d1 + d2)&gt;</li>
<li>affine_map&lt;(d0, d1) -&gt; (d0 * 3 + d1)&gt; In the future, more general interfaces can be devised to encode similar shape evolutions and map between an op and its operands. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="PadTilingInterface_8cpp_source.html#l00099">99</a> of file <a class="el" href="PadTilingInterface_8cpp_source.html">PadTilingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00316">mlir::bindDimsList()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01006">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">mlir::AffineMap::compose()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00104">createFoldedDimOp()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00032">DBGS</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00063">extractConstantMultiplier()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00037">getFullRankPaddingSizes()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">mlir::AffineMap::getSubMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00899">mlir::projectDims()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PadTilingInterface_8cpp_source.html#l00200">computeIndexingMapOpInterfacePaddedShape()</a>.</p>

</div>
</div>
<a id="afc396179b7b2aee5cfef868a42592c60" name="afc396179b7b2aee5cfef868a42592c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc396179b7b2aee5cfef868a42592c60">&#9670;&#160;</a></span>computeSliceParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a> mlir::linalg::computeSliceParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>valueToTile</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lbs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ubs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>subShapeSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>omitPartialTileCheck</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html" title="A struct containg offsets-sizes-strides arguments of the tiled shape.">SliceParameters</a> for a single <span class="tt">valueToTile</span> assuming that its user is being tiled with the given loop bounds <span class="tt">lbs</span> and <span class="tt">ubs</span> and the tile sizes <span class="tt">tileSizes</span>. </p>
<p><span class="tt">omitPartialTileCheck</span> controls whether to omit the partial/boundary tile condition check in cases where we statically know that it is unnecessary. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01891">1891</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00104">createFoldedDimOp()</a>, <a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">mlir::getAffineSymbolExpr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">mlir::AffineMap::getSubMap()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">mlir::AffineMap::inferFromExprList()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00074">isTiled()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01572">mlir::affine::makeComposedFoldedAffineMin()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00159">mlir::linalg::SliceParameters::offsets</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00160">mlir::linalg::SliceParameters::sizes</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00161">mlir::linalg::SliceParameters::strides</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02076">computeAllSliceParameters()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01878">makeTiledShape()</a>.</p>

</div>
</div>
<a id="aa3cdafc77c113c1fa2db8782dc0bdb29" name="aa3cdafc77c113c1fa2db8782dc0bdb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3cdafc77c113c1fa2db8782dc0bdb29">&#9670;&#160;</a></span>computeStaticContinuousTileSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1StaticContinuousTileSizeSpecification.html">StaticContinuousTileSizeSpecification</a> &gt; mlir::linalg::computeStaticContinuousTileSizes </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dimension</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>targetSize</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00106">106</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00958">mlir::linalg::detail::ContinuousTileSizeSpecificationBase&lt; T &gt;::tileSizes</a>, and <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00960">mlir::linalg::detail::ContinuousTileSizeSpecificationBase&lt; T &gt;::tripCounts</a>.</p>

</div>
</div>
<a id="a91c1fb37672289a396df9c95a9b1dd0b" name="a91c1fb37672289a396df9c95a9b1dd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c1fb37672289a396df9c95a9b1dd0b">&#9670;&#160;</a></span>computeStaticMultiTileSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1StaticMultiSizeSpecification.html">StaticMultiSizeSpecification</a> &gt; mlir::linalg::computeStaticMultiTileSizes </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dimension</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>targetSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>divisor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00236">236</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00950">mlir::linalg::detail::MultiSizeSpecificationBase&lt; T &gt;::highTileSize</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00952">mlir::linalg::detail::MultiSizeSpecificationBase&lt; T &gt;::highTripCount</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00950">mlir::linalg::detail::MultiSizeSpecificationBase&lt; T &gt;::lowTileSize</a>, and <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00952">mlir::linalg::detail::MultiSizeSpecificationBase&lt; T &gt;::lowTripCount</a>.</p>

</div>
</div>
<a id="a358e4f52f7be98a79c9189eb82a42eef" name="a358e4f52f7be98a79c9189eb82a42eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358e4f52f7be98a79c9189eb82a42eef">&#9670;&#160;</a></span>computeTileOffsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::linalg::computeTileOffsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ivs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tileSizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes tile offsets, given a list of loop <span class="tt">ivs</span> and <span class="tt">tileSizes</span>. </p>
<p>In case a tile size is zero (i.e., no tiling), the corresponding offset is also zero. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02008">2008</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00074">isTiled()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">mlir::isZeroInteger()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02076">computeAllSliceParameters()</a>.</p>

</div>
</div>
<a id="a29aed62cd711098f063d5a628905c074" name="a29aed62cd711098f063d5a628905c074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29aed62cd711098f063d5a628905c074">&#9670;&#160;</a></span>computeTileSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::linalg::computeTileSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizeBounds</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes tile sizes, given a list of <span class="tt">tileSizes</span> and dimension sizes (<span class="tt">sizeBounds</span>). </p>
<p>In case a tile size is zero (i.e., no tiling), the corresponding result size is the corresponding value from <span class="tt">sizeBounds</span>. Note: The returned tile sizes are closed intervals. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02022">2022</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00074">isTiled()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">mlir::isZeroInteger()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02076">computeAllSliceParameters()</a>.</p>

</div>
</div>
<a id="a4f8ea0aae80d24eeffa3fef8f1f08c43" name="a4f8ea0aae80d24eeffa3fef8f1f08c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8ea0aae80d24eeffa3fef8f1f08c43">&#9670;&#160;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the vector that is the concatenation of <span class="tt">a</span> and <span class="tt">b</span>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02474">2474</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>.</p>

</div>
</div>
<a id="aa9b5e5d8f840f9cd69a9257bec9d1b55" name="aa9b5e5d8f840f9cd69a9257bec9d1b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b5e5d8f840f9cd69a9257bec9d1b55">&#9670;&#160;</a></span>convLayoutMatches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::convLayoutMatches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>mapListExpected</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a></td>          <td class="paramname"><span class="paramname"><em>indexingMaps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given indexing maps matches with the expected indexing maps. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00488">488</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">mlir::AffineMap::inferFromExprList()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>.</p>

</div>
</div>
<a id="a88359f69353831d971485ff6b6b86dc1" name="a88359f69353831d971485ff6b6b86dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88359f69353831d971485ff6b6b86dc1">&#9670;&#160;</a></span>copyToGPUPrivateMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::copyToGPUPrivateMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>dst</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normal copy to between src and dst. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00504">504</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Value_8cpp_source.html#l00024">mlir::Value::getLoc()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a72fb3984f986840e0dc914c1ab90dc3b" name="a72fb3984f986840e0dc914c1ab90dc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fb3984f986840e0dc914c1ab90dc3b">&#9670;&#160;</a></span>copyToWorkgroupMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::copyToWorkgroupMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>dst</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create Memref copy operations and add gpu barrier guards before and after the copy operation to ensure data integrity. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00487">487</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="Value_8cpp_source.html#l00024">mlir::Value::getLoc()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a3f801aa72135899ae36567a9c78c5b3b" name="a3f801aa72135899ae36567a9c78c5b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f801aa72135899ae36567a9c78c5b3b">&#9670;&#160;</a></span>createAdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::createAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00033">33</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00416">rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00550">rewriteInIm2Col()</a>, and <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00123">rewriteInIm2Col()</a>.</p>

</div>
</div>
<a id="a503baeef1328177c20af2c28710f0066" name="a503baeef1328177c20af2c28710f0066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503baeef1328177c20af2c28710f0066">&#9670;&#160;</a></span>createAllReduceForResultsWithoutPartialShardings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::createAllReduceForResultsWithoutPartialShardings </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>unshardedOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#aa3c699ae89529032fd3f3dc9ef8fe839">GridAxis</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>opReductionGridAxes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#a03c57ac3b7bfa817f644e03dcf9a5de2">Sharding</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>resultShardings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>partitionMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00188">188</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00086">getReductionKindOfLinalgOp()</a>, <a class="el" href="IRMapping_8h_source.html#l00072">mlir::IRMapping::lookup()</a>, and <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00204">partitionLinalgOpWithShardedReduction()</a>.</p>

</div>
</div>
<a id="a491060ab8a250d42c9650c00ef3fc571" name="a491060ab8a250d42c9650c00ef3fc571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491060ab8a250d42c9650c00ef3fc571">&#9670;&#160;</a></span>createDestinationPassingStyleInitOperand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::createDestinationPassingStyleInitOperand </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>operandNumber</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>partitionedOperand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#aa3c699ae89529032fd3f3dc9ef8fe839">GridAxis</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reductionGridAxes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a5b2e5401a45d4e16070ebd5dcaef36b2">GridOp</a></td>          <td class="paramname"><span class="paramname"><em>gridOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00126">126</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="Shard_2Transforms_2Transforms_8cpp_source.html#l00228">mlir::shard::createProcessLinearIndex()</a>, <a class="el" href="Builders_8cpp_source.html#l00053">mlir::Builder::getI1Type()</a>, <a class="el" href="Builders_8h_source.html#l00663">mlir::ImplicitLocOpBuilder::getLoc()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00066">mlir::tensor::getMixedSizes()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02734">mlir::arith::getNeutralElement()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00290">mlir::matchReduction()</a>, and <a class="el" href="Builders_8h_source.html#l00436">mlir::OpBuilder::setInsertionPointToEnd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00172">createDestinationPassingStyleInitOperands()</a>.</p>

</div>
</div>
<a id="ac06fb8c7958f744e2ed23f25c4da79ba" name="ac06fb8c7958f744e2ed23f25c4da79ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06fb8c7958f744e2ed23f25c4da79ba">&#9670;&#160;</a></span>createDestinationPassingStyleInitOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::createDestinationPassingStyleInitOperands </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a5b2e5401a45d4e16070ebd5dcaef36b2">GridOp</a></td>          <td class="paramname"><span class="paramname"><em>gridOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>partitionedOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#aa3c699ae89529032fd3f3dc9ef8fe839">GridAxis</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reductionGridAxes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>partitionMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00172">172</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00126">createDestinationPassingStyleInitOperand()</a>, and <a class="el" href="IRMapping_8h_source.html#l00072">mlir::IRMapping::lookup()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00204">partitionLinalgOpWithShardedReduction()</a>.</p>

</div>
</div>
<a id="a6dac633b692c130881f315320220fcce" name="a6dac633b692c130881f315320220fcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dac633b692c130881f315320220fcce">&#9670;&#160;</a></span>createFoldedDimOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::linalg::createFoldedDimOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create one memref::DimOp or tensor::DimOp depending on the type of <span class="tt">val</span>. </p>
<p>This is a polymorphic convenience function to abstract away the rank and concrete type of <span class="tt">val</span>. Asserts that <span class="tt">val</span> is a memref or tensor type. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l00104">104</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00095">createOrFoldDimOp()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PadTilingInterface_8cpp_source.html#l00099">computePaddedShape()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01891">computeSliceParameters()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00103">fuse()</a>.</p>

</div>
</div>
<a id="a80e6451d40cef8244025d03bc83cfdad" name="a80e6451d40cef8244025d03bc83cfdad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e6451d40cef8244025d03bc83cfdad">&#9670;&#160;</a></span>createMul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::createMul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>accType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00041">41</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00238">mlir::convertScalarToDtype()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00416">rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00550">rewriteInIm2Col()</a>, and <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00123">rewriteInIm2Col()</a>.</p>

</div>
</div>
<a id="aaf73bb051fb347d6519cdcb174ba230e" name="aaf73bb051fb347d6519cdcb174ba230e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf73bb051fb347d6519cdcb174ba230e">&#9670;&#160;</a></span>createOrFoldDimOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::createOrFoldDimOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create one memref::DimOp or tensor::DimOp depending on the type of <span class="tt">val</span>. </p>
<p>This is a polymorphic convenience function to abstract away the rank and concrete type of <span class="tt">val</span>. Asserts that <span class="tt">val</span> is a memref or tensor type. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l00095">95</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00185">concatSizesFromInputs()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00104">createFoldedDimOp()</a>, and <a class="el" href="CodegenUtils_8cpp_source.html#l00412">mlir::sparse_tensor::sizesFromSrc()</a>.</p>

</div>
</div>
<a id="a487d4430e8217b1dabc50cb28bb93342" name="a487d4430e8217b1dabc50cb28bb93342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487d4430e8217b1dabc50cb28bb93342">&#9670;&#160;</a></span>deallocateGPUPrivateMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::deallocateGPUPrivateMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In case of GPU private memory there is no need to deallocate since the memory is freed when going outside of the scope. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00512">512</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="ad6babd80190e8df26f441fca7d2fbe31" name="ad6babd80190e8df26f441fca7d2fbe31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6babd80190e8df26f441fca7d2fbe31">&#9670;&#160;</a></span>deallocateWorkgroupMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::deallocateWorkgroupMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In case of GPU group memory there is no need to deallocate. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00480">480</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a22cf4ae6a6c9f8d82a3d3f13e55100c3" name="a22cf4ae6a6c9f8d82a3d3f13e55100c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cf4ae6a6c9f8d82a3d3f13e55100c3">&#9670;&#160;</a></span>decomposeWinogradFilterTransformOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::decomposeWinogradFilterTransformOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::WinogradFilterTransformOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite linalg.winograd_filter_transform. </p>
<p>The data layout of the filter is FHWC. The transformation matrix is 2-dimension. We need to extract H x W from FHWC first. We generate 2 levels of loops to iterate on F and C. After the rewriting, we get</p>
<p>scf.for f = lo_f to hi_f step 1 scf.for c = lo_c to hi_c step 1 extracted = extract filter&lt;h x w&gt; from filter&lt;f x h x w x c&gt; ret = linalg.matmul G, extracted ret = linalg.matmul ret, GT inserted = insert ret into filter&lt;h x w x c x f&gt; </p>

<p class="definition">Definition at line <a class="el" href="WinogradConv2D_8cpp_source.html#l01196">1196</a> of file <a class="el" href="WinogradConv2D_8cpp_source.html">WinogradConv2D.cpp</a>.</p>

</div>
</div>
<a id="ae75908ded36f97719f77c8b56ed859ef" name="ae75908ded36f97719f77c8b56ed859ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75908ded36f97719f77c8b56ed859ef">&#9670;&#160;</a></span>decomposeWinogradInputTransformOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::decomposeWinogradInputTransformOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::WinogradInputTransformOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite linalg.winograd_input_transform. </p>
<p>The data layout of the input is NHWC. The transformation matrix is 2-dimension. We need to extract H x W from NHWC first. We generate 4 levels of loops to iterate on N, C, tileH, and tileW. After the rewriting, we get</p>
<p>scf.for h = 0 to tileH step 1 scf.for w = 0 to tileW step 1 scf.for n = 0 to N step 1 scf.for c = 0 to C step 1 extracted = extract extracted&lt;alphaH x alphaW&gt; from input&lt;N x H x W x C&gt; at [n, (h x m), (w x m), c] ret = linalg.matmul BT, extracted ret = linalg.matmul ret, B inserted = insert ret&lt;alphaH x alphaW&gt; into output&lt;alphaH x alphaW x tileH x tileW x N x C&gt; at [0, 0, h, w, n, c] </p>

<p class="definition">Definition at line <a class="el" href="WinogradConv2D_8cpp_source.html#l01202">1202</a> of file <a class="el" href="WinogradConv2D_8cpp_source.html">WinogradConv2D.cpp</a>.</p>

</div>
</div>
<a id="a49f2f00a0e17dbbec5198127ee3151ba" name="a49f2f00a0e17dbbec5198127ee3151ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f2f00a0e17dbbec5198127ee3151ba">&#9670;&#160;</a></span>decomposeWinogradOutputTransformOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::decomposeWinogradOutputTransformOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::WinogradOutputTransformOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite linalg.winograd_output_transform. </p>
<p>The data layout of the output is HWNF. The transformation matrix is 2-dimension. We need to extract H x W from HWNF first. We generate 4 levels of loops to iterate on N, F, tileH, and tileW. After the transformation, we get</p>
<p>scf.for h = 0 to tileH step 1 scf.for w = 0 to tileW step 1 scf.for n = 0 to N step 1 scf.for f = 0 to F step 1 extracted = extract extracted&lt;alphaH x alphaW&gt; from input&lt;alphaH x alphaW x tileH x tileW x N x F&gt; at [0, 0, h, w, n, f] ret = linalg.matmul AT, extracted ret = linalg.matmul ret, A inserted = insert ret&lt;alphaH x alphaW&gt; into output&lt;N x H x W x F&gt; at [n, (h x m), (w x m), f] </p>

<p class="definition">Definition at line <a class="el" href="WinogradConv2D_8cpp_source.html#l01208">1208</a> of file <a class="el" href="WinogradConv2D_8cpp_source.html">WinogradConv2D.cpp</a>.</p>

</div>
</div>
<a id="a88467664ee2ebeb70bc1a2c3d5876a9c" name="a88467664ee2ebeb70bc1a2c3d5876a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88467664ee2ebeb70bc1a2c3d5876a9c">&#9670;&#160;</a></span>deduplicateOperandsAndRemoveDeadResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; linalg::GenericOp &gt; mlir::linalg::deduplicateOperandsAndRemoveDeadResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::GenericOp</td>          <td class="paramname"><span class="paramname"><em>genericOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>removeOutputs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to deduplicate operands and remove dead results of <span class="tt">linalg.generic</span> operations. </p>
<p>This is effectively DCE for a linalg.generic op. If there is deduplication of operands orremoval of results, replaces the <span class="tt">genericOp</span> with a new op and returns it. Returns the same operation if there is no deduplication/removal. </p>

<p class="definition">Definition at line <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00231">231</a> of file <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html">EraseUnusedOperandsAndResults.cpp</a>.</p>

<p class="reference">References <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00063">deduplicateInputOperands()</a>, <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00106">deduplicateOutputOperands()</a>, <a class="el" href="Builders_8cpp_source.html#l00318">mlir::Builder::getAffineMapArrayAttr()</a>, <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00172">populateOpPayload()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="a5b6d6c0f10b756281634aebb9f69d5dd" name="a5b6d6c0f10b756281634aebb9f69d5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6d6c0f10b756281634aebb9f69d5dd">&#9670;&#160;</a></span>dropUnitDims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1DropUnitDimsResult.html">DropUnitDimsResult</a> &gt; mlir::linalg::dropUnitDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GenericOp</td>          <td class="paramname"><span class="paramname"><em>genericOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00539">539</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00384">dropUnitDims()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00227">replaceUnitDimIndexOps()</a>.</p>

</div>
</div>
<a id="ac980878e4ea40184d0a2183288fd0f61" name="ac980878e4ea40184d0a2183288fd0f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac980878e4ea40184d0a2183288fd0f61">&#9670;&#160;</a></span>dropUnitDims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1DropUnitDimsResult.html">DropUnitDimsResult</a> &gt; mlir::linalg::dropUnitDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexingMapOpInterface</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a0752c7523022c2c98068a86865e35096">DroppedUnitDimsBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>droppedUnitDimsBuilder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00384">384</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="DropUnitDims_8cpp_source.html#l00278">collapseValue()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00829">mlir::concatAffineMaps()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00334">dropUnitExtentFromOperandMetadata()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00251">expandValue()</a>, <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>, <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00496">mlir::AffineMap::replaceDimsAndSymbols()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="DropUnitDims_8cpp_source.html#l00539">dropUnitDims()</a>.</p>

</div>
</div>
<a id="a956959faad992424aaa215510e50e618" name="a956959faad992424aaa215510e50e618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956959faad992424aaa215510e50e618">&#9670;&#160;</a></span>extractOrIdentityMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::linalg::extractOrIdentityMap </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>maybeMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>rank</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">maybeMap.get()</span> if <span class="tt">maybeMap</span> is set, otherwise returns the symbol-less identity map of <span class="tt">rank</span>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02454">2454</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>.</p>

</div>
</div>
<a id="a4ceec493e0b40673125a0402c3cf78e4" name="a4ceec493e0b40673125a0402c3cf78e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ceec493e0b40673125a0402c3cf78e4">&#9670;&#160;</a></span>fuseElementwiseOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html">mlir::linalg::ElementwiseOpFusionResult</a> &gt; mlir::linalg::fuseElementwiseOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *</td>          <td class="paramname"><span class="paramname"><em>fusedOperand</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the results of the producer that have uses outside of the consumer, after the fusion.</p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00339">339</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00139">areElementwiseOpsFusable()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">mlir::AffineMap::compose()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00218">generateFusedElementwiseOpRegion()</a>, <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00318">mlir::Builder::getAffineMapArrayAttr()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00047">getIndexingMapOfProducerOperandsInCoordinatesOfFusedOp()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00112">getPreservedProducerResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="a13c5cf1a47f0bf5b6405224845ff8d83" name="a13c5cf1a47f0bf5b6405224845ff8d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c5cf1a47f0bf5b6405224845ff8d83">&#9670;&#160;</a></span>fuseProducerOfTensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt; mlir::linalg::fuseProducerOfTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>consumerOpOperand</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implements the fusion part of the "tileAndFuse on tensors" transformation and thus requires the <span class="tt">consumerOpOperand</span> to be a <span class="tt">extract_slice</span> op (generally obtained by applying the tiling transformation). </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00217">217</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Fusion_8cpp_source.html#l00217">fuseProducerOfTensor()</a>, <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00192">getProducerOfTensor()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00217">fuseProducerOfTensor()</a>.</p>

</div>
</div>
<a id="aa7195637d33a1cf8133bc32a219adf6b" name="aa7195637d33a1cf8133bc32a219adf6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7195637d33a1cf8133bc32a219adf6b">&#9670;&#160;</a></span>fuseProducerOfTensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt; mlir::linalg::fuseProducerOfTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a></td>          <td class="paramname"><span class="paramname"><em>producerOpResult</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>consumerOpOperand</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This implements the fusion part of the "tileAndFuse on tensors" transformation and thus requires the <span class="tt">consumerOpOperand</span> to be a <span class="tt">extract_slice</span> op (generally obtained by applying the tiling transformation). </p>
<p>Assumes <span class="tt">producerOfTensor</span> is a Linalg op that produces <span class="tt">consumerOpOperand</span>. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00229">229</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00095">mlir::tensor::dropGivenUnitDims()</a>, <a class="el" href="Fusion_8cpp_source.html#l00103">fuse()</a>, <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Value_8h_source.html#l00466">mlir::OpResult::getOwner()</a>, <a class="el" href="Value_8cpp_source.html#l00046">mlir::Value::getParentBlock()</a>, <a class="el" href="Value_8h_source.html#l00469">mlir::OpResult::getResultNumber()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="UseDefLists_8h_source.html#l00163">mlir::IROperand&lt; DerivedT, IRValueT &gt;::set()</a>.</p>

</div>
</div>
<a id="a7fc28f76b6a2798611e0008260ae388d" name="a7fc28f76b6a2798611e0008260ae388d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc28f76b6a2798611e0008260ae388d">&#9670;&#160;</a></span>generalizeNamedOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; GenericOp &gt; mlir::linalg::generalizeNamedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a GenericOp from the given named operation <span class="tt">linalgOp</span> and replace the given <span class="tt">linalgOp</span>. </p>
<p>Return failure if <span class="tt">linalgOp</span> is a GenericOp or misses a region builder. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00046">46</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Generalization_8cpp_source.html#l00033">generalizeNamedOpPrecondition()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00376">mlir::RewriterBase::inlineRegionBefore()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02099">TypeRange</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02103">ValueRange</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00748">packMatmulGreedily()</a>, and <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01611">mlir::linalg::LinalgGeneralizationPattern::returningMatchAndRewrite()</a>.</p>

</div>
</div>
<a id="a754ec5c5960c640563ddcd9727b77d87" name="a754ec5c5960c640563ddcd9727b77d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754ec5c5960c640563ddcd9727b77d87">&#9670;&#160;</a></span>generateLibraryCallName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::linalg::generateLibraryCallName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name mangled library call name to disambiguate between different overloads at the C level. </p>
<p>The name mangling scheme is basic and uses MLIR type names:</p><ol type="1">
<li>form a string which is the concatenation of the linalg op name with all the operand type names, separate by underscores;</li>
<li>drop the <span class="tt">linalg.</span> prefix, and the <span class="tt">&lt;</span>, <span class="tt">&gt;</span>, <span class="tt">?</span> symbols from the type. Assumes <span class="tt">op</span> is a LinalgOp.</li>
</ol>
<p>Examples:</p>
<ol type="1">
<li>linalg.fill(f, A) : f32, <a class="el" href="namespacemlir_1_1memref.html">memref&lt;f32&gt;</a> name mangles into <span class="tt">linalg_fill_f32_viewf32</span></li>
<li>linalg.dot A, B, C : (memref&lt;?xf32, stride_specification&gt;, memref&lt;?xf32, stride_specification&gt;, <a class="el" href="namespacemlir_1_1memref.html">memref&lt;f32&gt;</a>) name mangles into <span class="tt">linalg_dot_viewxf32_viewxf32_viewf32</span></li>
<li>linalg.matmul(...) : memref&lt;?x?xf32, stride_specification&gt;, memref&lt;?x?xf32, stride_specification&gt;, memref&lt;?x?xf32, stride_specification&gt; name mangles into <span class="tt">linalg_matmul_viewxxf32_viewxxf32_viewxxf32</span> </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02515">2515</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp_source.html#l02482">appendMangledType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00512">mlir::Operation::getAttrs()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00397">mlir::Operation::getOperandTypes()</a>, and <a class="el" href="OperationSupport_8h_source.html#l00473">mlir::OperationName::getStringRef()</a>.</p>

</div>
</div>
<a id="a330275ee0b8daf6e838a8bce3d70a331" name="a330275ee0b8daf6e838a8bce3d70a331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330275ee0b8daf6e838a8bce3d70a331">&#9670;&#160;</a></span>generateParallelLoopNest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::generateParallelLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>lbs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>ubs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>steps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt;</td>          <td class="paramname"><span class="paramname"><em>iteratorTypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">linalg::ProcInfo</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>procInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>bodyBuilderFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ivStorage</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a loop nest consisting of scf.parallel and scf.for, depending on the <span class="tt">iteratorTypes.
</span></p>
<p>Consecutive parallel loops create a single scf.parallel operation; each sequential loop creates a new scf.for operation. The body of the innermost loop is populated by <span class="tt">bodyBuilderFn</span> that accepts a range of induction variables for all loops. <span class="tt">ivStorage</span> is used to store the partial list of induction variables. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01698">1698</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00311">mlir::ArithBuilder::_and()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00838">mlir::scf::buildLoopNest()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00274">Cyclic</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00304">CyclicNumProcsEqNumIters</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00292">CyclicNumProcsGeNumIters</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00315">mlir::linalg::ProcInfo::distributionMethod</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01698">generateParallelLoopNest()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00230">isParallelIterator()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00307">None</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00334">mlir::ArithBuilder::slt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01813">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01698">generateParallelLoopNest()</a>.</p>

</div>
</div>
<a id="a57c1353b2da290a69434399a04a994fa" name="a57c1353b2da290a69434399a04a994fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c1353b2da290a69434399a04a994fa">&#9670;&#160;</a></span>getAffineMapDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::linalg::getAffineMapDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a></td>          <td class="paramname"><span class="paramname"><em>indexingMaps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>mapIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>dimIndex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00399">399</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00454">matchConvDimAddExprPattern()</a>.</p>

</div>
</div>
<a id="a9ff863e16e260bf9475bda668a896737" name="a9ff863e16e260bf9475bda668a896737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff863e16e260bf9475bda668a896737">&#9670;&#160;</a></span>getAffineResultPositions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt; &gt; mlir::linalg::getAffineResultPositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a></td>          <td class="paramname"><span class="paramname"><em>maps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l03773">3773</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l04167">mlir::linalg::BatchMatmulTransposeAOp::isDefaultIndexingMaps()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l04260">mlir::linalg::BatchMatmulTransposeBOp::isDefaultIndexingMaps()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l03979">mlir::linalg::MatmulTransposeAOp::isDefaultIndexingMaps()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l04073">mlir::linalg::MatmulTransposeBOp::isDefaultIndexingMaps()</a>.</p>

</div>
</div>
<a id="a61f099443ddafc2ff4b45a9788b324d0" name="a61f099443ddafc2ff4b45a9788b324d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f099443ddafc2ff4b45a9788b324d0">&#9670;&#160;</a></span>getArityGroupAndKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ArityGroupAndKind mlir::linalg::getArityGroupAndKind </td>
          <td>(</td>
          <td class="paramtype">ElementwiseKind</td>          <td class="paramname"><span class="paramname"><em>kind</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l04752">4752</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="a57e3e50fb10350b034260d4b714368a9" name="a57e3e50fb10350b034260d4b714368a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e3e50fb10350b034260d4b714368a9">&#9670;&#160;</a></span>getBlockArgumentWithOptionalCastOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> mlir::linalg::getBlockArgumentWithOptionalCastOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a> that leads to <span class="tt">val</span>, if any. </p>
<p>Traverses optional ext*&zwj;/sitofp ops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00244">244</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00326">bodyMatcherForConvolutionOps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00355">bodyMatcherForPoolOps()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00273">bodyMatcherForZeroPointOffsets()</a>.</p>

</div>
</div>
<a id="a0f875e0531bfb0cf383ff1ca108092b0" name="a0f875e0531bfb0cf383ff1ca108092b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f875e0531bfb0cf383ff1ca108092b0">&#9670;&#160;</a></span>getCombinerOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::getCombinerOp </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00076">76</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00290">mlir::matchReduction()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00086">getReductionKindOfLinalgOp()</a>.</p>

</div>
</div>
<a id="ae27267a4634c46beba8c9f55c14cdfa1" name="ae27267a4634c46beba8c9f55c14cdfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27267a4634c46beba8c9f55c14cdfa1">&#9670;&#160;</a></span>getCombinerOpKind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; vector::CombiningKind &gt; mlir::linalg::getCombinerOpKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>combinerOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return vector::CombiningKind for the given op. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00638">638</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00702">buildMultiDimReduce()</a>.</p>

</div>
</div>
<a id="adacf5e0254e7596246d56037bab384ec" name="adacf5e0254e7596246d56037bab384ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacf5e0254e7596246d56037bab384ec">&#9670;&#160;</a></span>getConvolvedExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::linalg::getConvolvedExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>stride</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useSymbols</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00058">58</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, and <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00097">getIm2ColInputExpressions()</a>.</p>

</div>
</div>
<a id="a452649ff168e997865fbea4d06890b29" name="a452649ff168e997865fbea4d06890b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452649ff168e997865fbea4d06890b29">&#9670;&#160;</a></span>getDimAndTileMappingImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="classint64__t.html">int64_t</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::linalg::getDimAndTileMappingImpl </td>
          <td>(</td>
          <td class="paramtype">OpTy</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05033">5033</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

</div>
</div>
<a id="acc482eff5fffe862c02f038c2a9d20f9" name="acc482eff5fffe862c02f038c2a9d20f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc482eff5fffe862c02f038c2a9d20f9">&#9670;&#160;</a></span>getFmrFromWinogradConv2DFmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classint64__t.html">int64_t</a>, <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::linalg::getFmrFromWinogradConv2DFmr </td>
          <td>(</td>
          <td class="paramtype">WinogradConv2DFmr</td>          <td class="paramname"><span class="paramname"><em>fmr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given WinogradConv2DFmr enumeration value to a pair of m and r parameters. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l03757">3757</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

</div>
</div>
<a id="affb58b5d5caada44bf94cd80eb843637" name="affb58b5d5caada44bf94cd80eb843637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb58b5d5caada44bf94cd80eb843637">&#9670;&#160;</a></span>getGrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5b2e5401a45d4e16070ebd5dcaef36b2">GridOp</a> mlir::linalg::getGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#a03c57ac3b7bfa817f644e03dcf9a5de2">Sharding</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operandShardings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#a03c57ac3b7bfa817f644e03dcf9a5de2">Sharding</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>resultShardings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>symbolTable</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00100">100</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="ShardOps_8h_source.html#l00121">mlir::shard::getGrid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00204">partitionLinalgOpWithShardedReduction()</a>.</p>

</div>
</div>
<a id="a88f5597fa9ab33dcc1e4270e6af512ca" name="a88f5597fa9ab33dcc1e4270e6af512ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f5597fa9ab33dcc1e4270e6af512ca">&#9670;&#160;</a></span>getIm2ColInputExpressions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1linalg_1_1Im2ColToInputDimsExprs.html">Im2ColToInputDimsExprs</a> mlir::linalg::getIm2ColInputExpressions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1Im2ColToOperandsExprs.html">Im2ColToOperandsExprs</a></td>          <td class="paramname"><span class="paramname"><em>exprs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the affine expressions that map the indices of the im2col matrix to the corresponding input tensor indices for a 2D convolution with the the provided strides. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exprs</td><td>Affine expressions for output and filter indices. </td></tr>
    <tr><td class="paramname">strides</td><td>[height, width] stride values for the convolution. </td></tr>
    <tr><td class="paramname">rewriter</td><td><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> rewriter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Affine expressions mapping im2col matrix indices to input offsets. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00097">97</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00071">mlir::linalg::Im2ColToOperandsExprs::fhIndex</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00072">mlir::linalg::Im2ColToOperandsExprs::fwIndex</a>, <a class="el" href="Builders_8cpp_source.html#l00364">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00058">getConvolvedExpr()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00073">mlir::linalg::Im2ColToOperandsExprs::icIndex</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">mlir::AffineMap::inferFromExprList()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00074">mlir::linalg::Im2ColToOperandsExprs::ohIndex</a>, and <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00075">mlir::linalg::Im2ColToOperandsExprs::owIndex</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00416">rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00550">rewriteInIm2Col()</a>, and <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00123">rewriteInIm2Col()</a>.</p>

</div>
</div>
<a id="ae61503376ad6b88f0c35f8ce358dbc9e" name="ae61503376ad6b88f0c35f8ce358dbc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61503376ad6b88f0c35f8ce358dbc9e">&#9670;&#160;</a></span>getLinalgTilingCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> mlir::linalg::getLinalgTilingCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalization patterns relevant to apply after tiling patterns. </p>
<p>These are applied automatically by the tiling pass but need to be applied manually when tiling is called programmatically. </p>

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00850">850</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, and <a class="el" href="Tiling_8cpp_source.html#l00856">populateLinalgTilingCanonicalizationPatterns()</a>.</p>

</div>
</div>
<a id="a41950140c9f81b74b3bdcf1747160ed1" name="a41950140c9f81b74b3bdcf1747160ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41950140c9f81b74b3bdcf1747160ed1">&#9670;&#160;</a></span>getMixedTilesImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::linalg::getMixedTilesImpl </td>
          <td>(</td>
          <td class="paramtype">OpTy</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05048">5048</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00112">mlir::Builder::getI64IntegerAttr()</a>.</p>

</div>
</div>
<a id="af5828de2a3f61427e6a01bbaa121901a" name="af5828de2a3f61427e6a01bbaa121901a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5828de2a3f61427e6a01bbaa121901a">&#9670;&#160;</a></span>getNewMixedTileSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::linalg::getNewMixedTileSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>newPackedTy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mixedTiles</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l04989">4989</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="Builders_8cpp_source.html#l00051">mlir::Builder::getIndexType()</a>, <a class="el" href="Builders_8cpp_source.html#l00228">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="Traits_8cpp_source.html#l00117">getShape()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01293">mlir::tile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l05741">mlir::linalg::FoldTensorCastPackOp::matchAndRewrite()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l06064">mlir::linalg::FoldTensorCastUnPackOp::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="af36b73b6c38d09eef01a3ab1bde4438f" name="af36b73b6c38d09eef01a3ab1bde4438f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36b73b6c38d09eef01a3ab1bde4438f">&#9670;&#160;</a></span>getPackedOuterShapeWithoutTransposition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy, typename = std::enable_if_t&lt;std::is_same_v&lt;OpTy, linalg::PackOp&gt; ||                                      std::is_same_v&lt;OpTy, linalg::UnPackOp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::linalg::getPackedOuterShapeWithoutTransposition </td>
          <td>(</td>
          <td class="paramtype">OpTy</td>          <td class="paramname"><span class="paramname"><em>packOrUnPack</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the outer shape in the packed domain before applying the transposition. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l04961">4961</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00226">mlir::applyPermutationToVector()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00187">mlir::invertPermutationVector()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="ac247eeed2a533c7ace799fd5b9c50b8d" name="ac247eeed2a533c7ace799fd5b9c50b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac247eeed2a533c7ace799fd5b9c50b8d">&#9670;&#160;</a></span>getPackedOuterShapeWithoutTransposition&lt; PackOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; <a class="el" href="#af36b73b6c38d09eef01a3ab1bde4438f">mlir::linalg::getPackedOuterShapeWithoutTransposition</a>&lt; PackOp &gt; </td>
          <td>(</td>
          <td class="paramtype">PackOp</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a799fb205c9451cc54d83e002d1c9bc09" name="a799fb205c9451cc54d83e002d1c9bc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799fb205c9451cc54d83e002d1c9bc09">&#9670;&#160;</a></span>getPackedOuterShapeWithoutTransposition&lt; UnPackOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; <a class="el" href="#af36b73b6c38d09eef01a3ab1bde4438f">mlir::linalg::getPackedOuterShapeWithoutTransposition</a>&lt; UnPackOp &gt; </td>
          <td>(</td>
          <td class="paramtype">UnPackOp</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92b42ab91002d8c468cb54eaebdb3989" name="a92b42ab91002d8c468cb54eaebdb3989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b42ab91002d8c468cb54eaebdb3989">&#9670;&#160;</a></span>getPackInverseDestPerm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::linalg::getPackInverseDestPerm </td>
          <td>(</td>
          <td class="paramtype">linalg::PackOp</td>          <td class="paramname"><span class="paramname"><em>packOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PackingMetadata &amp;</td>          <td class="paramname"><span class="paramname"><em>metadata</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute inverse permutation for the destination tensor (i.e. </p>
<p>in the packed domain). </p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00217">lowerPack()</a>.</p>

</div>
</div>
<a id="a1d5a2792af9c24eb321985a0f4442464" name="a1d5a2792af9c24eb321985a0f4442464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5a2792af9c24eb321985a0f4442464">&#9670;&#160;</a></span>getPackInverseDestPerm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::linalg::getPackInverseDestPerm </td>
          <td>(</td>
          <td class="paramtype">PackOp</td>          <td class="paramname"><span class="paramname"><em>packOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PackingMetadata &amp;</td>          <td class="paramname"><span class="paramname"><em>metadata</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00174">174</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00150">computePackUnPackPerm()</a>.</p>

</div>
</div>
<a id="af17100c1511fdc6b92fdbf9bd5aeb36c" name="af17100c1511fdc6b92fdbf9bd5aeb36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17100c1511fdc6b92fdbf9bd5aeb36c">&#9670;&#160;</a></span>getPackOpResultTypeShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::linalg::getPackOpResultTypeShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sourceShape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>innerTileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>innerDimsPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>outerDimsPerm</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for PackOp::{getResultShape,inferPackedType}. </p>
<p>Returns the shape of the packed type. Having a shared helper helps implement these two methods in a way that ensures that they agree on which dimensions are dynamic. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05392">5392</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00226">mlir::applyPermutationToVector()</a>.</p>

</div>
</div>
<a id="a4f70173e3ee102c2077ef5cdf5908001" name="a4f70173e3ee102c2077ef5cdf5908001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f70173e3ee102c2077ef5cdf5908001">&#9670;&#160;</a></span>getPreservedProducerResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallDenseSet&lt; int &gt; mlir::linalg::getPreservedProducerResults </td>
          <td>(</td>
          <td class="paramtype">GenericOp</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GenericOp</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *</td>          <td class="paramname"><span class="paramname"><em>fusedOperand</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a set of indices of the producer's results which would be preserved after the fusion. </p>
<ul>
<li>There is a chance that the implementation of the transformation does not agree with the result of this method. This function gives a prediction based on an optimized fusion. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00112">112</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00079">isOpOperandCanBeDroppedAfterFusedLinalgs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00339">fuseElementwiseOps()</a>.</p>

</div>
</div>
<a id="af1aae248ee953a6fbfb303c090499f77" name="af1aae248ee953a6fbfb303c090499f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1aae248ee953a6fbfb303c090499f77">&#9670;&#160;</a></span>getPrunedAttributeList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt; mlir::linalg::getPrunedAttributeList </td>
          <td>(</td>
          <td class="paramtype">OpTy</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an attribute list that excludes pre-defined attributes. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00388">388</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00388">getPrunedAttributeList()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00388">getPrunedAttributeList()</a>, and <a class="el" href="SimplifyDepthwiseConv_8cpp_source.html#l00036">matchAndReplaceDepthwiseConv()</a>.</p>

</div>
</div>
<a id="a6c303f22e35937f101dc36b676ef8861" name="a6c303f22e35937f101dc36b676ef8861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c303f22e35937f101dc36b676ef8861">&#9670;&#160;</a></span>getReassociationMapForFoldingUnitDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; &gt; mlir::linalg::getReassociationMapForFoldingUnitDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mixedSizes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the reassociation maps to fold the result of a extract_slice (or source of a insert_slice) operation with given offsets, and sizes to its rank-reduced version. </p>
<p>This is only done for the cases where the size is 1 and offset is 0. Strictly speaking the offset 0 is not required in general, but non-zero offsets are not handled by SPIR-V backend at this point (and potentially cannot be handled). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02185">2185</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="a351f651dd2a55b2a452b56d68c2e2c4c" name="a351f651dd2a55b2a452b56d68c2e2c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351f651dd2a55b2a452b56d68c2e2c4c">&#9670;&#160;</a></span>getReductionKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9aed87a08c001b3ef7e0fcbd273041aa">ReductionKind</a> mlir::linalg::getReductionKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00046">46</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00086">getReductionKindOfLinalgOp()</a>.</p>

</div>
</div>
<a id="ada28e3e4bc6c8c677652c60e01bf2b6a" name="ada28e3e4bc6c8c677652c60e01bf2b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada28e3e4bc6c8c677652c60e01bf2b6a">&#9670;&#160;</a></span>getReductionKindOfLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9aed87a08c001b3ef7e0fcbd273041aa">ReductionKind</a> mlir::linalg::getReductionKindOfLinalgOp </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00086">86</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00076">getCombinerOp()</a>, and <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00046">getReductionKind()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00188">createAllReduceForResultsWithoutPartialShardings()</a>.</p>

</div>
</div>
<a id="a22ac062da6f15e8f1e328b24ded2109e" name="a22ac062da6f15e8f1e328b24ded2109e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ac062da6f15e8f1e328b24ded2109e">&#9670;&#160;</a></span>getStaticTilesImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::linalg::getStaticTilesImpl </td>
          <td>(</td>
          <td class="paramtype">OpTy</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05064">5064</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00072">mlir::dispatchIndexOpFoldResults()</a>.</p>

</div>
</div>
<a id="af2da35587b12f700693b151c166fee34" name="af2da35587b12f700693b151c166fee34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2da35587b12f700693b151c166fee34">&#9670;&#160;</a></span>getTensorOutputTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; mlir::linalg::getTensorOutputTypes </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of tensor output types produced when the given structured operation <span class="tt">op</span> is applied to the given <span class="tt">operands</span>. </p>
<p>Note that <span class="tt">operands</span> are not necessarily the actual operands of <span class="tt">op</span>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02038">2038</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="a1a3bb0a48c5e2778ea2bfd81a41db65d" name="a1a3bb0a48c5e2778ea2bfd81a41db65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3bb0a48c5e2778ea2bfd81a41db65d">&#9670;&#160;</a></span>getUnPackInverseSrcPerm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::linalg::getUnPackInverseSrcPerm </td>
          <td>(</td>
          <td class="paramtype">linalg::UnPackOp</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PackingMetadata &amp;</td>          <td class="paramname"><span class="paramname"><em>metadata</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute inverse permutation for the source tensor (i.e. </p>
<p>in the packed domain). </p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00345">lowerUnPack()</a>.</p>

</div>
</div>
<a id="a61460bb1ec0632288e4f52ee867278a8" name="a61460bb1ec0632288e4f52ee867278a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61460bb1ec0632288e4f52ee867278a8">&#9670;&#160;</a></span>getUnPackInverseSrcPerm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::linalg::getUnPackInverseSrcPerm </td>
          <td>(</td>
          <td class="paramtype">UnPackOp</td>          <td class="paramname"><span class="paramname"><em>unpackOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PackingMetadata &amp;</td>          <td class="paramname"><span class="paramname"><em>metadata</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00185">185</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00150">computePackUnPackPerm()</a>.</p>

</div>
</div>
<a id="ae474be1b8e656c231ec447b79d2d5e8d" name="ae474be1b8e656c231ec447b79d2d5e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae474be1b8e656c231ec447b79d2d5e8d">&#9670;&#160;</a></span>getWinogradConv2DFmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; WinogradConv2DFmr &gt; mlir::linalg::getWinogradConv2DFmr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given <span class="tt">m</span> and <span class="tt">r</span> parameters to a WinogradConv2DFmr enumeration value. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l03747">3747</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

</div>
</div>
<a id="ab874160ec1bdc15b5c867c4799391a03" name="ab874160ec1bdc15b5c867c4799391a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab874160ec1bdc15b5c867c4799391a03">&#9670;&#160;</a></span>hasAllOneValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::hasAllOneValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00028">28</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00416">rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00550">rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00123">rewriteInIm2Col()</a>, and <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00260">rewriteInIm2Col()</a>.</p>

</div>
</div>
<a id="a5473845890c7e81fc544f7bfce900d81" name="a5473845890c7e81fc544f7bfce900d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5473845890c7e81fc544f7bfce900d81">&#9670;&#160;</a></span>hasOnlyScalarElementwiseOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::hasOnlyScalarElementwiseOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect whether <span class="tt">r</span> has only ConstantOp, ElementwiseMappable and YieldOp. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00201">201</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01390">mlir::OpTrait::hasElementwiseMappableTraits()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00068">mlir::Region::hasOneBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00215">isElementwise()</a>.</p>

</div>
</div>
<a id="abe3de4bb45fd63e06339cb0ba92533fa" name="abe3de4bb45fd63e06339cb0ba92533fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3de4bb45fd63e06339cb0ba92533fa">&#9670;&#160;</a></span>hasSameInnerOuterAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::hasSameInnerOuterAttribute </td>
          <td>(</td>
          <td class="paramtype">PackOp</td>          <td class="paramname"><span class="paramname"><em>packOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnPackOp</td>          <td class="paramname"><span class="paramname"><em>unPackOp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05543">5543</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00197">mlir::isIdentityPermutation()</a>.</p>

</div>
</div>
<a id="a142a09c03dbaa0d795e44f62d4b6b395" name="a142a09c03dbaa0d795e44f62d4b6b395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142a09c03dbaa0d795e44f62d4b6b395">&#9670;&#160;</a></span>hasVectorizationImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::hasVectorizationImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if there's dedicated logic in the Linalg Vectorizer to vectorize this <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a>, false otherwise. </p>
<p>Note that this helper merely implements a very high level check and that the vectorizer also requires various additional pre-conditions to be met for it to work (these are checked by the vectorizer itself). </p>

</div>
</div>
<a id="aa603d3bdb590cef7749279812bd8e11a" name="aa603d3bdb590cef7749279812bd8e11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa603d3bdb590cef7749279812bd8e11a">&#9670;&#160;</a></span>haveSameTiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::haveSameTiles </td>
          <td>(</td>
          <td class="paramtype">PackOp</td>          <td class="paramname"><span class="paramname"><em>packOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnPackOp</td>          <td class="paramname"><span class="paramname"><em>unPackOp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05557">5557</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00176">mlir::isEqualConstantIntOrValue()</a>.</p>

</div>
</div>
<a id="a344a0fa8893af22df90d795e19c1a713" name="a344a0fa8893af22df90d795e19c1a713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344a0fa8893af22df90d795e19c1a713">&#9670;&#160;</a></span>hoistPaddingOnTensors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::hoistPaddingOnTensors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp</td>          <td class="paramname"><span class="paramname"><em>opToHoist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>numLoops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>transposeVector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp &amp;</td>          <td class="paramname"><span class="paramname"><em>hoistedOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; TransposeOp &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>transposeOps</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mechanically hoist padding operations on tensors by <span class="tt">numLoops</span> into a new, generally larger tensor. </p>
<p>This achieves packing of multiple padding ops into a larger tensor. On success, <span class="tt">opToHoist</span> is replaced by the cloned version in the packing loop so the caller can continue reasoning about the padding operation. If <span class="tt">transposeVector</span> is non-empty, hoist padding introduces a TransposeOp to transpose the padded tensor before inserting it into the packed tensor. A <span class="tt">transposeVector</span> can change the storage order of the padded tensor but does not change the order of the pack or compute loops.</p>
<p>TODO: In the future, we should consider rewriting as a <a class="el" href="#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a> after hoisting since this abstraction is now available.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md5"></a>
Example in pseudo-mlir:</h1>
<p>If hoistPaddingOnTensors is called with <span class="tt">nLoops</span> = 2 on the following IR. </p><div class="fragment"><div class="line"><a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for (%i, %<a class="code hl_union" href="unionj.html">j</a>, %k)</div>
<div class="line">  %st0 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.extract_slice f(%i, %k) : ... to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;?x?xf32&gt;</div>
<div class="line">  %0 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.pad %st0 low[0, 0] high[...] {</div>
<div class="line">  ^bb0( ... ):</div>
<div class="line">    <a class="code hl_namespace" href="namespacemlir_1_1linalg.html">linalg</a>.yield %pad</div>
<div class="line">  } : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;?x?xf32&gt; to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;4x8xf32&gt;</div>
<div class="line">  compute(%0)</div>
<div class="ttc" id="anamespacemlir_1_1linalg_html"><div class="ttname"><a href="namespacemlir_1_1linalg.html">mlir::linalg</a></div><div class="ttdef"><b>Definition</b> <a href="LinalgToStandard_8h_source.html#l00024">LinalgToStandard.h:24</a></div></div>
<div class="ttc" id="anamespacemlir_1_1scf_html"><div class="ttname"><a href="namespacemlir_1_1scf.html">mlir::scf</a></div><div class="ttdef"><b>Definition</b> <a href="SCFToGPU_8h_source.html#l00024">SCFToGPU.h:24</a></div></div>
<div class="ttc" id="anamespacemlir_1_1tensor_html"><div class="ttname"><a href="namespacemlir_1_1tensor.html">mlir::tensor</a></div><div class="ttdef"><b>Definition</b> <a href="BufferizationTransformOps_8h_source.html#l00019">BufferizationTransformOps.h:19</a></div></div>
<div class="ttc" id="aunionj_html"><div class="ttname"><a href="unionj.html">j</a></div><div class="ttdoc">Eliminates variable at the specified position using Fourier-Motzkin variable elimination.</div></div>
</div><!-- fragment --><p>IR resembling the following is produced:</p>
<div class="fragment"><div class="line"><a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for (%i) {</div>
<div class="line">  %packed_init = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.empty range(%<a class="code hl_union" href="unionj.html">j</a>) : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;?x4x8xf32&gt;</div>
<div class="line">  %packed = <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.<a class="code hl_function" href="AffineAnalysis_8cpp.html#a6bb1f7bcc7c517c4619adcfd36fa554d">for</a> (%k) iter_args(%p : %packed_init) {</div>
<div class="line">    %st0 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.extract_slice f(%i, %k) : ... to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;?x?xf32&gt;</div>
<div class="line">    %0 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.pad %st0 low[0, 0] high[...] {</div>
<div class="line">    ^bb0( ... ):</div>
<div class="line">      <a class="code hl_namespace" href="namespacemlir_1_1linalg.html">linalg</a>.yield %pad</div>
<div class="line">    } : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;?x?xf32&gt; to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;4x8xf32&gt;</div>
<div class="line">    %1 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.insert_slice %0 ...</div>
<div class="line">        : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;4x8xf32&gt; to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;?x4x8xf32&gt;</div>
<div class="line">    <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.yield %1: <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;?x4x8xf32&gt;</div>
<div class="line">  } -&gt; <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;?x4x8xf32&gt;</div>
<div class="line">  <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.<a class="code hl_function" href="AffineAnalysis_8cpp.html#a6bb1f7bcc7c517c4619adcfd36fa554d">for</a> (%<a class="code hl_union" href="unionj.html">j</a>, %k) {</div>
<div class="line">    %st0 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.extract_slice %packed [%k, 0, 0][1, 4, 8][1, 1, 1] :</div>
<div class="line">             <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x4x8xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;4x8xf32&gt;</a></div>
<div class="line">    compute(%st0)</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aAffineAnalysis_8cpp_html_a6bb1f7bcc7c517c4619adcfd36fa554d"><div class="ttname"><a href="AffineAnalysis_8cpp.html#a6bb1f7bcc7c517c4619adcfd36fa554d">for</a></div><div class="ttdeci">for(Operation *op :ops)</div><div class="ttdef"><b>Definition</b> <a href="AffineAnalysis_8cpp_source.html#l00264">AffineAnalysis.cpp:264</a></div></div>
</div><!-- fragment --> <p>Construct the packing loop nest.</p>

<p class="definition">Definition at line <a class="el" href="HoistPadding_8cpp_source.html#l00942">942</a> of file <a class="el" href="HoistPadding_8cpp_source.html">HoistPadding.cpp</a>.</p>

<p class="reference">References <a class="el" href="HoistPadding_8cpp_source.html#l00545">buildPackingLoopNestImpl()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00076">mlir::tensor::computeTransposedType()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00032">DBGS</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00238">mlir::Operation::getParentOfType()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00880">replaceByPackingResult()</a>, and <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HoistPadding_8cpp_source.html#l01007">hoistPaddingOnTensors()</a>, and <a class="el" href="Padding_8cpp_source.html#l00355">padAndHoistLinalgOp()</a>.</p>

</div>
</div>
<a id="ac1d7ae638195a0c07357a33d4b8cfec0" name="ac1d7ae638195a0c07357a33d4b8cfec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d7ae638195a0c07357a33d4b8cfec0">&#9670;&#160;</a></span>hoistPaddingOnTensors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::hoistPaddingOnTensors </td>
          <td>(</td>
          <td class="paramtype">tensor::PadOp</td>          <td class="paramname"><span class="paramname"><em>opToHoist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>numLoops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>transposeVector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp &amp;</td>          <td class="paramname"><span class="paramname"><em>hoistedOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; TransposeOp &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>transposeOps</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls into <span class="tt">hoistPaddingOnTensors</span> with a local <a class="el" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ...">IRRewriter</a>. </p>

<p class="definition">Definition at line <a class="el" href="HoistPadding_8cpp_source.html#l01007">1007</a> of file <a class="el" href="HoistPadding_8cpp_source.html">HoistPadding.cpp</a>.</p>

<p class="reference">References <a class="el" href="HoistPadding_8cpp_source.html#l00942">hoistPaddingOnTensors()</a>.</p>

</div>
</div>
<a id="ab283416b78913b7c9bb7f322758d98c9" name="ab283416b78913b7c9bb7f322758d98c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab283416b78913b7c9bb7f322758d98c9">&#9670;&#160;</a></span>hoistRedundantVectorBroadcasts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::hoistRedundantVectorBroadcasts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist vector.extract/vector.broadcast pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are met: </p>
<ol type="1">
<li>The vector.extract operation is applied on an iter_argument, and no other operator is using this argument in the body of the loop.</li>
<li>The position of the vector.extract is either a static value, or defined outside of the loop.</li>
<li>The vector.broadcast operation is yielded by the loop. To improve hoisting opportunities, call the <span class="tt">moveLoopInvariantCode</span> helper function on the candidate loop above which to hoist. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Hoisting_8cpp_source.html#l00089">89</a> of file <a class="el" href="Hoisting_8cpp_source.html">Hoisting.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00148">broadcast()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00285">mlir::changed</a>, <a class="el" href="Hoisting_8cpp_source.html#l00032">DBGS</a>, <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00638">mlir::RewriterBase::modifyOpInPlace()</a>, <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00061">mlir::moveLoopInvariantCode()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00421">mlir::RewriterBase::moveOpAfter()</a>, <a class="el" href="PatternMatch_8h_source.html#l00646">mlir::RewriterBase::replaceAllUsesWith()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00043">replaceWithDifferentYield()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="ae6b3914ef0f129c2145a4c6512cdac8c" name="ae6b3914ef0f129c2145a4c6512cdac8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b3914ef0f129c2145a4c6512cdac8c">&#9670;&#160;</a></span>hoistRedundantVectorTransfers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::hoistRedundantVectorTransfers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>verifyNonZeroTrip</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist vector.transfer_read/vector.transfer_write on buffers pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are true: </p>
<ol type="1">
<li>The two ops access the same memref with the same indices.</li>
<li>All operands are invariant under the enclosing scf::ForOp.</li>
<li>No uses of the memref either dominate the transfer_read or are dominated by the transfer_write (i.e. no aliasing between the write and the read across the loop)</li>
<li>The source operands for vector.transfer_{read|write} do not originate from Ops implementing ViewLikeOpInterface (to reduce the risk of aliasing).</li>
<li>If <span class="tt">verifyNonZeroTrip</span> is true, then the lower bound of the loop must be statically smaller than the upper bound of the loop, guaranteeing that the loop body will execute at least once. To improve hoisting opportunities, call the <span class="tt">moveLoopInvariantCode</span> helper function on the candidate loop above which to hoist. Hoisting the transfers results in scf::ForOp yielding the value that originally transited through memory.</li>
</ol>
<p>TODO: To further improve hoisting opportunities, fold aliasing memref operations into respective vector.transfer{read|write} operations and avoid using ops implementing ViewLikeOpInterface as the source for transfer Ops.</p>
<p>WARNING: This hoisting does not model parallelism and is generally incorrect when used on distributed loops with memref semantics! NOTE: Setting <span class="tt">verifyNonZeroTrip = true</span> makes this more stable for distributed loops with memref semantics, but there could still be some issues when loops are executed a different number of times for different threads. </p>

<p class="definition">Definition at line <a class="el" href="Hoisting_8cpp_source.html#l00198">198</a> of file <a class="el" href="Hoisting_8cpp_source.html">Hoisting.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00285">mlir::changed</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00629">mlir::ValueBoundsConstraintSet::computeConstantBound()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00032">DBGS</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00074">mlir::getForwardSlice()</a>, <a class="el" href="Value_8h_source.html#l00197">mlir::Value::hasOneUse()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00315">mlir::vector::isDisjointTransferSet()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00044">mlir::presburger::LB</a>, <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00061">mlir::moveLoopInvariantCode()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00164">noAliasingUseInLoop()</a>, <a class="el" href="Dominance_8cpp_source.html#l00323">mlir::DominanceInfo::properlyDominates()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00044">mlir::presburger::UB</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a6cc6445c80fee3f958456e7e94740557" name="a6cc6445c80fee3f958456e7e94740557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc6445c80fee3f958456e7e94740557">&#9670;&#160;</a></span>inferContractionDims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContractionDimensions.html">ContractionDimensions</a> &gt; mlir::linalg::inferContractionDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>indexingMaps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00492">492</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00441">inferContractionDimsImpl()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00419">inferIteratorsFromOutMap()</a>.</p>

</div>
</div>
<a id="aa2fe10e20900f7c49da8d51805f9e9f0" name="aa2fe10e20900f7c49da8d51805f9e9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fe10e20900f7c49da8d51805f9e9f0">&#9670;&#160;</a></span>inferContractionDims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContractionDimensions.html">ContractionDimensions</a> &gt; mlir::linalg::inferContractionDims </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find at least 2 parallel (m and n) and 1 reduction (k) dimension candidates that form a matmul subcomputation within <span class="tt">linalgOp</span>. </p>
<p>These dimensions are such that:</p><ol type="1">
<li>The m dimension is involved in an outer-product along LHS (i.e. it is a permutation on RES and LHS and does not appear in RHS).</li>
<li>The n dimension is involved in an outer-product along RHS (i.e. it is a permutation on RES and RHS and does not appear in LHS).</li>
<li>The k dimension appears as a permutation on LHS and RHS.</li>
<li>m, n and k appear only once in any given indexing.</li>
<li>Optional batch dimensions that appear in all operands are captured. This allows e.g. detecting that some contraction is embedded within <span class="tt">linalgOp</span> with some orthogonal heuristic. When multiple dimension occurrences exist that match <span class="tt">batch</span>, <span class="tt">m</span>, <span class="tt">n</span>, or <span class="tt">k</span>, indices are returned in sorted order. Returns a failure if any of <span class="tt">m</span>, <span class="tt">n</span> or <span class="tt">k</span> is empty. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00484">484</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00441">inferContractionDimsImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BlockPackMatmul_8cpp_source.html#l00138">blockPackMatmul()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00513">mlir::linalg::detail::isContractionInterfaceImpl()</a>, <a class="el" href="Linalg_8cpp_source.html#l00052">mlirLinalgInferContractionDimensions()</a>, <a class="el" href="Linalg_8cpp_source.html#l00079">mlirLinalgInferContractionDimensionsFromMaps()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00748">packMatmulGreedily()</a>, and <a class="el" href="BlockPackMatmul_8cpp_source.html#l00043">validateFullTilesOnDims()</a>.</p>

</div>
</div>
<a id="a63f1beb2cf9d6935a346b2e4b4d3c7f5" name="a63f1beb2cf9d6935a346b2e4b4d3c7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f1beb2cf9d6935a346b2e4b4d3c7f5">&#9670;&#160;</a></span>inferConvolutionDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ConvolutionDimensions.html">ConvolutionDimensions</a> &gt; mlir::linalg::inferConvolutionDims </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find at least 1 parallel (output_image) and reduction (filter_loop) dimension candidates that form a convolution subcomputation within <span class="tt">linalgOp</span>. </p>
<p>The LHS is assumed to be the convolution input while the RHS is assumed as the filter. These dimensions are such that:</p><ol type="1">
<li>Optional batch dimensions that appear in the input and filter.</li>
<li>The output_image dimension is involved in a cross-correlation along LHS (i.e. it is a permutation on RES and LHS and has an associated filter_loop in RHS).</li>
<li>Optional output_channel dimension is involved in an outer-product along RHS (i.e. it is a permutation on RES and RHS and does not appear in LHS).</li>
<li>Optional input_channel dimension appears as a permutation on LHS and RHS.</li>
<li>The filter_loop dimension appears as a permutation on the RHS and represents the shape of the kernel cross-correlated along a corresponding output_image dim.</li>
<li>The input_channel dimension appears as a permutation on LHS and RHS.</li>
<li>All dimensions appear only once in any given indexing map. This allows e.g. detecting that some convolution is embedded within <span class="tt">linalgOp</span> with some orthogonal heuristic. When multiple dimension occurrences exist that match any classification indices are returned in sorted order. Returns a failure if <span class="tt">output_image</span> (and implicitly <span class="tt">filter_loop</span>) is empty. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00853">853</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00741">inferConvolutionDimsImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_8cpp_source.html#l00119">mlirLinalgInferConvolutionDimensions()</a>.</p>

</div>
</div>
<a id="a19f85ff360bf1a176189d8a29a349623" name="a19f85ff360bf1a176189d8a29a349623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f85ff360bf1a176189d8a29a349623">&#9670;&#160;</a></span>inferStaticShape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::inferStaticShape </td>
          <td>(</td>
          <td class="paramtype">PackOp</td>          <td class="paramname"><span class="paramname"><em>packOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>srcShape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>destShape</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <span class="tt">srcShape</span> or <span class="tt">destShape</span> is different from the one in <span class="tt">packOp</span> and populates each with the inferred static shape. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05584">5584</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00187">mlir::invertPermutationVector()</a>.</p>

</div>
</div>
<a id="af8bfb7adf709f8802dfc47a8e602ecb0" name="af8bfb7adf709f8802dfc47a8e602ecb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bfb7adf709f8802dfc47a8e602ecb0">&#9670;&#160;</a></span>inferStaticShape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::inferStaticShape </td>
          <td>(</td>
          <td class="paramtype">UnPackOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>srcShape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>destShape</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <span class="tt">srcShape</span> or <span class="tt">destShape</span> is different from the one in <span class="tt">op</span> and populates each with the inferred static shape. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05905">5905</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00187">mlir::invertPermutationVector()</a>.</p>

</div>
</div>
<a id="a78f9038823afe23e270d5bdc0734bc3e" name="a78f9038823afe23e270d5bdc0734bc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f9038823afe23e270d5bdc0734bc3e">&#9670;&#160;</a></span>insertSlicesBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::insertSlicesBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>results</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates <span class="tt">insert_slice</span> ops that insert <span class="tt">results</span> back into larger tensors they were originally extracted from with <span class="tt">extract_slice</span> before being passed as <span class="tt">operands</span> to the given structured operation <span class="tt">op</span> or its clone. </p>
<p>Note that <span class="tt">operands</span> are not necessarily the actual operands of <span class="tt">op</span>, the operation serves only as metadata container for operand types and positions. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02047">2047</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, and <a class="el" href="LoopUtils_8cpp.html#ad077dc835cc07a8b6e9fd23f222b4ac6">inserted()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="a8dcc62e199cdb1863a3d6f30e4dc317a" name="a8dcc62e199cdb1863a3d6f30e4dc317a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcc62e199cdb1863a3d6f30e4dc317a">&#9670;&#160;</a></span>interchangeGenericOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; GenericOp &gt; mlir::linalg::interchangeGenericOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GenericOp</td>          <td class="paramname"><span class="paramname"><em>genericOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>interchangeVector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interchange the <span class="tt">iterator_types</span> and <span class="tt">iterator_maps</span> dimensions and adapts the index accesses of <span class="tt">op</span>. </p>
<p>This is an in-place transformation controlled by <span class="tt">interchangeVector</span>. An empty vector is interpreted as the identity permutation and the transformation returns early.</p>
<p>E.g. the permutation <span class="tt">(i,j,k) -&gt; (j,k,i)</span> is expressed with <span class="tt">interchangeVector = [1,2,0]</span>. All values in <span class="tt">interchangeVector</span> must be integers, in the range 0..<span class="tt">op.rank</span> without duplications (i.e. <span class="tt">[1,1,2]</span> is an invalid permutation).</p>
<p>Return failure if the permutation is not valid. </p>

<p class="definition">Definition at line <a class="el" href="Interchange_8cpp_source.html#l00045">45</a> of file <a class="el" href="Interchange_8cpp_source.html">Interchange.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00226">mlir::applyPermutationToVector()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">mlir::AffineMap::compose()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00247">mlir::RewriterBase::finalizeOpModification()</a>, <a class="el" href="Builders_8cpp_source.html#l00318">mlir::Builder::getAffineMapArrayAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00266">mlir::Builder::getArrayAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00260">mlir::AffineMap::getPermutationMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">mlir::AffineMap::getSubMap()</a>, <a class="el" href="Interchange_8cpp_source.html#l00031">interchangeGenericOpPrecondition()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00365">mlir::AffineMap::isEmpty()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8h_source.html#l00529">mlir::RewriterBase::replaceOpWithNewOp()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00622">mlir::RewriterBase::startOpModification()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00748">packMatmulGreedily()</a>.</p>

</div>
</div>
<a id="a9fdf6fd72d97540e86680857176b705e" name="a9fdf6fd72d97540e86680857176b705e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fdf6fd72d97540e86680857176b705e">&#9670;&#160;</a></span>isaBroadcastOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt; mlir::linalg::isaBroadcastOpInterface </td>
          <td>(</td>
          <td class="paramtype">GenericOp</td>          <td class="paramname"><span class="paramname"><em>genericOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <span class="tt">genericOp</span> is semantically equivalent to a <span class="tt">linalg.broadcast</span>. </p>
<p>Returns broadcast dimensions if true. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00141">141</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Specialize_8cpp_source.html#l00323">specializeGenericOp()</a>.</p>

</div>
</div>
<a id="ab5277093c168682f123f1e99d90461f0" name="ab5277093c168682f123f1e99d90461f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5277093c168682f123f1e99d90461f0">&#9670;&#160;</a></span>isaContractionOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::isaContractionOpInterface </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <span class="tt">linalgOp</span> conforms to ContractionOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00565">565</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00513">mlir::linalg::detail::isContractionInterfaceImpl()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00503">mlir::linalg::detail::Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldAddIntoDest_8cpp_source.html#l00058">FoldAddIntoDest::matchAndRewrite()</a>, <a class="el" href="Linalg_8cpp_source.html#l00045">mlirLinalgIsAContractionOp()</a>, and <a class="el" href="Specialize_8cpp_source.html#l00323">specializeGenericOp()</a>.</p>

</div>
</div>
<a id="a7c76ee8dee2d6cb36fd4c974c60463f3" name="a7c76ee8dee2d6cb36fd4c974c60463f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c76ee8dee2d6cb36fd4c974c60463f3">&#9670;&#160;</a></span>isaConvolutionOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::isaConvolutionOpInterface </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>allowEmptyConvolvedDims</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <span class="tt">linalgOp</span> conforms to ConvolutionOpInterface. </p>
<p>By default, we require the <span class="tt">linalgOp</span> to have non-empty convolved dims (implicitly non-empty <span class="tt">output_image</span> and <span class="tt">filter_loop</span>). Users can loosen the constraint by setting <span class="tt">allowEmptyConvolvedDims</span> to true </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">1042</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00884">mlir::linalg::detail::isConvolutionInterfaceImpl()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00871">mlir::linalg::detail::Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00655">isaConvolutionOpOfType&lt; linalg::Conv1DNcwFcwOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00628">isaConvolutionOpOfType&lt; linalg::Conv1DNwcWcfOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00604">isaConvolutionOpOfType&lt; linalg::Conv1DOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00835">isaConvolutionOpOfType&lt; linalg::Conv2DNchwFchwOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00866">isaConvolutionOpOfType&lt; linalg::Conv2DNchwFchwQOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00898">isaConvolutionOpOfType&lt; linalg::Conv2DNgchwFgchwOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00930">isaConvolutionOpOfType&lt; linalg::Conv2DNgchwGfchwOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00963">isaConvolutionOpOfType&lt; linalg::Conv2DNgchwGfchwQOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00772">isaConvolutionOpOfType&lt; linalg::Conv2DNhwcFhwcOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00803">isaConvolutionOpOfType&lt; linalg::Conv2DNhwcFhwcQOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00709">isaConvolutionOpOfType&lt; linalg::Conv2DNhwcHwcfOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00740">isaConvolutionOpOfType&lt; linalg::Conv2DNhwcHwcfQOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00997">isaConvolutionOpOfType&lt; linalg::Conv2DNhwgcGfhwcOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01030">isaConvolutionOpOfType&lt; linalg::Conv2DNhwgcGfhwcQOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00682">isaConvolutionOpOfType&lt; linalg::Conv2DOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01064">isaConvolutionOpOfType&lt; linalg::Conv3DOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01095">isaConvolutionOpOfType&lt; linalg::DepthwiseConv1DNcwCwOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01147">isaConvolutionOpOfType&lt; linalg::DepthwiseConv1DNwcWcmOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01121">isaConvolutionOpOfType&lt; linalg::DepthwiseConv1DNwcWcOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01174">isaConvolutionOpOfType&lt; linalg::DepthwiseConv2DNchwChwOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01264">isaConvolutionOpOfType&lt; linalg::DepthwiseConv2DNhwcHwcmOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01295">isaConvolutionOpOfType&lt; linalg::DepthwiseConv2DNhwcHwcmQOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01203">isaConvolutionOpOfType&lt; linalg::DepthwiseConv2DNhwcHwcOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01233">isaConvolutionOpOfType&lt; linalg::DepthwiseConv2DNhwcHwcQOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01330">isaConvolutionOpOfType&lt; linalg::DepthwiseConv3DNdhwcDhwcmOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01364">isaConvolutionOpOfType&lt; linalg::PoolingNhwcMaxOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01454">isaConvolutionOpOfType&lt; linalg::PoolingNhwcMaxUnsignedOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01394">isaConvolutionOpOfType&lt; linalg::PoolingNhwcMinOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01484">isaConvolutionOpOfType&lt; linalg::PoolingNhwcMinUnsignedOp &gt;()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01424">isaConvolutionOpOfType&lt; linalg::PoolingNhwcSumOp &gt;()</a>, <a class="el" href="Linalg_8cpp_source.html#l00110">mlirLinalgIsAConvolutionOp()</a>, and <a class="el" href="Specialize_8cpp_source.html#l00323">specializeGenericOp()</a>.</p>

</div>
</div>
<a id="ad5cf6cfb2d2c8ac100efa843033bc4b7" name="ad5cf6cfb2d2c8ac100efa843033bc4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">&#9670;&#160;</a></span>isaConvolutionOpOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConvOpTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::isaConvolutionOpOfType </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a linalg <span class="tt">op</span> this function returns true if it is a convolution op of type <span class="tt">ConvOpTy</span> and populates <span class="tt">dilations</span> and <span class="tt">strides</span> with values inferred from the indexing maps. </p>

</div>
</div>
<a id="a2ccd13eed8b4883288fff8e4ddb70550" name="a2ccd13eed8b4883288fff8e4ddb70550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccd13eed8b4883288fff8e4ddb70550">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::Conv1DNcwFcwOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::Conv1DNcwFcwOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00655">655</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="ac72c2d9c21aeb5f939e149892ccd4f1d" name="ac72c2d9c21aeb5f939e149892ccd4f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72c2d9c21aeb5f939e149892ccd4f1d">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::Conv1DNwcWcfOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::Conv1DNwcWcfOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00628">628</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a1ffbd632e2d58f582f3e675ed4961d11" name="a1ffbd632e2d58f582f3e675ed4961d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ffbd632e2d58f582f3e675ed4961d11">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::Conv1DOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::Conv1DOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00604">604</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a44d5c7a263e7866b254d3345b76606a5" name="a44d5c7a263e7866b254d3345b76606a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d5c7a263e7866b254d3345b76606a5">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::Conv2DNchwFchwOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::Conv2DNchwFchwOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00835">835</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a9f2abec2f144cdaa94c9ec88a7fa811d" name="a9f2abec2f144cdaa94c9ec88a7fa811d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2abec2f144cdaa94c9ec88a7fa811d">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::Conv2DNchwFchwQOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::Conv2DNchwFchwQOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00866">866</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a444a777a6371ee3853783c0eb66498a9" name="a444a777a6371ee3853783c0eb66498a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444a777a6371ee3853783c0eb66498a9">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::Conv2DNgchwFgchwOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::Conv2DNgchwFgchwOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00898">898</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a565f6703ec3f519ad23e0dbf21ad4133" name="a565f6703ec3f519ad23e0dbf21ad4133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565f6703ec3f519ad23e0dbf21ad4133">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::Conv2DNgchwGfchwOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::Conv2DNgchwGfchwOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00930">930</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a93e4e48b0b9d958118b8bc858f7b0c8a" name="a93e4e48b0b9d958118b8bc858f7b0c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e4e48b0b9d958118b8bc858f7b0c8a">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::Conv2DNgchwGfchwQOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::Conv2DNgchwGfchwQOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00963">963</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="ab65bfad16b799f7b843af5496c3a3d5a" name="ab65bfad16b799f7b843af5496c3a3d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65bfad16b799f7b843af5496c3a3d5a">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::Conv2DNhwcFhwcOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::Conv2DNhwcFhwcOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00772">772</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="ab73b5e645b8a1bcde0c85ca92eaaf5f2" name="ab73b5e645b8a1bcde0c85ca92eaaf5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73b5e645b8a1bcde0c85ca92eaaf5f2">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::Conv2DNhwcFhwcQOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::Conv2DNhwcFhwcQOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00803">803</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="ab72cb2343a00a08b64eba22a8b3ff3ed" name="ab72cb2343a00a08b64eba22a8b3ff3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72cb2343a00a08b64eba22a8b3ff3ed">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::Conv2DNhwcHwcfOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::Conv2DNhwcHwcfOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00709">709</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a05a4ead0e9693a4d927e7945ba01a6c7" name="a05a4ead0e9693a4d927e7945ba01a6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a4ead0e9693a4d927e7945ba01a6c7">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::Conv2DNhwcHwcfQOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::Conv2DNhwcHwcfQOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00740">740</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="aaad1dedfd1a75b6b22eaf5832074aa71" name="aaad1dedfd1a75b6b22eaf5832074aa71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad1dedfd1a75b6b22eaf5832074aa71">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::Conv2DNhwgcGfhwcOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::Conv2DNhwgcGfhwcOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00997">997</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a3389d7d40ab4e152d42551834ddaef96" name="a3389d7d40ab4e152d42551834ddaef96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3389d7d40ab4e152d42551834ddaef96">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::Conv2DNhwgcGfhwcQOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::Conv2DNhwgcGfhwcQOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01030">1030</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a3652d880723e9fe9030efc75b4796b75" name="a3652d880723e9fe9030efc75b4796b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3652d880723e9fe9030efc75b4796b75">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::Conv2DOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::Conv2DOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00682">682</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a467dc274a8b53da6d8f2fc0e3652996d" name="a467dc274a8b53da6d8f2fc0e3652996d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467dc274a8b53da6d8f2fc0e3652996d">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::Conv3DOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::Conv3DOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01064">1064</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a7e34b5813ebc19922109bf642c603ee5" name="a7e34b5813ebc19922109bf642c603ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e34b5813ebc19922109bf642c603ee5">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::DepthwiseConv1DNcwCwOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::DepthwiseConv1DNcwCwOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01095">1095</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a9ad1d94837e0b166307a48e35c1b25f4" name="a9ad1d94837e0b166307a48e35c1b25f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad1d94837e0b166307a48e35c1b25f4">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::DepthwiseConv1DNwcWcmOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::DepthwiseConv1DNwcWcmOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01147">1147</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a4118447711892cbf3b2a3abec5c2acaa" name="a4118447711892cbf3b2a3abec5c2acaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4118447711892cbf3b2a3abec5c2acaa">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::DepthwiseConv1DNwcWcOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::DepthwiseConv1DNwcWcOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01121">1121</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a1393714f9958cd16212c282bdf4282b4" name="a1393714f9958cd16212c282bdf4282b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1393714f9958cd16212c282bdf4282b4">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::DepthwiseConv2DNchwChwOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::DepthwiseConv2DNchwChwOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01174">1174</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a8ac1ea88c5d05743ee23ef4c1ff0a657" name="a8ac1ea88c5d05743ee23ef4c1ff0a657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac1ea88c5d05743ee23ef4c1ff0a657">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::DepthwiseConv2DNhwcHwcmOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::DepthwiseConv2DNhwcHwcmOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01264">1264</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a2e4917139f8f69e658ac803b391b0402" name="a2e4917139f8f69e658ac803b391b0402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4917139f8f69e658ac803b391b0402">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::DepthwiseConv2DNhwcHwcmQOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::DepthwiseConv2DNhwcHwcmQOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01295">1295</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a602bb8a7a014244bddf1ff52238a94fe" name="a602bb8a7a014244bddf1ff52238a94fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602bb8a7a014244bddf1ff52238a94fe">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::DepthwiseConv2DNhwcHwcOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::DepthwiseConv2DNhwcHwcOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01203">1203</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="ab522e1456b3cde1c1ae05e4c42ccab3b" name="ab522e1456b3cde1c1ae05e4c42ccab3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab522e1456b3cde1c1ae05e4c42ccab3b">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::DepthwiseConv2DNhwcHwcQOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::DepthwiseConv2DNhwcHwcQOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01233">1233</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a00054ed9c16213133183f0e6801e242b" name="a00054ed9c16213133183f0e6801e242b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00054ed9c16213133183f0e6801e242b">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::DepthwiseConv3DNdhwcDhwcmOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::DepthwiseConv3DNdhwcDhwcmOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01330">1330</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a47691e1a880347f57af5d61024168165" name="a47691e1a880347f57af5d61024168165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47691e1a880347f57af5d61024168165">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::PoolingNhwcMaxOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::PoolingNhwcMaxOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01364">1364</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00503">MaxSigned</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="afeffd7f1f218aa2f2c95d31622bac954" name="afeffd7f1f218aa2f2c95d31622bac954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeffd7f1f218aa2f2c95d31622bac954">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::PoolingNhwcMaxUnsignedOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::PoolingNhwcMaxUnsignedOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01454">1454</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00504">MaxUnsigned</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a9d73360b6d362ef7f9bd9477f8a7143c" name="a9d73360b6d362ef7f9bd9477f8a7143c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d73360b6d362ef7f9bd9477f8a7143c">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::PoolingNhwcMinOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::PoolingNhwcMinOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01394">1394</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00505">MinSigned</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="aaf7d1b8633cd2c58c411b273567a686f" name="aaf7d1b8633cd2c58c411b273567a686f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7d1b8633cd2c58c411b273567a686f">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::PoolingNhwcMinUnsignedOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::PoolingNhwcMinUnsignedOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01484">1484</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00506">MinUnsigned</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a04acf2f26e9a2817f7396b1f1f9409d4" name="a04acf2f26e9a2817f7396b1f1f9409d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04acf2f26e9a2817f7396b1f1f9409d4">&#9670;&#160;</a></span>isaConvolutionOpOfType&lt; linalg::PoolingNhwcSumOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ad5cf6cfb2d2c8ac100efa843033bc4b7">mlir::linalg::isaConvolutionOpOfType</a>&lt; linalg::PoolingNhwcSumOp &gt; </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>dilations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01424">1424</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00546">mlir::linalg::ConvMatcherBuilder::dim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00565">mlir::linalg::ConvMatcherBuilder::matchMaps()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00549">mlir::linalg::ConvMatcherBuilder::strided()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00507">Sum</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00607">W</a>.</p>

</div>
</div>
<a id="a171ae143026d28b2e6954c74bb535831" name="a171ae143026d28b2e6954c74bb535831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171ae143026d28b2e6954c74bb535831">&#9670;&#160;</a></span>isaCopyOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::isaCopyOpInterface </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <span class="tt">linalgOp</span> is semantically equivalent to a <span class="tt">linalg.copyOp</span>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00061">61</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00152">mlir::Block::back()</a>, <a class="el" href="Block_8h_source.html#l00129">mlir::Block::getArgument()</a>, and <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Specialize_8cpp_source.html#l00323">specializeGenericOp()</a>.</p>

</div>
</div>
<a id="afc247b3bd43d4462293e09845b698e7a" name="afc247b3bd43d4462293e09845b698e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc247b3bd43d4462293e09845b698e7a">&#9670;&#160;</a></span>isaElemwiseSingleBinaryOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::isaElemwiseSingleBinaryOpInterface </td>
          <td>(</td>
          <td class="paramtype">GenericOp</td>          <td class="paramname"><span class="paramname"><em>genericOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <span class="tt">genericOp</span> is semantically equivalent to a single linalg elementwise binary op e.g. </p>
<p>linalg.sub. </p>

<p class="reference">References <a class="el" href="RawOstreamExtras_8cpp_source.html#l00012">mlir::thread_safe_nulls()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Specialize_8cpp_source.html#l00323">specializeGenericOp()</a>.</p>

</div>
</div>
<a id="a14eec3edd7d29c8980b155ed0dee1a0c" name="a14eec3edd7d29c8980b155ed0dee1a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14eec3edd7d29c8980b155ed0dee1a0c">&#9670;&#160;</a></span>isaElemwiseSingleUnaryOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::isaElemwiseSingleUnaryOpInterface </td>
          <td>(</td>
          <td class="paramtype">GenericOp</td>          <td class="paramname"><span class="paramname"><em>genericOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a given <span class="tt">genericOp</span> is semantically equivalent to a single linalgelementwise unary op. </p>
<p>e.g. linalg.exp. A linalg.generic body could be a series of unary elementwise ops e.g. <span class="tt">exp(neg(x))</span>, such as formed by linalg op fusion. Here we restrict it to detecting cases where body is is a single computation op. </p>

<p class="reference">Referenced by <a class="el" href="Specialize_8cpp_source.html#l00323">specializeGenericOp()</a>.</p>

</div>
</div>
<a id="aea1ca69a91110433c24e13af5c4ae3a9" name="aea1ca69a91110433c24e13af5c4ae3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1ca69a91110433c24e13af5c4ae3a9">&#9670;&#160;</a></span>isaFillOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::isaFillOpInterface </td>
          <td>(</td>
          <td class="paramtype">GenericOp</td>          <td class="paramname"><span class="paramname"><em>genericOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <span class="tt">genericOp</span> is semantically equivalent to a <span class="tt">linalg.fill</span>. </p>
<p>Supports two patterns:</p><ol type="1">
<li>External: linalg.generic ins(scalar) outs(tensor) { yield scalar }</li>
<li>Inlined: linalg.generic outs(tensor) { yield constant } Returns the scalar fill value if true. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00131">131</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00114">isaExternalFillOp()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00087">isaInlinedFillOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Specialize_8cpp_source.html#l00323">specializeGenericOp()</a>.</p>

</div>
</div>
<a id="a03e0016d67ebca76011c67253b093af0" name="a03e0016d67ebca76011c67253b093af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e0016d67ebca76011c67253b093af0">&#9670;&#160;</a></span>isaTransposeOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt; mlir::linalg::isaTransposeOpInterface </td>
          <td>(</td>
          <td class="paramtype">GenericOp</td>          <td class="paramname"><span class="paramname"><em>genericOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <span class="tt">genericOp</span> is semantically equivalent to a <span class="tt">linalg.transpose</span>. </p>
<p>Returns permuted dimensions if true. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00191">191</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Specialize_8cpp_source.html#l00323">specializeGenericOp()</a>.</p>

</div>
</div>
<a id="a31426a6a1dc69e5819138ba53c6e7ef9" name="a31426a6a1dc69e5819138ba53c6e7ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31426a6a1dc69e5819138ba53c6e7ef9">&#9670;&#160;</a></span>isDimSequencePreserved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::isDimSequencePreserved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>indexingMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a11a02d1f78682e704d9aa4a6ef3cb364">ReassociationIndicesRef</a></td>          <td class="paramname"><span class="paramname"><em>dimSequence</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <span class="tt">true</span> if a given sequence of dimensions are contiguous in the range of the specified indexing map. </p>
<p>For a given <span class="tt">dimSequence</span>, check if the sequence is conserved in the <span class="tt">indexingMap</span>.</p>
<p><span class="tt">indexingMap</span> is expected to be a projected permutation. Non-existence of the sequence returns true as well. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01306">1306</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">mlir::AffineMap::isProjectedPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01347">areDimSequencesPreserved()</a>.</p>

</div>
</div>
<a id="adc256f0d611f6f167955a5fc0d35c542" name="adc256f0d611f6f167955a5fc0d35c542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc256f0d611f6f167955a5fc0d35c542">&#9670;&#160;</a></span>isDimTimesConstantOrDimOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> mlir::linalg::isDimTimesConstantOrDimOnly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <span class="tt">expr</span> is either: </p>
<ul>
<li>a dimension expr alone (implying multiplication by 1), or</li>
<li>a multiplication of dimension expr by any positive constant != 1 In both cases we will capture the dimension expression into <span class="tt">dim</span> and return the constant multiplier. Returns -1 in case of a match failure. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00412">412</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AffineConstantExpr.html#ad4bf344715eb83d42aeadf8a71925662">mlir::AffineConstantExpr::getValue()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00043">mlir::Mul</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00454">matchConvDimAddExprPattern()</a>.</p>

</div>
</div>
<a id="a8b1c347bc995910212c197f9f8728b12" name="a8b1c347bc995910212c197f9f8728b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1c347bc995910212c197f9f8728b12">&#9670;&#160;</a></span>isElementwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::isElementwise </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a LinalgOp is an element-wise operation. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00215">215</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00195">allIndexingsAreProjectedPermutation()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00201">hasOnlyScalarElementwiseOp()</a>.</p>

</div>
</div>
<a id="a258a284dc398c6d6510840831132df77" name="a258a284dc398c6d6510840831132df77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258a284dc398c6d6510840831132df77">&#9670;&#160;</a></span>isInvalidPackingPosSpecification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::isInvalidPackingPosSpecification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dimsPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>rank</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <span class="tt">dimsPos</span> is invalid. </p>
<p>It is invalid when: a) It contains duplicate. b) At least one dimension is out of bound (<span class="tt">dimPos</span> is &gt;= 0 and &lt; rank). c) The number of elements in <span class="tt">dimsPos</span> is &gt; than <span class="tt">rank</span>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05077">5077</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l05091">commonVerifierPackAndUnPackOp()</a>.</p>

</div>
</div>
<a id="a20d84aa10cc5bda416b75ff65007c677" name="a20d84aa10cc5bda416b75ff65007c677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d84aa10cc5bda416b75ff65007c677">&#9670;&#160;</a></span>isLikePadUnPad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PackOrUnpackOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::isLikePadUnPad </td>
          <td>(</td>
          <td class="paramtype">PackOrUnpackOp</td>          <td class="paramname"><span class="paramname"><em>packOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RankedTensorType</td>          <td class="paramname"><span class="paramname"><em>packedTensorType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05675">5675</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

</div>
</div>
<a id="a24909cfdf87977961b71f1ca78a25919" name="a24909cfdf87977961b71f1ca78a25919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24909cfdf87977961b71f1ca78a25919">&#9670;&#160;</a></span>isParallelIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::isParallelIterator </td>
          <td>(</td>
          <td class="paramtype">utils::IteratorType</td>          <td class="paramname"><span class="paramname"><em>iteratorType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if iterator type has "parallel" semantics. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00230">230</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01698">generateParallelLoopNest()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01403">getCollapsableIterationSpaceDims()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="a5377722f56e02541897c157260bd1eee" name="a5377722f56e02541897c157260bd1eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5377722f56e02541897c157260bd1eee">&#9670;&#160;</a></span>isReductionIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::isReductionIterator </td>
          <td>(</td>
          <td class="paramtype">utils::IteratorType</td>          <td class="paramname"><span class="paramname"><em>iteratorType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if iterator type has "reduction" semantics. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00234">234</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01403">getCollapsableIterationSpaceDims()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00711">getDimsToReduce()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00718">hasReductionIterator()</a>, and <a class="el" href="CodegenEnv_8cpp_source.html#l00135">mlir::sparse_tensor::CodegenEnv::isAdmissibleTensorExp()</a>.</p>

</div>
</div>
<a id="a7b7f777c5538e35bbdd3aaabdb07e6f7" name="a7b7f777c5538e35bbdd3aaabdb07e6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7f777c5538e35bbdd3aaabdb07e6f7">&#9670;&#160;</a></span>linalgOpAnchoredEmptyTensorEliminationStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::linalgOpAnchoredEmptyTensorEliminationStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">bufferization::OneShotAnalysisState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to eliminate tensor::EmptyOps inside <span class="tt">op</span> that are anchored on a LinalgOp. </p>
<p>This transforms looks for LinalgOps that have an unused output operand and an input operand that is rooted in a tensor::EmptyOp. The tensor::EmptyOp uses are replaced with the output operand and the two operands of the LinalgOp are swapped.</p>
<p>Example: %0 = tensor.empty() %1 = linalg.matmul ins(...) outs(%0) %2 = linalg.generic ins(%1) outs(dest) { ^bb0(in: f32, out: f32): // out not used }</p>
<p>The IR is transformed as follows: %0 = tensor.empty() %1 = linalg.matmul ins(...) outs(dest) %2 = linalg.generic ins(%0) outs(%1) { ^bb0(in: f32, out: f32): // Use out instead of in }</p>
<p>The "ins" operand has no uses inside the body of the LinalgOp and can be folded away with existing cleanup patterns. Afterwards, the tensor::EmptyOp can also fold away. </p>

<p class="definition">Definition at line <a class="el" href="EliminateEmptyTensors_8cpp_source.html#l00039">39</a> of file <a class="el" href="EliminateEmptyTensors_8cpp_source.html">EliminateEmptyTensors.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">mlir::config</a>, <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="EliminateEmptyTensors_8cpp_source.html#l00023">getUnusedOutOperand()</a>, <a class="el" href="Value_8h_source.html#l00188">mlir::Value::getUses()</a>, <a class="el" href="PatternMatch_8h_source.html#l00638">mlir::RewriterBase::modifyOpInPlace()</a>, <a class="el" href="Dominance_8cpp_source.html#l00323">mlir::DominanceInfo::properlyDominates()</a>, <a class="el" href="PatternMatch_8h_source.html#l00646">mlir::RewriterBase::replaceAllUsesWith()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00969">mlir::bufferization::OneShotAnalysisState::resetCache()</a>, <a class="el" href="UseDefLists_8h_source.html#l00163">mlir::IROperand&lt; DerivedT, IRValueT &gt;::set()</a>, <a class="el" href="WalkResult_8h_source.html#l00048">mlir::WalkResult::skip()</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a95f289e066dcbb7844bd444c0880fc36" name="a95f289e066dcbb7844bd444c0880fc36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f289e066dcbb7844bd444c0880fc36">&#9670;&#160;</a></span>linalgOpToAffineLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="#a193831e3afcf32c859a980c17c8c276b">LinalgLoops</a> &gt; mlir::linalg::linalgOpToAffineLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a loop nest of <span class="tt">affine.for</span> with the proper body for <span class="tt">linalgOp</span>. </p>
<p>Emits a loop nest of <span class="tt">affine.for</span> with the proper body for <span class="tt">linalgOp</span>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00363">363</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">References <a class="el" href="Loops_8cpp_source.html#l00209">linalgOpToLoopsImpl()</a>.</p>

</div>
</div>
<a id="a7edd4be30bfb8af9bc8e486f8368c1e2" name="a7edd4be30bfb8af9bc8e486f8368c1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7edd4be30bfb8af9bc8e486f8368c1e2">&#9670;&#160;</a></span>linalgOpToLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="#a193831e3afcf32c859a980c17c8c276b">LinalgLoops</a> &gt; mlir::linalg::linalgOpToLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a loop nest of <span class="tt">scf.for</span> with the proper body for <span class="tt">linalgOp</span>. </p>
<p>Emits a loop nest of <span class="tt">scf.for</span> with the proper body for <span class="tt">linalgOp</span>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00368">368</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">References <a class="el" href="Loops_8cpp_source.html#l00209">linalgOpToLoopsImpl()</a>.</p>

</div>
</div>
<a id="aff809877c1d119dae06d06a8bad953e4" name="aff809877c1d119dae06d06a8bad953e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff809877c1d119dae06d06a8bad953e4">&#9670;&#160;</a></span>linalgOpToParallelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="#a193831e3afcf32c859a980c17c8c276b">LinalgLoops</a> &gt; mlir::linalg::linalgOpToParallelLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a loop nest of <span class="tt">scf.parallel</span> with the proper body for <span class="tt">linalgOp</span>. </p>
<p>Emits a loop nest of <span class="tt">scf.parallel</span> with the proper body for <span class="tt">linalgOp</span>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00375">375</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">References <a class="el" href="Loops_8cpp_source.html#l00209">linalgOpToLoopsImpl()</a>.</p>

</div>
</div>
<a id="afebe4a9f3b87bb8f196bf2d577511a05" name="afebe4a9f3b87bb8f196bf2d577511a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afebe4a9f3b87bb8f196bf2d577511a05">&#9670;&#160;</a></span>lowerPack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1LowerPackResult.html">LowerPackResult</a> &gt; mlir::linalg::lowerPack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::PackOp</td>          <td class="paramname"><span class="paramname"><em>packOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>lowerPadLikeWithInsertSlice</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite pack as pad + reshape + transpose. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00217">217</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00226">mlir::applyPermutationToVector()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00023">mlir::getElementTypeOrSelf()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00057">mlir::tensor::getMixedSize()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00066">mlir::tensor::getMixedSizes()</a>, <a class="el" href="#a92b42ab91002d8c468cb54eaebdb3989">getPackInverseDestPerm()</a>, <a class="el" href="Builders_8cpp_source.html#l00324">mlir::Builder::getZeroAttr()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00187">mlir::invertPermutationVector()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00490">mlir::isRankReducedType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00241">mlir::RankedTensorType::Builder::setShape()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00094">stringifyReassocIndices()</a>, and <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00357">mlir::Success</a>.</p>

</div>
</div>
<a id="a3cea34f55211c79271dff09bb07c3279" name="a3cea34f55211c79271dff09bb07c3279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cea34f55211c79271dff09bb07c3279">&#9670;&#160;</a></span>lowerUnPack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1LowerUnPackOpResult.html">LowerUnPackOpResult</a> &gt; mlir::linalg::lowerUnPack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::UnPackOp</td>          <td class="paramname"><span class="paramname"><em>unPackOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>lowerUnpadLikeWithExtractSlice</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite pack as empty + transpose + reshape + extract_slice. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00345">345</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00226">mlir::applyPermutationToVector()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00066">mlir::tensor::getMixedSizes()</a>, <a class="el" href="#a1a3bb0a48c5e2778ea2bfd81a41db65d">getUnPackInverseSrcPerm()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00241">mlir::RankedTensorType::Builder::setShape()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00094">stringifyReassocIndices()</a>.</p>

</div>
</div>
<a id="a962a46fba2ac497e30bb6d23fef35d1a" name="a962a46fba2ac497e30bb6d23fef35d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962a46fba2ac497e30bb6d23fef35d1a">&#9670;&#160;</a></span>makeAffineDimExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::makeAffineDimExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>startIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">num</span> <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> dimensions at positions [startIdx, startIdx + num) and increments <span class="tt">startIdx</span> to <span class="tt">startIdx + num</span>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02465">2465</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>.</p>

</div>
</div>
<a id="ad11bd07c6a72404260df26efdd0ba069" name="ad11bd07c6a72404260df26efdd0ba069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11bd07c6a72404260df26efdd0ba069">&#9670;&#160;</a></span>makeComposedPadHighOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::makeComposedPadHighOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RankedTensorType</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>padding</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>nofold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>typeDynDims</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a tensor::PadOp that pads <span class="tt">source</span> to the shape of <span class="tt">type</span> whose sizes are assumed to be greater than the dynamic <span class="tt">source</span> size. </p>
<p>If <span class="tt">typeDynDims</span> is specified, then it must contain the sizes of all the dynamic dimensions in order of appearance in <span class="tt">type</span>, otherwise the function will pad those values to <span class="tt">0</span>. The padding introduces trailing <span class="tt">pad</span> values until the target size is met. If <span class="tt">source</span> is defined by one or more LinalgOps that have been padded with the same value and sizes, return their padded result instead of creating a tensor::PadOp.</p>
<p>Example: </p><div class="fragment"><div class="line">%0 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.extract_slice %arg0 [%iv0, %iv1] [%sz0, %sz1]</div>
<div class="line">%1 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.pad %0 low[0, 0] high[...] { <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.yield %cst }</div>
<div class="line">%2 = <a class="code hl_namespace" href="namespacemlir_1_1linalg.html">linalg</a>.matmul ins(...) outs(%1)</div>
<div class="line">%3 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.extract_slice %2 [0, 0] [%sz0, %sz1]</div>
</div><!-- fragment --><p> makeComposedPadHighOp(source=%3, pad=cst) returns %2 makeComposedPadHighOp(source=%3, pad=other_cst) returns %4 </p><div class="fragment"><div class="line">%4 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.pad %3 low[0, 0] high[...] { <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.yield %other_cst }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01510">1510</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00023">mlir::tensor::createPadHighOp()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00469">mlir::OpResult::getResultNumber()</a>, <a class="el" href="Matchers_8h_source.html#l00369">mlir::m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PadTilingInterface_8cpp_source.html#l00227">padOperand()</a>, and <a class="el" href="Padding_8cpp_source.html#l00187">padOperandToSmallestStaticBoundingBox()</a>.</p>

</div>
</div>
<a id="a30703b58e97c9678d9ee3d95c1b31f5d" name="a30703b58e97c9678d9ee3d95c1b31f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30703b58e97c9678d9ee3d95c1b31f5d">&#9670;&#160;</a></span>makeMemRefCopyOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GenericOp mlir::linalg::makeMemRefCopyOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns GenericOp that copies an n-D memref. </p>
<p>Unlike the current implementation of memref::CopyOp, this op can further tile, lower to loops or vectorize. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01578">1578</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a8144efefcad502e511c24aa5ce5b36e8" name="a8144efefcad502e511c24aa5ce5b36e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8144efefcad502e511c24aa5ce5b36e8">&#9670;&#160;</a></span>makeTiledLoopRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 4 &gt;, <a class="el" href="#ac63ef3b10f63a46b5d07ad3cbf2ed19d">LoopIndexToRangeIndexMap</a> &gt; mlir::linalg::makeTiledLoopRanges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>allShapeSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>allTileSizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00044">44</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01514">mlir::affine::makeComposedFoldedMultiResultAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="aa568a297670d2eb8609fa6df9849a449" name="aa568a297670d2eb8609fa6df9849a449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa568a297670d2eb8609fa6df9849a449">&#9670;&#160;</a></span>makeTiledShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::linalg::makeTiledShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>valueToTile</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lbs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ubs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>subShapeSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>omitPartialTileCheck</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an extract_slice/subview op for a single <span class="tt">valueToTile</span> with <span class="tt">builder</span>. </p>
<p>This new operation extracts a tile of <span class="tt">valueToTile</span>, starting at offsets <span class="tt">lbs</span> and with sizes <span class="tt">subShapeSizes</span>. <span class="tt">omitPartialTileCheck</span> controls whether to omit the partial/boundary tile condition check in cases where we statically know that it is unnecessary. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01878">1878</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01891">computeSliceParameters()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01859">materializeTiledShape()</a>.</p>

</div>
</div>
<a id="a1a5fecbf19090f24723800d371f08271" name="a1a5fecbf19090f24723800d371f08271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5fecbf19090f24723800d371f08271">&#9670;&#160;</a></span>makeTiledShapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::makeTiledShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>valuesToTile</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ivs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizeBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>omitPartialTileCheck</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates extract_slice/subview ops for all <span class="tt">valuesToTile</span> of the given <span class="tt">linalgOp</span> with <span class="tt">builder</span>, assuming <span class="tt">linalgOp</span> is being fused into a loop nest for tiling with the given induction variables <span class="tt">ivs</span> and tile sizes <span class="tt">tileSizes</span>. </p>
<p><span class="tt">sizeBounds</span> are the iteration space bounds for <em>all</em> the implicit loops in <span class="tt">linalgOp</span>. <span class="tt">omitPartialTileCheck</span> controls whether to omit the partial/boundary tile condition check in cases where we statically know that it is unnecessary.</p>
<p>Note that a constant zero in <span class="tt">tileSizes</span> means no tiling at that implicit loop. The number of non-zero values in <span class="tt">tileSizes</span> should be equal to the number of values in <span class="tt">ivs</span>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02127">2127</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02076">computeAllSliceParameters()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01859">materializeTiledShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00103">fuse()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="aaccfb97ed7b794263563cb312b75c0ca" name="aaccfb97ed7b794263563cb312b75c0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaccfb97ed7b794263563cb312b75c0ca">&#9670;&#160;</a></span>matchConvDimAddExprPattern()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::matchConvDimAddExprPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a></td>          <td class="paramname"><span class="paramname"><em>indexingMaps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>iDim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>fDim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>oDim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dilation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stride</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an array of AffineMaps <span class="tt">indexingMaps</span> verify the following commutatively:- indexingMaps[0].getResult(iDim) == indexingMaps[1].getResult(fDim) * &lt;c0&gt; + indexingMaps[n-1].getResult(oDim) * &lt;c1&gt; where,. </p>
<ul>
<li>c0 and c1 can be any constant,</li>
<li>n is the size of the indexingMaps' array,</li>
<li>0, 1 and n-1 are input, filter and output map indices respectively,</li>
<li>iDim, fDim and oDim are the input, filter and output dimension indices in their respective indexing maps Example: #inputMap = affine_map&lt;(d0, d1, d2, d3, d4, d5, d6) -&gt; (d0, d1 * 2 + d4 * 3, d2 + d5, d6)&gt; #filterMap = affine_map&lt;(d0, d1, d2, d3, d4, d5, d6) -&gt; (d4, d5, d6, d3)&gt; #outputMap = affine_map&lt;(d0, d1, d2, d3, d4, d5, d6) -&gt; (d0, d1, d2, d3)&gt;</li>
</ul>
<p>Here, #inputMap[1] = #outputMap[1] * 2 + #filterMap[0] * 3 Therefore, matchConvDimAddExprPattern(indexingMaps, 1, 0, 1, dilation, stride) would return true and update dilation = 3 and stride = 2 </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00454">454</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00041">mlir::Add</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00399">getAffineMapDim()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00412">isDimTimesConstantOrDimOnly()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00555">mlir::linalg::ConvMatcherBuilder::matchStride()</a>.</p>

</div>
</div>
<a id="abfc10c8ca9e8968a650ca511956358ab" name="abfc10c8ca9e8968a650ca511956358ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc10c8ca9e8968a650ca511956358ab">&#9670;&#160;</a></span>materializeTiledShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::linalg::materializeTiledShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>valueToTile</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1SliceParameters.html">SliceParameters</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sliceParams</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01859">1859</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00159">mlir::linalg::SliceParameters::offsets</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00160">mlir::linalg::SliceParameters::sizes</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00161">mlir::linalg::SliceParameters::strides</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01878">makeTiledShape()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02127">makeTiledShapes()</a>.</p>

</div>
</div>
<a id="a917a655a236200d3202b07fb842561b8" name="a917a655a236200d3202b07fb842561b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917a655a236200d3202b07fb842561b8">&#9670;&#160;</a></span>offsetIndices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::offsetIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>offests</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the specified offsets to any <span class="tt">linalg.index</span> ops contained in the given <span class="tt">linalgOp</span>. </p>
<p>The offsets are provided in the same order as iteration space dimensions. Null offests are assumed to be zero. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02149">2149</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02149">offsetIndices()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00103">fuse()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02149">offsetIndices()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00073">transformIndexOps()</a>.</p>

</div>
</div>
<a id="a34bed319cb33ba0b063edefa38e27309" name="a34bed319cb33ba0b063edefa38e27309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bed319cb33ba0b063edefa38e27309">&#9670;&#160;</a></span>offsetIndices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::offsetIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>offests</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02155">2155</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

</div>
</div>
<a id="abd29d6299d2891ae1d092974bc1c4e30" name="abd29d6299d2891ae1d092974bc1c4e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd29d6299d2891ae1d092974bc1c4e30">&#9670;&#160;</a></span>pack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt; mlir::linalg::pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>packedSizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement packing of a single LinalgOp by <span class="tt">packedSizes</span>. </p>
<p>Implement packing of a single LinalgOp by performing packing by <span class="tt">packedSizes</span>.</p>
<p>There must be one packedSizes entry per <span class="tt">linalgOp</span> iterator. Return the packed Linalg op on success, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00463">463</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00023">mlir::getElementTypeOrSelf()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="classmlir_1_1ValueRange.html#ab8f3a1aeea4da0acfaad1bc71b072017">mlir::ValueRange::getTypes()</a>, <a class="el" href="Builders_8cpp_source.html#l00324">mlir::Builder::getZeroAttr()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00147">packLinalgMetadataOnce()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01293">mlir::tile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00748">packMatmulGreedily()</a>.</p>

</div>
</div>
<a id="ab3567489d885b34059aa8286957de564" name="ab3567489d885b34059aa8286957de564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3567489d885b34059aa8286957de564">&#9670;&#160;</a></span>packMatmulGreedily()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt; mlir::linalg::packMatmulGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mnkPackedSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mnkPaddedSizesNextMultipleOf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mnkOrder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack a LinalgOp by greedily inferring matmul dimensions (m, n, k) where m and n are proper parallel dimensions and k is a proper reduction dimension. </p>
<p>Packing occurs by rewriting the op as a linalg.generic and calling <a class="el" href="#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg::pack</a> by <span class="tt">mnkPackedSizes</span>. The order of the packed dimensions is customizable: the <span class="tt">mnkOrder</span> is a permutation of {0, 1, 2} to reorder {m, n, k} into one of the 8 possible forms. The outer dimensions of the operands are not permuted at this time, this is left for future work. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00748">748</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01006">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00217">mlir::computePermutationVector()</a>, <a class="el" href="Generalization_8cpp_source.html#l00046">generalizeNamedOp()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00484">inferContractionDims()</a>, <a class="el" href="Interchange_8cpp_source.html#l00045">interchangeGenericOp()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00204">mlir::isPermutationVector()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00463">pack()</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00037">mlir::Range::size</a>.</p>

<p class="reference">Referenced by <a class="el" href="BlockPackMatmul_8cpp_source.html#l00138">blockPackMatmul()</a>.</p>

</div>
</div>
<a id="a26e3825819b0563bb199218baf11ca73" name="a26e3825819b0563bb199218baf11ca73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e3825819b0563bb199218baf11ca73">&#9670;&#160;</a></span>packTranspose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackTransposeResult.html">PackTransposeResult</a> &gt; mlir::linalg::packTranspose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::PackOp</td>          <td class="paramname"><span class="paramname"><em>packOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::UnPackOp</td>          <td class="paramname"><span class="paramname"><em>maybeUnPackOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>outerPerm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>innerPerm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose a single PackOp -&gt; LinalgOp -&gt; UnPackOp chain and return the transposed PackOp -&gt; LinalgOp -&gt; UnPackOp chain after replacements. </p>
<p>Return failure if either:</p><ol type="1">
<li>the <span class="tt">packOp</span> does not have the <span class="tt">linalgOp</span> as its unique use.</li>
<li>the <span class="tt">maybeUnPackOp</span>, if specified must be a consumer of the result tied to the unique <span class="tt">packOp</span> use.</li>
<li><span class="tt">outerPerm</span> (resp. <span class="tt">innerPerm</span>) must be valid permutations of <span class="tt">packOp.getOuterDimsPerm</span> (resp. <span class="tt">packOp.getInnerDimsPerm</span>) or empty. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00657">657</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00226">mlir::OpOperand::getOperandNumber()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00204">mlir::isPermutationVector()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00611">transposeOneLinalgOperandAndReplace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BlockPackMatmul_8cpp_source.html#l00089">transposePackedMatmul()</a>.</p>

</div>
</div>
<a id="aad04f1a354ddbbdec275dd9afd45bdce" name="aad04f1a354ddbbdec275dd9afd45bdce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad04f1a354ddbbdec275dd9afd45bdce">&#9670;&#160;</a></span>padAndHoistLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; LinalgOp &gt; mlir::linalg::padAndHoistLinalgOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply padding and hoisting to <span class="tt">linalgOp</span> according to the configuration specified in <span class="tt">options</span>. </p>

<p class="definition">Definition at line <a class="el" href="Padding_8cpp_source.html#l00355">355</a> of file <a class="el" href="Padding_8cpp_source.html">Padding.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00942">hoistPaddingOnTensors()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00338">mlir::linalg::LinalgPaddingOptions::None</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Padding_8cpp_source.html#l00244">rewriteAsPaddedOp()</a>.</p>

</div>
</div>
<a id="a8f2b11de8cf430259d6ed044bfd270dd" name="a8f2b11de8cf430259d6ed044bfd270dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2b11de8cf430259d6ed044bfd270dd">&#9670;&#160;</a></span>paddingIsNotNeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::linalg::paddingIsNotNeeded </td>
          <td>(</td>
          <td class="paramtype">PackOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the pack op does not need a padding value. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05570">5570</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

</div>
</div>
<a id="af003de5775138c2f4af68e820e46c856" name="af003de5775138c2f4af68e820e46c856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af003de5775138c2f4af68e820e46c856">&#9670;&#160;</a></span>parseIndexingMapsAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> &gt; mlir::linalg::parseIndexingMapsAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parser</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l03892">3892</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a7850fe0a2961f835384adb372758d58b">mlir::AsmParser::getCurrentLocation()</a>, <a class="el" href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a5f240da7e00c4072d9f268efe1179b1d">mlir::AsmParser::parseEqual()</a>, and <a class="el" href="classmlir_1_1AsmParser.html#a305f6334c61eb92a164bd865851f55f4">mlir::AsmParser::parseOptionalKeyword()</a>.</p>

</div>
</div>
<a id="a1ef94144fa6cebafabf150478f750ff9" name="a1ef94144fa6cebafabf150478f750ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef94144fa6cebafabf150478f750ff9">&#9670;&#160;</a></span>partitionLinalgOpWithShardedReduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::partitionLinalgOpWithShardedReduction </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>partitionedOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#a03c57ac3b7bfa817f644e03dcf9a5de2">Sharding</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operandShardings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#a03c57ac3b7bfa817f644e03dcf9a5de2">Sharding</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>resultShardings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt;</td>          <td class="paramname"><span class="paramname"><em>loopIteratorTypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="#aa3c699ae89529032fd3f3dc9ef8fe839">GridAxis</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>gridAxisAssignmentForLoopIterators</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>partitionMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>symbolTable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00204">204</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00188">createAllReduceForResultsWithoutPartialShardings()</a>, <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00172">createDestinationPassingStyleInitOperands()</a>, <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00100">getGrid()</a>, <a class="el" href="ShardingInterface_8cpp_source.html#l00625">mlir::shard::getReductionGridAxes()</a>, <a class="el" href="IRMapping_8h_source.html#l00072">mlir::IRMapping::lookup()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="ae273bd1d7e48f4503eefba4f1487fa56" name="ae273bd1d7e48f4503eefba4f1487fa56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae273bd1d7e48f4503eefba4f1487fa56">&#9670;&#160;</a></span>peelLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::peelLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to peel and canonicalize loop <span class="tt">op</span> and return the new result. </p>
<p>Also applies affine_min/max bounds simplification on the fly where relevant. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00053">53</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, and <a class="el" href="namespacemlir_1_1scf.html#a55e793e622ecb45a3c5ff79b66939191">mlir::scf::peelForLoopAndSimplifyBounds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00069">peelLoops()</a>.</p>

</div>
</div>
<a id="a5faa18744febf8ff36b38176ca04d8fc" name="a5faa18744febf8ff36b38176ca04d8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5faa18744febf8ff36b38176ca04d8fc">&#9670;&#160;</a></span>peelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::peelLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peel 'loops' and applies affine_min/max bounds simplification on the fly where relevant. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00069">69</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00053">peelLoop()</a>.</p>

</div>
</div>
<a id="a1bf177055be0ddc8558b82cfbf4f8df7" name="a1bf177055be0ddc8558b82cfbf4f8df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf177055be0ddc8558b82cfbf4f8df7">&#9670;&#160;</a></span>populateBlockPackMatmulPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateBlockPackMatmulPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a41903a6655e9be09920ce399e3e71865">ControlBlockPackMatmulFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>controlFn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to block pack Linalg matmul ops. </p>

<p class="definition">Definition at line <a class="el" href="BlockPackMatmul_8cpp_source.html#l00319">319</a> of file <a class="el" href="BlockPackMatmul_8cpp_source.html">BlockPackMatmul.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a18fce962e3d12d2dfc3b467076c71f39" name="a18fce962e3d12d2dfc3b467076c71f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18fce962e3d12d2dfc3b467076c71f39">&#9670;&#160;</a></span>populateBubbleUpExtractSliceOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateBubbleUpExtractSliceOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns that are used to bubble up extract slice op above linalg op. </p>

<p class="definition">Definition at line <a class="el" href="BubbleUpExtractSlice_8cpp_source.html#l00131">131</a> of file <a class="el" href="BubbleUpExtractSlice_8cpp_source.html">BubbleUpExtractSlice.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a8ef1d681922add4fcf065a64d713c3b5" name="a8ef1d681922add4fcf065a64d713c3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef1d681922add4fcf065a64d713c3b5">&#9670;&#160;</a></span>populateCollapseDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateCollapseDimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a56475069e4631a3e7e54964a3fc576bb">GetCollapsableDimensionsFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>controlCollapseDimensions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to collapse dimensions in a linalg.generic op. </p>
<p>This will collapse tensor operands when needed and expand back the result tensors. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l02462">2462</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ad0b142daa69f3f2b8986960b726ba2eb" name="ad0b142daa69f3f2b8986960b726ba2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b142daa69f3f2b8986960b726ba2eb">&#9670;&#160;</a></span>populateConstantFoldLinalgOperations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateConstantFoldLinalgOperations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a9f4136d97cdab12f0760756f1adc1721">ControlFusionFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>controlFn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to constant fold Linalg operations. </p>

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l00304">304</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a08373cf12e45f28268db4e84f038f6ca" name="a08373cf12e45f28268db4e84f038f6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08373cf12e45f28268db4e84f038f6ca">&#9670;&#160;</a></span>populateContractionOpRankReducingPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateContractionOpRankReducingPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds patterns that reduce the rank of named contraction ops that have unit dimensions in the operand(s) by converting to a sequence of <span class="tt">collapse_shape</span>, <span class="tt">&lt;corresponding linalg named op&gt;</span>, <span class="tt">expand_shape</span> (if on tensors). </p>
<p>For example a <span class="tt">linalg.batch_matmul</span> with unit batch size will convert to <span class="tt">linalg.matmul</span> and a <span class="tt">linalg.matvec</span> with with unit spatial dim in lhs will convert to a <span class="tt">linalg.dot</span>. </p>

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l01106">1106</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a1e349c4f7a13b98a31f89dec948c5533" name="a1e349c4f7a13b98a31f89dec948c5533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e349c4f7a13b98a31f89dec948c5533">&#9670;&#160;</a></span>populateConvertConv2DToImg2ColPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateConvertConv2DToImg2ColPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns to transform linalg.conv_2d_xxx operations into linalg.generic (for img2col packing) and linalg.matmul. </p>
<p>Note: currently limited to Tensor semantics only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0e2c1f265ce47a53398eab6e8f18b30c" title="Convert linalg.conv_2d_nhwc_hwcf into linalg.generic (for img2col packing) and linalg....">rewriteInIm2Col</a> <a class="el" href="AffineAnalysis_8cpp.html#a6bb1f7bcc7c517c4619adcfd36fa554d">for</a> more details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00741">741</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a68f8e903a075470f95fa853892083469" name="a68f8e903a075470f95fa853892083469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f8e903a075470f95fa853892083469">&#9670;&#160;</a></span>populateConvertToDestinationStylePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateConvertToDestinationStylePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that convert non-destination-style ops to destination style ops. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00615">615</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a891b8f2d145dcc3327ba55c7a49d44e4" name="a891b8f2d145dcc3327ba55c7a49d44e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891b8f2d145dcc3327ba55c7a49d44e4">&#9670;&#160;</a></span>populateConvolutionVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateConvolutionVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns for vectorizing low-D convolution ops. </p>
<p>This is a step in progressive lowering for convolution ops, it assume high-D convolution ops were decomposed previously. </p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a01a1d26266bdb81ec39619dde149ceda" name="a01a1d26266bdb81ec39619dde149ceda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a1d26266bdb81ec39619dde149ceda">&#9670;&#160;</a></span>populateDataLayoutPropagationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateDataLayoutPropagationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ac7e80c46fd448c104f6709b43c315755">ControlPropagationFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>controlPackUnPackPropagation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>PoisonPaddingOk</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to bubble up or down data layout ops across other operations. </p>
<p>The function also has an option to allow the patterns to propagate with poison padding if requested by the caller. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutPropagation_8cpp_source.html#l01609">1609</a> of file <a class="el" href="DataLayoutPropagation_8cpp_source.html">DataLayoutPropagation.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a887c3b461640ae2783747a1c89726203" name="a887c3b461640ae2783747a1c89726203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887c3b461640ae2783747a1c89726203">&#9670;&#160;</a></span>populateDecomposeConvolutionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateDecomposeConvolutionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linalg decompose convolutions patterns. </p>
<p>Populates patterns to decompose high-D convolution ops into low-D ones. This is a step in progressive lowering for convolution ops, afterwards we can vectorize the low-D convolution ops. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01650">1650</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="aad6f59ca20a1e8ce21c3c29916aec917" name="aad6f59ca20a1e8ce21c3c29916aec917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6f59ca20a1e8ce21c3c29916aec917">&#9670;&#160;</a></span>populateDecomposeLinalgOpsPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateDecomposeLinalgOpsPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>removeDeadArgsAndResults</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns for splitting a <span class="tt">LinalgOp</span> with multiple statements within its payload into multiple <span class="tt">GenericOp</span> that have a single statement. </p>
<p>The option <span class="tt">removeDeadArgsAndResults</span> adds patterns to remove dead arguments and results from the generated decomposed ops. This is default <span class="tt">true</span> since the core decomposition patterns relies on these clean up patterns. It is set to false only for testing purposes. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00384">384</a> of file <a class="el" href="DecomposeLinalgOps_8cpp_source.html">DecomposeLinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, and <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00431">populateEraseUnusedOperandsAndResultsPatterns()</a>.</p>

</div>
</div>
<a id="a96851c32371159549c91211e266f3f0e" name="a96851c32371159549c91211e266f3f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96851c32371159549c91211e266f3f0e">&#9670;&#160;</a></span>populateDecomposePackUnpackPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateDecomposePackUnpackPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns to decompose <a class="el" href="#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a> and linalg.unpack Ops into e.g. </p>
<p>tensor.pad, linalg.transpose, tensor.{insert|extract}_slice. Require all outer dims to be unit. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01671">1671</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ae93e7e4b8d10bb895e935d0b4799f3a9" name="ae93e7e4b8d10bb895e935d0b4799f3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93e7e4b8d10bb895e935d0b4799f3a9">&#9670;&#160;</a></span>populateDecomposePadPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateDecomposePadPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns to decompose tensor.pad into e.g. </p>
<p>tensor.empty, linalg.fill, tensor.insert_slice. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01676">1676</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a3a1d8a95a9bec4041581a35ce791a503" name="a3a1d8a95a9bec4041581a35ce791a503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1d8a95a9bec4041581a35ce791a503">&#9670;&#160;</a></span>populateDecomposeProjectedPermutationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateDecomposeProjectedPermutationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add patterns to make explicit broadcasts and transforms in the input operands of a genericOp. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeGenericByUnfoldingPermutation_8cpp_source.html#l00245">245</a> of file <a class="el" href="DecomposeGenericByUnfoldingPermutation_8cpp_source.html">DecomposeGenericByUnfoldingPermutation.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a88f5ef52c3bd7a0c67503bb7b5f97ae7" name="a88f5ef52c3bd7a0c67503bb7b5f97ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f5ef52c3bd7a0c67503bb7b5f97ae7">&#9670;&#160;</a></span>populateDecomposeWinogradOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateDecomposeWinogradOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to decompose Winograd operators. </p>

<p class="definition">Definition at line <a class="el" href="WinogradConv2D_8cpp_source.html#l01220">1220</a> of file <a class="el" href="WinogradConv2D_8cpp_source.html">WinogradConv2D.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="af537f75332b531f2f627083684c201e4" name="af537f75332b531f2f627083684c201e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af537f75332b531f2f627083684c201e4">&#9670;&#160;</a></span>populateElementwiseOpsFusionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateElementwiseOpsFusionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a9f4136d97cdab12f0760756f1adc1721">ControlFusionFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>controlElementwiseOpFusion</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns for fusing linalg operation on tensors. </p>
<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to fuse <span class="tt">linalg.generic</span> -&gt; <span class="tt">linalg.generic</span> operations when both operations are fusable elementwise operations. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l02451">2451</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, and <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00431">populateEraseUnusedOperandsAndResultsPatterns()</a>.</p>

</div>
</div>
<a id="a7a49133ef595966377878adc42196f47" name="a7a49133ef595966377878adc42196f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a49133ef595966377878adc42196f47">&#9670;&#160;</a></span>populateElementwiseToLinalgConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateElementwiseToLinalgConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that convert <span class="tt">ElementwiseMappable</span> ops to linalg parallel loops. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00155">155</a> of file <a class="el" href="ElementwiseToLinalg_8cpp_source.html">ElementwiseToLinalg.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="abe6e2c64c65b1a22b1794d731be0c612" name="abe6e2c64c65b1a22b1794d731be0c612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6e2c64c65b1a22b1794d731be0c612">&#9670;&#160;</a></span>populateEraseUnnecessaryInputsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateEraseUnnecessaryInputsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to promote inputs to outputs and remove unused inputs of <span class="tt">linalg.generic</span> ops. </p>

<p class="definition">Definition at line <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00438">438</a> of file <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html">EraseUnusedOperandsAndResults.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a9cbdbb9ec2d0ed200d6a679ffd803c7e" name="a9cbdbb9ec2d0ed200d6a679ffd803c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbdbb9ec2d0ed200d6a679ffd803c7e">&#9670;&#160;</a></span>populateEraseUnusedOperandsAndResultsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateEraseUnusedOperandsAndResultsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to remove dead operands and results of <span class="tt">linalg.generic</span> operations. </p>
<p>This is a pattern wrapper for <span class="tt">deduplicateOperandsAndRemoveDeadResults</span>. </p>

<p class="definition">Definition at line <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00431">431</a> of file <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html">EraseUnusedOperandsAndResults.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00384">populateDecomposeLinalgOpsPattern()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l02451">populateElementwiseOpsFusionPatterns()</a>.</p>

</div>
</div>
<a id="a170a7562074760f0aa1786f1d3d1db3b" name="a170a7562074760f0aa1786f1d3d1db3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170a7562074760f0aa1786f1d3d1db3b">&#9670;&#160;</a></span>populateExtractSliceSinkingPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateExtractSliceSinkingPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ac7e80c46fd448c104f6709b43c315755">ControlPropagationFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>controlPackUnPackPropagation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to sink extract slice across other operations. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutPropagation_8cpp_source.html#l01621">1621</a> of file <a class="el" href="DataLayoutPropagation_8cpp_source.html">DataLayoutPropagation.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="aeb6bcda20dbb76f4b453abfc31adcc98" name="aeb6bcda20dbb76f4b453abfc31adcc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6bcda20dbb76f4b453abfc31adcc98">&#9670;&#160;</a></span>populateFoldAddIntoDestPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateFoldAddIntoDestPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to replace <span class="tt">linalg.add</span> when destination passing on a contraction op suffices for achieving the sum. </p>

<p class="definition">Definition at line <a class="el" href="FoldAddIntoDest_8cpp_source.html#l00147">147</a> of file <a class="el" href="FoldAddIntoDest_8cpp_source.html">FoldAddIntoDest.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ab23b572eea62b16b1020bd964dc67d36" name="ab23b572eea62b16b1020bd964dc67d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23b572eea62b16b1020bd964dc67d36">&#9670;&#160;</a></span>populateFoldIntoPackAndUnpackPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateFoldIntoPackAndUnpackPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#abf9a441fc28af495ff61ceedd25694d2">ControlFoldIntoPackUnpackFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>controlFn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">patterns</span> with patterns that fold operations like <span class="tt">tensor.pad</span> and <span class="tt">tensor.extract_slice</span> into <span class="tt">tensor.pack</span> and <span class="tt">tensor.unpack</span> operations respectively. </p>

<p class="definition">Definition at line <a class="el" href="PackAndUnpackPatterns_8cpp_source.html#l00609">609</a> of file <a class="el" href="PackAndUnpackPatterns_8cpp_source.html">PackAndUnpackPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="aac248e317eae5124cbaad8bbb832a806" name="aac248e317eae5124cbaad8bbb832a806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac248e317eae5124cbaad8bbb832a806">&#9670;&#160;</a></span>populateFoldPackUnpackIntoTensorEmptyPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateFoldPackUnpackIntoTensorEmptyPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">patterns</span> with patterns that fold operations like <span class="tt"><a class="el" href="#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a></span> and <span class="tt">linalg.unpack</span> into <span class="tt">tensor.empty</span>. </p>

<p class="definition">Definition at line <a class="el" href="PackAndUnpackPatterns_8cpp_source.html#l00624">624</a> of file <a class="el" href="PackAndUnpackPatterns_8cpp_source.html">PackAndUnpackPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a3c8bdabd42dfb2f3617cc87eccfa4199" name="a3c8bdabd42dfb2f3617cc87eccfa4199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8bdabd42dfb2f3617cc87eccfa4199">&#9670;&#160;</a></span>populateFoldReshapeOpsByCollapsingPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateFoldReshapeOpsByCollapsingPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a9f4136d97cdab12f0760756f1adc1721">ControlFusionFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>controlFoldingReshapes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold an expanding tensor.expand_shape operation with its producer generic operation by collapsing the dimensions of the generic op. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l02438">2438</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ac73f0e4d33b9691f06d722f2146c4a66" name="ac73f0e4d33b9691f06d722f2146c4a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73f0e4d33b9691f06d722f2146c4a66">&#9670;&#160;</a></span>populateFoldReshapeOpsByExpansionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateFoldReshapeOpsByExpansionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a9f4136d97cdab12f0760756f1adc1721">ControlFusionFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>controlFoldingReshapes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold an expanding (collapsing) tensor_reshape operation with its producer (consumer) generic operation by expanding the dimensionality of the loop in the generic op. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l02425">2425</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a7134894ce50357a7e8fefe7c379acac7" name="a7134894ce50357a7e8fefe7c379acac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7134894ce50357a7e8fefe7c379acac7">&#9670;&#160;</a></span>populateFoldUnitExtentDimsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateFoldUnitExtentDimsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">linalg::ControlDropUnitDims</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold unit-extent dimensions in operands/results of linalg ops on tensors via reassociative reshape ops. </p>

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00836">836</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00522">mlir::linalg::ControlDropUnitDims::ExtractInsertSlice</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00803">populateFoldUnitExtentDimsViaReshapesPatterns()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00823">populateFoldUnitExtentDimsViaSlicesPatterns()</a>.</p>

</div>
</div>
<a id="a0e0b4c454598e4be0bd0fcde89783a20" name="a0e0b4c454598e4be0bd0fcde89783a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0b4c454598e4be0bd0fcde89783a20">&#9670;&#160;</a></span>populateFuseTensorPadWithProducerLinalgOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateFuseTensorPadWithProducerLinalgOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to fuse a <span class="tt">tensor.pad</span> operation with the producer of its source, if the producer is a <span class="tt">linalg</span> operation with all parallel iterator types. </p>

<p class="definition">Definition at line <a class="el" href="FusePadOpWithLinalgProducer_8cpp_source.html#l00120">120</a> of file <a class="el" href="FusePadOpWithLinalgProducer_8cpp_source.html">FusePadOpWithLinalgProducer.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="acc64a8c8a9ecf3de84383893d8e4ddc2" name="acc64a8c8a9ecf3de84383893d8e4ddc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc64a8c8a9ecf3de84383893d8e4ddc2">&#9670;&#160;</a></span>populateInlineConstantOperandsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateInlineConstantOperandsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns that are used to inline constant operands into linalg generic ops. </p>

<p class="definition">Definition at line <a class="el" href="InlineScalarOperands_8cpp_source.html#l00098">98</a> of file <a class="el" href="InlineScalarOperands_8cpp_source.html">InlineScalarOperands.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a479c320b2d7a71b7d9c50d04047eba8f" name="a479c320b2d7a71b7d9c50d04047eba8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479c320b2d7a71b7d9c50d04047eba8f">&#9670;&#160;</a></span>populateLinalgFoldIntoElementwisePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgFoldIntoElementwisePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">patterns</span> with patterns that fold operations like <span class="tt">linalg.transform</span> into elementwise op map. </p>

<p class="definition">Definition at line <a class="el" href="FoldIntoElementwise_8cpp_source.html#l00084">84</a> of file <a class="el" href="FoldIntoElementwise_8cpp_source.html">FoldIntoElementwise.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="adc9ad663f56317f953958cb9434bd8fc" name="adc9ad663f56317f953958cb9434bd8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9ad663f56317f953958cb9434bd8fc">&#9670;&#160;</a></span>populateLinalgGenericOpsSpecializationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgGenericOpsSpecializationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">patterns</span> with patterns to convert linalg.generic ops to named ops where possible. </p>
<p>A linalg.generic can represent wide range and complex computations for which equivalent linalg named op may not exist e.g. linalg.generic that takes a tensor and computes a polynomial such as: p(x) = an*x^n + ... + a1x + a0 There is no equivalent named op to convert to. Many such cases exist. </p>

<p class="definition">Definition at line <a class="el" href="Specialize_8cpp_source.html#l00425">425</a> of file <a class="el" href="Specialize_8cpp_source.html">Specialize.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ada9bb5c9c8ef1aadbbc563431443b5e2" name="ada9bb5c9c8ef1aadbbc563431443b5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9bb5c9c8ef1aadbbc563431443b5e2">&#9670;&#160;</a></span>populateLinalgNamedOpsGeneralizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgNamedOpsGeneralizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linalg generalization patterns. </p>
<p>Populates <span class="tt">patterns</span> with patterns to convert spec-generated named ops to linalg.generic ops. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00089">89</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ae12537adb2614537d3d6d5db2612629f" name="ae12537adb2614537d3d6d5db2612629f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12537adb2614537d3d6d5db2612629f">&#9670;&#160;</a></span>populateLinalgNamedToElementwisePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgNamedToElementwisePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">patterns</span> that convert linalg named ops e.g. </p>
<p><span class="tt">linalg.add</span> to equivalent <span class="tt">linalg.elementwise</span>. </p>

<p class="definition">Definition at line <a class="el" href="NamedToElementwise_8cpp_source.html#l00073">73</a> of file <a class="el" href="NamedToElementwise_8cpp_source.html">NamedToElementwise.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a4701ad0fa2e34da0089a80135935f02e" name="a4701ad0fa2e34da0089a80135935f02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4701ad0fa2e34da0089a80135935f02e">&#9670;&#160;</a></span>populateLinalgTilingCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgTilingCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00856">856</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00850">getLinalgTilingCanonicalizationPatterns()</a>.</p>

</div>
</div>
<a id="a703d4f21c6f57b8c680dc20dd6928a61" name="a703d4f21c6f57b8c680dc20dd6928a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703d4f21c6f57b8c680dc20dd6928a61">&#9670;&#160;</a></span>populateLinalgToStandardConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgToStandardConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Linalg to Standard. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToStandard_8cpp_source.html#l00126">126</a> of file <a class="el" href="LinalgToStandard_8cpp_source.html">LinalgToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a042bb54cd9155ed1ca8818a16ab5110a" name="a042bb54cd9155ed1ca8818a16ab5110a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042bb54cd9155ed1ca8818a16ab5110a">&#9670;&#160;</a></span>populateMoveInitOperandsToInputPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateMoveInitOperandsToInputPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pattern that converts init operands to input operands. </p>

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00848">848</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a43c2ef8a778a33a17885475c11b50bdd" name="a43c2ef8a778a33a17885475c11b50bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c2ef8a778a33a17885475c11b50bdd">&#9670;&#160;</a></span>populatePadOpVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populatePadOpVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>baseBenefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">patterns</span> with patterns that vectorize tensor.pad. </p>
<p>These patterns are meant to apply in a complementary fashion. Benefits are used to encode a certain ordering of pattern application. To avoid scattering magic constants throughout the code base, the patterns must be added with this function. <span class="tt">baseBenefit</span> can be used to offset the benefit of all tensor::PadOp vectorization patterns by a certain value. </p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a588c1b33d58eb56f528112cfef47bffb" name="a588c1b33d58eb56f528112cfef47bffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588c1b33d58eb56f528112cfef47bffb">&#9670;&#160;</a></span>populateSimplifyDepthwiseConvPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateSimplifyDepthwiseConvPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to simplify depthwise convolutions. </p>

<p class="definition">Definition at line <a class="el" href="SimplifyDepthwiseConv_8cpp_source.html#l00161">161</a> of file <a class="el" href="SimplifyDepthwiseConv_8cpp_source.html">SimplifyDepthwiseConv.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="aab3e6438bd84e7e76e5352c0c54fb5b7" name="aab3e6438bd84e7e76e5352c0c54fb5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3e6438bd84e7e76e5352c0c54fb5b7">&#9670;&#160;</a></span>populateSimplifyPackAndUnpackPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateSimplifyPackAndUnpackPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">patterns</span> with patterns that simplify <span class="tt">tensor.pack</span> and <span class="tt">tensor.unpack</span> operations. </p>

<p class="definition">Definition at line <a class="el" href="PackAndUnpackPatterns_8cpp_source.html#l00619">619</a> of file <a class="el" href="PackAndUnpackPatterns_8cpp_source.html">PackAndUnpackPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a49366865f5ce183ae19888eceb6667e5" name="a49366865f5ce183ae19888eceb6667e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49366865f5ce183ae19888eceb6667e5">&#9670;&#160;</a></span>populateSparseTensorRewriting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateSparseTensorRewriting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that are only useful in the context of sparse tensors. </p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a0c26bb1f203c97b9d5bcf9b8ae6ea102" name="a0c26bb1f203c97b9d5bcf9b8ae6ea102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c26bb1f203c97b9d5bcf9b8ae6ea102">&#9670;&#160;</a></span>populateSplitReductionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateSplitReductionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a505f71c7a182531357360cb2151dc1f3">ControlSplitReductionFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>controlSplitReductionFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useAlloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to apply <span class="tt">splitReduction</span> below. </p>

<p class="definition">Definition at line <a class="el" href="SplitReduction_8cpp_source.html#l00448">448</a> of file <a class="el" href="SplitReduction_8cpp_source.html">SplitReduction.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ac8003a713f74f7a32cc681c245ae9708" name="ac8003a713f74f7a32cc681c245ae9708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8003a713f74f7a32cc681c245ae9708">&#9670;&#160;</a></span>populateSwapExtractSliceWithFillPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateSwapExtractSliceWithFillPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds patterns that waps tensor.extract_slice(linalg.fill(cst, init)) into linalg.fill(cst, tensor.extract_slice(init)). </p>

<p class="definition">Definition at line <a class="el" href="SwapExtractSliceWithFillPatterns_8cpp_source.html#l00042">42</a> of file <a class="el" href="SwapExtractSliceWithFillPatterns_8cpp_source.html">SwapExtractSliceWithFillPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a90bd97b279b588f6e57a048d72a69a9c" name="a90bd97b279b588f6e57a048d72a69a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bd97b279b588f6e57a048d72a69a9c">&#9670;&#160;</a></span>populateTransposeConv2DPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateTransposeConv2DPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TransposeConv2D_8cpp_source.html#l00134">134</a> of file <a class="el" href="TransposeConv2D_8cpp_source.html">TransposeConv2D.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a0786aed514452424d437b02ff9816dce" name="a0786aed514452424d437b02ff9816dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0786aed514452424d437b02ff9816dce">&#9670;&#160;</a></span>populateTransposeMatmulPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateTransposeMatmulPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>transposeLHS</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to convert Linalg matmul ops to transposed variants. </p>

<p class="definition">Definition at line <a class="el" href="TransposeMatmul_8cpp_source.html#l00168">168</a> of file <a class="el" href="TransposeMatmul_8cpp_source.html">TransposeMatmul.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a4a5263d91b36edf98bda8c609f486214" name="a4a5263d91b36edf98bda8c609f486214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5263d91b36edf98bda8c609f486214">&#9670;&#160;</a></span>populateWinogradConv2DPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateWinogradConv2DPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WinogradConv2DFmr</td>          <td class="paramname"><span class="paramname"><em>fmr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to apply Winograd Conv2D algorithm F(m x m, r x r). </p>

<p class="definition">Definition at line <a class="el" href="WinogradConv2D_8cpp_source.html#l01213">1213</a> of file <a class="el" href="WinogradConv2D_8cpp_source.html">WinogradConv2D.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a4ed54a24fbd0044060290027188db5c0" name="a4ed54a24fbd0044060290027188db5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed54a24fbd0044060290027188db5c0">&#9670;&#160;</a></span>promoteSubviewAsNewBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a> &gt; mlir::linalg::promoteSubviewAsNewBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::SubViewOp</td>          <td class="paramname"><span class="paramname"><em>subView</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useOriginalSubviewSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a9ada278f74ee670af18b6bfd04271e3b">AllocBufferCallbackFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>allocationFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>layout</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00237">237</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00629">mlir::ValueBoundsConstraintSet::computeConstantBound()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, and <a class="el" href="IntegerRelation_8h_source.html#l00044">mlir::presburger::UB</a>.</p>

<p class="reference">Referenced by <a class="el" href="Promotion_8cpp_source.html#l00288">promoteSubViews()</a>.</p>

</div>
</div>
<a id="acd639dc165f0ab64ec7afbac992c4d65" name="acd639dc165f0ab64ec7afbac992c4d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd639dc165f0ab64ec7afbac992c4d65">&#9670;&#160;</a></span>promoteSubViews()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; LinalgOp &gt; mlir::linalg::promoteSubViews </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote the <span class="tt">subViews</span> into a new buffer allocated at the insertion point <span class="tt">b</span>. </p>
<p>Promotion occurs in 3 steps:</p><ol type="1">
<li>Create a new buffer for a full tile (i.e. not clipped at the boundary).</li>
<li>Take a full view on the buffer.</li>
<li>Take a partial slice of the full view in step 2. and copy into it.</li>
</ol>
<p>Return the modified linalg op (the modification happens in place) as well as all the copy ops created. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00422">422</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00509">mlir::DataLayout::closest()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="Promotion_8cpp_source.html#l00422">promoteSubViews()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Promotion_8cpp_source.html#l00422">promoteSubViews()</a>, and <a class="el" href="Promotion_8cpp_source.html#l00347">promoteSubViews()</a>.</p>

</div>
</div>
<a id="a850b9fd11404efe17bca02011aff2e88" name="a850b9fd11404efe17bca02011aff2e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850b9fd11404efe17bca02011aff2e88">&#9670;&#160;</a></span>promoteSubviewsPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::promoteSubviewsPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote memref.subviews feeding linalg-on-buffers operations. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00400">400</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a688a83ed3c19e68f4acfed8486771451" name="a688a83ed3c19e68f4acfed8486771451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688a83ed3c19e68f4acfed8486771451">&#9670;&#160;</a></span>registerAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... OpTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::registerAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variadic helper function. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00327">327</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00321">registerOne()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00331">registerShardingInterfaceExternalModels()</a>, and <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l01431">registerTilingInterfaceExternalModels()</a>.</p>

</div>
</div>
<a id="a0ae5e64320c923f94446d6b60153fee4" name="a0ae5e64320c923f94446d6b60153fee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae5e64320c923f94446d6b60153fee4">&#9670;&#160;</a></span>registerAllDialectInterfaceImplementations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::registerAllDialectInterfaceImplementations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AllInterfaces_8cpp_source.html#l00017">17</a> of file <a class="el" href="AllInterfaces_8cpp_source.html">AllInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Linalg_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00196">registerBufferizableOpInterfaceExternalModels()</a>, <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00331">registerShardingInterfaceExternalModels()</a>, <a class="el" href="Linalg_2Transforms_2SubsetInsertionOpInterfaceImpl_8cpp_source.html#l00072">registerSubsetOpInterfaceExternalModels()</a>, <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l01431">registerTilingInterfaceExternalModels()</a>, and <a class="el" href="Linalg_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00054">registerValueBoundsOpInterfaceExternalModels()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ab570ed1db81a641eb5b3d9948775e517" name="ab570ed1db81a641eb5b3d9948775e517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab570ed1db81a641eb5b3d9948775e517">&#9670;&#160;</a></span>registerBufferizableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::registerBufferizableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00196">196</a> of file <a class="el" href="Linalg_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html">BufferizableOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AllInterfaces_8cpp_source.html#l00017">registerAllDialectInterfaceImplementations()</a>.</p>

</div>
</div>
<a id="a645065016a10ad2397796861ba5b8c3e" name="a645065016a10ad2397796861ba5b8c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645065016a10ad2397796861ba5b8c3e">&#9670;&#160;</a></span>registerOne()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::registerOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00321">321</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00327">registerAll()</a>, <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l01425">registerAll()</a>, <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00331">registerShardingInterfaceExternalModels()</a>, and <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l01431">registerTilingInterfaceExternalModels()</a>.</p>

</div>
</div>
<a id="a34d52ce7a6266192f3f98587b7c6575b" name="a34d52ce7a6266192f3f98587b7c6575b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d52ce7a6266192f3f98587b7c6575b">&#9670;&#160;</a></span>registerRuntimeVerifiableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::registerRuntimeVerifiableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2RuntimeOpVerification_8cpp_source.html#l00153">153</a> of file <a class="el" href="Linalg_2Transforms_2RuntimeOpVerification_8cpp_source.html">RuntimeOpVerification.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="MLIRContext_8h_source.html#l00110">mlir::MLIRContext::loadDialect()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ac6ef5d2a9e63222d223b416027377828" name="ac6ef5d2a9e63222d223b416027377828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ef5d2a9e63222d223b416027377828">&#9670;&#160;</a></span>registerShardingInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::registerShardingInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00331">331</a> of file <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html">ShardingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00416">mlir::MLIRContext::appendDialectRegistry()</a>, <a class="el" href="DialectRegistry_8h_source.html#l00200">mlir::DialectRegistry::getDialectNames()</a>, <a class="el" href="MLIRContext_8h_source.html#l00100">mlir::MLIRContext::getOrLoadDialect()</a>, <a class="el" href="DialectRegistry_8h_source.html#l00152">mlir::DialectRegistry::insert()</a>, <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00327">registerAll()</a>, and <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00321">registerOne()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AllInterfaces_8cpp_source.html#l00017">registerAllDialectInterfaceImplementations()</a>.</p>

</div>
</div>
<a id="ac973b30789682417b95981a6ea093fb3" name="ac973b30789682417b95981a6ea093fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac973b30789682417b95981a6ea093fb3">&#9670;&#160;</a></span>registerSubsetOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::registerSubsetOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2SubsetInsertionOpInterfaceImpl_8cpp_source.html#l00072">72</a> of file <a class="el" href="Linalg_2Transforms_2SubsetInsertionOpInterfaceImpl_8cpp_source.html">SubsetInsertionOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AllInterfaces_8cpp_source.html#l00017">registerAllDialectInterfaceImplementations()</a>.</p>

</div>
</div>
<a id="ae430d8314310084f3bfae3c0de4081dd" name="ae430d8314310084f3bfae3c0de4081dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae430d8314310084f3bfae3c0de4081dd">&#9670;&#160;</a></span>registerTilingInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::registerTilingInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l01431">1431</a> of file <a class="el" href="TilingInterfaceImpl_8cpp_source.html">TilingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00327">registerAll()</a>, and <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00321">registerOne()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AllInterfaces_8cpp_source.html#l00017">registerAllDialectInterfaceImplementations()</a>.</p>

</div>
</div>
<a id="a61ea527040089116cd00f5fec9802ad8" name="a61ea527040089116cd00f5fec9802ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ea527040089116cd00f5fec9802ad8">&#9670;&#160;</a></span>registerTilingInterfaceExternalModelsForPackUnPackOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::registerTilingInterfaceExternalModelsForPackUnPackOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the above registeration, but it is only for <span class="tt">tensor.pack</span> and <span class="tt">tensor.unpack</span> ops. </p>

<p class="definition">Definition at line <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l01443">1443</a> of file <a class="el" href="TilingInterfaceImpl_8cpp_source.html">TilingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

</div>
</div>
<a id="ae64270d2058ef5fd99281df6e7de4464" name="ae64270d2058ef5fd99281df6e7de4464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64270d2058ef5fd99281df6e7de4464">&#9670;&#160;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::nvgpu::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectExtension_8cpp_source.html#l00058">58</a> of file <a class="el" href="DialectExtension_8cpp_source.html">DialectExtension.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00222">mlir::DialectRegistry::addExtensions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a5e756b2e152d167af6823f8fb6298933" name="a5e756b2e152d167af6823f8fb6298933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e756b2e152d167af6823f8fb6298933">&#9670;&#160;</a></span>registerValueBoundsOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::registerValueBoundsOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00054">54</a> of file <a class="el" href="Linalg_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AllInterfaces_8cpp_source.html#l00017">registerAllDialectInterfaceImplementations()</a>.</p>

</div>
</div>
<a id="a0369f798f7a1803f0c897c0f33edb5e5" name="a0369f798f7a1803f0c897c0f33edb5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0369f798f7a1803f0c897c0f33edb5e5">&#9670;&#160;</a></span>reifyResultShapesImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::reifyResultShapesImpl </td>
          <td>(</td>
          <td class="paramtype">OpTy</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a676bc3fbf14bd5dba33f962b259d2034">ReifiedRankedShapedTypeDims</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reifiedReturnShapes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l05021">5021</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00066">mlir::tensor::getMixedSizes()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a402b2b94588021b9d4c088f351c35c69" name="a402b2b94588021b9d4c088f351c35c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402b2b94588021b9d4c088f351c35c69">&#9670;&#160;</a></span>rewriteAsPaddedOp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceResult.html">PadTilingInterfaceResult</a> &gt; mlir::linalg::rewriteAsPaddedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface</td>          <td class="paramname"><span class="paramname"><em>toPad</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a1f5ce0fcb27f388f81435ec80109e7c6">PadSizeComputationFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>computePaddingSizeFun</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&amp;<a class="el" href="#aa357f78e61caac5bae1dad723393734a">computeIndexingMapOpInterfacePaddedShape</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pad the iterator dimensions of <span class="tt">toPad</span>. </p>
<ul>
<li>"options.paddingSizes" indicates that each padding dimension should be padded to the specified padding size.</li>
<li>"options.padToMultipleOf" indicates that the paddingSizes should be</li>
<li>Use "options.paddingValues" to set the padding value of the created </li>
</ul>

<p class="definition">Definition at line <a class="el" href="PadTilingInterface_8cpp_source.html#l00266">266</a> of file <a class="el" href="PadTilingInterface_8cpp_source.html">PadTilingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00197">mlir::clone()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00032">DBGS</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00023">mlir::getElementTypeOrSelf()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="Builders_8cpp_source.html#l00324">mlir::Builder::getZeroAttr()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00227">padOperand()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00027">mlir::reifyResultShapes()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02103">ValueRange</a>.</p>

</div>
</div>
<a id="a08d1dafbd1447fdcbad0e11434292563" name="a08d1dafbd1447fdcbad0e11434292563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d1dafbd1447fdcbad0e11434292563">&#9670;&#160;</a></span>rewriteAsPaddedOp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::rewriteAsPaddedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>opToPad</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp &amp;</td>          <td class="paramname"><span class="paramname"><em>paddedOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>replacements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; tensor::PadOp &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>padOps</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pad the iterator dimensions <span class="tt">options.paddingDimensions</span> of all <span class="tt">opToPad</span> operands to a static bounding box. </p>
<p>The original <span class="tt">opToPad</span> is cloned and operates on the padded tensors.</p>
<ul>
<li>"options.padToMultipleOf" indicates that each padding dimension should be padded to the specified multiple.</li>
<li>Use "options.paddingValues" and "options.nofoldFlags" to set padding value and nofold attribute of the created tensor::PadOps, respectively.</li>
<li>The unpadded results (extracted slice of the cloned operation) are returned via <span class="tt">replacements</span>.</li>
<li>The tensor::PadOps are returned via <span class="tt">padOps</span>.</li>
<li>"options.copyBackOp" specifies the op type for copying back the unpadded result to the original destination tensor. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Padding_8cpp_source.html#l00244">244</a> of file <a class="el" href="Padding_8cpp_source.html">Padding.cpp</a>.</p>

<p class="reference">References <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00197">mlir::clone()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00032">DBGS</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00023">mlir::getElementTypeOrSelf()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="Builders_8cpp_source.html#l00324">mlir::Builder::getZeroAttr()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00340">mlir::linalg::LinalgPaddingOptions::LinalgCopy</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00338">mlir::linalg::LinalgPaddingOptions::None</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="Padding_8cpp_source.html#l00187">padOperandToSmallestStaticBoundingBox()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00027">mlir::reifyResultShapes()</a>, <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointAfter()</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02103">ValueRange</a>.</p>

<p class="reference">Referenced by <a class="el" href="Padding_8cpp_source.html#l00355">padAndHoistLinalgOp()</a>.</p>

</div>
</div>
<a id="a5a579fdd0e468c7aec96f84d016c829e" name="a5a579fdd0e468c7aec96f84d016c829e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a579fdd0e468c7aec96f84d016c829e">&#9670;&#160;</a></span>rewriteInDestinationPassingStyle() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::rewriteInDestinationPassingStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::FromElementsOp</td>          <td class="paramname"><span class="paramname"><em>fromElementsOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite tensor.from_elements to linalg.generic. </p>
<p>Lower tensor.from_elements to a sequence of chained tensor.insert. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00350">350</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00032">createInserts()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00529">mlir::RewriterBase::replaceOpWithNewOp()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02103">ValueRange</a>.</p>

</div>
</div>
<a id="ab2e500c4bf906d65572af9b3d2982852" name="ab2e500c4bf906d65572af9b3d2982852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e500c4bf906d65572af9b3d2982852">&#9670;&#160;</a></span>rewriteInDestinationPassingStyle() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::rewriteInDestinationPassingStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::GenerateOp</td>          <td class="paramname"><span class="paramname"><em>generateOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite tensor.generate to linalg.generic. </p>
<p>Lower tensor.generate to linalg.generic. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00388">388</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00430">mlir::OpBuilder::createBlock()</a>, <a class="el" href="Builders_8cpp_source.html#l00387">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00343">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00529">mlir::RewriterBase::replaceOpWithNewOp()</a>, <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02103">ValueRange</a>.</p>

</div>
</div>
<a id="acf3e743297fd7a20a30c7c4e39608fbc" name="acf3e743297fd7a20a30c7c4e39608fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3e743297fd7a20a30c7c4e39608fbc">&#9670;&#160;</a></span>rewriteInDestinationPassingStyle() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::rewriteInDestinationPassingStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp</td>          <td class="paramname"><span class="paramname"><em>padOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite tensor.pad to linalg.generic + tensor.insert_slice. </p>
<p>Lower tensor.pad to linalg.generic + tensor.insert_slice. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00429">429</a> of file <a class="el" href="ConvertToDestinationStyle_8cpp_source.html">ConvertToDestinationStyle.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00066">mlir::tensor::getMixedSizes()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">mlir::isZeroInteger()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00093">movePaddingToFillOrGenericOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00027">mlir::reifyResultShapes()</a>, <a class="el" href="PatternMatch_8h_source.html#l00529">mlir::RewriterBase::replaceOpWithNewOp()</a>, and <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

</div>
</div>
<a id="ad43dfb86d76bed86ecd1117849e5b6f4" name="ad43dfb86d76bed86ecd1117849e5b6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43dfb86d76bed86ecd1117849e5b6f4">&#9670;&#160;</a></span>rewriteInIm2Col() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt; mlir::linalg::rewriteInIm2Col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::Conv2DNchwFchwOp</td>          <td class="paramname"><span class="paramname"><em>convOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to rewriteInIm2Col with linalg::Conv2DNhwcHwcfOp except because the channels are to the left of the image shape dimensions, the position of the contraction dimension in the resulting matmul is reversed. </p>
<p>This swaps the LHS and RHS of the matmul when compared with nhwc (i.e. (D, C x Kh x Kw) * (C x Kh x Kw, Ho x Wo)) </p>

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00416">416</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="XeGPUDialect_8cpp_source.html#l00976">add</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00081">mlir::linalg::Im2ColToInputDimsExprs::bIndex</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00084">mlir::linalg::Im2ColToInputDimsExprs::cIndex</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00033">createAdd()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00041">createMul()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00097">mlir::delinearize()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00071">mlir::linalg::Im2ColToOperandsExprs::fhIndex</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00072">mlir::linalg::Im2ColToOperandsExprs::fwIndex</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00364">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00097">getIm2ColInputExpressions()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00028">hasAllOneValues()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00082">mlir::linalg::Im2ColToInputDimsExprs::hIndex</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00073">mlir::linalg::Im2ColToOperandsExprs::icIndex</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">mlir::AffineMap::inferFromExprList()</a>, <a class="el" href="XeGPUDialect_8cpp_source.html#l00972">mul</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00074">mlir::linalg::Im2ColToOperandsExprs::ohIndex</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00075">mlir::linalg::Im2ColToOperandsExprs::owIndex</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00083">mlir::linalg::Im2ColToInputDimsExprs::wIndex</a>.</p>

</div>
</div>
<a id="a7efbd1a00187259d6074a842842175c2" name="a7efbd1a00187259d6074a842842175c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7efbd1a00187259d6074a842842175c2">&#9670;&#160;</a></span>rewriteInIm2Col() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt; mlir::linalg::rewriteInIm2Col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::Conv2DNhwcFhwcOp</td>          <td class="paramname"><span class="paramname"><em>convOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as the above but for Fhwc channel orderings in the filter. </p>
<p>In this case the matrix multiplication is actually a row-wise dot-product rather than a row-column dot-product. This is to avoid transposing the filter matrix which would be required for a regular matrix multiplication to produce the correct output dimensions. </p>

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00550">550</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="XeGPUDialect_8cpp_source.html#l00976">add</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00081">mlir::linalg::Im2ColToInputDimsExprs::bIndex</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00084">mlir::linalg::Im2ColToInputDimsExprs::cIndex</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00033">createAdd()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00041">createMul()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00097">mlir::delinearize()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00071">mlir::linalg::Im2ColToOperandsExprs::fhIndex</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00072">mlir::linalg::Im2ColToOperandsExprs::fwIndex</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00364">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00097">getIm2ColInputExpressions()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00028">hasAllOneValues()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00082">mlir::linalg::Im2ColToInputDimsExprs::hIndex</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00073">mlir::linalg::Im2ColToOperandsExprs::icIndex</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">mlir::AffineMap::inferFromExprList()</a>, <a class="el" href="XeGPUDialect_8cpp_source.html#l00972">mul</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00074">mlir::linalg::Im2ColToOperandsExprs::ohIndex</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00075">mlir::linalg::Im2ColToOperandsExprs::owIndex</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00083">mlir::linalg::Im2ColToInputDimsExprs::wIndex</a>.</p>

</div>
</div>
<a id="a0e2c1f265ce47a53398eab6e8f18b30c" name="a0e2c1f265ce47a53398eab6e8f18b30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2c1f265ce47a53398eab6e8f18b30c">&#9670;&#160;</a></span>rewriteInIm2Col() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt; mlir::linalg::rewriteInIm2Col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::Conv2DNhwcHwcfOp</td>          <td class="paramname"><span class="paramname"><em>convOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert linalg.conv_2d_nhwc_hwcf into linalg.generic (for img2col packing) and linalg.matmul. </p>
<p>A convolution operation can be written as a matrix-matrix multiplication by unfolding the cross-correlation between input and filter and explicitly copy overlapped sliding window inputs.</p>
<p>Consider 2D input X with single channel input and output and 2x2 filter W: [x(0, 0) , x(0, 1) , ..., x(0, n) ] [x(1, 0) , x(1, 1) , ..., x(1, n) ] [. , . ,. , . ] [w(0, 0), w(0, 1)] [. , . , . , . ] (conv) [w(1, 0), w(1, 1)] [. , . , ., . ] [x(n-1, 0), x(n-1, 1), ..., x(n-1, n-1)]</p>
<p>The packed input data (img2col) is a matrix with |rows| = output spatial size, |columns| = filter spatial size. To compute the output Y(i, j) we need to calculate the dot product between filter window at input X(x, y)) and the filter which will look like the following where r.h.s is the img2col matrix and l.h.s is the flattened filter:</p>
<p>[x(0,0), x(0,1), x(1,0), x(1,1)] [x(0,1), x(1,1), x(0,2), x(1,2)] (matmul) [w(0,0), w(0,1), w(1,0), w(1,1)] [x(0,1), x(1,1), x(0,2), x(1,2)] [ . , . , . , . ]</p>
<p>In general for 2D case with (N, H, W, C) input and (Kh, Kw, C, D) filter and output (N, Ho, Wo, D) the convolution is the following matrix-matrix multiplication (Ho x Wo, Kh x Kw x C) * (Kh x Kw x C, D) for each input in the N input. For the case where N &gt; 1 its a batched matrix-matrix multiplication.</p>
<p>On success, return both the operation that produces the img2col tensor and the final operation of the sequence that replaces the original convolution. </p>

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00123">123</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="XeGPUDialect_8cpp_source.html#l00976">add</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00081">mlir::linalg::Im2ColToInputDimsExprs::bIndex</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00084">mlir::linalg::Im2ColToInputDimsExprs::cIndex</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00033">createAdd()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00041">createMul()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00097">mlir::delinearize()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00071">mlir::linalg::Im2ColToOperandsExprs::fhIndex</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00072">mlir::linalg::Im2ColToOperandsExprs::fwIndex</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00364">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00097">getIm2ColInputExpressions()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00028">hasAllOneValues()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00082">mlir::linalg::Im2ColToInputDimsExprs::hIndex</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00073">mlir::linalg::Im2ColToOperandsExprs::icIndex</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">mlir::AffineMap::inferFromExprList()</a>, <a class="el" href="XeGPUDialect_8cpp_source.html#l00972">mul</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00074">mlir::linalg::Im2ColToOperandsExprs::ohIndex</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00075">mlir::linalg::Im2ColToOperandsExprs::owIndex</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00083">mlir::linalg::Im2ColToInputDimsExprs::wIndex</a>.</p>

</div>
</div>
<a id="a49f61511bb9ed963c3eeb360bfdb1a6a" name="a49f61511bb9ed963c3eeb360bfdb1a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f61511bb9ed963c3eeb360bfdb1a6a">&#9670;&#160;</a></span>rewriteInIm2Col() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt; mlir::linalg::rewriteInIm2Col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::DepthwiseConv2DNhwcHwcOp</td>          <td class="paramname"><span class="paramname"><em>convOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to rewriteInIm2Col with linalg::Conv2DNhwcHwcfOp except there is no reduction among the input channels so each convolution can be a matrix-vector product and by transposing both input filter so channels are outer most the computation is a batched matrix-vector product. </p>

<p class="definition">Definition at line <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00260">260</a> of file <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html">ConvertConv2DToImg2Col.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00372">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00364">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00028">hasAllOneValues()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>.</p>

</div>
</div>
<a id="a3be344205769eaea42d412b4c0fae11a" name="a3be344205769eaea42d412b4c0fae11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be344205769eaea42d412b4c0fae11a">&#9670;&#160;</a></span>specializeGenericOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; LinalgOp &gt; mlir::linalg::specializeGenericOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GenericOp</td>          <td class="paramname"><span class="paramname"><em>genericOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a namedOp from the given GenericOp and replace the GenericOp. </p>
<p>Currently we can specialize only trivial linalg copy operations. </p>

<p class="definition">Definition at line <a class="el" href="Specialize_8cpp_source.html#l00323">323</a> of file <a class="el" href="Specialize_8cpp_source.html">Specialize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Specialize_8cpp_source.html#l00056">areBinOpsSwapped()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00141">isaBroadcastOpInterface()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00565">isaContractionOpInterface()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l01042">isaConvolutionOpInterface()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00061">isaCopyOpInterface()</a>, <a class="el" href="#afc247b3bd43d4462293e09845b698e7a">isaElemwiseSingleBinaryOpInterface()</a>, <a class="el" href="#a14eec3edd7d29c8980b155ed0dee1a0c">isaElemwiseSingleUnaryOpInterface()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00131">isaFillOpInterface()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00191">isaTransposeOpInterface()</a>, <a class="el" href="Specialize_8cpp_source.html#l00030">REPLACE_BINARY_OP</a>, <a class="el" href="Specialize_8cpp_source.html#l00037">REPLACE_UNARY_OP</a>, and <a class="el" href="PatternMatch_8h_source.html#l00529">mlir::RewriterBase::replaceOpWithNewOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01625">mlir::linalg::LinalgSpecializationPattern::returningMatchAndRewrite()</a>.</p>

</div>
</div>
<a id="af025e45095e64f984901c4f65fa3c72f" name="af025e45095e64f984901c4f65fa3c72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af025e45095e64f984901c4f65fa3c72f">&#9670;&#160;</a></span>splitOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; TilingInterface, TilingInterface &gt; mlir::linalg::splitOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dimension</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>splitPoint</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given <span class="tt">op</span> into two parts along the given iteration space <span class="tt">dimension</span> at the specified <span class="tt">splitPoint</span>, and return the two parts. </p>
<p>If the second part is statically known to be empty, do not create it and return nullptr instead. Error state is signalled by returning a pair of nullptrs.</p>
<p>For example, the following op:</p>
<p>linalg.matmul ins(%0, %1 : <a class="el" href="namespacemlir_1_1tensor.html">tensor&lt;128x32xf32&gt;</a>, <a class="el" href="namespacemlir_1_1tensor.html">tensor&lt;32x64xf32&gt;</a>) outs(%2 : <a class="el" href="namespacemlir_1_1tensor.html">tensor&lt;128x64xf32&gt;</a>)</p>
<p>split along the first dimension at position 42 will result in:</p>
<p>%3 = tensor.extract_slice %0[0, 0][42, 32][1, 1] %4 = tensor.extract_slice %2[0, 0][42, 64][1, 1] %5 = linalg.matmul ins(%3, %1 : <a class="el" href="namespacemlir_1_1tensor.html">tensor&lt;42x32xf32&gt;</a>, <a class="el" href="namespacemlir_1_1tensor.html">tensor&lt;32x64xf32&gt;</a>) outs(%5 : <a class="el" href="namespacemlir_1_1tensor.html">tensor&lt;42x64xf32&gt;</a>) %6 = tensor.insert_slice %5 into %2[0, 0][42, 64][1, 1]</p>
<p>%7 = tensor.extract_slice %0[42, 0][86, 32][1, 1] %8 = tensor.extract_slice %6[42, 0][86, 64][1, 1] %9 = linalg.matmul ins(%7, %1 : <a class="el" href="namespacemlir_1_1tensor.html">tensor&lt;86x32xf32&gt;</a>, <a class="el" href="namespacemlir_1_1tensor.html">tensor&lt;32x64xf32&gt;</a>) outs(%8 : <a class="el" href="namespacemlir_1_1tensor.html">tensor&lt;86x64xf32&gt;</a>) tensor.insert_slice %5 into %6[42, 0][86, 64][1, 1]</p>
<p>Note that there is no simplification other than constant propagation applied to slice extraction and insertion. </p>

<p class="definition">Definition at line <a class="el" href="Split_8cpp_source.html#l00067">67</a> of file <a class="el" href="Split_8cpp_source.html">Split.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="Split_8cpp_source.html#l00032">createSplitPart()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00110">mlir::tensor::getOrCreateDestinations()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">mlir::AffineMap::inferFromExprList()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01572">mlir::affine::makeComposedFoldedAffineMin()</a>, <a class="el" href="PatternMatch_8h_source.html#l00638">mlir::RewriterBase::modifyOpInPlace()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00036">mlir::Range::offset</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00037">mlir::Range::size</a>.</p>

</div>
</div>
<a id="aaa4f58f6a18fb7c9af60fb15122e0994" name="aaa4f58f6a18fb7c9af60fb15122e0994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4f58f6a18fb7c9af60fb15122e0994">&#9670;&#160;</a></span>splitReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a> &gt; mlir::linalg::splitReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a505f71c7a182531357360cb2151dc1f3">ControlSplitReductionFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>controlSplitReductionFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useAlloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SplitReduction_8cpp_source.html#l00030">30</a> of file <a class="el" href="SplitReduction_8cpp_source.html">SplitReduction.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00411">mlir::AffineMap::getDimPosition()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02734">mlir::arith::getNeutralElement()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00481">mlir::linalg::SplitReductionOptions::index</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00483">mlir::linalg::SplitReductionOptions::innerParallel</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00290">mlir::matchReduction()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00478">mlir::linalg::SplitReductionOptions::ratio</a>, <a class="el" href="IR_2Operation_8h_source.html#l00351">mlir::Operation::setOperand()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02099">TypeRange</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02103">ValueRange</a>.</p>

</div>
</div>
<a id="af87c3f5c965b8e271579136775d51ffc" name="af87c3f5c965b8e271579136775d51ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87c3f5c965b8e271579136775d51ffc">&#9670;&#160;</a></span>splitReductionByScaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a> &gt; mlir::linalg::splitReductionByScaling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a505f71c7a182531357360cb2151dc1f3">ControlSplitReductionFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>controlSplitReductionFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useAlloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scaling-based implementation of the split reduction transformation. </p>
<p>Core rewrite implementation.</p>
<p>Instead of introducing an ExpandShapeOp, this rewrites a reduction dimension <span class="tt">k</span> into <span class="tt">k * scale + kk</span>.</p>
<p>Example: </p><div class="fragment"><div class="line">%0 = <a class="code hl_namespace" href="namespacemlir_1_1linalg.html">linalg</a>.matmul ins(%A, %B: <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;16x256xf32&gt;</a>, <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;256x32xf32&gt;</a>)</div>
<div class="line">  outs(%C: <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;16x32xf32&gt;</a>) -&gt; <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;16x32xf32&gt;</a></div>
</div><!-- fragment --><p>Is transformed to:</p>
<div class="fragment"><div class="line"><span class="preprocessor">     #map0 = affine_map&lt;(d0, d1, d2, d3) -&gt; (d0, d2 * 4 + d3)&gt;</span></div>
<div class="line"><span class="preprocessor">     #map1 = affine_map&lt;(d0, d1, d2, d3) -&gt; (d2 * 4 + d3, d1)&gt;</span></div>
<div class="line"><span class="preprocessor">     #map2 = affine_map&lt;(d0, d1, d2, d3) -&gt; (d2, d3)&gt;</span></div>
<div class="line"><span class="preprocessor">     #map3 = affine_map&lt;(d0, d1, d2, d3) -&gt; (d0, d1, d2)&gt;</span></div>
<div class="line"><span class="preprocessor">     #map4 = affine_map&lt;(d0, d1, d2) -&gt; (d0, d1, d2)&gt;</span></div>
<div class="line"><span class="preprocessor">     #map5 = affine_map&lt;(d0, d1, d2) -&gt; (d0, d1)&gt;</span></div>
<div class="line">     %0 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.empty [16, 32, 64] : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;16x32x64xf32&gt;</a></div>
<div class="line">     %cst = <a class="code hl_namespace" href="namespacemlir_1_1arith.html">arith</a>.constant 0.000000e+00 : f32</div>
<div class="line">     %1 = <a class="code hl_namespace" href="namespacemlir_1_1linalg.html">linalg</a>.fill ins(%cst : f32) outs(%0 : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;16x32x64xf32&gt;</a>) -&gt;</div>
<div class="line">        <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;16x32x64xf32&gt;</a></div>
<div class="line">     %2 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.empty [64, 4] : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;64x4xi1&gt;</a></div>
<div class="line">   </div>
<div class="line">     %3 = <a class="code hl_namespace" href="namespacemlir_1_1linalg.html">linalg</a>.generic {indexing_maps = [#map0, #map1, #map2, #map3],</div>
<div class="line">       iterator_types = [<span class="stringliteral">&quot;parallel&quot;</span>, <span class="stringliteral">&quot;parallel&quot;</span>, <span class="stringliteral">&quot;parallel&quot;</span>, <span class="stringliteral">&quot;reduction&quot;</span>]}</div>
<div class="line">       ins(%A, %B, %2 : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;16x256xf32&gt;</a>, <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;256x32xf32&gt;</a>,</div>
<div class="line">       <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;64x4xi1&gt;</a>)</div>
<div class="line">      outs(%1 : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;16x32x64xf32&gt;</a>) {</div>
<div class="line">         ^bb0(%arg3: f32, %arg4: f32, %arg5: i1, %arg6: f32):</div>
<div class="line">           %5 = <a class="code hl_namespace" href="namespacemlir_1_1arith.html">arith</a>.mulf %arg3, %arg4 : f32</div>
<div class="line">           %6 = <a class="code hl_namespace" href="namespacemlir_1_1arith.html">arith</a>.addf %arg6, %5 : f32</div>
<div class="line">           <a class="code hl_namespace" href="namespacemlir_1_1linalg.html">linalg</a>.yield %6 : f32</div>
<div class="line">     } -&gt; <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;16x32x64xf32&gt;</div>
<div class="line">   </div>
<div class="line">     %4 = <a class="code hl_namespace" href="namespacemlir_1_1linalg.html">linalg</a>.generic {indexing_maps = [#map4, #map5],</div>
<div class="line">       iterator_types = [<span class="stringliteral">&quot;parallel&quot;</span>, <span class="stringliteral">&quot;parallel&quot;</span>, <span class="stringliteral">&quot;reduction&quot;</span>]} */</div>
<div class="line"><span class="comment">//     ins(%3 : tensor&lt;16x32x64xf32&gt;)</span><span class="comment"></span></div>
<div class="line"><span class="comment">/**    outs(%C : tensor&lt;16x32xf32&gt;) {</span></div>
<div class="line"><span class="comment">         ^bb0(%arg3: f32, %arg4: f32):</span></div>
<div class="line"><span class="comment">           %5 = arith.addf %arg3, %arg4 : f32</span></div>
<div class="line"><span class="comment">           linalg.yield %5 : f32</span></div>
<div class="line"><span class="comment">     } -&gt; tensor&lt;16x32xf32&gt;</span></div>
<div class="line"><span class="comment">   </span></div>
<div class="line"><span class="comment">     return %4 : tensor&lt;16x32xf32&gt;</span></div>
<div class="ttc" id="anamespacemlir_1_1arith_html"><div class="ttname"><a href="namespacemlir_1_1arith.html">mlir::arith</a></div><div class="ttdef"><b>Definition</b> <a href="ArithCommon_2AttrToLLVMConverter_8h_source.html#l00020">AttrToLLVMConverter.h:20</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="SplitReduction_8cpp_source.html#l00241">241</a> of file <a class="el" href="SplitReduction_8cpp_source.html">SplitReduction.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00062">mlir::tensor::createDynamicDimValues()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00293">mlir::AffineMap::dropResult()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02734">mlir::arith::getNeutralElement()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00481">mlir::linalg::SplitReductionOptions::index</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00483">mlir::linalg::SplitReductionOptions::innerParallel</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00264">mlir::RankedTensorType::Builder::insertDim()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00230">insertParallelDim()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00290">mlir::matchReduction()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00478">mlir::linalg::SplitReductionOptions::ratio</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00215">scaleReductionDim()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00351">mlir::Operation::setOperand()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02103">ValueRange</a>.</p>

</div>
</div>
<a id="ac13050e75a64a26bf82a80b19006d0e9" name="ac13050e75a64a26bf82a80b19006d0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13050e75a64a26bf82a80b19006d0e9">&#9670;&#160;</a></span>tileLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt; mlir::linalg::tileLinalgOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00816">816</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00122">Loops</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00124">ParallelLoops</a>, and <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="ab3085a8dbbf3c572b3279bdcc53dbe72" name="ab3085a8dbbf3c572b3279bdcc53dbe72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3085a8dbbf3c572b3279bdcc53dbe72">&#9670;&#160;</a></span>tileReductionUsingForall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html">linalg::ForallReductionTilingResult</a> &gt; mlir::linalg::tileReductionUsingForall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PartialReductionOpInterface</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>numThreads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tileSizes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mapping</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to tile a reduction to parallel iterations computing partial reductions. </p>
<p>After the loop all the partial reduction are merged into a final reduction. For example for the following sequence</p>
<div class="fragment"><div class="line">%0 = linalg.generic %in [&quot;parallel&quot;, &quot;reduction&quot;]</div>
<div class="line">  : tensor&lt;7x9xf32&gt; -&gt; tensor&lt;7xf32&gt;</div>
</div><!-- fragment --><p>into:</p>
<div class="fragment"><div class="line">%0 = linalg.fill ... : tensor&lt;7x4xf32&gt;</div>
<div class="line">%1 = scf.forall (%iv) in (%c4) shared_outs(%arg0 = %0)</div>
<div class="line">  -&gt; (tensor&lt;7x4xf32&gt;) {</div>
<div class="line">  %2 = tensor.extract_slice %arg3 : tensor&lt;7x4xf32&gt; to tensor&lt;7xf32&gt;</div>
<div class="line">  %3 = tensor.extract_slice %in : tensor&lt;7x9xf32&gt; -&gt; tensor&lt;7x?xf32&gt;</div>
<div class="line">  %4 = linalg.generic %2, %3 [&quot;parallel&quot;, &quot;reduction&quot;]</div>
<div class="line">    : tensor&lt;7x?xf32&gt; -&gt; tensor&lt;7xf32&gt;</div>
<div class="line">  %5 = tensor.insert_slice %3, %arg0[0, %iv] : tensor&lt;7x4xf32&gt;</div>
<div class="line">}</div>
<div class="line">%6 = linalg.generic %1 [&quot;parallel&quot;, &quot;reduction&quot;]</div>
<div class="line">  : tensor&lt;7x4xf32&gt; -&gt; tensor&lt;7xf32&gt;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00588">588</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Tiling_8cpp_source.html#l00362">calculateTileOffsetsAndSizes()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00081">mlir::getAsOpFoldResult()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00110">mlir::tensor::getOrCreateDestinations()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01028">mlir::linalg::ForallReductionTilingResult::initialValues</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">mlir::isZeroInteger()</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01030">mlir::linalg::ForallReductionTilingResult::loops</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01026">mlir::linalg::ForallReductionTilingResult::mergeOps</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01024">mlir::linalg::ForallReductionTilingResult::parallelTiledOps</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="a1b2368f6f815597fcf395106e8978e44" name="a1b2368f6f815597fcf395106e8978e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2368f6f815597fcf395106e8978e44">&#9670;&#160;</a></span>transformIndexOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::transformIndexOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ivs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ac63ef3b10f63a46b5d07ad3cbf2ed19d">LoopIndexToRangeIndexMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>loopIndexToRangeIndex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All indices returned by IndexOp should be invariant with respect to tiling. </p>
<p>Therefore, if an operation is tiled, we have to transform the indices accordingly, i.e. offset them by the values of the corresponding induction variables that are captured implicitly in the body of the op.</p>
<p>Example. <span class="tt">linalg.generic</span> before tiling:</p>
<p>#id_2d = (i, j) -&gt; (i, j) #pointwise_2d_trait = { indexing_maps = [#id_2d, #id_2d], iterator_types = ["parallel", "parallel"] } linalg.generic #pointwise_2d_trait operand, result { ^bb0(operand_in: f32, result_in: f32): i = linalg.index 0 : index j = linalg.index 1 : index &lt;some operations that use i, j&gt; }: <a class="el" href="namespacemlir_1_1memref.html">memref&lt;50x100xf32&gt;</a>, <a class="el" href="namespacemlir_1_1memref.html">memref&lt;50x100xf32&gt;</a></p>
<p>After tiling pass with tiles sizes 10 and 25:</p>
<p>#strided = (i, j)[s0, s1, s2] -&gt; (i * s1 + s0 + j * s2)</p>
<p>c1 = arith.constant 1 : index c0 = arith.constant 0 : index c25 = arith.constant 25 : index c10 = arith.constant 10 : index operand_dim_0 = dim operand, 0 : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;50x100xf32&gt;</a> operand_dim_1 = dim operand, 1 : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;50x100xf32&gt;</a> scf.for k = c0 to operand_dim_0 step c10 { scf.for l = c0 to operand_dim_1 step c25 { %4 = memref.subview operand[k, l][c10, c25][c1, c1] : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;50x100xf32&gt;</a> to memref&lt;?x?xf32, #strided&gt; %5 = memref.subview result[k, l][c10, c25][c1, c1] : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;50x100xf32&gt;</a> to memref&lt;?x?xf32, #strided&gt; linalg.generic pointwise_2d_trait %4, %5 { ^bb0(operand_in: f32, result_in: f32): i = linalg.index 0 : index j = linalg.index 1 : index // Indices <span class="tt">k</span> and <span class="tt">l</span> are implicitly captured in the body. transformed_i = arith.addi i, k : index // index <span class="tt">i</span> is offset by k transformed_j = arith.addi j, l : index // index <span class="tt">j</span> is offset by l // Every use of i, j is replaced with transformed_i, transformed_j &lt;some operations that use transformed_i, transformed_j&gt; }: memref&lt;?x?xf32, #strided&gt;, memref&lt;?x?xf32, #strided&gt; } }</p>
<p>TODO: Investigate whether mixing implicit and explicit indices does not lead to losing information. </p>

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00073">73</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00081">mlir::getAsOpFoldResult()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02149">offsetIndices()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="a816f67d5546592d18de9ec5de0e791f3" name="a816f67d5546592d18de9ec5de0e791f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816f67d5546592d18de9ec5de0e791f3">&#9670;&#160;</a></span>transposeBatchMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::transposeBatchMatmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::BatchMatmulOp</td>          <td class="paramname"><span class="paramname"><em>batchMatmulOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>transposeLHS</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to replace. </p>
<p>linalg.batch_matmul(a, b)</p>
<p>with</p>
<p>linalg.batch_matmul_transpose_a(linalg.transpose(a), b)</p>
<p>Only the non-batch dimensions are transposed. By default the LHS is transposed. Set <span class="tt">transposeLHS=false</span> to transpose RHS instead. </p>

<p class="definition">Definition at line <a class="el" href="TransposeMatmul_8cpp_source.html#l00087">87</a> of file <a class="el" href="TransposeMatmul_8cpp_source.html">TransposeMatmul.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp_source.html#l04190">mlir::linalg::BatchMatmulTransposeAOp::create()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l04283">mlir::linalg::BatchMatmulTransposeBOp::create()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>.</p>

</div>
</div>
<a id="a6ea35f9b824fbdf551b76ddf974fc418" name="a6ea35f9b824fbdf551b76ddf974fc418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea35f9b824fbdf551b76ddf974fc418">&#9670;&#160;</a></span>transposeConv2D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::transposeConv2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::Conv2DNhwcFhwcOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert linalg.conv_2d_nhwc_fhwc(_q) to linalg.conv_2d_nhwc_hwcf(_q) by materializing transpose. </p>

<p class="definition">Definition at line <a class="el" href="TransposeConv2D_8cpp_source.html#l00120">120</a> of file <a class="el" href="TransposeConv2D_8cpp_source.html">TransposeConv2D.cpp</a>.</p>

</div>
</div>
<a id="ada14eab9218f7ff7f15f695a980fb717" name="ada14eab9218f7ff7f15f695a980fb717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada14eab9218f7ff7f15f695a980fb717">&#9670;&#160;</a></span>transposeConv2D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::transposeConv2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::Conv2DNhwcFhwcQOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TransposeConv2D_8cpp_source.html#l00127">127</a> of file <a class="el" href="TransposeConv2D_8cpp_source.html">TransposeConv2D.cpp</a>.</p>

</div>
</div>
<a id="ad8836bfb07ad8fc4f7bda9aa174da988" name="ad8836bfb07ad8fc4f7bda9aa174da988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8836bfb07ad8fc4f7bda9aa174da988">&#9670;&#160;</a></span>transposeMatmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::transposeMatmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::MatmulOp</td>          <td class="paramname"><span class="paramname"><em>matmulOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>transposeLHS</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert Linalg matmul ops to transposed variants. </p>
<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to replace.</p>
<p>linalg.matmul(a, b)</p>
<p>with</p>
<p>linalg.matmul_transpose_a(linalg.transpose(a), b)</p>
<p>By default the LHS is transposed. Set <span class="tt">transposeLHS=false</span> to transpose RHS instead. </p>

<p class="definition">Definition at line <a class="el" href="TransposeMatmul_8cpp_source.html#l00030">30</a> of file <a class="el" href="TransposeMatmul_8cpp_source.html">TransposeMatmul.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp_source.html#l04002">mlir::linalg::MatmulTransposeAOp::create()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l04096">mlir::linalg::MatmulTransposeBOp::create()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>.</p>

</div>
</div>
<a id="aeb173d5edf56a08ed3610924312dd364" name="aeb173d5edf56a08ed3610924312dd364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb173d5edf56a08ed3610924312dd364">&#9670;&#160;</a></span>updateBoundsForCyclicDistribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::updateBoundsForCyclicDistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>procId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>nprocs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>step</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the <span class="tt">lb</span>, <span class="tt">ub</span> and <span class="tt">step</span> to get per processor <span class="tt">lb</span>, <span class="tt">ub</span> and <span class="tt">step</span>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01677">1677</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">mlir::getAffineSymbolExpr()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01416">mlir::affine::makeComposedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01813">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>.</p>

</div>
</div>
<a id="a303bb59c046a82276569e6b906002997" name="a303bb59c046a82276569e6b906002997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303bb59c046a82276569e6b906002997">&#9670;&#160;</a></span>vectorize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1VectorizationResult.html">VectorizationResult</a> &gt; mlir::linalg::vectorize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inputVectorSizes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classbool.html">bool</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inputScalableVecDims</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>vectorizeNDExtract</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>flatten1DDepthwiseConv</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>assumeDynamicDimsMatchVecSizes</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>createNamedContraction</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <span class="tt"><a class="el" href="structmlir_1_1linalg_1_1VectorizationResult.html" title="Transformation information returned after vectorizing.">VectorizationResult</a></span> containing the results of the vectorized op, or failure if the transformation fails. </p>
<p>If provided, <span class="tt">inputVectorSizes</span> are used to vectorize this operation. <span class="tt">inputVectorSizes</span> must match the rank of the iteration space of the operation and the input vector sizes must be greater than or equal to their counterpart iteration space sizes, if static. <span class="tt">inputVectorShapes</span> also allows the vectorization of operations with dynamic shapes. Optionally, <span class="tt">createNamedContraction</span> can force compatible contractions to be vectorized directly to vector.contract operation. </p>

</div>
</div>
<a id="a8c63bc9239511b70751c238a12f5b1da" name="a8c63bc9239511b70751c238a12f5b1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c63bc9239511b70751c238a12f5b1da">&#9670;&#160;</a></span>vectorizeCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::vectorizeCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::CopyOp</td>          <td class="paramname"><span class="paramname"><em>copyOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a suitable vector form for a Copy op with fully static shape. </p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00893">mlir::linalg::CopyVectorizationPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a8d0310adee4f127279f9147a71db0181" name="a8d0310adee4f127279f9147a71db0181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0310adee4f127279f9147a71db0181">&#9670;&#160;</a></span>vectorizeOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::linalg::vectorizeOpPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inputVectorSizes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classbool.html">bool</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inputScalableVecDims</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>vectorizeNDExtract</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>flatten1DDepthwiseConv</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return success if the operation can be vectorized. </p>

</div>
</div>
<a id="ad12a26862a648652876cc38d26ddcd23" name="ad12a26862a648652876cc38d26ddcd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12a26862a648652876cc38d26ddcd23">&#9670;&#160;</a></span>winogradConv2D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::winogradConv2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::Conv2DNhwcFhwcOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::WinogradConv2DFmr</td>          <td class="paramname"><span class="paramname"><em>fmr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="WinogradConv2D_8cpp_source.html#l01189">1189</a> of file <a class="el" href="WinogradConv2D_8cpp_source.html">WinogradConv2D.cpp</a>.</p>

</div>
</div>
<a id="a6e047772994b241ad2de48dfc28d7340" name="a6e047772994b241ad2de48dfc28d7340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e047772994b241ad2de48dfc28d7340">&#9670;&#160;</a></span>winogradConv2D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::linalg::winogradConv2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">linalg::Conv2DNhwcFhwcOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WinogradConv2DFmr</td>          <td class="paramname"><span class="paramname"><em>fmr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert linalg.conv_2d_nhwc_fhwc to Winograd Conv2D algorithm F(m x m, r x r). </p>
<p>m is the dimension size of output and r is the dimension size of filter. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
