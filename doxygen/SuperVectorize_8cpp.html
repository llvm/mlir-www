<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Affine/Transforms/SuperVectorize.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a href="dir_30022079959872f4a1874dfcab7bb1fc.html">Affine</a></li><li class="navelem"><a href="dir_20e768baa5d01a8ee51c7c9b68e644ce.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">SuperVectorize.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Dialect_2Affine_2Passes_8h_source.html">mlir/Dialect/Affine/Passes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SliceAnalysis_8h_source.html">mlir/Analysis/SliceAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineAnalysis_8h_source.html">mlir/Dialect/Affine/Analysis/AffineAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopAnalysis_8h_source.html">mlir/Dialect/Affine/Analysis/LoopAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="NestedMatcher_8h_source.html">mlir/Dialect/Affine/Analysis/NestedMatcher.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Affine_2Utils_8h_source.html">mlir/Dialect/Affine/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Arith_2IR_2Arith_8h_source.html">mlir/Dialect/Arith/IR/Arith.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="FuncOps_8h_source.html">mlir/Dialect/Func/IR/FuncOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VectorOps_8h_source.html">mlir/Dialect/Vector/IR/VectorOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VectorUtils_8h_source.html">mlir/Dialect/Vector/Utils/VectorUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IRMapping_8h_source.html">mlir/IR/IRMapping.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="include_2mlir_2Pass_2Pass_8h_source.html">mlir/Pass/Pass.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Support_2LLVM_8h_source.html">mlir/Support/LLVM.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &quot;mlir/Dialect/Affine/Passes.h.inc&quot;</code><br />
</div>
<p><a href="SuperVectorize_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:mlir_3A_3Aaffine_3A_3Aimpl_3A_3AAffineVectorizeBase_3C_20DerivedT_20_3E" id="r_mlir_3A_3Aaffine_3A_3Aimpl_3A_3AAffineVectorizeBase_3C_20DerivedT_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1impl_1_1AffineVectorizeBase.html">mlir::affine::impl::AffineVectorizeBase&lt; DerivedT &gt;</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:mlir" id="r_mlir"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="memitem:mlir_3A_3Aaffine" id="r_mlir_3A_3Aaffine"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html">mlir::affine</a></td></tr>
<tr class="memitem:mlir_3A_3Aaffine_3A_3Aimpl" id="r_mlir_3A_3Aaffine_3A_3Aimpl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine_1_1impl.html">mlir::affine::impl</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:acaee4b386ba2945c1ace21ad8ecbac73" id="r_acaee4b386ba2945c1ace21ad8ecbac73"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acaee4b386ba2945c1ace21ad8ecbac73">GEN_PASS_DEF_AFFINEVECTORIZE</a></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d" id="r_ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;early-vect&quot;</td></tr>
<tr class="memdesc:ad78e062f62e0d6e453941fb4ca843e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a high-level vectorization strategy on a Function.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6a24a9f0bb2746c3d0872759977d0b96" id="r_a6a24a9f0bb2746c3d0872759977d0b96"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine_1_1impl.html#a6a24a9f0bb2746c3d0872759977d0b96">mlir::affine::impl::createAffineVectorize</a> ()</td></tr>
<tr class="memitem:a0d9e2b3aee2215c781a3f9f41ee45968" id="r_a0d9e2b3aee2215c781a3f9f41ee45968"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine_1_1impl.html#a0d9e2b3aee2215c781a3f9f41ee45968">mlir::affine::impl::createAffineVectorize</a> (<a class="el" href="structmlir_1_1affine_1_1AffineVectorizeOptions.html">AffineVectorizeOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:aa65f8449ec0c16cda685788e865265dc" id="r_aa65f8449ec0c16cda685788e865265dc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#aa65f8449ec0c16cda685788e865265dc">mlir::affine::createAffineVectorize</a> ()</td></tr>
<tr class="memitem:a2f680ba9877f07ecc0c3ed9dab02a9a9" id="r_a2f680ba9877f07ecc0c3ed9dab02a9a9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a2f680ba9877f07ecc0c3ed9dab02a9a9">mlir::affine::createAffineVectorize</a> (<a class="el" href="structmlir_1_1affine_1_1AffineVectorizeOptions.html">AffineVectorizeOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a813fd50e431196fa605b66c4091cc5a4" id="r_a813fd50e431196fa605b66c4091cc5a4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemlir_1_1affine.html#a7ac41cc03dea5e719278bacddd8f0829">FilterFunctionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a813fd50e431196fa605b66c4091cc5a4">isVectorizableLoopPtrFactory</a> (const <a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;parallelLoops, int fastestVaryingMemRefDimension)</td></tr>
<tr class="memdesc:a813fd50e431196fa605b66c4091cc5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <br /></td></tr>
<tr class="memitem:a1dc992b3e5eb40e467a0f5e364125b43" id="r_a1dc992b3e5eb40e467a0f5e364125b43"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dc992b3e5eb40e467a0f5e364125b43">makePattern</a> (const <a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;parallelLoops, int vectorRank, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; fastestVaryingPattern)</td></tr>
<tr class="memdesc:a1dc992b3e5eb40e467a0f5e364125b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vectorization pattern from the command line arguments.  <br /></td></tr>
<tr class="memitem:ac564c0566b654dea8e0d1c0458943c7c" id="r_ac564c0566b654dea8e0d1c0458943c7c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac564c0566b654dea8e0d1c0458943c7c">vectorTransferPattern</a> ()</td></tr>
<tr class="memitem:a2770a30614289df9645750217ed5b86e" id="r_a2770a30614289df9645750217ed5b86e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2770a30614289df9645750217ed5b86e">vectorizeLoopIfProfitable</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *loop, <a class="el" href="classunsigned.html">unsigned</a> depthInPattern, <a class="el" href="classunsigned.html">unsigned</a> patternDepth, VectorizationStrategy *strategy)</td></tr>
<tr class="memitem:a7b753fbff5d2aa2f6353b3ab53c4dcc6" id="r_a7b753fbff5d2aa2f6353b3ab53c4dcc6"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b753fbff5d2aa2f6353b3ab53c4dcc6">analyzeProfitability</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1affine_1_1NestedMatch.html">NestedMatch</a> &gt; matches, <a class="el" href="classunsigned.html">unsigned</a> depthInPattern, <a class="el" href="classunsigned.html">unsigned</a> patternDepth, VectorizationStrategy *strategy)</td></tr>
<tr class="memdesc:a7b753fbff5d2aa2f6353b3ab53c4dcc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a simple strawman strategy for vectorization.  <br /></td></tr>
<tr class="memitem:a9091a26a4aeed73f007e1b9e5a0784ff" id="r_a9091a26a4aeed73f007e1b9e5a0784ff"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9091a26a4aeed73f007e1b9e5a0784ff">eraseLoopNest</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a9091a26a4aeed73f007e1b9e5a0784ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases a loop nest, including all its nested operations.  <br /></td></tr>
<tr class="memitem:ad765b0b8701a0ac063c727bf0915573c" id="r_ad765b0b8701a0ac063c727bf0915573c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad765b0b8701a0ac063c727bf0915573c">computeMemoryOpIndices</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> mapOperands, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;results)</td></tr>
<tr class="memitem:a92301bec02cb80bed5dfe59fef345e98" id="r_a92301bec02cb80bed5dfe59fef345e98"><td class="memItemLeft" align="right" valign="top">static VectorType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92301bec02cb80bed5dfe59fef345e98">getVectorType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> scalarTy, const VectorizationStrategy *strategy)</td></tr>
<tr class="memdesc:a92301bec02cb80bed5dfe59fef345e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector type resulting from applying the provided vectorization strategy on the scalar type.  <br /></td></tr>
<tr class="memitem:a8d83e7c160ae10471fe0b50816b087a9" id="r_a8d83e7c160ae10471fe0b50816b087a9"><td class="memItemLeft" align="right" valign="top">static arith::ConstantOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d83e7c160ae10471fe0b50816b087a9">vectorizeConstant</a> (arith::ConstantOp constOp, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state)</td></tr>
<tr class="memdesc:a8d83e7c160ae10471fe0b50816b087a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to transform a scalar constant into a vector constant.  <br /></td></tr>
<tr class="memitem:a76efdc273bcdca9c52f61b2ec21979ea" id="r_a76efdc273bcdca9c52f61b2ec21979ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76efdc273bcdca9c52f61b2ec21979ea">vectorizeAffineApplyOp</a> (AffineApplyOp applyOp, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state)</td></tr>
<tr class="memdesc:a76efdc273bcdca9c52f61b2ec21979ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">We have no need to vectorize affine.apply.  <br /></td></tr>
<tr class="memitem:ab277cf2afb2c993c7aeea818cf17c6a2" id="r_ab277cf2afb2c993c7aeea818cf17c6a2"><td class="memItemLeft" align="right" valign="top">static arith::ConstantOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab277cf2afb2c993c7aeea818cf17c6a2">createInitialVector</a> (arith::AtomicRMWKind reductionKind, <a class="el" href="classmlir_1_1Value.html">Value</a> oldOperand, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state)</td></tr>
<tr class="memdesc:ab277cf2afb2c993c7aeea818cf17c6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a constant vector filled with the neutral elements of the given reduction.  <br /></td></tr>
<tr class="memitem:ae0baa9b3816267713d213c61f49bc81c" id="r_ae0baa9b3816267713d213c61f49bc81c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0baa9b3816267713d213c61f49bc81c">createMask</a> (AffineForOp vecForOp, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state)</td></tr>
<tr class="memdesc:ae0baa9b3816267713d213c61f49bc81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mask used to filter out garbage elements in the last iteration of unaligned loops.  <br /></td></tr>
<tr class="memitem:a8f5144f6d42a7c57e4c654f2812909b9" id="r_a8f5144f6d42a7c57e4c654f2812909b9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f5144f6d42a7c57e4c654f2812909b9">isUniformDefinition</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const VectorizationStrategy *strategy)</td></tr>
<tr class="memdesc:a8f5144f6d42a7c57e4c654f2812909b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided value is vector uniform given the vectorization strategy.  <br /></td></tr>
<tr class="memitem:a19d00d4d03c52266df8e3739d1e8b8ce" id="r_a19d00d4d03c52266df8e3739d1e8b8ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19d00d4d03c52266df8e3739d1e8b8ce">vectorizeUniform</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> uniformVal, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state)</td></tr>
<tr class="memdesc:a19d00d4d03c52266df8e3739d1e8b8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a broadcast op for the provided uniform value using the vectorization strategy in 'state'.  <br /></td></tr>
<tr class="memitem:a9feac15d4af3a625b7b6426c579be8c2" id="r_a9feac15d4af3a625b7b6426c579be8c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9feac15d4af3a625b7b6426c579be8c2">vectorizeOperand</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> operand, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state)</td></tr>
<tr class="memdesc:a9feac15d4af3a625b7b6426c579be8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to vectorize a given <span class="tt">operand</span> by applying the following logic:  <br /></td></tr>
<tr class="memitem:a879085552a185c778d775adbe1dcd187" id="r_a879085552a185c778d775adbe1dcd187"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a879085552a185c778d775adbe1dcd187">isIVMappedToMultipleIndices</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; <a class="el" href="AffineAnalysis_8cpp.html#a7b261d2d5f193015afc3427b0c0951ed">indices</a>, const <a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;loopToVectorDim)</td></tr>
<tr class="memdesc:a879085552a185c778d775adbe1dcd187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any vectorized loop IV drives more than one index.  <br /></td></tr>
<tr class="memitem:a60db1ed05bddc04dde5968edf86e1c2e" id="r_a60db1ed05bddc04dde5968edf86e1c2e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60db1ed05bddc04dde5968edf86e1c2e">vectorizeAffineLoad</a> (AffineLoadOp loadOp, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state)</td></tr>
<tr class="memdesc:a60db1ed05bddc04dde5968edf86e1c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorizes an affine load with the vectorization strategy in 'state' by generating a 'vector.transfer_read' op with the proper permutation map inferred from the indices of the load.  <br /></td></tr>
<tr class="memitem:ab93b499c7cf74433c36009ae0afc0e21" id="r_ab93b499c7cf74433c36009ae0afc0e21"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab93b499c7cf74433c36009ae0afc0e21">vectorizeAffineStore</a> (AffineStoreOp storeOp, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state)</td></tr>
<tr class="memdesc:ab93b499c7cf74433c36009ae0afc0e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorizes an affine store with the vectorization strategy in 'state' by generating a 'vector.transfer_write' op with the proper permutation map inferred from the indices of the store.  <br /></td></tr>
<tr class="memitem:a4c454b0e869a9101580a1a048d0cf5bb" id="r_a4c454b0e869a9101580a1a048d0cf5bb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c454b0e869a9101580a1a048d0cf5bb">isNeutralElementConst</a> (arith::AtomicRMWKind reductionKind, <a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state)</td></tr>
<tr class="memdesc:a4c454b0e869a9101580a1a048d0cf5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <span class="tt">value</span> is a constant equal to the neutral element of the given vectorizable reduction.  <br /></td></tr>
<tr class="memitem:a75edffd40fd0fb97877f5a93dec0c760" id="r_a75edffd40fd0fb97877f5a93dec0c760"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75edffd40fd0fb97877f5a93dec0c760">vectorizeAffineForOp</a> (AffineForOp forOp, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state)</td></tr>
<tr class="memdesc:a75edffd40fd0fb97877f5a93dec0c760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorizes a loop with the vectorization strategy in 'state'.  <br /></td></tr>
<tr class="memitem:ab4a0e9a73e9bddbba43ed1b1624a2936" id="r_ab4a0e9a73e9bddbba43ed1b1624a2936"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4a0e9a73e9bddbba43ed1b1624a2936">widenOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state)</td></tr>
<tr class="memdesc:ab4a0e9a73e9bddbba43ed1b1624a2936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorizes arbitrary operation by plain widening.  <br /></td></tr>
<tr class="memitem:aaf17657a99036f79b99980402798d753" id="r_aaf17657a99036f79b99980402798d753"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf17657a99036f79b99980402798d753">vectorizeAffineYieldOp</a> (AffineYieldOp yieldOp, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state)</td></tr>
<tr class="memdesc:aaf17657a99036f79b99980402798d753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorizes a yield operation by widening its types.  <br /></td></tr>
<tr class="memitem:a481bbf90f4171113e1867747d9db4a3b" id="r_a481bbf90f4171113e1867747d9db4a3b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a481bbf90f4171113e1867747d9db4a3b">vectorizeOneOperation</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state)</td></tr>
<tr class="memdesc:a481bbf90f4171113e1867747d9db4a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes Operation-specific behavior for vectorization.  <br /></td></tr>
<tr class="memitem:aa0aaf4fbfeafbb9d5fdcd1a83cd4c6b7" id="r_aa0aaf4fbfeafbb9d5fdcd1a83cd4c6b7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0aaf4fbfeafbb9d5fdcd1a83cd4c6b7">getMatchedAffineLoopsRec</a> (<a class="el" href="classmlir_1_1affine_1_1NestedMatch.html">NestedMatch</a> match, <a class="el" href="classunsigned.html">unsigned</a> currentLevel, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt; &gt; &amp;loops)</td></tr>
<tr class="memdesc:aa0aaf4fbfeafbb9d5fdcd1a83cd4c6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive implementation to convert all the nested loops in 'match' to a 2D vector container that preserves the relative nesting level of each loop with respect to the others in 'match'.  <br /></td></tr>
<tr class="memitem:a98fa2c9dc47102ea22f3910d60d0e498" id="r_a98fa2c9dc47102ea22f3910d60d0e498"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98fa2c9dc47102ea22f3910d60d0e498">getMatchedAffineLoops</a> (<a class="el" href="classmlir_1_1affine_1_1NestedMatch.html">NestedMatch</a> match, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt; &gt; &amp;loops)</td></tr>
<tr class="memdesc:a98fa2c9dc47102ea22f3910d60d0e498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts all the nested loops in 'match' to a 2D vector container that preserves the relative nesting level of each loop with respect to the others in 'match'.  <br /></td></tr>
<tr class="memitem:a5e46021ebbae2e68b6467ec7d4f7ca5f" id="r_a5e46021ebbae2e68b6467ec7d4f7ca5f"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e46021ebbae2e68b6467ec7d4f7ca5f">vectorizeLoopNest</a> (std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt; &gt; &amp;loops, const VectorizationStrategy &amp;strategy)</td></tr>
<tr class="memdesc:a5e46021ebbae2e68b6467ec7d4f7ca5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementation to vectorize affine loops from a single loop nest using an n-D vectorization strategy.  <br /></td></tr>
<tr class="memitem:a1efda1293ff3efde069d8aa8fd0453f5" id="r_a1efda1293ff3efde069d8aa8fd0453f5"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1efda1293ff3efde069d8aa8fd0453f5">vectorizeRootMatch</a> (<a class="el" href="classmlir_1_1affine_1_1NestedMatch.html">NestedMatch</a> m, const VectorizationStrategy &amp;strategy)</td></tr>
<tr class="memdesc:a1efda1293ff3efde069d8aa8fd0453f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the matched loops and vectorizes them following a topological order.  <br /></td></tr>
<tr class="memitem:ada8c6524ef34ad615a28bdcd605bfd20" id="r_ada8c6524ef34ad615a28bdcd605bfd20"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada8c6524ef34ad615a28bdcd605bfd20">computeIntersectionBuckets</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1affine_1_1NestedMatch.html">NestedMatch</a> &gt; matches, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1affine_1_1NestedMatch.html">NestedMatch</a>, 8 &gt; &gt; &amp;intersectionBuckets)</td></tr>
<tr class="memdesc:ada8c6524ef34ad615a28bdcd605bfd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses all the loop matches and classifies them into intersection buckets.  <br /></td></tr>
<tr class="memitem:ac6e11df45c7e1cf41950932f9c79ce84" id="r_ac6e11df45c7e1cf41950932f9c79ce84"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6e11df45c7e1cf41950932f9c79ce84">vectorizeLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *parentOp, <a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; vectorSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; fastestVaryingPattern, const <a class="el" href="namespacemlir_1_1affine.html#a0e3d2cec8b9f06af928ef8b6fe719bc2">ReductionLoopMap</a> &amp;reductionLoops)</td></tr>
<tr class="memdesc:ac6e11df45c7e1cf41950932f9c79ce84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementation to vectorize affine loops in 'loops' using the n-D vectorization factors in 'vectorSizes'.  <br /></td></tr>
<tr class="memitem:a3b2bc8ae63139c1937254e1e3f6557c0" id="r_a3b2bc8ae63139c1937254e1e3f6557c0"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b2bc8ae63139c1937254e1e3f6557c0">verifyLoopNesting</a> (const std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt; &gt; &amp;loops)</td></tr>
<tr class="memdesc:a3b2bc8ae63139c1937254e1e3f6557c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that affine loops in 'loops' meet the nesting criteria expected by SuperVectorizer:  <br /></td></tr>
</table>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&#160;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;early-vect&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a high-level vectorization strategy on a Function. </p>
<p>The abstraction used is that of super-vectors, which provide a single, compact, representation in the vector types, information that is expected to reduce the impact of the phase ordering problem</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md38"></a>
Vector granularity:</h1>
<p>This pass is designed to perform vectorization at a super-vector granularity. A super-vector is loosely defined as a vector type that is a multiple of a "good" vector size so the HW can efficiently implement a set of high-level primitives. Multiple is understood along any dimension; e.g. both <a class="el" href="namespacemlir_1_1vector.html">vector&lt;16xf32&gt;</a> and <a class="el" href="namespacemlir_1_1vector.html">vector&lt;2x8xf32&gt;</a> are valid super-vectors for a <a class="el" href="namespacemlir_1_1vector.html">vector&lt;8xf32&gt;</a> HW vector. Note that a "good vector size so the HW can
    efficiently implement a set of high-level primitives" is not necessarily an integer multiple of actual hardware registers. We leave details of this distinction unspecified for now.</p>
<p>Some may prefer the terminology a "tile of HW vectors". In this case, one should note that super-vectors implement an "always full tile" abstraction. They guarantee no partial-tile separation is necessary by relying on a high-level copy-reshape abstraction that we call vector.transfer. This copy-reshape operations is also responsible for performing layout transposition if necessary. In the general case this will require a scoped allocation in some notional local memory.</p>
<p>Whatever the mental model one prefers to use for this abstraction, the key point is that we burn into a single, compact, representation in the vector types, information that is expected to reduce the impact of the phase ordering problem. Indeed, a vector type conveys information that:</p><ol type="1">
<li>the associated loops have dependency semantics that do not prevent vectorization;</li>
<li>the associate loops have been sliced in chunks of static sizes that are compatible with vector sizes (i.e. similar to unroll-and-jam);</li>
<li>the inner loops, in the unroll-and-jam analogy of 2, are captured by the vector type and no vectorization hampering transformations can be applied to them anymore;</li>
<li>the underlying memrefs are accessed in some notional contiguous way that allows loading into vectors with some amount of spatial locality; In other words, super-vectorization provides a level of separation of concern by way of opacity to subsequent passes. This has the effect of encapsulating and propagating vectorization constraints down the list of passes until we are ready to lower further.</li>
</ol>
<p>For a particular target, a notion of minimal n-d vector size will be specified and vectorization targets a multiple of those. In the following paragraph, let "k ." represent "a multiple of", to be understood as a multiple in the same dimension (e.g. <a class="el" href="namespacemlir_1_1vector.html">vector&lt;16 x k . 128&gt;</a> summarizes <a class="el" href="namespacemlir_1_1vector.html">vector&lt;16 x 128&gt;</a>, <a class="el" href="namespacemlir_1_1vector.html">vector&lt;16 x 256&gt;</a>, <a class="el" href="namespacemlir_1_1vector.html">vector&lt;16 x 1024&gt;</a>, etc).</p>
<p>Some non-exhaustive notable super-vector sizes of interest include:</p><ul>
<li>CPU: <a class="el" href="namespacemlir_1_1vector.html">vector&lt;k . HW_vector_size&gt;</a>, vector&lt;k' . core_count x k . HW_vector_size&gt;, vector&lt;socket_count x k' . core_count x k . HW_vector_size&gt;;</li>
<li>GPU: <a class="el" href="namespacemlir_1_1vector.html">vector&lt;k . warp_size&gt;</a>, <a class="el" href="namespacemlir_1_1vector.html">vector&lt;k . warp_size x float2&gt;</a>, <a class="el" href="namespacemlir_1_1vector.html">vector&lt;k . warp_size x float4&gt;</a>, <a class="el" href="namespacemlir_1_1vector.html">vector&lt;k . warp_size x 4 x 4x 4&gt;</a> (for tensor_core sizes).</li>
</ul>
<p><a class="el" href="namespacemlir.html#aed48aeaaa3484827b729cced4fb0dfb6" title="Tile a nest of standard for loops rooted at rootForOp by finding such parametric tile sizes that the ...">Loops</a> and operations are emitted that operate on those super-vector shapes. Subsequent lowering passes will materialize to actual HW vector sizes. These passes are expected to be (gradually) more target-specific.</p>
<p>At a high level, a vectorized load in a loop will resemble: </p><div class="fragment"><div class="line">affine.for %i = ? to ? step ? {</div>
<div class="line">  %v_a = vector.transfer_read A[%i] : memref&lt;?xf32&gt;, vector&lt;128xf32&gt;</div>
<div class="line">}</div>
</div><!-- fragment --><p> It is the responsibility of the implementation of vector.transfer_read to materialize vector registers from the original scalar memrefs. A later (more target-dependent) lowering pass will materialize to actual HW vector sizes. This lowering may be occur at different times:</p><ol type="1">
<li>at the MLIR level into a combination of loops, unrolling, DmaStartOp + DmaWaitOp + vectorized operations for data transformations and shuffle; thus opening opportunities for unrolling and pipelining. This is an instance of library call "whiteboxing"; or</li>
<li>later in the a target-specific lowering pass or hand-written library call; achieving full separation of concerns. This is an instance of library call; or</li>
<li>a mix of both, e.g. based on a model. In the future, these operations will expose a contract to constrain the search on vectorization patterns and sizes.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md39"></a>
Occurrence of super-vectorization in the compiler flow:</h1>
<p>This is an active area of investigation. We start with 2 remarks to position super-vectorization in the context of existing ongoing work: <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> VPLAN and <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> SLP Vectorizer.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md40"></a>
LLVM VPLAN:</h2>
<p>The astute reader may have noticed that in the limit, super-vectorization can be applied at a similar time and with similar objectives than VPLAN. For instance, in the case of a traditional, polyhedral compilation-flow (for instance, the PPCG project uses ISL to provide dependence analysis, multi-level(scheduling + tiling), lifting footprint to fast memory, communication synthesis, mapping, register optimizations) and before unrolling. When vectorization is applied at this <em>late</em> level in a typical polyhedral flow, and is instantiated with actual hardware vector sizes, super-vectorization is expected to match (or subsume) the type of patterns that <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>'s VPLAN aims at targeting. The main difference here is that MLIR is higher level and our implementation should be significantly simpler. Also note that in this mode, recursive patterns are probably a bit of an overkill although it is reasonable to expect that mixing a bit of outer loop and inner loop vectorization + unrolling will provide interesting choices to MLIR.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md41"></a>
LLVM SLP Vectorizer:</h2>
<p>Super-vectorization however is not meant to be usable in a similar fashion to the SLP vectorizer. The main difference lies in the information that both vectorizers use: super-vectorization examines contiguity of memory references along fastest varying dimensions and loops with recursive nested patterns capturing imperfectly-nested loop nests; the SLP vectorizer, on the other hand, performs flat pattern matching inside a single unrolled loop body and stitches together pieces of load and store operations into full 1-D vectors. We envision that the SLP vectorizer is a good way to capture innermost loop, control-flow dependent patterns that super-vectorization may not be able to capture easily. In other words, super-vectorization does not aim at replacing the SLP vectorizer and the two solutions are complementary.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md42"></a>
Ongoing investigations:</h2>
<p>We discuss the following <em>early</em> places where super-vectorization is applicable and touch on the expected benefits and risks . We list the opportunities in the context of the traditional polyhedral compiler flow described in PPCG. There are essentially 6 places in the MLIR pass pipeline we expect to experiment with super-vectorization:</p><ol type="1">
<li>Right after language lowering to MLIR: this is the earliest time where super-vectorization is expected to be applied. At this level, all the language/user/library-level annotations are available and can be fully exploited. Examples include loop-type annotations (such as parallel, reduction, scan, dependence distance vector, vectorizable) as well as memory access annotations (such as non-aliasing writes guaranteed, indirect accesses that are permutations by construction) accesses or that a particular operation is prescribed atomic by the user. At this level, anything that enriches what dependence analysis can do should be aggressively exploited. At this level we are close to having explicit vector types in the language, except we do not impose that burden on the programmer/library: we derive information from scalar code + annotations.</li>
<li>After dependence analysis and before polyhedral scheduling: the information that supports vectorization does not need to be supplied by a higher level of abstraction. Traditional dependence analysis is available in MLIR and will be used to drive vectorization and cost models.</li>
</ol>
<p>Let's pause here and remark that applying super-vectorization as described in 1. and 2. presents clear opportunities and risks:</p><ul>
<li>the opportunity is that vectorization is burned in the type system and is protected from the adverse effect of loop scheduling, tiling, loop interchange and all passes downstream. Provided that subsequent passes are able to operate on vector types; the vector shapes, associated loop iterator properties, alignment, and contiguity of fastest varying dimensions are preserved until we lower the super-vector types. We expect this to significantly rein in on the adverse effects of phase ordering.</li>
<li>the risks are that a. all passes after super-vectorization have to work on elemental vector types (not that this is always true, wherever vectorization is applied) and b. that imposing vectorization constraints too early may be overall detrimental to loop fusion, tiling and other transformations because the dependence distances are coarsened when operating on elemental vector types. For this reason, the pattern profitability analysis should include a component that also captures the maximal amount of fusion available under a particular pattern. This is still at the stage of rough ideas but in this context, search is our friend as the Tensor Comprehensions and auto-TVM contributions demonstrated previously. Bottom-line is we do not yet have good answers for the above but aim at making it easy to answer such questions.</li>
</ul>
<p>Back to our listing, the last places where early super-vectorization makes sense are:</p><ol type="1">
<li>right after polyhedral-style scheduling: PLUTO-style algorithms are known to improve locality, parallelism and be configurable (e.g. max-fuse, smart-fuse etc). They can also have adverse effects on contiguity properties that are required for vectorization but the vector.transfer copy-reshape-pad-transpose abstraction is expected to help recapture these properties.</li>
<li>right after polyhedral-style scheduling+tiling;</li>
<li>right after scheduling+tiling+rescheduling: points 4 and 5 represent probably the most promising places because applying tiling achieves a separation of concerns that allows rescheduling to worry less about locality and more about parallelism and distribution (e.g. min-fuse).</li>
</ol>
<p>At these levels the risk-reward looks different: on one hand we probably lost a good deal of language/user/library-level annotation; on the other hand we gained parallelism and locality through scheduling and tiling. However we probably want to ensure tiling is compatible with the full-tile-only abstraction used in super-vectorization or suffer the consequences. It is too early to place bets on what will win but we expect super-vectorization to be the right abstraction to allow exploring at all these levels. And again, search is our friend.</p>
<p>Lastly, we mention it again here:</p><ol type="1">
<li>as a MLIR-based alternative to VPLAN.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md43"></a>
Lowering, unrolling, pipelining:</h1>
<p>TODO: point to the proper places.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md44"></a>
Algorithm:</h1>
<p>The algorithm proceeds in a few steps:</p><ol type="1">
<li>defining super-vectorization patterns and matching them on the tree of AffineForOp. A super-vectorization pattern is defined as a recursive data structures that matches and captures nested, imperfectly-nested loops that have a. conformable loop annotations attached (e.g. parallel, reduction, vectorizable, ...) as well as b. all contiguous load/store operations along a specified minor dimension (not necessarily the fastest varying) ;</li>
<li>analyzing those patterns for profitability (TODO: and interference);</li>
<li>then, for each pattern in order: a. applying iterative rewriting of the loops and all their nested operations in topological order. Rewriting is implemented by coarsening the loops and converting operations and operands to their vector forms. Processing operations in topological order is relatively simple due to the structured nature of the control-flow representation. This order ensures that all the operands of a given operation have been vectorized before the operation itself in a single traversal, except for operands defined outside of the loop nest. The algorithm can convert the following operations to their vector form:<ul>
<li>Affine load and store operations are converted to opaque vector transfer read and write operations.</li>
<li>Scalar constant operations/operands are converted to vector constant operations (splat).</li>
<li>Uniform operands (only induction variables of loops not mapped to a vector dimension, or operands defined outside of the loop nest for now) are broadcasted to a vector. TODO: Support more uniform cases.</li>
<li>Affine for operations with 'iter_args' are vectorized by vectorizing their 'iter_args' operands and results. TODO: Support more complex loops with divergent lbs and/or ubs.</li>
<li>The remaining operations in the loop nest are vectorized by widening their scalar types to vector types. b. if everything under the root AffineForOp in the current pattern is vectorized properly, we commit that loop to the IR and remove the scalar loop. Otherwise, we discard the vectorized loop and keep the original scalar loop. c. vectorization is applied on the next pattern in the list. Because pattern interference avoidance is not yet implemented and that we do not support further vectorizing an already vector load we need to re-verify that the pattern is still vectorizable. This is expected to make cost models more difficult to write and is subject to improvement in the future.</li>
</ul>
</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md45"></a>
Choice of loop transformation to support the algorithm:</h1>
<p>The choice of loop transformation to apply for coarsening vectorized loops is still subject to exploratory tradeoffs. In particular, say we want to vectorize by a factor 128, we want to transform the following input: </p><div class="fragment"><div class="line">affine.for %i = %M to %N {</div>
<div class="line">  %a = affine.load %A[%i] : memref&lt;?xf32&gt;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Traditionally, one would vectorize late (after scheduling, tiling, memory promotion etc) say after stripmining (and potentially unrolling in the case of <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>'s SLP vectorizer): </p><div class="fragment"><div class="line">affine.for %i = floor(%M, 128) to ceil(%N, 128) {</div>
<div class="line">  affine.for %ii = max(%M, 128 * %i) to min(%N, 128*%i + 127) {</div>
<div class="line">    %a = affine.load %A[%ii] : memref&lt;?xf32&gt;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Instead, we seek to vectorize early and freeze vector types before scheduling, so we want to generate a pattern that resembles: </p><div class="fragment"><div class="line">affine.for %i = ? to ? step ? {</div>
<div class="line">  %v_a = vector.transfer_read %A[%i] : memref&lt;?xf32&gt;, vector&lt;128xf32&gt;</div>
<div class="line">}</div>
</div><!-- fragment --><p>i. simply dividing the lower / upper bounds by 128 creates issues when representing expressions such as ii + 1 because now we only have access to original values that have been divided. Additional information is needed to specify accesses at below-128 granularity; ii. another alternative is to coarsen the loop step but this may have consequences on dependence analysis and fusability of loops: fusable loops probably need to have the same step (because we don't want to stripmine/unroll to enable fusion). As a consequence, we choose to represent the coarsening using the loop step for now and reevaluate in the future. Note that we can renormalize loop steps later if/when we have evidence that they are problematic.</p>
<p>For the simple strawman example above, vectorizing for a 1-D vector abstraction of size 128 returns code similar to: </p><div class="fragment"><div class="line">affine.for %i = %M to %N step 128 {</div>
<div class="line">  %v_a = vector.transfer_read %A[%i] : memref&lt;?xf32&gt;, vector&lt;128xf32&gt;</div>
<div class="line">}</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md46"></a>
Unsupported cases, extensions, and work in progress (help welcome :-) ):</h1>
<ol type="1">
<li>lowering to concrete vector types for various HW;</li>
<li>reduction support for n-D vectorization and non-unit steps;</li>
<li>non-effecting padding during vector.transfer_read and filter during vector.transfer_write;</li>
<li>misalignment support vector.transfer_read / vector.transfer_write (hopefully without read-modify-writes);</li>
<li>control-flow support;</li>
<li>cost-models, heuristics and search;</li>
<li><a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a> implementation, extensions and implication on memref views;</li>
<li>many TODOs left around.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md47"></a>
Examples:</h1>
<p>Consider the following Function: </p><div class="fragment"><div class="line">func @vector_add_2d(%M : index, %N : index) -&gt; f32 {</div>
<div class="line">  %A = alloc (%M, %N) : memref&lt;?x?xf32, 0&gt;</div>
<div class="line">  %B = alloc (%M, %N) : memref&lt;?x?xf32, 0&gt;</div>
<div class="line">  %C = alloc (%M, %N) : memref&lt;?x?xf32, 0&gt;</div>
<div class="line">  %f1 = arith.constant 1.0 : f32</div>
<div class="line">  %f2 = arith.constant 2.0 : f32</div>
<div class="line">  affine.for %i0 = 0 to %M {</div>
<div class="line">    affine.for %i1 = 0 to %N {</div>
<div class="line">      // non-scoped %f1</div>
<div class="line">      affine.store %f1, %A[%i0, %i1] : memref&lt;?x?xf32, 0&gt;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  affine.for %i2 = 0 to %M {</div>
<div class="line">    affine.for %i3 = 0 to %N {</div>
<div class="line">      // non-scoped %f2</div>
<div class="line">      affine.store %f2, %B[%i2, %i3] : memref&lt;?x?xf32, 0&gt;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  affine.for %i4 = 0 to %M {</div>
<div class="line">    affine.for %i5 = 0 to %N {</div>
<div class="line">      %a5 = affine.load %A[%i4, %i5] : memref&lt;?x?xf32, 0&gt;</div>
<div class="line">      %b5 = affine.load %B[%i4, %i5] : memref&lt;?x?xf32, 0&gt;</div>
<div class="line">      %s5 = arith.addf %a5, %b5 : f32</div>
<div class="line">      // non-scoped %f1</div>
<div class="line">      %s6 = arith.addf %s5, %f1 : f32</div>
<div class="line">      // non-scoped %f2</div>
<div class="line">      %s7 = arith.addf %s5, %f2 : f32</div>
<div class="line">      // diamond dependency.</div>
<div class="line">      %s8 = arith.addf %s7, %s6 : f32</div>
<div class="line">      affine.store %s8, %C[%i4, %i5] : memref&lt;?x?xf32, 0&gt;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  %c7 = arith.constant 7 : index</div>
<div class="line">  %c42 = arith.constant 42 : index</div>
<div class="line">  %res = load %C[%c7, %c42] : memref&lt;?x?xf32, 0&gt;</div>
<div class="line">  return %res : f32</div>
<div class="line">}</div>
</div><!-- fragment --><p>The -affine-super-vectorize pass with the following arguments: </p><div class="fragment"><div class="line">-<a class="code hl_namespace" href="namespacemlir_1_1affine.html">affine</a>-super-vectorize=<span class="stringliteral">&quot;virtual-vector-size=256 test-fastest-varying=0&quot;</span></div>
<div class="ttc" id="anamespacemlir_1_1affine_html"><div class="ttname"><a href="namespacemlir_1_1affine.html">mlir::affine</a></div><div class="ttdef"><b>Definition</b> <a href="AffineToStandard_8h_source.html#l00023">AffineToStandard.h:23</a></div></div>
</div><!-- fragment --><p>produces this standard innermost-loop vectorized code: </p><div class="fragment"><div class="line">func @vector_add_2d(%arg0 : index, %arg1 : index) -&gt; f32 {</div>
<div class="line">  %0 = memref.alloc(%arg0, %arg1) : memref&lt;?x?xf32&gt;</div>
<div class="line">  %1 = memref.alloc(%arg0, %arg1) : memref&lt;?x?xf32&gt;</div>
<div class="line">  %2 = memref.alloc(%arg0, %arg1) : memref&lt;?x?xf32&gt;</div>
<div class="line">  %cst = arith.constant 1.0 : f32</div>
<div class="line">  %cst_0 = arith.constant 2.0 : f32</div>
<div class="line">  affine.for %i0 = 0 to %arg0 {</div>
<div class="line">    affine.for %i1 = 0 to %arg1 step 256 {</div>
<div class="line">      %cst_1 = arith.constant dense&lt;vector&lt;256xf32&gt;, 1.0&gt; :</div>
<div class="line">               vector&lt;256xf32&gt;</div>
<div class="line">      vector.transfer_write %cst_1, %0[%i0, %i1] :</div>
<div class="line">               vector&lt;256xf32&gt;, memref&lt;?x?xf32&gt;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  affine.for %i2 = 0 to %arg0 {</div>
<div class="line">    affine.for %i3 = 0 to %arg1 step 256 {</div>
<div class="line">      %cst_2 = arith.constant dense&lt;vector&lt;256xf32&gt;, 2.0&gt; :</div>
<div class="line">               vector&lt;256xf32&gt;</div>
<div class="line">      vector.transfer_write %cst_2, %1[%i2, %i3] :</div>
<div class="line">               vector&lt;256xf32&gt;, memref&lt;?x?xf32&gt;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  affine.for %i4 = 0 to %arg0 {</div>
<div class="line">    affine.for %i5 = 0 to %arg1 step 256 {</div>
<div class="line">      %3 = vector.transfer_read %0[%i4, %i5] :</div>
<div class="line">           memref&lt;?x?xf32&gt;, vector&lt;256xf32&gt;</div>
<div class="line">      %4 = vector.transfer_read %1[%i4, %i5] :</div>
<div class="line">           memref&lt;?x?xf32&gt;, vector&lt;256xf32&gt;</div>
<div class="line">      %5 = arith.addf %3, %4 : vector&lt;256xf32&gt;</div>
<div class="line">      %cst_3 = arith.constant dense&lt;vector&lt;256xf32&gt;, 1.0&gt; :</div>
<div class="line">               vector&lt;256xf32&gt;</div>
<div class="line">      %6 = arith.addf %5, %cst_3 : vector&lt;256xf32&gt;</div>
<div class="line">      %cst_4 = arith.constant dense&lt;vector&lt;256xf32&gt;, 2.0&gt; :</div>
<div class="line">               vector&lt;256xf32&gt;</div>
<div class="line">      %7 = arith.addf %5, %cst_4 : vector&lt;256xf32&gt;</div>
<div class="line">      %8 = arith.addf %7, %6 : vector&lt;256xf32&gt;</div>
<div class="line">      vector.transfer_write %8, %2[%i4, %i5] :</div>
<div class="line">               vector&lt;256xf32&gt;, memref&lt;?x?xf32&gt;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  %c7 = arith.constant 7 : index</div>
<div class="line">  %c42 = arith.constant 42 : index</div>
<div class="line">  %9 = load %2[%c7, %c42] : memref&lt;?x?xf32&gt;</div>
<div class="line">  return %9 : f32</div>
<div class="line">}</div>
</div><!-- fragment --><p>The -affine-super-vectorize pass with the following arguments: </p><div class="fragment"><div class="line">-<a class="code hl_namespace" href="namespacemlir_1_1affine.html">affine</a>-super-vectorize=<span class="stringliteral">&quot;virtual-vector-size=32,256 \</span></div>
<div class="line"><span class="stringliteral">                         test-fastest-varying=1,0&quot;</span></div>
</div><!-- fragment --><p>produces this more interesting mixed outer-innermost-loop vectorized code: </p><div class="fragment"><div class="line">func @vector_add_2d(%arg0 : index, %arg1 : index) -&gt; f32 {</div>
<div class="line">  %0 = memref.alloc(%arg0, %arg1) : memref&lt;?x?xf32&gt;</div>
<div class="line">  %1 = memref.alloc(%arg0, %arg1) : memref&lt;?x?xf32&gt;</div>
<div class="line">  %2 = memref.alloc(%arg0, %arg1) : memref&lt;?x?xf32&gt;</div>
<div class="line">  %cst = arith.constant 1.0 : f32</div>
<div class="line">  %cst_0 = arith.constant 2.0 : f32</div>
<div class="line">  affine.for %i0 = 0 to %arg0 step 32 {</div>
<div class="line">    affine.for %i1 = 0 to %arg1 step 256 {</div>
<div class="line">      %cst_1 = arith.constant dense&lt;vector&lt;32x256xf32&gt;, 1.0&gt; :</div>
<div class="line">               vector&lt;32x256xf32&gt;</div>
<div class="line">      vector.transfer_write %cst_1, %0[%i0, %i1] :</div>
<div class="line">               vector&lt;32x256xf32&gt;, memref&lt;?x?xf32&gt;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  affine.for %i2 = 0 to %arg0 step 32 {</div>
<div class="line">    affine.for %i3 = 0 to %arg1 step 256 {</div>
<div class="line">      %cst_2 = arith.constant dense&lt;vector&lt;32x256xf32&gt;, 2.0&gt; :</div>
<div class="line">               vector&lt;32x256xf32&gt;</div>
<div class="line">      vector.transfer_write %cst_2, %1[%i2, %i3] :</div>
<div class="line">               vector&lt;32x256xf32&gt;, memref&lt;?x?xf32&gt;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  affine.for %i4 = 0 to %arg0 step 32 {</div>
<div class="line">    affine.for %i5 = 0 to %arg1 step 256 {</div>
<div class="line">      %3 = vector.transfer_read %0[%i4, %i5] :</div>
<div class="line">               memref&lt;?x?xf32&gt; vector&lt;32x256xf32&gt;</div>
<div class="line">      %4 = vector.transfer_read %1[%i4, %i5] :</div>
<div class="line">               memref&lt;?x?xf32&gt;, vector&lt;32x256xf32&gt;</div>
<div class="line">      %5 = arith.addf %3, %4 : vector&lt;32x256xf32&gt;</div>
<div class="line">      %cst_3 = arith.constant dense&lt;vector&lt;32x256xf32&gt;, 1.0&gt; :</div>
<div class="line">               vector&lt;32x256xf32&gt;</div>
<div class="line">      %6 = arith.addf %5, %cst_3 : vector&lt;32x256xf32&gt;</div>
<div class="line">      %cst_4 = arith.constant dense&lt;vector&lt;32x256xf32&gt;, 2.0&gt; :</div>
<div class="line">               vector&lt;32x256xf32&gt;</div>
<div class="line">      %7 = arith.addf %5, %cst_4 : vector&lt;32x256xf32&gt;</div>
<div class="line">      %8 = arith.addf %7, %6 : vector&lt;32x256xf32&gt;</div>
<div class="line">      vector.transfer_write %8, %2[%i4, %i5] :</div>
<div class="line">               vector&lt;32x256xf32&gt;, memref&lt;?x?xf32&gt;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  %c7 = arith.constant 7 : index</div>
<div class="line">  %c42 = arith.constant 42 : index</div>
<div class="line">  %9 = load %2[%c7, %c42] : memref&lt;?x?xf32&gt;</div>
<div class="line">  return %9 : f32</div>
<div class="line">}</div>
</div><!-- fragment --><p>Of course, much more intricate n-D imperfectly-nested patterns can be vectorized too and specified in a fully declarative fashion.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md48"></a>
Reduction:</h1>
<p>Vectorizing reduction loops along the reduction dimension is supported if:</p><ul>
<li>the reduction kind is supported,</li>
<li>the vectorization is 1-D, and</li>
<li>the step size of the loop equals to one.</li>
</ul>
<p>Comparing to the non-vector-dimension case, two additional things are done during vectorization of such loops:</p><ul>
<li>The resulting vector returned from the loop is reduced to a scalar using <span class="tt">vector.reduce</span>.</li>
<li>In some cases a mask is applied to the vector yielded at the end of the loop to prevent garbage values from being written to the accumulator.</li>
</ul>
<p>Reduction vectorization is switched off by default, it can be enabled by passing a map from loops to reductions to utility functions, or by passing <span class="tt">vectorize-reductions=true</span> to the vectorization pass.</p>
<p>Consider the following example: </p><div class="fragment"><div class="line">func @vecred(%in: memref&lt;512xf32&gt;) -&gt; f32 {</div>
<div class="line">  %cst = arith.constant 0.000000e+00 : f32</div>
<div class="line">  %sum = affine.for %i = 0 to 500 iter_args(%part_sum = %cst) -&gt; (f32) {</div>
<div class="line">    %ld = affine.load %in[%i] : memref&lt;512xf32&gt;</div>
<div class="line">    %cos = math.cos %ld : f32</div>
<div class="line">    %add = arith.addf %part_sum, %cos : f32</div>
<div class="line">    affine.yield %add : f32</div>
<div class="line">  }</div>
<div class="line">  return %sum : f32</div>
<div class="line">}</div>
</div><!-- fragment --><p>The -affine-super-vectorize pass with the following arguments: </p><div class="fragment"><div class="line">-<a class="code hl_namespace" href="namespacemlir_1_1affine.html">affine</a>-super-vectorize=<span class="stringliteral">&quot;virtual-vector-size=128 test-fastest-varying=0 \</span></div>
<div class="line"><span class="stringliteral">                         vectorize-reductions=true&quot;</span></div>
</div><!-- fragment --><p> produces the following output: </p><div class="fragment"><div class="line">#map = affine_map&lt;(d0) -&gt; (-d0 + 500)&gt;</div>
<div class="line">func @vecred(%arg0: memref&lt;512xf32&gt;) -&gt; f32 {</div>
<div class="line">  %cst = arith.constant 0.000000e+00 : f32</div>
<div class="line">  %cst_0 = arith.constant dense&lt;0.000000e+00&gt; : vector&lt;128xf32&gt;</div>
<div class="line">  %0 = affine.for %arg1 = 0 to 500 step 128 iter_args(%arg2 = %cst_0)</div>
<div class="line">          -&gt; (vector&lt;128xf32&gt;) {</div>
<div class="line">    // %2 is the number of iterations left in the original loop.</div>
<div class="line">    %2 = affine.apply #map(%arg1)</div>
<div class="line">    %3 = vector.create_mask %2 : vector&lt;128xi1&gt;</div>
<div class="line">    %cst_1 = arith.constant 0.000000e+00 : f32</div>
<div class="line">    %4 = vector.transfer_read %arg0[%arg1], %cst_1 :</div>
<div class="line">                    memref&lt;512xf32&gt;, vector&lt;128xf32&gt;</div>
<div class="line">    %5 = math.cos %4 : vector&lt;128xf32&gt;</div>
<div class="line">    %6 = arith.addf %arg2, %5 : vector&lt;128xf32&gt;</div>
<div class="line">    // We filter out the effect of last 12 elements using the mask.</div>
<div class="line">    %7 = select %3, %6, %arg2 : vector&lt;128xi1&gt;, vector&lt;128xf32&gt;</div>
<div class="line">    affine.yield %7 : vector&lt;128xf32&gt;</div>
<div class="line">  }</div>
<div class="line">  %1 = vector.reduction &lt;add&gt;, %0 : vector&lt;128xf32&gt; into f32</div>
<div class="line">  return %1 : f32</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that because of loop misalignment we needed to apply a mask to prevent last 12 elements from affecting the final result. The mask is full of ones in every iteration except for the last one, in which it has the form <span class="tt">11...100...0</span> with 116 ones and 12 zeros. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l00575">575</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

</div>
</div>
<a id="acaee4b386ba2945c1ace21ad8ecbac73" name="acaee4b386ba2945c1ace21ad8ecbac73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaee4b386ba2945c1ace21ad8ecbac73">&#9670;&#160;</a></span>GEN_PASS_DEF_AFFINEVECTORIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEN_PASS_DEF_AFFINEVECTORIZE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l00035">35</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a7b753fbff5d2aa2f6353b3ab53c4dcc6" name="a7b753fbff5d2aa2f6353b3ab53c4dcc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b753fbff5d2aa2f6353b3ab53c4dcc6">&#9670;&#160;</a></span>analyzeProfitability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult analyzeProfitability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1affine_1_1NestedMatch.html">NestedMatch</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>matches</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>depthInPattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>patternDepth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorizationStrategy *</td>          <td class="paramname"><span class="paramname"><em>strategy</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements a simple strawman strategy for vectorization. </p>
<p>Given a matched pattern <span class="tt">matches</span> of depth <span class="tt">patternDepth</span>, this strategy greedily assigns the fastest varying dimension ** of the vector ** to the innermost loop in the pattern. When coupled with a pattern that looks for the fastest varying dimension in load/store MemRefs, this creates a generic vectorization strategy that works for any loop in a hierarchy (outermost, innermost or intermediate).</p>
<p>TODO: In the future we should additionally increase the power of the profitability analysis along 3 directions:</p><ol type="1">
<li>account for loop extents (both static and parametric + annotations);</li>
<li>account for data layout permutations;</li>
<li>account for impact of vectorization on maximal loop fusion. Then we can quantify the above to build a cost model and search over strategies. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l00657">657</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="SuperVectorize_8cpp_source.html#l00657">analyzeProfitability()</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l00629">vectorizeLoopIfProfitable()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l00657">analyzeProfitability()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01721">vectorizeLoops()</a>.</p>

</div>
</div>
<a id="ada8c6524ef34ad615a28bdcd605bfd20" name="ada8c6524ef34ad615a28bdcd605bfd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8c6524ef34ad615a28bdcd605bfd20">&#9670;&#160;</a></span>computeIntersectionBuckets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> computeIntersectionBuckets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1affine_1_1NestedMatch.html">NestedMatch</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>matches</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1affine_1_1NestedMatch.html">NestedMatch</a>, 8 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>intersectionBuckets</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverses all the loop matches and classifies them into intersection buckets. </p>
<p>Two matches intersect if any of them encloses the other one. A match intersects with a bucket if the match intersects with the root (outermost) loop in that bucket. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01677">1677</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01721">vectorizeLoops()</a>.</p>

</div>
</div>
<a id="ad765b0b8701a0ac063c727bf0915573c" name="ad765b0b8701a0ac063c727bf0915573c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad765b0b8701a0ac063c727bf0915573c">&#9670;&#160;</a></span>computeMemoryOpIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> computeMemoryOpIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>mapOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>results</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l00901">901</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01216">vectorizeAffineLoad()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01270">vectorizeAffineStore()</a>.</p>

</div>
</div>
<a id="ab277cf2afb2c993c7aeea818cf17c6a2" name="ab277cf2afb2c993c7aeea818cf17c6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab277cf2afb2c993c7aeea818cf17c6a2">&#9670;&#160;</a></span>createInitialVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arith::ConstantOp createInitialVector </td>
          <td>(</td>
          <td class="paramtype">arith::AtomicRMWKind</td>          <td class="paramname"><span class="paramname"><em>reductionKind</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>oldOperand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a constant vector filled with the neutral elements of the given reduction. </p>
<p>The scalar type of vector elements will be taken from <span class="tt">oldOperand</span>. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01000">1000</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>, <a class="el" href="Value_8cpp_source.html#l00024">mlir::Value::getLoc()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l00936">getVectorType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01332">vectorizeAffineForOp()</a>.</p>

</div>
</div>
<a id="ae0baa9b3816267713d213c61f49bc81c" name="ae0baa9b3816267713d213c61f49bc81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0baa9b3816267713d213c61f49bc81c">&#9670;&#160;</a></span>createMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> createMask </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>vecForOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a mask used to filter out garbage elements in the last iteration of unaligned loops. </p>
<p>If a mask is not required then <span class="tt">nullptr</span> is returned. The mask will be a vector of booleans representing meaningful vector elements in the current iteration. It is filled with ones for each iteration except for the last one, where it has the form <span class="tt">11...100...0</span> with the number of ones equal to the number of meaningful elements (i.e. the number of iterations that would be left in the original loop). </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01024">1024</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00364">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00067">mlir::Builder::getIntegerType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01416">mlir::affine::makeComposedAffineApply()</a>, and <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01332">vectorizeAffineForOp()</a>.</p>

</div>
</div>
<a id="a9091a26a4aeed73f007e1b9e5a0784ff" name="a9091a26a4aeed73f007e1b9e5a0784ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9091a26a4aeed73f007e1b9e5a0784ff">&#9670;&#160;</a></span>eraseLoopNest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> eraseLoopNest </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases a loop nest, including all its nested operations. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l00889">889</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01595">vectorizeLoopNest()</a>.</p>

</div>
</div>
<a id="a98fa2c9dc47102ea22f3910d60d0e498" name="a98fa2c9dc47102ea22f3910d60d0e498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98fa2c9dc47102ea22f3910d60d0e498">&#9670;&#160;</a></span>getMatchedAffineLoops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> getMatchedAffineLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1NestedMatch.html">NestedMatch</a></td>          <td class="paramname"><span class="paramname"><em>match</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts all the nested loops in 'match' to a 2D vector container that preserves the relative nesting level of each loop with respect to the others in 'match'. </p>
<p>This means that every loop in 'loops[i]' will have a parent loop in 'loops[i-1]'. A loop in 'loops[i]' may or may not have a child loop in 'loops[i+1]'. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01587">1587</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="SuperVectorize_8cpp_source.html#l01567">getMatchedAffineLoopsRec()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01666">vectorizeRootMatch()</a>.</p>

</div>
</div>
<a id="aa0aaf4fbfeafbb9d5fdcd1a83cd4c6b7" name="aa0aaf4fbfeafbb9d5fdcd1a83cd4c6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0aaf4fbfeafbb9d5fdcd1a83cd4c6b7">&#9670;&#160;</a></span>getMatchedAffineLoopsRec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> getMatchedAffineLoopsRec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1NestedMatch.html">NestedMatch</a></td>          <td class="paramname"><span class="paramname"><em>match</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>currentLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursive implementation to convert all the nested loops in 'match' to a 2D vector container that preserves the relative nesting level of each loop with respect to the others in 'match'. </p>
<p>'currentLevel' is the nesting level that will be assigned to the loop in the current 'match'. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01567">1567</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="SuperVectorize_8cpp_source.html#l01567">getMatchedAffineLoopsRec()</a>, <a class="el" href="NestedMatcher_8h_source.html#l00057">mlir::affine::NestedMatch::getMatchedChildren()</a>, and <a class="el" href="NestedMatcher_8h_source.html#l00056">mlir::affine::NestedMatch::getMatchedOperation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01587">getMatchedAffineLoops()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01567">getMatchedAffineLoopsRec()</a>.</p>

</div>
</div>
<a id="a92301bec02cb80bed5dfe59fef345e98" name="a92301bec02cb80bed5dfe59fef345e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92301bec02cb80bed5dfe59fef345e98">&#9670;&#160;</a></span>getVectorType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorType getVectorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>scalarTy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorizationStrategy *</td>          <td class="paramname"><span class="paramname"><em>strategy</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the vector type resulting from applying the provided vectorization strategy on the scalar type. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l00936">936</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01000">createInitialVector()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01114">vectorizeUniform()</a>.</p>

</div>
</div>
<a id="a879085552a185c778d775adbe1dcd187" name="a879085552a185c778d775adbe1dcd187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879085552a185c778d775adbe1dcd187">&#9670;&#160;</a></span>isIVMappedToMultipleIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isIVMappedToMultipleIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>loopToVectorDim</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if any vectorized loop IV drives more than one index. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01185">1185</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00308">mlir::affine::getInvariantAccesses()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01216">vectorizeAffineLoad()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01270">vectorizeAffineStore()</a>.</p>

</div>
</div>
<a id="a4c454b0e869a9101580a1a048d0cf5bb" name="a4c454b0e869a9101580a1a048d0cf5bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c454b0e869a9101580a1a048d0cf5bb">&#9670;&#160;</a></span>isNeutralElementConst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isNeutralElementConst </td>
          <td>(</td>
          <td class="paramtype">arith::AtomicRMWKind</td>          <td class="paramname"><span class="paramname"><em>reductionKind</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <span class="tt">value</span> is a constant equal to the neutral element of the given vectorizable reduction. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01314">1314</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8cpp_source.html#l00024">mlir::Value::getLoc()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01332">vectorizeAffineForOp()</a>.</p>

</div>
</div>
<a id="a8f5144f6d42a7c57e4c654f2812909b9" name="a8f5144f6d42a7c57e4c654f2812909b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5144f6d42a7c57e4c654f2812909b9">&#9670;&#160;</a></span>isUniformDefinition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isUniformDefinition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorizationStrategy *</td>          <td class="paramname"><span class="paramname"><em>strategy</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the provided value is vector uniform given the vectorization strategy. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01097">1097</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02938">mlir::affine::getForInductionVarOwner()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00120">mlir::Type::isIntOrIndexOrFloat()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01145">vectorizeOperand()</a>.</p>

</div>
</div>
<a id="a813fd50e431196fa605b66c4091cc5a4" name="a813fd50e431196fa605b66c4091cc5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813fd50e431196fa605b66c4091cc5a4">&#9670;&#160;</a></span>isVectorizableLoopPtrFactory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1affine.html#a7ac41cc03dea5e719278bacddd8f0829">FilterFunctionType</a> isVectorizableLoopPtrFactory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parallelLoops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fastestVaryingMemRefDimension</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward declaration. </p>
<p>Returns a <a class="el" href="namespacemlir_1_1affine.html#a7ac41cc03dea5e719278bacddd8f0829" title="A NestedPattern is a nested operation walker that:">FilterFunctionType</a> that can be used in <a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> to match a loop whose underlying load/store accesses are either invariant or all. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l00918">918</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l00589">makePattern()</a>.</p>

</div>
</div>
<a id="a1dc992b3e5eb40e467a0f5e364125b43" name="a1dc992b3e5eb40e467a0f5e364125b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc992b3e5eb40e467a0f5e364125b43">&#9670;&#160;</a></span>makePattern()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> &gt; makePattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parallelLoops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vectorRank</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>fastestVaryingPattern</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a vectorization pattern from the command line arguments. </p>
<p>Up to 3-D patterns are supported. If the command line argument requests a pattern of higher order, returns an empty pattern list which will conservatively result in no vectorization. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l00589">589</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="NestedMatcher_8cpp_source.html#l00157">mlir::affine::matcher::For()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l00918">isVectorizableLoopPtrFactory()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01721">vectorizeLoops()</a>.</p>

</div>
</div>
<a id="a76efdc273bcdca9c52f61b2ec21979ea" name="a76efdc273bcdca9c52f61b2ec21979ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76efdc273bcdca9c52f61b2ec21979ea">&#9670;&#160;</a></span>vectorizeAffineApplyOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * vectorizeAffineApplyOp </td>
          <td>(</td>
          <td class="paramtype">AffineApplyOp</td>          <td class="paramname"><span class="paramname"><em>applyOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We have no need to vectorize affine.apply. </p>
<p>However, we still need to generate it and replace the operands with values in valueScalarReplacement. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l00973">973</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01534">vectorizeOneOperation()</a>.</p>

</div>
</div>
<a id="a75edffd40fd0fb97877f5a93dec0c760" name="a75edffd40fd0fb97877f5a93dec0c760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75edffd40fd0fb97877f5a93dec0c760">&#9670;&#160;</a></span>vectorizeAffineForOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * vectorizeAffineForOp </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vectorizes a loop with the vectorization strategy in 'state'. </p>
<p>A new loop is created and registered as replacement for the scalar loop. The builder's insertion point is set to the new loop's body so that subsequent vectorized operations are inserted into the new loop. If the loop is a vector dimension, the step of the newly created loop will reflect the vectorization factor used to vectorized that dimension. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01332">1332</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="SuperVectorize_8cpp_source.html#l01000">createInitialVector()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01024">createMask()</a>, <a class="el" href="Value_8cpp_source.html#l00024">mlir::Value::getLoc()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02786">mlir::arith::getReductionOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00684">mlir::vector::getVectorReductionOp()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01314">isNeutralElementConst()</a>, <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01145">vectorizeOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01534">vectorizeOneOperation()</a>.</p>

</div>
</div>
<a id="a60db1ed05bddc04dde5968edf86e1c2e" name="a60db1ed05bddc04dde5968edf86e1c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60db1ed05bddc04dde5968edf86e1c2e">&#9670;&#160;</a></span>vectorizeAffineLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * vectorizeAffineLoad </td>
          <td>(</td>
          <td class="paramtype">AffineLoadOp</td>          <td class="paramname"><span class="paramname"><em>loadOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vectorizes an affine load with the vectorization strategy in 'state' by generating a 'vector.transfer_read' op with the proper permutation map inferred from the indices of the load. </p>
<p>The new 'vector.transfer_read' is registered as replacement of the scalar load. Returns the newly created 'vector.transfer_read' if vectorization was successful. Returns nullptr, otherwise. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01216">1216</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="SuperVectorize_8cpp_source.html#l00901">computeMemoryOpIndices()</a>, <a class="el" href="Builders_8h_source.html#l00442">mlir::OpBuilder::getInsertionBlock()</a>, <a class="el" href="Builders_8cpp_source.html#l00387">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01185">isIVMappedToMultipleIndices()</a>, and <a class="el" href="VectorUtils_8cpp_source.html#l00124">makePermutationMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01534">vectorizeOneOperation()</a>.</p>

</div>
</div>
<a id="ab93b499c7cf74433c36009ae0afc0e21" name="ab93b499c7cf74433c36009ae0afc0e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93b499c7cf74433c36009ae0afc0e21">&#9670;&#160;</a></span>vectorizeAffineStore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * vectorizeAffineStore </td>
          <td>(</td>
          <td class="paramtype">AffineStoreOp</td>          <td class="paramname"><span class="paramname"><em>storeOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vectorizes an affine store with the vectorization strategy in 'state' by generating a 'vector.transfer_write' op with the proper permutation map inferred from the indices of the store. </p>
<p>The new 'vector.transfer_store' is registered as replacement of the scalar load. Returns the newly created 'vector.transfer_write' if vectorization was successful. Returns nullptr, otherwise. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01270">1270</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="SuperVectorize_8cpp_source.html#l00901">computeMemoryOpIndices()</a>, <a class="el" href="Builders_8h_source.html#l00442">mlir::OpBuilder::getInsertionBlock()</a>, <a class="el" href="Builders_8cpp_source.html#l00387">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01185">isIVMappedToMultipleIndices()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00124">makePermutationMap()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01145">vectorizeOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01534">vectorizeOneOperation()</a>.</p>

</div>
</div>
<a id="aaf17657a99036f79b99980402798d753" name="aaf17657a99036f79b99980402798d753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf17657a99036f79b99980402798d753">&#9670;&#160;</a></span>vectorizeAffineYieldOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * vectorizeAffineYieldOp </td>
          <td>(</td>
          <td class="paramtype">AffineYieldOp</td>          <td class="paramname"><span class="paramname"><em>yieldOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vectorizes a yield operation by widening its types. </p>
<p>The builder's insertion point is set after the vectorized parent op to continue vectorizing the operations after the parent op. When vectorizing a reduction loop a mask may be used to prevent adding garbage values to the accumulator. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01486">1486</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00442">mlir::OpBuilder::getInsertionBlock()</a>, <a class="el" href="Value_8cpp_source.html#l00024">mlir::Value::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00346">mlir::Operation::getNumOperands()</a>, <a class="el" href="Block_8cpp_source.html#l00031">mlir::Block::getParentOp()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00290">mlir::matchReduction()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointAfter()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01454">widenOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01534">vectorizeOneOperation()</a>.</p>

</div>
</div>
<a id="a8d83e7c160ae10471fe0b50816b087a9" name="a8d83e7c160ae10471fe0b50816b087a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d83e7c160ae10471fe0b50816b087a9">&#9670;&#160;</a></span>vectorizeConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arith::ConstantOp vectorizeConstant </td>
          <td>(</td>
          <td class="paramtype">arith::ConstantOp</td>          <td class="paramname"><span class="paramname"><em>constOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to transform a scalar constant into a vector constant. </p>
<p>Returns the vector constant if the scalar type is valid vector element type. Returns nullptr, otherwise. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l00945">945</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01534">vectorizeOneOperation()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01145">vectorizeOperand()</a>.</p>

</div>
</div>
<a id="a2770a30614289df9645750217ed5b86e" name="a2770a30614289df9645750217ed5b86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2770a30614289df9645750217ed5b86e">&#9670;&#160;</a></span>vectorizeLoopIfProfitable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> vectorizeLoopIfProfitable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>loop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>depthInPattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>patternDepth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorizationStrategy *</td>          <td class="paramname"><span class="paramname"><em>strategy</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l00629">629</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l00657">analyzeProfitability()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01721">vectorizeLoops()</a>.</p>

</div>
</div>
<a id="a5e46021ebbae2e68b6467ec7d4f7ca5f" name="a5e46021ebbae2e68b6467ec7d4f7ca5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e46021ebbae2e68b6467ec7d4f7ca5f">&#9670;&#160;</a></span>vectorizeLoopNest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult vectorizeLoopNest </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorizationStrategy &amp;</td>          <td class="paramname"><span class="paramname"><em>strategy</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal implementation to vectorize affine loops from a single loop nest using an n-D vectorization strategy. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01595">1595</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00889">eraseLoopNest()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00473">mlir::affine::isVectorizableLoopBody()</a>, <a class="el" href="Visitors_8h_source.html#l00028">mlir::PreOrder</a>, <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointAfter()</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01534">vectorizeOneOperation()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l00611">vectorTransferPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01666">vectorizeRootMatch()</a>.</p>

</div>
</div>
<a id="ac6e11df45c7e1cf41950932f9c79ce84" name="ac6e11df45c7e1cf41950932f9c79ce84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e11df45c7e1cf41950932f9c79ce84">&#9670;&#160;</a></span>vectorizeLoops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> vectorizeLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>parentOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>vectorSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>fastestVaryingPattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1affine.html#a0e3d2cec8b9f06af928ef8b6fe719bc2">ReductionLoopMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reductionLoops</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal implementation to vectorize affine loops in 'loops' using the n-D vectorization factors in 'vectorSizes'. </p>
<p>By default, each vectorization factor is applied inner-to-outer to the loops of each loop nest. 'fastestVaryingPattern' can be optionally used to provide a different loop vectorization order. <span class="tt">reductionLoops</span> can be provided to specify loops which can be vectorized along the reduction dimension. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01721">1721</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="SuperVectorize_8cpp_source.html#l00657">analyzeProfitability()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01677">computeIntersectionBuckets()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00589">makePattern()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00629">vectorizeLoopIfProfitable()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01666">vectorizeRootMatch()</a>.</p>

</div>
</div>
<a id="a481bbf90f4171113e1867747d9db4a3b" name="a481bbf90f4171113e1867747d9db4a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481bbf90f4171113e1867747d9db4a3b">&#9670;&#160;</a></span>vectorizeOneOperation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * vectorizeOneOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes Operation-specific behavior for vectorization. </p>
<p>In general we assume that all operands of an op must be vectorized but this is not always true. In the future, it would be nice to have a trait that describes how a particular operation vectorizes. For now we implement the case distinction here. Returns a vectorized form of an operation or nullptr if vectorization fails. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01534">1534</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00674">mlir::Operation::getNumRegions()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00973">vectorizeAffineApplyOp()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01332">vectorizeAffineForOp()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01216">vectorizeAffineLoad()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01270">vectorizeAffineStore()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01486">vectorizeAffineYieldOp()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00945">vectorizeConstant()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01454">widenOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01595">vectorizeLoopNest()</a>.</p>

</div>
</div>
<a id="a9feac15d4af3a625b7b6426c579be8c2" name="a9feac15d4af3a625b7b6426c579be8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9feac15d4af3a625b7b6426c579be8c2">&#9670;&#160;</a></span>vectorizeOperand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> vectorizeOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>operand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to vectorize a given <span class="tt">operand</span> by applying the following logic: </p>
<ol type="1">
<li>if the defining operation has been already vectorized, <span class="tt">operand</span> is already in the proper vector form;</li>
<li>if the <span class="tt">operand</span> is a constant, returns the vectorized form of the constant;</li>
<li>if the <span class="tt">operand</span> is uniform, returns a vector broadcast of the <span class="tt">op</span>;</li>
<li>otherwise, the vectorization of <span class="tt">operand</span> is not supported. Newly created vector operations are registered in <span class="tt">state</span> as replacement for their scalar counterparts. In particular this logic captures some of the use cases where definitions that are not scoped under the current pattern are needed to vectorize. One such example is top level function constants that need to be splatted.</li>
</ol>
<p>Returns an operand that has been vectorized to match <span class="tt">state</span>'s strategy if vectorization is possible with the above logic. Returns nullptr otherwise.</p>
<p>TODO: handle more complex cases. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01145">1145</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01097">isUniformDefinition()</a>, <a class="el" href="IRMapping_8h_source.html#l00058">mlir::IRMapping::lookupOrNull()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00945">vectorizeConstant()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01114">vectorizeUniform()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01332">vectorizeAffineForOp()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01270">vectorizeAffineStore()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01454">widenOp()</a>.</p>

</div>
</div>
<a id="a1efda1293ff3efde069d8aa8fd0453f5" name="a1efda1293ff3efde069d8aa8fd0453f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efda1293ff3efde069d8aa8fd0453f5">&#9670;&#160;</a></span>vectorizeRootMatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult vectorizeRootMatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1NestedMatch.html">NestedMatch</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorizationStrategy &amp;</td>          <td class="paramname"><span class="paramname"><em>strategy</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the matched loops and vectorizes them following a topological order. </p>
<p>A new vector loop nest will be created if vectorization succeeds. The original loop nest won't be modified in any case. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01666">1666</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="SuperVectorize_8cpp_source.html#l01587">getMatchedAffineLoops()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01595">vectorizeLoopNest()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01721">vectorizeLoops()</a>.</p>

</div>
</div>
<a id="a19d00d4d03c52266df8e3739d1e8b8ce" name="a19d00d4d03c52266df8e3739d1e8b8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d00d4d03c52266df8e3739d1e8b8ce">&#9670;&#160;</a></span>vectorizeUniform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * vectorizeUniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>uniformVal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a broadcast op for the provided uniform value using the vectorization strategy in 'state'. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01114">1114</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00024">mlir::Value::getLoc()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00936">getVectorType()</a>, <a class="el" href="IRMapping_8h_source.html#l00065">mlir::IRMapping::lookupOrDefault()</a>, and <a class="el" href="Builders_8h_source.html#l00421">mlir::OpBuilder::setInsertionPointAfterValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01145">vectorizeOperand()</a>.</p>

</div>
</div>
<a id="ac564c0566b654dea8e0d1c0458943c7c" name="ac564c0566b654dea8e0d1c0458943c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac564c0566b654dea8e0d1c0458943c7c">&#9670;&#160;</a></span>vectorTransferPattern()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> &amp; vectorTransferPattern </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l00611">611</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="NestedMatcher_8cpp_source.html#l00135">mlir::affine::matcher::Op()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01595">vectorizeLoopNest()</a>.</p>

</div>
</div>
<a id="a3b2bc8ae63139c1937254e1e3f6557c0" name="a3b2bc8ae63139c1937254e1e3f6557c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2bc8ae63139c1937254e1e3f6557c0">&#9670;&#160;</a></span>verifyLoopNesting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult verifyLoopNesting </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify that affine loops in 'loops' meet the nesting criteria expected by SuperVectorizer: </p>
<ul>
<li>There must be at least one loop.</li>
<li>There must be a single root loop (nesting level 0).</li>
<li>Each loop at a given nesting level must be nested in a loop from a previous nesting level. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01833">1833</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="ab4a0e9a73e9bddbba43ed1b1624a2936" name="ab4a0e9a73e9bddbba43ed1b1624a2936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a0e9a73e9bddbba43ed1b1624a2936">&#9670;&#160;</a></span>widenOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * widenOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vectorizes arbitrary operation by plain widening. </p>
<p>We apply generic type widening of all its results and retrieve the vector counterparts for all its operands. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01454">1454</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00457">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00512">mlir::Operation::getAttrs()</a>, <a class="el" href="OperationSupport_8h_source.html#l00476">mlir::OperationName::getIdentifier()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01145">vectorizeOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01486">vectorizeAffineYieldOp()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01534">vectorizeOneOperation()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
