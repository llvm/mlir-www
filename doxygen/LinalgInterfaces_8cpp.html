<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Linalg/IR/LinalgInterfaces.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_8edb792440615361a0811a7329611599.html">Linalg</a></li><li class="navelem"><a class="el" href="dir_3a23a4f6964fd1d6dffdd753e7d701b1.html">IR</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">LinalgInterfaces.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="LinalgInterfaces_8h_source.html">mlir/Dialect/Linalg/IR/LinalgInterfaces.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Arith_2IR_2Arith_8h_source.html">mlir/Dialect/Arith/IR/Arith.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html">mlir/Dialect/Arith/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Complex_8h_source.html">mlir/Dialect/Complex/IR/Complex.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Linalg_2IR_2Linalg_8h_source.html">mlir/Dialect/Linalg/IR/Linalg.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">mlir/IR/AffineExpr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineExprVisitor_8h_source.html">mlir/IR/AffineExprVisitor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineMap_8h_source.html">mlir/IR/AffineMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="BuiltinTypeInterfaces_8h_source.html">mlir/IR/BuiltinTypeInterfaces.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MLIRContext_8h_source.html">mlir/IR/MLIRContext.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TypeUtilities_8h_source.html">mlir/IR/TypeUtilities.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SetOperations.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallBitVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallVector.h&quot;</code><br />
<code>#include &quot;llvm/Support/Casting.h&quot;</code><br />
<code>#include &quot;llvm/Support/raw_ostream.h&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &quot;mlir/Dialect/Linalg/IR/LinalgInterfaces.cpp.inc&quot;</code><br />
</div>
<p><a href="LinalgInterfaces_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHasAffineDimExprVisitor.html">HasAffineDimExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor to check if any of the given set of positions from AffineDimExprs are used within an AffineExpr.  <a href="structHasAffineDimExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html">mlir::linalg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1detail.html">mlir::linalg::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2884106fc260b44792b7e9be2ec8c1f8"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a2884106fc260b44792b7e9be2ec8c1f8">mlir::linalg::detail::MatchContractionResult</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a2884106fc260b44792b7e9be2ec8c1f8a505a83f220c02df2f85c3810cd9ceb38">mlir::linalg::detail::Success</a> = 0
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a2884106fc260b44792b7e9be2ec8c1f8a28e9cbb4027731ecdbfb585f5a3ff178">mlir::linalg::detail::NotLinalgOp</a>
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a2884106fc260b44792b7e9be2ec8c1f8af82cdd4f42e5650686fa2cb15fb9793a">mlir::linalg::detail::WrongNumOperands</a>
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a2884106fc260b44792b7e9be2ec8c1f8a3b196322d9bd5caae11ac768a5d07d20">mlir::linalg::detail::NoReduction</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a2884106fc260b44792b7e9be2ec8c1f8a4c9fb5fdbd65237e339fcce3bd4c3cf3">mlir::linalg::detail::NotProjectedPermutations</a>
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a2884106fc260b44792b7e9be2ec8c1f8a3ec09de12aa8c61a1310544bba3894b9">mlir::linalg::detail::NotAddMul</a>
<br />
 }</td></tr>
<tr class="separator:a2884106fc260b44792b7e9be2ec8c1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dab6da3207d5e469655f08bc221009"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009">mlir::linalg::detail::MatchConvolutionResult</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009a505a83f220c02df2f85c3810cd9ceb38">mlir::linalg::detail::Success</a> = 0
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009a28e9cbb4027731ecdbfb585f5a3ff178">mlir::linalg::detail::NotLinalgOp</a>
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009af82cdd4f42e5650686fa2cb15fb9793a">mlir::linalg::detail::WrongNumOperands</a>
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009a3508d8e971e0901260317197c7a712d6">mlir::linalg::detail::WrongInputIndexingMap</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009a4c9fb5fdbd65237e339fcce3bd4c3cf3">mlir::linalg::detail::NotProjectedPermutations</a>
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009a83bf6ddc428cfad862ffed47ee190299">mlir::linalg::detail::NonConvolutionLoop</a>
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009ac61936fad0de69ebfee2d23fdc242c58">mlir::linalg::detail::OutputDimsNotParallel</a>
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009a52260f8743a3d073b02b2845ee6a04c6">mlir::linalg::detail::NonOutputDimNotReduction</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009aafe2fd3a4366c32a2f01fc0261a71490">mlir::linalg::detail::EmptyConvolvedDims</a>
<br />
 }</td></tr>
<tr class="separator:aa3dab6da3207d5e469655f08bc221009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7838c87bd95b3622804657ff4503aea"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LinalgInterfaces_8cpp.html#ad7838c87bd95b3622804657ff4503aea">MatchFillResult</a> { <a class="el" href="LinalgInterfaces_8cpp.html#ad7838c87bd95b3622804657ff4503aeaa505a83f220c02df2f85c3810cd9ceb38">Success</a> = 0
, <a class="el" href="LinalgInterfaces_8cpp.html#ad7838c87bd95b3622804657ff4503aeaa28e9cbb4027731ecdbfb585f5a3ff178">NotLinalgOp</a>
, <a class="el" href="LinalgInterfaces_8cpp.html#ad7838c87bd95b3622804657ff4503aeaaf82cdd4f42e5650686fa2cb15fb9793a">WrongNumOperands</a>
, <a class="el" href="LinalgInterfaces_8cpp.html#ad7838c87bd95b3622804657ff4503aeaa15c79d268d3fe2e86dd28adcbb36645e">NotScalarInput</a>
 }</td></tr>
<tr class="separator:ad7838c87bd95b3622804657ff4503aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8292610fb30def7b1b181edd599939eb"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LinalgInterfaces_8cpp.html#a8292610fb30def7b1b181edd599939eb">isaInlinedFillOp</a> (GenericOp op)</td></tr>
<tr class="memdesc:a8292610fb30def7b1b181edd599939eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects if a linalg.generic operation represents a fill with an inlined constant.  <a href="LinalgInterfaces_8cpp.html#a8292610fb30def7b1b181edd599939eb">More...</a><br /></td></tr>
<tr class="separator:a8292610fb30def7b1b181edd599939eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15555216c68c3882eb6a844b00cd8917"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LinalgInterfaces_8cpp.html#a15555216c68c3882eb6a844b00cd8917">isaExternalFillOp</a> (GenericOp op)</td></tr>
<tr class="memdesc:a15555216c68c3882eb6a844b00cd8917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects if a linalg.generic operation represents an external scalar input.  <a href="LinalgInterfaces_8cpp.html#a15555216c68c3882eb6a844b00cd8917">More...</a><br /></td></tr>
<tr class="separator:a15555216c68c3882eb6a844b00cd8917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab768e9259c9eec6977d77c2ce51c9694"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LinalgInterfaces_8cpp.html#ab768e9259c9eec6977d77c2ce51c9694">isaElemwiseSingleUnaryOrBinaryOpInterface</a> (linalg::GenericOp op, unsigned arity)</td></tr>
<tr class="separator:ab768e9259c9eec6977d77c2ce51c9694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b61947f3fddc5fbd6290faaebcb92d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LinalgInterfaces_8cpp.html#a15b61947f3fddc5fbd6290faaebcb92d">getSourceSkipUnary</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a15b61947f3fddc5fbd6290faaebcb92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the value is defined by a chain of unary side effect-free, go up the use-def chain until the first value that isn't defined by such an op.  <a href="LinalgInterfaces_8cpp.html#a15b61947f3fddc5fbd6290faaebcb92d">More...</a><br /></td></tr>
<tr class="separator:a15b61947f3fddc5fbd6290faaebcb92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400ae51689d3aaea856d04d823e0927b"><td class="memTemplParams" colspan="2">template&lt;typename AddOpTy , typename MulOpTy , typename... Args&gt; </td></tr>
<tr class="memitem:a400ae51689d3aaea856d04d823e0927b"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="LinalgInterfaces_8cpp.html#a400ae51689d3aaea856d04d823e0927b">isPairTemplateImpl</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *add, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *mul)</td></tr>
<tr class="memdesc:a400ae51689d3aaea856d04d823e0927b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the two operations are of the kinds specified by a pair of consecutive template arguments.  <a href="LinalgInterfaces_8cpp.html#a400ae51689d3aaea856d04d823e0927b">More...</a><br /></td></tr>
<tr class="separator:a400ae51689d3aaea856d04d823e0927b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a542c81b580d132fa27f67814df3aa"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a76a542c81b580d132fa27f67814df3aa"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="LinalgInterfaces_8cpp.html#a76a542c81b580d132fa27f67814df3aa">isContractionBody</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> &amp;block)</td></tr>
<tr class="memdesc:a76a542c81b580d132fa27f67814df3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the block is a body of a contraction with the kinds of operations given pairwise by template arguments.  <a href="LinalgInterfaces_8cpp.html#a76a542c81b580d132fa27f67814df3aa">More...</a><br /></td></tr>
<tr class="separator:a76a542c81b580d132fa27f67814df3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3adb8df7bc926dc1e7fc6ffdb85f9d"><td class="memItemLeft" align="right" valign="top">static llvm::SmallDenseSet&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LinalgInterfaces_8cpp.html#ada3adb8df7bc926dc1e7fc6ffdb85f9d">findPermutationsIndexingOperand</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexingMap, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt; iterators, utils::IteratorType iter)</td></tr>
<tr class="memdesc:ada3adb8df7bc926dc1e7fc6ffdb85f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <code>indexingMap</code> and its corresponding <code>iterators</code>, returns the positions of the iterators of type <code>iter</code> that are indexed by the <code>indexingMap</code> as a permutation.  <a href="LinalgInterfaces_8cpp.html#ada3adb8df7bc926dc1e7fc6ffdb85f9d">More...</a><br /></td></tr>
<tr class="separator:ada3adb8df7bc926dc1e7fc6ffdb85f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0a63a62b20a8a65dd45d39f01f9f4e"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; utils::IteratorType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LinalgInterfaces_8cpp.html#ade0a63a62b20a8a65dd45d39f01f9f4e">inferIteratorsFromOutMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:ade0a63a62b20a8a65dd45d39f01f9f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the iterator types from the init affine map.  <a href="LinalgInterfaces_8cpp.html#ade0a63a62b20a8a65dd45d39f01f9f4e">More...</a><br /></td></tr>
<tr class="separator:ade0a63a62b20a8a65dd45d39f01f9f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761ff0b07aba42783605a17786d0f5f4"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContractionDimensions.html">ContractionDimensions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LinalgInterfaces_8cpp.html#a761ff0b07aba42783605a17786d0f5f4">inferContractionDimsImpl</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; indexingMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt; iterators)</td></tr>
<tr class="memdesc:a761ff0b07aba42783605a17786d0f5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find 2 parallel (m and n) and 1 reduction (k) dimension candidates that form a matmul subcomputation within <code>linalgOp</code>.  <a href="LinalgInterfaces_8cpp.html#a761ff0b07aba42783605a17786d0f5f4">More...</a><br /></td></tr>
<tr class="separator:a761ff0b07aba42783605a17786d0f5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2986e967d5eeabd16c6aac5c00341de3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2986e967d5eeabd16c6aac5c00341de3"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="LinalgInterfaces_8cpp.html#a2986e967d5eeabd16c6aac5c00341de3">getAffineExprOfType</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> lhs, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> rhs)</td></tr>
<tr class="memdesc:a2986e967d5eeabd16c6aac5c00341de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Of the given two expressions returns one that is of type T (<code>lhs</code> gets preference over <code>rhs</code>)  <a href="LinalgInterfaces_8cpp.html#a2986e967d5eeabd16c6aac5c00341de3">More...</a><br /></td></tr>
<tr class="separator:a2986e967d5eeabd16c6aac5c00341de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b9f2a336c263a8ed4d20ad7a7235bc"><td class="memItemLeft" align="right" valign="top">static llvm::SmallDenseSet&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LinalgInterfaces_8cpp.html#a96b9f2a336c263a8ed4d20ad7a7235bc">getPreservedDims</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="separator:a96b9f2a336c263a8ed4d20ad7a7235bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5631e6d4db2a8db38d518596f97b72a4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LinalgInterfaces_8cpp.html#a5631e6d4db2a8db38d518596f97b72a4">getConstantsFromExprList</a> (const <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt; &amp;exprs)</td></tr>
<tr class="separator:a5631e6d4db2a8db38d518596f97b72a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14abec7a4b876d2b1cb83d70071d9675"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ConvolutionDimensions.html">ConvolutionDimensions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LinalgInterfaces_8cpp.html#a14abec7a4b876d2b1cb83d70071d9675">inferConvolutionDimsImpl</a> (LinalgOp linalgOp, ConvAccessExprWalker &amp;inputExprWalker, bool allowEmptyConvolvedDims)</td></tr>
<tr class="memdesc:a14abec7a4b876d2b1cb83d70071d9675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classifies dimensions in the <code>linalgOp</code> used by a convolution subcomputation, as captured by <code>inputExprWalker</code>.  <a href="LinalgInterfaces_8cpp.html#a14abec7a4b876d2b1cb83d70071d9675">More...</a><br /></td></tr>
<tr class="separator:a14abec7a4b876d2b1cb83d70071d9675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d3911e7f6cd1cc99a1860a44abfa10"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="LinalgInterfaces_8cpp.html#ad7838c87bd95b3622804657ff4503aea">MatchFillResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LinalgInterfaces_8cpp.html#a61d3911e7f6cd1cc99a1860a44abfa10">isFillInterfaceImpl</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a61d3911e7f6cd1cc99a1860a44abfa10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfca71e2845054760aa178dc1c9ce431"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; int64_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LinalgInterfaces_8cpp.html#adfca71e2845054760aa178dc1c9ce431">getResultsPositionInLoopsToShapeMap</a> (LinalgOp &amp;op)</td></tr>
<tr class="separator:adfca71e2845054760aa178dc1c9ce431"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ad7838c87bd95b3622804657ff4503aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7838c87bd95b3622804657ff4503aea">&#9670;&nbsp;</a></span>MatchFillResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="LinalgInterfaces_8cpp.html#ad7838c87bd95b3622804657ff4503aea">MatchFillResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad7838c87bd95b3622804657ff4503aeaa505a83f220c02df2f85c3810cd9ceb38"></a>Success&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7838c87bd95b3622804657ff4503aeaa28e9cbb4027731ecdbfb585f5a3ff178"></a>NotLinalgOp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7838c87bd95b3622804657ff4503aeaaf82cdd4f42e5650686fa2cb15fb9793a"></a>WrongNumOperands&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7838c87bd95b3622804657ff4503aeaa15c79d268d3fe2e86dd28adcbb36645e"></a>NotScalarInput&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l01063">1063</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ada3adb8df7bc926dc1e7fc6ffdb85f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3adb8df7bc926dc1e7fc6ffdb85f9d">&#9670;&nbsp;</a></span>findPermutationsIndexingOperand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::SmallDenseSet&lt;int64_t&gt; findPermutationsIndexingOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>indexingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt;&#160;</td>
          <td class="paramname"><em>iterators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utils::IteratorType&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an <code>indexingMap</code> and its corresponding <code>iterators</code>, returns the positions of the iterators of type <code>iter</code> that are indexed by the <code>indexingMap</code> as a permutation. </p>
<p>This is useful to infer various subcomputations on a <code>LinalgOp</code>. This is performed by looking up each result in the <code>indexingMap</code> and determining whether:</p><ul>
<li>It is a single AffineDimExpr.</li>
<li>It is the only result involving this AffineDimExpr. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00395">395</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00444">inferContractionDimsImpl()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00744">inferConvolutionDimsImpl()</a>.</p>

</div>
</div>
<a id="a2986e967d5eeabd16c6aac5c00341de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2986e967d5eeabd16c6aac5c00341de3">&#9670;&nbsp;</a></span>getAffineExprOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T getAffineExprOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Of the given two expressions returns one that is of type T (<code>lhs</code> gets preference over <code>rhs</code>) </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00604">604</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a5631e6d4db2a8db38d518596f97b72a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5631e6d4db2a8db38d518596f97b72a4">&#9670;&nbsp;</a></span>getConstantsFromExprList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t, 2&gt; getConstantsFromExprList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>exprs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00726">726</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00744">inferConvolutionDimsImpl()</a>.</p>

</div>
</div>
<a id="a96b9f2a336c263a8ed4d20ad7a7235bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b9f2a336c263a8ed4d20ad7a7235bc">&#9670;&nbsp;</a></span>getPreservedDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::SmallDenseSet&lt;int64_t&gt; getPreservedDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00716">716</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">mlir::AffineMap::isProjectedPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00887">mlir::linalg::detail::isConvolutionInterfaceImpl()</a>.</p>

</div>
</div>
<a id="adfca71e2845054760aa178dc1c9ce431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfca71e2845054760aa178dc1c9ce431">&#9670;&nbsp;</a></span>getResultsPositionInLoopsToShapeMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;int64_t, int64_t&gt; getResultsPositionInLoopsToShapeMap </td>
          <td>(</td>
          <td class="paramtype">LinalgOp &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l01159">1159</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a15b61947f3fddc5fbd6290faaebcb92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b61947f3fddc5fbd6290faaebcb92d">&#9670;&nbsp;</a></span>getSourceSkipUnary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> getSourceSkipUnary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the value is defined by a chain of unary side effect-free, go up the use-def chain until the first value that isn't defined by such an op. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00289">289</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00346">mlir::Operation::getNumOperands()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00301">mlir::linalg::detail::isContractionBody()</a>.</p>

</div>
</div>
<a id="a761ff0b07aba42783605a17786d0f5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761ff0b07aba42783605a17786d0f5f4">&#9670;&nbsp;</a></span>inferContractionDimsImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;<a class="el" href="structmlir_1_1linalg_1_1ContractionDimensions.html">ContractionDimensions</a>&gt; inferContractionDimsImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>indexingMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt;&#160;</td>
          <td class="paramname"><em>iterators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find 2 parallel (m and n) and 1 reduction (k) dimension candidates that form a matmul subcomputation within <code>linalgOp</code>. </p>
<p>These dimensions are such that:</p><ol type="1">
<li>The m dimension is involved in an outer-product along LHS (i.e. it is a permutation on RES and LHS and does not appear in RHS).</li>
<li>The n dimension is involved in an outer-product along RHS (i.e. it is a permutation on RES and RHS and does not appear in LHS).</li>
<li>The k dimension appears as a permutation on LHS and RHS.</li>
<li>m, n and k appear only once in any given indexing.</li>
<li>Optional batch dimensions that appear in all operands are captured. This allows e.g. detecting that some contraction is embedded within <code>linalgOp</code> with some orthogonal heuristic. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00444">444</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00395">findPermutationsIndexingOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00487">mlir::linalg::inferContractionDims()</a>.</p>

</div>
</div>
<a id="a14abec7a4b876d2b1cb83d70071d9675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14abec7a4b876d2b1cb83d70071d9675">&#9670;&nbsp;</a></span>inferConvolutionDimsImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;<a class="el" href="structmlir_1_1linalg_1_1ConvolutionDimensions.html">ConvolutionDimensions</a>&gt; inferConvolutionDimsImpl </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConvAccessExprWalker &amp;&#160;</td>
          <td class="paramname"><em>inputExprWalker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowEmptyConvolvedDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Classifies dimensions in the <code>linalgOp</code> used by a convolution subcomputation, as captured by <code>inputExprWalker</code>. </p>
<p>If <code>allowEmptyConvolvedDims</code> is not set this this will fail if there is not at least convolved dimension pair (output image + filter loop). Convolution dimensions are specified in sorted order, and strides match the order of the filter loop dimensions, while the dilations match the order of the output image dimensions. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00744">744</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00395">findPermutationsIndexingOperand()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00726">getConstantsFromExprList()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00856">mlir::linalg::inferConvolutionDims()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00887">mlir::linalg::detail::isConvolutionInterfaceImpl()</a>.</p>

</div>
</div>
<a id="ade0a63a62b20a8a65dd45d39f01f9f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0a63a62b20a8a65dd45d39f01f9f4e">&#9670;&nbsp;</a></span>inferIteratorsFromOutMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;utils::IteratorType&gt; &gt; inferIteratorsFromOutMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Infer the iterator types from the init affine map. </p>
<p>This looks at which dims are present in the map results, and returns an iterator types array with parallel types for dims that are present, and reduction types for dims that are not present. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00422">422</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">mlir::AffineMap::isProjectedPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00495">mlir::linalg::inferContractionDims()</a>.</p>

</div>
</div>
<a id="ab768e9259c9eec6977d77c2ce51c9694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab768e9259c9eec6977d77c2ce51c9694">&#9670;&nbsp;</a></span>isaElemwiseSingleUnaryOrBinaryOpInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isaElemwiseSingleUnaryOrBinaryOpInterface </td>
          <td>(</td>
          <td class="paramtype">linalg::GenericOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>arity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00222">222</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00152">mlir::Block::back()</a>, <a class="el" href="Block_8h_source.html#l00153">mlir::Block::front()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00346">mlir::Operation::getNumOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, and <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>.</p>

</div>
</div>
<a id="a15555216c68c3882eb6a844b00cd8917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15555216c68c3882eb6a844b00cd8917">&#9670;&nbsp;</a></span>isaExternalFillOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; isaExternalFillOp </td>
          <td>(</td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects if a linalg.generic operation represents an external scalar input. </p>
<p>If so, returns the constant value. Otherwise, returns std::nullopt. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00114">114</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00131">mlir::linalg::isaFillOpInterface()</a>.</p>

</div>
</div>
<a id="a8292610fb30def7b1b181edd599939eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8292610fb30def7b1b181edd599939eb">&#9670;&nbsp;</a></span>isaInlinedFillOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; isaInlinedFillOp </td>
          <td>(</td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects if a linalg.generic operation represents a fill with an inlined constant. </p>
<p>If so, returns the constant value. Otherwise, returns std::nullopt. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00087">87</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00152">mlir::Block::back()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, and <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00131">mlir::linalg::isaFillOpInterface()</a>.</p>

</div>
</div>
<a id="a76a542c81b580d132fa27f67814df3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a542c81b580d132fa27f67814df3aa">&#9670;&nbsp;</a></span>isContractionBody()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isContractionBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the block is a body of a contraction with the kinds of operations given pairwise by template arguments. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00383">383</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00301">mlir::linalg::detail::isContractionBody()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00516">mlir::linalg::detail::isContractionInterfaceImpl()</a>.</p>

</div>
</div>
<a id="a61d3911e7f6cd1cc99a1860a44abfa10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d3911e7f6cd1cc99a1860a44abfa10">&#9670;&nbsp;</a></span>isFillInterfaceImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="LinalgInterfaces_8cpp.html#ad7838c87bd95b3622804657ff4503aea">MatchFillResult</a> isFillInterfaceImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l01070">1070</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp.html#ad7838c87bd95b3622804657ff4503aeaa28e9cbb4027731ecdbfb585f5a3ff178">NotLinalgOp</a>, <a class="el" href="LinalgInterfaces_8cpp.html#ad7838c87bd95b3622804657ff4503aeaa15c79d268d3fe2e86dd28adcbb36645e">NotScalarInput</a>, <a class="el" href="LinalgInterfaces_8cpp.html#ad7838c87bd95b3622804657ff4503aeaa505a83f220c02df2f85c3810cd9ceb38">Success</a>, and <a class="el" href="LinalgInterfaces_8cpp.html#ad7838c87bd95b3622804657ff4503aeaaf82cdd4f42e5650686fa2cb15fb9793a">WrongNumOperands</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l01084">mlir::linalg::detail::verifyFillInterface()</a>.</p>

</div>
</div>
<a id="a400ae51689d3aaea856d04d823e0927b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400ae51689d3aaea856d04d823e0927b">&#9670;&nbsp;</a></span>isPairTemplateImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AddOpTy , typename MulOpTy , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isPairTemplateImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>mul</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the two operations are of the kinds specified by a pair of consecutive template arguments. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00368">368</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:28 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
