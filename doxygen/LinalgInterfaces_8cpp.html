<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Linalg/IR/LinalgInterfaces.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a href="dir_8edb792440615361a0811a7329611599.html">Linalg</a></li><li class="navelem"><a href="dir_3a23a4f6964fd1d6dffdd753e7d701b1.html">IR</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">LinalgInterfaces.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="LinalgInterfaces_8h_source.html">mlir/Dialect/Linalg/IR/LinalgInterfaces.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Arith_2IR_2Arith_8h_source.html">mlir/Dialect/Arith/IR/Arith.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html">mlir/Dialect/Arith/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Complex_8h_source.html">mlir/Dialect/Complex/IR/Complex.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Linalg_2IR_2Linalg_8h_source.html">mlir/Dialect/Linalg/IR/Linalg.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">mlir/IR/AffineExpr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineExprVisitor_8h_source.html">mlir/IR/AffineExprVisitor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineMap_8h_source.html">mlir/IR/AffineMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="BuiltinTypeInterfaces_8h_source.html">mlir/IR/BuiltinTypeInterfaces.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MLIRContext_8h_source.html">mlir/IR/MLIRContext.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TypeUtilities_8h_source.html">mlir/IR/TypeUtilities.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SetOperations.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallBitVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallVector.h&quot;</code><br />
<code>#include &quot;llvm/Support/Casting.h&quot;</code><br />
<code>#include &quot;llvm/Support/raw_ostream.h&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &quot;mlir/Dialect/Linalg/IR/LinalgInterfaces.cpp.inc&quot;</code><br />
</div>
<p><a href="LinalgInterfaces_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:HasAffineDimExprVisitor" id="r_HasAffineDimExprVisitor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHasAffineDimExprVisitor.html">HasAffineDimExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor to check if any of the given set of positions from AffineDimExprs are used within an <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a>.  <a href="structHasAffineDimExprVisitor.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:mlir" id="r_mlir"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg" id="r_mlir_3A_3Alinalg"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html">mlir::linalg</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3Adetail" id="r_mlir_3A_3Alinalg_3A_3Adetail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1detail.html">mlir::linalg::detail</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2884106fc260b44792b7e9be2ec8c1f8" id="r_a2884106fc260b44792b7e9be2ec8c1f8"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a2884106fc260b44792b7e9be2ec8c1f8">mlir::linalg::detail::MatchContractionResult</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a2884106fc260b44792b7e9be2ec8c1f8a505a83f220c02df2f85c3810cd9ceb38">mlir::linalg::detail::Success</a> = 0
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a2884106fc260b44792b7e9be2ec8c1f8a28e9cbb4027731ecdbfb585f5a3ff178">mlir::linalg::detail::NotLinalgOp</a>
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a2884106fc260b44792b7e9be2ec8c1f8af82cdd4f42e5650686fa2cb15fb9793a">mlir::linalg::detail::WrongNumOperands</a>
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a2884106fc260b44792b7e9be2ec8c1f8a3b196322d9bd5caae11ac768a5d07d20">mlir::linalg::detail::NoReduction</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a2884106fc260b44792b7e9be2ec8c1f8a4c9fb5fdbd65237e339fcce3bd4c3cf3">mlir::linalg::detail::NotProjectedPermutations</a>
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a2884106fc260b44792b7e9be2ec8c1f8a3ec09de12aa8c61a1310544bba3894b9">mlir::linalg::detail::NotAddMul</a>
<br />
 }</td></tr>
<tr class="memitem:aa3dab6da3207d5e469655f08bc221009" id="r_aa3dab6da3207d5e469655f08bc221009"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009">mlir::linalg::detail::MatchConvolutionResult</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009a505a83f220c02df2f85c3810cd9ceb38">mlir::linalg::detail::Success</a> = 0
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009a28e9cbb4027731ecdbfb585f5a3ff178">mlir::linalg::detail::NotLinalgOp</a>
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009af82cdd4f42e5650686fa2cb15fb9793a">mlir::linalg::detail::WrongNumOperands</a>
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009a3508d8e971e0901260317197c7a712d6">mlir::linalg::detail::WrongInputIndexingMap</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009a4c9fb5fdbd65237e339fcce3bd4c3cf3">mlir::linalg::detail::NotProjectedPermutations</a>
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009a83bf6ddc428cfad862ffed47ee190299">mlir::linalg::detail::NonConvolutionLoop</a>
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009ac61936fad0de69ebfee2d23fdc242c58">mlir::linalg::detail::OutputDimsNotParallel</a>
, <a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009a52260f8743a3d073b02b2845ee6a04c6">mlir::linalg::detail::NonOutputDimNotReduction</a>
, <br />
&#160;&#160;<a class="el" href="namespacemlir_1_1linalg_1_1detail.html#aa3dab6da3207d5e469655f08bc221009aafe2fd3a4366c32a2f01fc0261a71490">mlir::linalg::detail::EmptyConvolvedDims</a>
<br />
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af382de1f947727868f771e3966e08328" id="r_af382de1f947727868f771e3966e08328"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af382de1f947727868f771e3966e08328">isaInlinedFillOp</a> (GenericOp op)</td></tr>
<tr class="memdesc:af382de1f947727868f771e3966e08328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects if a linalg.generic operation represents a fill with an inlined constant.  <br /></td></tr>
<tr class="memitem:aaaf816d7d6663ca1a8e7e730caa3ea21" id="r_aaaf816d7d6663ca1a8e7e730caa3ea21"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaf816d7d6663ca1a8e7e730caa3ea21">isaExternalFillOp</a> (GenericOp op)</td></tr>
<tr class="memdesc:aaaf816d7d6663ca1a8e7e730caa3ea21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects if a linalg.generic operation represents an external scalar input.  <br /></td></tr>
<tr class="memitem:ab768e9259c9eec6977d77c2ce51c9694" id="r_ab768e9259c9eec6977d77c2ce51c9694"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab768e9259c9eec6977d77c2ce51c9694">isaElemwiseSingleUnaryOrBinaryOpInterface</a> (linalg::GenericOp op, <a class="el" href="classunsigned.html">unsigned</a> arity)</td></tr>
<tr class="memitem:a15b61947f3fddc5fbd6290faaebcb92d" id="r_a15b61947f3fddc5fbd6290faaebcb92d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15b61947f3fddc5fbd6290faaebcb92d">getSourceSkipUnary</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a15b61947f3fddc5fbd6290faaebcb92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the value is defined by a chain of unary side effect-free, go up the use-def chain until the first value that isn't defined by such an op.  <br /></td></tr>
<tr class="memitem:a400ae51689d3aaea856d04d823e0927b" id="r_a400ae51689d3aaea856d04d823e0927b"><td class="memTemplParams" colspan="2">template&lt;typename AddOpTy, typename MulOpTy, typename... Args&gt; </td></tr>
<tr class="memitem:a400ae51689d3aaea856d04d823e0927b template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a400ae51689d3aaea856d04d823e0927b">isPairTemplateImpl</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *<a class="el" href="XeGPUDialect_8cpp.html#a1a14019f88db2a0b038688cd9830ea7e">add</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *<a class="el" href="XeGPUDialect_8cpp.html#a0da29b54f1662523e9e9da60dde8b629">mul</a>)</td></tr>
<tr class="memdesc:a400ae51689d3aaea856d04d823e0927b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the two operations are of the kinds specified by a pair of consecutive template arguments.  <br /></td></tr>
<tr class="memitem:a76a542c81b580d132fa27f67814df3aa" id="r_a76a542c81b580d132fa27f67814df3aa"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a76a542c81b580d132fa27f67814df3aa template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76a542c81b580d132fa27f67814df3aa">isContractionBody</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> &amp;block)</td></tr>
<tr class="memdesc:a76a542c81b580d132fa27f67814df3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the block is a body of a contraction with the kinds of operations given pairwise by template arguments.  <br /></td></tr>
<tr class="memitem:ae19b9b5cd1b66e6b6da46fd595d607b1" id="r_ae19b9b5cd1b66e6b6da46fd595d607b1"><td class="memItemLeft" align="right" valign="top">static llvm::SmallDenseSet&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae19b9b5cd1b66e6b6da46fd595d607b1">findPermutationsIndexingOperand</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexingMap, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt; iterators, utils::IteratorType iter)</td></tr>
<tr class="memdesc:ae19b9b5cd1b66e6b6da46fd595d607b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <span class="tt">indexingMap</span> and its corresponding <span class="tt">iterators</span>, returns the positions of the iterators of type <span class="tt">iter</span> that are indexed by the <span class="tt">indexingMap</span> as a permutation.  <br /></td></tr>
<tr class="memitem:ab3eebb2f4745f3a84e7b9dff3b81c024" id="r_ab3eebb2f4745f3a84e7b9dff3b81c024"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; utils::IteratorType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3eebb2f4745f3a84e7b9dff3b81c024">inferIteratorsFromOutMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:ab3eebb2f4745f3a84e7b9dff3b81c024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the iterator types from the init affine map.  <br /></td></tr>
<tr class="memitem:a023217004590f1eef3a254658215f7e4" id="r_a023217004590f1eef3a254658215f7e4"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContractionDimensions.html">ContractionDimensions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a023217004590f1eef3a254658215f7e4">inferContractionDimsImpl</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; indexingMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt; iterators)</td></tr>
<tr class="memdesc:a023217004590f1eef3a254658215f7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find 2 parallel (m and n) and 1 reduction (k) dimension candidates that form a matmul subcomputation within <span class="tt">linalgOp</span>.  <br /></td></tr>
<tr class="memitem:a2986e967d5eeabd16c6aac5c00341de3" id="r_a2986e967d5eeabd16c6aac5c00341de3"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a2986e967d5eeabd16c6aac5c00341de3 template"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2986e967d5eeabd16c6aac5c00341de3">getAffineExprOfType</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memdesc:a2986e967d5eeabd16c6aac5c00341de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Of the given two expressions returns one that is of type T (<span class="tt">lhs</span> gets preference over <span class="tt">rhs</span>)  <br /></td></tr>
<tr class="memitem:a199e090aab8d818f89ec28ab894a3a45" id="r_a199e090aab8d818f89ec28ab894a3a45"><td class="memItemLeft" align="right" valign="top">static llvm::SmallDenseSet&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a199e090aab8d818f89ec28ab894a3a45">getPreservedDims</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memitem:ae3d1a2a38db84ceb12b94f5998fca34f" id="r_ae3d1a2a38db84ceb12b94f5998fca34f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3d1a2a38db84ceb12b94f5998fca34f">getConstantsFromExprList</a> (const <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt; &amp;exprs)</td></tr>
<tr class="memitem:a436bb67d8467ee3d8d069f5543a78cea" id="r_a436bb67d8467ee3d8d069f5543a78cea"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ConvolutionDimensions.html">ConvolutionDimensions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a436bb67d8467ee3d8d069f5543a78cea">inferConvolutionDimsImpl</a> (LinalgOp linalgOp, ConvAccessExprWalker &amp;inputExprWalker, <a class="el" href="classbool.html">bool</a> allowEmptyConvolvedDims)</td></tr>
<tr class="memdesc:a436bb67d8467ee3d8d069f5543a78cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classifies dimensions in the <span class="tt">linalgOp</span> used by a convolution subcomputation, as captured by <span class="tt">inputExprWalker</span>.  <br /></td></tr>
<tr class="memitem:a61d3911e7f6cd1cc99a1860a44abfa10" id="r_a61d3911e7f6cd1cc99a1860a44abfa10"><td class="memItemLeft" align="right" valign="top">static MatchFillResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61d3911e7f6cd1cc99a1860a44abfa10">isFillInterfaceImpl</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a3cf285c17756f4de40df3175b3a070db" id="r_a3cf285c17756f4de40df3175b3a070db"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; <a class="el" href="classint64__t.html">int64_t</a>, <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cf285c17756f4de40df3175b3a070db">getResultsPositionInLoopsToShapeMap</a> (LinalgOp &amp;op)</td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ae19b9b5cd1b66e6b6da46fd595d607b1" name="ae19b9b5cd1b66e6b6da46fd595d607b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19b9b5cd1b66e6b6da46fd595d607b1">&#9670;&#160;</a></span>findPermutationsIndexingOperand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallDenseSet&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; findPermutationsIndexingOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>indexingMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt;</td>          <td class="paramname"><span class="paramname"><em>iterators</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utils::IteratorType</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an <span class="tt">indexingMap</span> and its corresponding <span class="tt">iterators</span>, returns the positions of the iterators of type <span class="tt">iter</span> that are indexed by the <span class="tt">indexingMap</span> as a permutation. </p>
<p>This is useful to infer various subcomputations on a <span class="tt">LinalgOp</span>. This is performed by looking up each result in the <span class="tt">indexingMap</span> and determining whether:</p><ul>
<li>It is a single <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>.</li>
<li>It is the only result involving this <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00392">392</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00441">inferContractionDimsImpl()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00741">inferConvolutionDimsImpl()</a>.</p>

</div>
</div>
<a id="a2986e967d5eeabd16c6aac5c00341de3" name="a2986e967d5eeabd16c6aac5c00341de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2986e967d5eeabd16c6aac5c00341de3">&#9670;&#160;</a></span>getAffineExprOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T getAffineExprOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Of the given two expressions returns one that is of type T (<span class="tt">lhs</span> gets preference over <span class="tt">rhs</span>) </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00601">601</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="ae3d1a2a38db84ceb12b94f5998fca34f" name="ae3d1a2a38db84ceb12b94f5998fca34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d1a2a38db84ceb12b94f5998fca34f">&#9670;&#160;</a></span>getConstantsFromExprList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a>, 2 &gt; getConstantsFromExprList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exprs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00723">723</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00741">inferConvolutionDimsImpl()</a>.</p>

</div>
</div>
<a id="a199e090aab8d818f89ec28ab894a3a45" name="a199e090aab8d818f89ec28ab894a3a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199e090aab8d818f89ec28ab894a3a45">&#9670;&#160;</a></span>getPreservedDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SmallDenseSet&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; getPreservedDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00713">713</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">mlir::AffineMap::isProjectedPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00884">mlir::linalg::detail::isConvolutionInterfaceImpl()</a>.</p>

</div>
</div>
<a id="a3cf285c17756f4de40df3175b3a070db" name="a3cf285c17756f4de40df3175b3a070db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf285c17756f4de40df3175b3a070db">&#9670;&#160;</a></span>getResultsPositionInLoopsToShapeMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classint64__t.html">int64_t</a>, <a class="el" href="classint64__t.html">int64_t</a> &gt; getResultsPositionInLoopsToShapeMap </td>
          <td>(</td>
          <td class="paramtype">LinalgOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l01175">1175</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a15b61947f3fddc5fbd6290faaebcb92d" name="a15b61947f3fddc5fbd6290faaebcb92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b61947f3fddc5fbd6290faaebcb92d">&#9670;&#160;</a></span>getSourceSkipUnary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> getSourceSkipUnary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the value is defined by a chain of unary side effect-free, go up the use-def chain until the first value that isn't defined by such an op. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00285">285</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00346">mlir::Operation::getNumOperands()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00297">mlir::linalg::detail::isContractionBody()</a>.</p>

</div>
</div>
<a id="a023217004590f1eef3a254658215f7e4" name="a023217004590f1eef3a254658215f7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023217004590f1eef3a254658215f7e4">&#9670;&#160;</a></span>inferContractionDimsImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContractionDimensions.html">ContractionDimensions</a> &gt; inferContractionDimsImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>indexingMaps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; utils::IteratorType &gt;</td>          <td class="paramname"><span class="paramname"><em>iterators</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find 2 parallel (m and n) and 1 reduction (k) dimension candidates that form a matmul subcomputation within <span class="tt">linalgOp</span>. </p>
<p>These dimensions are such that:</p><ol type="1">
<li>The m dimension is involved in an outer-product along LHS (i.e. it is a permutation on RES and LHS and does not appear in RHS).</li>
<li>The n dimension is involved in an outer-product along RHS (i.e. it is a permutation on RES and RHS and does not appear in LHS).</li>
<li>The k dimension appears as a permutation on LHS and RHS.</li>
<li>m, n and k appear only once in any given indexing.</li>
<li>Optional batch dimensions that appear in all operands are captured. This allows e.g. detecting that some contraction is embedded within <span class="tt">linalgOp</span> with some orthogonal heuristic. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00441">441</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="LinalgInterfaces_8h_source.html#l00045">mlir::linalg::ContractionDimensions::batch</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00392">findPermutationsIndexingOperand()</a>, <a class="el" href="LinalgInterfaces_8h_source.html#l00048">mlir::linalg::ContractionDimensions::k</a>, <a class="el" href="LinalgInterfaces_8h_source.html#l00046">mlir::linalg::ContractionDimensions::m</a>, and <a class="el" href="LinalgInterfaces_8h_source.html#l00047">mlir::linalg::ContractionDimensions::n</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00492">mlir::linalg::inferContractionDims()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00484">mlir::linalg::inferContractionDims()</a>.</p>

</div>
</div>
<a id="a436bb67d8467ee3d8d069f5543a78cea" name="a436bb67d8467ee3d8d069f5543a78cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436bb67d8467ee3d8d069f5543a78cea">&#9670;&#160;</a></span>inferConvolutionDimsImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ConvolutionDimensions.html">ConvolutionDimensions</a> &gt; inferConvolutionDimsImpl </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConvAccessExprWalker &amp;</td>          <td class="paramname"><span class="paramname"><em>inputExprWalker</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>allowEmptyConvolvedDims</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Classifies dimensions in the <span class="tt">linalgOp</span> used by a convolution subcomputation, as captured by <span class="tt">inputExprWalker</span>. </p>
<p>If <span class="tt">allowEmptyConvolvedDims</span> is not set this this will fail if there is not at least convolved dimension pair (output image + filter loop). Convolution dimensions are specified in sorted order, and strides match the order of the filter loop dimensions, while the dilations match the order of the output image dimensions. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00741">741</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8h_source.html#l00077">mlir::linalg::ConvolutionDimensions::batch</a>, <a class="el" href="LinalgInterfaces_8h_source.html#l00082">mlir::linalg::ConvolutionDimensions::depth</a>, <a class="el" href="LinalgInterfaces_8h_source.html#l00084">mlir::linalg::ConvolutionDimensions::dilations</a>, <a class="el" href="LinalgInterfaces_8h_source.html#l00080">mlir::linalg::ConvolutionDimensions::filterLoop</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00392">findPermutationsIndexingOperand()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00723">getConstantsFromExprList()</a>, <a class="el" href="LinalgInterfaces_8h_source.html#l00081">mlir::linalg::ConvolutionDimensions::inputChannel</a>, <a class="el" href="LinalgInterfaces_8h_source.html#l00079">mlir::linalg::ConvolutionDimensions::outputChannel</a>, <a class="el" href="LinalgInterfaces_8h_source.html#l00078">mlir::linalg::ConvolutionDimensions::outputImage</a>, and <a class="el" href="LinalgInterfaces_8h_source.html#l00083">mlir::linalg::ConvolutionDimensions::strides</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00853">mlir::linalg::inferConvolutionDims()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00884">mlir::linalg::detail::isConvolutionInterfaceImpl()</a>.</p>

</div>
</div>
<a id="ab3eebb2f4745f3a84e7b9dff3b81c024" name="ab3eebb2f4745f3a84e7b9dff3b81c024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3eebb2f4745f3a84e7b9dff3b81c024">&#9670;&#160;</a></span>inferIteratorsFromOutMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; utils::IteratorType &gt; &gt; inferIteratorsFromOutMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Infer the iterator types from the init affine map. </p>
<p>This looks at which dims are present in the map results, and returns an iterator types array with parallel types for dims that are present, and reduction types for dims that are not present. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00419">419</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">mlir::AffineMap::isProjectedPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00492">mlir::linalg::inferContractionDims()</a>.</p>

</div>
</div>
<a id="ab768e9259c9eec6977d77c2ce51c9694" name="ab768e9259c9eec6977d77c2ce51c9694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab768e9259c9eec6977d77c2ce51c9694">&#9670;&#160;</a></span>isaElemwiseSingleUnaryOrBinaryOpInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isaElemwiseSingleUnaryOrBinaryOpInterface </td>
          <td>(</td>
          <td class="paramtype">linalg::GenericOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>arity</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00222">222</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00152">mlir::Block::back()</a>, <a class="el" href="Block_8h_source.html#l00153">mlir::Block::front()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00346">mlir::Operation::getNumOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, and <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>.</p>

</div>
</div>
<a id="aaaf816d7d6663ca1a8e7e730caa3ea21" name="aaaf816d7d6663ca1a8e7e730caa3ea21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf816d7d6663ca1a8e7e730caa3ea21">&#9670;&#160;</a></span>isaExternalFillOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; isaExternalFillOp </td>
          <td>(</td>
          <td class="paramtype">GenericOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects if a linalg.generic operation represents an external scalar input. </p>
<p>If so, returns the constant value. Otherwise, returns std::nullopt. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00114">114</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00131">mlir::linalg::isaFillOpInterface()</a>.</p>

</div>
</div>
<a id="af382de1f947727868f771e3966e08328" name="af382de1f947727868f771e3966e08328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af382de1f947727868f771e3966e08328">&#9670;&#160;</a></span>isaInlinedFillOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; isaInlinedFillOp </td>
          <td>(</td>
          <td class="paramtype">GenericOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects if a linalg.generic operation represents a fill with an inlined constant. </p>
<p>If so, returns the constant value. Otherwise, returns std::nullopt. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00087">87</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00152">mlir::Block::back()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, and <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00131">mlir::linalg::isaFillOpInterface()</a>.</p>

</div>
</div>
<a id="a76a542c81b580d132fa27f67814df3aa" name="a76a542c81b580d132fa27f67814df3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a542c81b580d132fa27f67814df3aa">&#9670;&#160;</a></span>isContractionBody()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isContractionBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the block is a body of a contraction with the kinds of operations given pairwise by template arguments. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00380">380</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00297">mlir::linalg::detail::isContractionBody()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00365">isPairTemplateImpl()</a>.</p>

</div>
</div>
<a id="a61d3911e7f6cd1cc99a1860a44abfa10" name="a61d3911e7f6cd1cc99a1860a44abfa10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d3911e7f6cd1cc99a1860a44abfa10">&#9670;&#160;</a></span>isFillInterfaceImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatchFillResult isFillInterfaceImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l01070">1070</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00023">mlir::getElementTypeOrSelf()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l01091">mlir::linalg::detail::verifyFillInterface()</a>.</p>

</div>
</div>
<a id="a400ae51689d3aaea856d04d823e0927b" name="a400ae51689d3aaea856d04d823e0927b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400ae51689d3aaea856d04d823e0927b">&#9670;&#160;</a></span>isPairTemplateImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AddOpTy, typename MulOpTy, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isPairTemplateImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>add</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>mul</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the two operations are of the kinds specified by a pair of consecutive template arguments. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00365">365</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="XeGPUDialect_8cpp_source.html#l00976">add</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00365">isPairTemplateImpl()</a>, and <a class="el" href="XeGPUDialect_8cpp_source.html#l00972">mul</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00380">isContractionBody()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00365">isPairTemplateImpl()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
