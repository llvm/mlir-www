<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mlir::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classmlir_1_1AttrTypeReplacer.html" title="This is an attribute/type replacer that is naively cached.">AttrTypeReplacer</a>.  
<a href="namespacemlir_1_1detail.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1detail_1_1analysis__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1analysis__impl.html">analysis_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1detail_1_1pass__options"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1pass__options.html">pass_options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1detail_1_1storage__user__base__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1storage__user__base__impl.html">storage_user_base_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1detail_1_1StorageUserTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1StorageUserTrait.html">StorageUserTrait</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AliasAnalysisTraits.html">AliasAnalysisTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains various internal trait classes used by the main <a class="el" href="classmlir_1_1AliasAnalysis.html" title="This class represents the main alias analysis interface in MLIR.">AliasAnalysis</a> class below.  <a href="structmlir_1_1detail_1_1AliasAnalysisTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1CallbackOstream.html">CallbackOstream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple raw ostream subclass that forwards write_impl calls to the user-supplied callback together with opaque user-supplied data.  <a href="classmlir_1_1detail_1_1CallbackOstream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1TileOffsetRangeImpl.html">TileOffsetRangeImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the set of parameters that are used to make tile offset calculations in the <a class="el" href="classmlir_1_1detail_1_1TileOffsetRangeIterator.html" title="The STL-style iterator implementation for StaticTileOffsetRange.">TileOffsetRangeIterator</a>.  <a href="classmlir_1_1detail_1_1TileOffsetRangeImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1TileOffsetRangeIterator.html">TileOffsetRangeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The STL-style iterator implementation for <a class="el" href="classmlir_1_1StaticTileOffsetRange.html" title="A range-style iterator that allows for iterating over the offsets of all potential tiles of size tile...">StaticTileOffsetRange</a>.  <a href="classmlir_1_1detail_1_1TileOffsetRangeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1Vector1D.html">Vector1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1Vector1D_3_01T_00_01Dim_00_01true_01_4.html">Vector1D&lt; T, Dim, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1Vector1D_3_01T_00_01Dim_00_01false_01_4.html">Vector1D&lt; T, Dim, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AttributeUniquer.html">AttributeUniquer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AttrTypeReplacerBase.html">AttrTypeReplacerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a base utility for replacing attributes/types, and their sub elements.  <a href="classmlir_1_1detail_1_1AttrTypeReplacerBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__tuple.html">is_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__tuple_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">is_tuple&lt; std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__pair.html">is_pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__pair_3_01std_1_1pair_3_01Ts_8_8_8_01_4_01_4.html">is_pair&lt; std::pair&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1op__filter__iterator.html">op_filter_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility iterator that filters out operations that are not 'OpT'.  <a href="classmlir_1_1detail_1_1op__filter__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1op__iterator.html">op_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides iteration over the held operations of a block for a specific operation type.  <a href="classmlir_1_1detail_1_1op__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ElementsAttrIndexer.html">ElementsAttrIndexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides support for indexing into the element range of an ElementsAttr.  <a href="structmlir_1_1detail_1_1ElementsAttrIndexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1ElementsAttrIterator.html">ElementsAttrIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a generic iterator for ElementsAttr.  <a href="classmlir_1_1detail_1_1ElementsAttrIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1ElementsAttrRange.html">ElementsAttrRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides iterator utilities for an ElementsAttr range.  <a href="classmlir_1_1detail_1_1ElementsAttrRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DenseElementIndexedIteratorImpl.html">DenseElementIndexedIteratorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impl iterator for indexed <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> iterators that records a data pointer and data index that is adjusted for the case of a splat attribute.  <a href="classmlir_1_1detail_1_1DenseElementIndexedIteratorImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__complex__t.html">is_complex_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> trait detector that checks if a given type T is a complex type.  <a href="structmlir_1_1detail_1_1is__complex__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__complex__t_3_01std_1_1complex_3_01T_01_4_01_4.html">is_complex_t&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">DenseArrayAttrImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for DenseArrayAttr that is instantiated and specialized for each supported element type below.  <a href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">DenseResourceElementsAttrBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classDenseResourceElementsAttr.html">DenseResourceElementsAttr</a> that is instantiated and specialized for each supported element type below.  <a href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DialectInterfaceBase.html">DialectInterfaceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class used for all derived interface types.  <a href="classmlir_1_1detail_1_1DialectInterfaceBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DialectInterfaceCollectionBase.html">DialectInterfaceCollectionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the base class for a collection of instances for a specific interface kind.  <a href="classmlir_1_1detail_1_1DialectInterfaceCollectionBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DominanceInfoBase.html">DominanceInfoBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1attr__value__binder.html">attr_value_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a certain kind of <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> and binds the value inside the <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <a href="structmlir_1_1detail_1_1attr__value__binder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__op__matcher.html">constant_op_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the <code>ConstantLike</code> trait.  <a href="structmlir_1_1detail_1_1constant__op__matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1NameOpMatcher.html">NameOpMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the specified op name.  <a href="structmlir_1_1detail_1_1NameOpMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AttrOpMatcher.html">AttrOpMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the specified attribute name.  <a href="structmlir_1_1detail_1_1AttrOpMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">constant_op_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the <code>ConstantLike</code> trait, and binds the folded attribute value.  <a href="structmlir_1_1detail_1_1constant__op__binder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1infer__int__range__op__binder.html">infer_int_range_op_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matcher that matches operations that implement the <code>InferIntRangeInterface</code> interface, and binds the inferred range.  <a href="structmlir_1_1detail_1_1infer__int__range__op__binder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AttrOpBinder.html">AttrOpBinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the specified attribute name, and binds the attribute value.  <a href="structmlir_1_1detail_1_1AttrOpBinder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__float__value__binder.html">constant_float_value_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a constant scalar / vector splat / tensor splat float <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> or <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> and binds the constant float value.  <a href="structmlir_1_1detail_1_1constant__float__value__binder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">constant_float_predicate_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a given target constant scalar / vector splat / tensor splat float value that fulfills a predicate.  <a href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__int__value__binder.html">constant_int_value_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a constant scalar / vector splat / tensor splat integer <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> or <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> and binds the constant integer value.  <a href="structmlir_1_1detail_1_1constant__int__value__binder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">constant_int_predicate_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a given target constant scalar / vector splat / tensor splat integer value that fulfills a predicate.  <a href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__int__range__predicate__matcher.html">constant_int_range_predicate_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matcher that matches a given a constant scalar / vector splat / tensor splat integer value or a constant integer range that fulfills a predicate.  <a href="structmlir_1_1detail_1_1constant__int__range__predicate__matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">op_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a certain kind of op.  <a href="structmlir_1_1detail_1_1op__matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AnyValueMatcher.html">AnyValueMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminal matcher, always returns true.  <a href="structmlir_1_1detail_1_1AnyValueMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AnyCapturedValueMatcher.html">AnyCapturedValueMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminal matcher, always returns true.  <a href="structmlir_1_1detail_1_1AnyCapturedValueMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1PatternMatcherValue.html">PatternMatcherValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds to a specific value and matches it.  <a href="structmlir_1_1detail_1_1PatternMatcherValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1RecursivePatternMatcher.html">RecursivePatternMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1detail_1_1RecursivePatternMatcher.html" title="RecursivePatternMatcher that composes.">RecursivePatternMatcher</a> that composes.  <a href="structmlir_1_1detail_1_1RecursivePatternMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1OperandStorage.html">OperandStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class handles the management of operation operands.  <a href="classmlir_1_1detail_1_1OperandStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1OpOrInterfaceRewritePatternBase.html">OpOrInterfaceRewritePatternBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1detail_1_1OpOrInterfaceRewritePatternBase.html" title="OpOrInterfaceRewritePatternBase is a wrapper around RewritePattern that allows for matching and rewri...">OpOrInterfaceRewritePatternBase</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> that allows for matching and rewriting against an instance of a derived operation class or <a class="el" href="classmlir_1_1detail_1_1Interface.html" title="This class represents an abstract interface.">Interface</a>.  <a href="structmlir_1_1detail_1_1OpOrInterfaceRewritePatternBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserTraitBase.html">StorageUserTraitBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for implementing traits for storage classes.  <a href="classmlir_1_1detail_1_1StorageUserTraitBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">StorageUserBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for implementing users of storage classes uniqued by a <a class="el" href="classmlir_1_1StorageUniquer.html" title="A utility class to get or create instances of &quot;storage classes&quot;.">StorageUniquer</a>.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html">TypeUniquer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to get, or create, unique instances of types within an <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a>.  <a href="structmlir_1_1detail_1_1TypeUniquer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1IROperandBase.html">IROperandBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the base for <a class="el" href="classmlir_1_1IROperand.html" title="A reference to a value, suitable for use as an operand of an operation.">IROperand</a>, and provides all of the non-templated facilities for operand use management.  <a href="classmlir_1_1detail_1_1IROperandBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1ValueImpl.html">ValueImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all derived <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> classes.  <a href="classmlir_1_1detail_1_1ValueImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1BlockArgumentImpl.html">BlockArgumentImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal implementation of a <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a>.  <a href="classmlir_1_1detail_1_1BlockArgumentImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1OpResultImpl.html">OpResultImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the implementation for an operation result.  <a href="classmlir_1_1detail_1_1OpResultImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1InlineOpResult.html">InlineOpResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the implementation for an operation result whose index can be represented "inline" in the underlying <a class="el" href="classmlir_1_1detail_1_1ValueImpl.html" title="The base class for all derived Value classes.">ValueImpl</a>.  <a href="structmlir_1_1detail_1_1InlineOpResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1OutOfLineOpResult.html">OutOfLineOpResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the implementation for an operation result whose index cannot be represented "inline", and thus requires an additional index field.  <a href="classmlir_1_1detail_1_1OutOfLineOpResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1TypedValue.html">TypedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1detail_1_1TypedValue.html" title="TypedValue is a Value with a statically know type.">TypedValue</a> is a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> with a statically know type.  <a href="structmlir_1_1detail_1_1TypedValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PreservedAnalyses.html">PreservedAnalyses</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to represent the analyses that are known to be preserved.  <a href="classmlir_1_1detail_1_1PreservedAnalyses.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AnalysisConcept.html">AnalysisConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract polymorphic base class representing an analysis.  <a href="structmlir_1_1detail_1_1AnalysisConcept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AnalysisModel.html">AnalysisModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A derived analysis model used to hold a specific analysis object.  <a href="structmlir_1_1detail_1_1AnalysisModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AnalysisMap.html">AnalysisMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a cache of analyses for a single operation.  <a href="classmlir_1_1detail_1_1AnalysisMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1NestedAnalysisMap.html">NestedAnalysisMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An analysis map that contains a map for the current operation, and a set of maps for any child operations.  <a href="structmlir_1_1detail_1_1NestedAnalysisMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1PassExecutionState.html">PassExecutionState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state for a single execution of a pass.  <a href="structmlir_1_1detail_1_1PassExecutionState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PassOptions.html">PassOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base container class and manager for all pass options.  <a href="classmlir_1_1detail_1_1PassOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Interface.html">Interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an abstract interface.  <a href="classmlir_1_1detail_1_1Interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1count__if__t__impl.html">count_if_t_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template utility that computes the number of elements within <code>T</code> that satisfy the given predicate.  <a href="structmlir_1_1detail_1_1count__if__t__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1count__if__t__impl_3_01Pred_00_01N_00_01T_00_01Us_8_8_8_01_4.html">count_if_t_impl&lt; Pred, N, T, Us... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1InterfaceMap.html">InterfaceMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an efficient mapping between a given <code><a class="el" href="classmlir_1_1detail_1_1Interface.html" title="This class represents an abstract interface.">Interface</a></code> type, and a particular implementation of its concept.  <a href="classmlir_1_1detail_1_1InterfaceMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1FallbackTypeIDResolver.html">FallbackTypeIDResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a fallback for resolving TypeIDs.  <a href="classmlir_1_1detail_1_1FallbackTypeIDResolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__fully__resolved__t.html">is_fully_resolved_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1TypeIDResolver.html">TypeIDResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a resolver for getting the ID for a given class T.  <a href="classmlir_1_1detail_1_1TypeIDResolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1InlineTypeIDResolver.html">InlineTypeIDResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides utilities for resolving the <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a> of a class that provides a <code>static <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a> <a class="el" href="structmlir_1_1detail_1_1InlineTypeIDResolver.html#a94343b857aec8e86b6000bbd453f786b">resolveTypeID()</a></code> method.  <a href="structmlir_1_1detail_1_1InlineTypeIDResolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1TypeIDResolver_3_01T_00_01std_1_1enable__if__t_3_01InlineTypeIDResolver_1d0aed3a2268b37a1e2af8caec7ea91e4.html">TypeIDResolver&lt; T, std::enable_if_t&lt; InlineTypeIDResolver::has_resolve_typeid&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a resolver for getting the ID for a given class T, when the class provides a <code>static <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a> <a class="el" href="classmlir_1_1detail_1_1TypeIDResolver_3_01T_00_01std_1_1enable__if__t_3_01InlineTypeIDResolver_1d0aed3a2268b37a1e2af8caec7ea91e4.html#a44f66ca9f3d85b18a223313feb90f7e7">resolveTypeID()</a></code> method.  <a href="classmlir_1_1detail_1_1TypeIDResolver_3_01T_00_01std_1_1enable__if__t_3_01InlineTypeIDResolver_1d0aed3a2268b37a1e2af8caec7ea91e4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1CreateAlgebraicOpForEndomorphismSimplification.html">CreateAlgebraicOpForEndomorphismSimplification</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AsmParserImpl.html">AsmParserImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the implementation of the generic parser methods within <a class="el" href="classmlir_1_1AsmParser.html" title="This base class exposes generic asm parser hooks, usable across the various derived parsers.">AsmParser</a>.  <a href="classmlir_1_1detail_1_1AsmParserImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html">Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implement support for parsing global entities like attributes and types.  <a href="classmlir_1_1detail_1_1Parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1SymbolState.html">SymbolState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains record of any parsed top-level symbols.  <a href="structmlir_1_1detail_1_1SymbolState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ParserState.html">ParserState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class refers to all of the state maintained globally by the parser, such as the current lexer position etc.  <a href="structmlir_1_1detail_1_1ParserState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DataLayoutEntryAttrStorage.html">DataLayoutEntryAttrStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineExprStorage.html">AffineExprStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage class appearing in an affine expression.  <a href="structmlir_1_1detail_1_1AffineExprStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineBinaryOpExprStorage.html">AffineBinaryOpExprStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binary operation appearing in an affine expression.  <a href="structmlir_1_1detail_1_1AffineBinaryOpExprStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineDimExprStorage.html">AffineDimExprStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimensional or symbolic identifier appearing in an affine expression.  <a href="structmlir_1_1detail_1_1AffineDimExprStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineConstantExprStorage.html">AffineConstantExprStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer constant appearing in affine expression.  <a href="structmlir_1_1detail_1_1AffineConstantExprStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineMapStorage.html">AffineMapStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AsmStateImpl.html">AsmStateImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DenseElementsAttributeStorage.html">DenseElementsAttributeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute representing a reference to a dense vector or tensor object.  <a href="structmlir_1_1detail_1_1DenseElementsAttributeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DenseIntOrFPElementsAttrStorage.html">DenseIntOrFPElementsAttrStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute representing a reference to a dense vector or tensor object.  <a href="structmlir_1_1detail_1_1DenseIntOrFPElementsAttrStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DenseStringElementsAttrStorage.html">DenseStringElementsAttrStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute representing a reference to a dense vector or tensor object containing strings.  <a href="structmlir_1_1detail_1_1DenseStringElementsAttrStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1StringAttrStorage.html">StringAttrStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DistinctAttrStorage.html">DistinctAttrStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute to store a distinct reference to another attribute.  <a href="structmlir_1_1detail_1_1DistinctAttrStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DistinctAttributeUniquer.html">DistinctAttributeUniquer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialized attribute uniquer for distinct attributes that always allocates since the distinct attribute instances use the address of their storage as unique identifier.  <a href="classmlir_1_1detail_1_1DistinctAttributeUniquer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DistinctAttributeAllocator.html">DistinctAttributeAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An allocator for distinct attribute storage instances.  <a href="classmlir_1_1detail_1_1DistinctAttributeAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DiagnosticEngineImpl.html">DiagnosticEngineImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1SourceMgrDiagnosticHandlerImpl.html">SourceMgrDiagnosticHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ExpectedDiag.html">ExpectedDiag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an expected output diagnostic.  <a href="structmlir_1_1detail_1_1ExpectedDiag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1SourceMgrDiagnosticVerifierHandlerImpl.html">SourceMgrDiagnosticVerifierHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ParallelDiagnosticHandlerImpl.html">ParallelDiagnosticHandlerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DynamicTypeStorage.html">DynamicTypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of <a class="el" href="classmlir_1_1DynamicType.html" title="A dynamic type instance.">DynamicType</a>.  <a href="structmlir_1_1detail_1_1DynamicTypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DynamicAttrStorage.html">DynamicAttrStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of <a class="el" href="classmlir_1_1DynamicAttr.html" title="A dynamic attribute instance.">DynamicAttr</a>.  <a href="structmlir_1_1detail_1_1DynamicAttrStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1IntegerSetStorage.html">IntegerSetStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1FileLineColRangeAttrStorage.html">FileLineColRangeAttrStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1IntegerTypeStorage.html">IntegerTypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> Storage and Uniquing.  <a href="structmlir_1_1detail_1_1IntegerTypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1FunctionTypeStorage.html">FunctionTypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> Storage and Uniquing.  <a href="structmlir_1_1detail_1_1FunctionTypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1TupleTypeStorage.html">TupleTypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing a collection of other types.  <a href="structmlir_1_1detail_1_1TupleTypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1OpPassManagerImpl.html">OpPassManagerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1PassInstrumentorImpl.html">PassInstrumentorImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1RecoveryReproducerContext.html">RecoveryReproducerContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the context for generating a recovery reproducer.  <a href="structmlir_1_1detail_1_1RecoveryReproducerContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1OpToOpPassAdaptor.html">OpToOpPassAdaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptor pass used to run operation passes over nested operations.  <a href="classmlir_1_1detail_1_1OpToOpPassAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PassCrashReproducerGenerator.html">PassCrashReproducerGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1PassPipelineCLParserImpl.html">PassPipelineCLParserImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PDLByteCodeMutableState.html">PDLByteCodeMutableState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PDLByteCodePattern.html">PDLByteCodePattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PDLByteCode.html">PDLByteCode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1StorageUniquerImpl.html">StorageUniquerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the implementation of the <a class="el" href="classmlir_1_1StorageUniquer.html" title="A utility class to get or create instances of &quot;storage classes&quot;.">StorageUniquer</a> class.  <a href="structmlir_1_1detail_1_1StorageUniquerImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1TimingManagerImpl.html">TimingManagerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private implementation details of the <code><a class="el" href="classmlir_1_1TimingManager.html" title="This class represents facilities to measure execution time.">TimingManager</a></code>.  <a href="classmlir_1_1detail_1_1TimingManagerImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DefaultTimingManagerImpl.html">DefaultTimingManagerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation details of the <code><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream.">DefaultTimingManager</a></code>.  <a href="classmlir_1_1detail_1_1DefaultTimingManagerImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ConversionPatternRewriterImpl.html">ConversionPatternRewriterImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6674e02b9acfc220caf0a47e6dbab6ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6674e02b9acfc220caf0a47e6dbab6ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a6674e02b9acfc220caf0a47e6dbab6ea">has_default_sub_element_handler_t</a> = decltype(T::DefaultHandlerTag)</td></tr>
<tr class="separator:a6674e02b9acfc220caf0a47e6dbab6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec637be4fc5a4b359ff417c0f44350b4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:aec637be4fc5a4b359ff417c0f44350b4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aec637be4fc5a4b359ff417c0f44350b4">has_get_method</a> = decltype(T::get(std::declval&lt; Ts &gt;()...))</td></tr>
<tr class="separator:aec637be4fc5a4b359ff417c0f44350b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c91ce05af5c861e1d789201346c457c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a3c91ce05af5c861e1d789201346c457c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a3c91ce05af5c861e1d789201346c457c">has_get_as_key</a> = decltype(std::declval&lt; T &gt;().getAsKey())</td></tr>
<tr class="separator:a3c91ce05af5c861e1d789201346c457c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912e3cd5feea0574a2f3fce7c34dcefd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a912e3cd5feea0574a2f3fce7c34dcefd">DenseIterPtrAndSplat</a> = std::pair&lt; const char *, bool &gt;</td></tr>
<tr class="memdesc:a912e3cd5feea0574a2f3fce7c34dcefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair of raw pointer and a boolean flag of whether the pointer holds a splat,.  <a href="namespacemlir_1_1detail.html#a912e3cd5feea0574a2f3fce7c34dcefd">More...</a><br /></td></tr>
<tr class="separator:a912e3cd5feea0574a2f3fce7c34dcefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea4de026e8ae1a9a190b47a066df22f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abea4de026e8ae1a9a190b47a066df22f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#abea4de026e8ae1a9a190b47a066df22f">has_push_back_t</a> = decltype(std::declval&lt; T &gt;().push_back(std::declval&lt; typename T::value_type &amp;&amp; &gt;()))</td></tr>
<tr class="separator:abea4de026e8ae1a9a190b47a066df22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b238e9d75ea8d492ed8460058770f1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MatchTarget &gt; </td></tr>
<tr class="memitem:ad4b238e9d75ea8d492ed8460058770f1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ad4b238e9d75ea8d492ed8460058770f1">has_compatible_matcher_t</a> = decltype(std::declval&lt; T &gt;().match(std::declval&lt; MatchTarget &gt;()))</td></tr>
<tr class="memdesc:ad4b238e9d75ea8d492ed8460058770f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check whether T provides a 'match' method with type <code>MatchTarget</code> (<a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>, <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>, or <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>).  <a href="namespacemlir_1_1detail.html#ad4b238e9d75ea8d492ed8460058770f1">More...</a><br /></td></tr>
<tr class="separator:ad4b238e9d75ea8d492ed8460058770f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b75c9bae3caf1909b6d6277fb6ea61"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2b75c9bae3caf1909b6d6277fb6ea61"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae2b75c9bae3caf1909b6d6277fb6ea61">first_argument</a> = decltype(<a class="el" href="namespacemlir_1_1detail.html#a63c39ecb3618964551c0b29bc356b675">first_argument_type</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="memdesc:ae2b75c9bae3caf1909b6d6277fb6ea61"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> definition of the first argument to the given callable 'T'.  <a href="namespacemlir_1_1detail.html#ae2b75c9bae3caf1909b6d6277fb6ea61">More...</a><br /></td></tr>
<tr class="separator:ae2b75c9bae3caf1909b6d6277fb6ea61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5258e43cc82e8e9a4c2c605f10a16461"><td class="memTemplParams" colspan="2">template&lt;typename FnT &gt; </td></tr>
<tr class="memitem:a5258e43cc82e8e9a4c2c605f10a16461"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a5258e43cc82e8e9a4c2c605f10a16461">walkResultType</a> = decltype(<a class="el" href="namespacemlir_1_1detail.html#a152b851682ac1cad31c84dc1a6fc38cb">walk</a>(nullptr, std::declval&lt; FnT &gt;()))</td></tr>
<tr class="memdesc:a5258e43cc82e8e9a4c2c605f10a16461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to provide the return type of a templated walk method.  <a href="namespacemlir_1_1detail.html#a5258e43cc82e8e9a4c2c605f10a16461">More...</a><br /></td></tr>
<tr class="separator:a5258e43cc82e8e9a4c2c605f10a16461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbea31f5f9034714e29d3a49cae75a4"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class Pred, typename... Ts&gt; </td></tr>
<tr class="memitem:aabbea31f5f9034714e29d3a49cae75a4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aabbea31f5f9034714e29d3a49cae75a4">count_if_t</a> = <a class="el" href="structmlir_1_1detail_1_1count__if__t__impl.html">count_if_t_impl</a>&lt; Pred, 0, Ts... &gt;</td></tr>
<tr class="separator:aabbea31f5f9034714e29d3a49cae75a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf60d55489c71894501becbfaa8c21c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:addf60d55489c71894501becbfaa8c21c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#addf60d55489c71894501becbfaa8c21c">is_interface_t</a> = decltype(<a class="el" href="namespacemlir_1_1detail.html#a493be0c467bac528a100115486f3ec69">isInterfaceImpl</a>(std::declval&lt; T &amp; &gt;()))</td></tr>
<tr class="separator:addf60d55489c71894501becbfaa8c21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b5779c5d7667528bc58cd2f184f180"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9b5779c5d7667528bc58cd2f184f180"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae9b5779c5d7667528bc58cd2f184f180">IsInterface</a> = llvm::is_detected&lt; <a class="el" href="namespacemlir_1_1detail.html#addf60d55489c71894501becbfaa8c21c">is_interface_t</a>, T &gt;</td></tr>
<tr class="separator:ae9b5779c5d7667528bc58cd2f184f180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be2dcfec91412eb27290aab9294b4cc"><td class="memTemplParams" colspan="2">template&lt;typename ImplTy , typename... Args&gt; </td></tr>
<tr class="memitem:a1be2dcfec91412eb27290aab9294b4cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a1be2dcfec91412eb27290aab9294b4cc">has_impltype_getkey_t</a> = decltype(ImplTy::getKey(std::declval&lt; Args &gt;()...))</td></tr>
<tr class="memdesc:a1be2dcfec91412eb27290aab9294b4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if ImplTy provides a 'getKey' method with types 'Args'.  <a href="namespacemlir_1_1detail.html#a1be2dcfec91412eb27290aab9294b4cc">More...</a><br /></td></tr>
<tr class="separator:a1be2dcfec91412eb27290aab9294b4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2713c77027515db7c2d5f698d0f33c"><td class="memTemplParams" colspan="2">template&lt;typename ImplTy , typename T &gt; </td></tr>
<tr class="memitem:afb2713c77027515db7c2d5f698d0f33c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#afb2713c77027515db7c2d5f698d0f33c">has_impltype_hash_t</a> = decltype(ImplTy::hashKey(std::declval&lt; T &gt;()))</td></tr>
<tr class="memdesc:afb2713c77027515db7c2d5f698d0f33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if ImplTy provides a 'hashKey' method for 'T'.  <a href="namespacemlir_1_1detail.html#afb2713c77027515db7c2d5f698d0f33c">More...</a><br /></td></tr>
<tr class="separator:afb2713c77027515db7c2d5f698d0f33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a78296380781bb5c3af2dd2ad9b70c26f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a78296380781bb5c3af2dd2ad9b70c26f">OpProperties</a> : char </td></tr>
<tr class="memdesc:a78296380781bb5c3af2dd2ad9b70c26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "tag" used for mapping the properties storage in llvm::TrailingObjects.  <a href="namespacemlir_1_1detail.html#a78296380781bb5c3af2dd2ad9b70c26f">More...</a><br /></td></tr>
<tr class="separator:a78296380781bb5c3af2dd2ad9b70c26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1e92b3730d5a0d2e1c4f704cb4674d1e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a1e92b3730d5a0d2e1c4f704cb4674d1e">isPowerOf2</a> (int n)</td></tr>
<tr class="separator:a1e92b3730d5a0d2e1c4f704cb4674d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a50c1b52f8e20f12e77716d79a5868"><td class="memItemLeft" align="right" valign="top">constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a69a50c1b52f8e20f12e77716d79a5868">nextPowerOf2</a> (int n)</td></tr>
<tr class="separator:a69a50c1b52f8e20f12e77716d79a5868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48e4040142437e45b8fe0f83b837ad9"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ab48e4040142437e45b8fe0f83b837ad9"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; int64_t, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ab48e4040142437e45b8fe0f83b837ad9">makeStrides</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape)</td></tr>
<tr class="memdesc:ab48e4040142437e45b8fe0f83b837ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a shape with sizes greater than 0 along all dimensions, returns the distance, in number of elements, between a slice in a dimension and the next slice in the same dimension.  <a href="namespacemlir_1_1detail.html#ab48e4040142437e45b8fe0f83b837ad9">More...</a><br /></td></tr>
<tr class="separator:ab48e4040142437e45b8fe0f83b837ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8eaeb3d7b3be7839ef146f1f82a313"><td class="memTemplParams" colspan="2">template&lt;int N, typename T &gt; </td></tr>
<tr class="memitem:ada8eaeb3d7b3be7839ef146f1f82a313"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(N &gt;=1), <a class="el" href="structStridedMemRefType.html">StridedMemRefType</a>&lt; T, N &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ada8eaeb3d7b3be7839ef146f1f82a313">makeStridedMemRefDescriptor</a> (T *ptr, T *alignedPtr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shapeAlloc)</td></tr>
<tr class="memdesc:ada8eaeb3d7b3be7839ef146f1f82a313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <code>StridedMemRefDescriptor&lt;T, N&gt;</code> that matches the MLIR ABI.  <a href="namespacemlir_1_1detail.html#ada8eaeb3d7b3be7839ef146f1f82a313">More...</a><br /></td></tr>
<tr class="separator:ada8eaeb3d7b3be7839ef146f1f82a313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a76d14b47a24b32bcb01c58dced65f8"><td class="memTemplParams" colspan="2">template&lt;int N, typename T &gt; </td></tr>
<tr class="memitem:a1a76d14b47a24b32bcb01c58dced65f8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(N==0), <a class="el" href="structStridedMemRefType.html">StridedMemRefType</a>&lt; T, 0 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a1a76d14b47a24b32bcb01c58dced65f8">makeStridedMemRefDescriptor</a> (T *ptr, T *alignedPtr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shapeAlloc={})</td></tr>
<tr class="memdesc:a1a76d14b47a24b32bcb01c58dced65f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <code>StridedMemRefDescriptor&lt;T, 0&gt;</code> that matches the MLIR ABI.  <a href="namespacemlir_1_1detail.html#a1a76d14b47a24b32bcb01c58dced65f8">More...</a><br /></td></tr>
<tr class="separator:a1a76d14b47a24b32bcb01c58dced65f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae964b04f941d43593051e7ffd751e6c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae964b04f941d43593051e7ffd751e6c1"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; T *, T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae964b04f941d43593051e7ffd751e6c1">allocAligned</a> (size_t nElements, <a class="el" href="namespacemlir.html#ac9afb3b6f82b256aea9f20e913e8afd5">AllocFunType</a> allocFun=&amp;::malloc, std::optional&lt; uint64_t &gt; alignment=std::optional&lt; uint64_t &gt;())</td></tr>
<tr class="memdesc:ae964b04f941d43593051e7ffd751e6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align <code>nElements</code> of type T with an optional <code>alignment</code>.  <a href="namespacemlir_1_1detail.html#ae964b04f941d43593051e7ffd751e6c1">More...</a><br /></td></tr>
<tr class="separator:ae964b04f941d43593051e7ffd751e6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083757618e89b0f53d587541eccf53e0"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a083757618e89b0f53d587541eccf53e0">getBranchSuccessorArgument</a> (const <a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> &amp;operands, unsigned operandIndex, <a class="el" href="classmlir_1_1Block.html">Block</a> *successor)</td></tr>
<tr class="memdesc:a083757618e89b0f53d587541eccf53e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <code><a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a></code> corresponding to operand <code>operandIndex</code> in some successor if <code>operandIndex</code> is within the range of <code>operands</code>, or std::nullopt if <code>operandIndex</code> isn't a successor operand index.  <a href="namespacemlir_1_1detail.html#a083757618e89b0f53d587541eccf53e0">More...</a><br /></td></tr>
<tr class="separator:a083757618e89b0f53d587541eccf53e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2f4d4cb24fe5f60b359e5962ad5498"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a2e2f4d4cb24fe5f60b359e5962ad5498">verifyBranchSuccessorOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, unsigned succNo, const <a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> &amp;operands)</td></tr>
<tr class="memdesc:a2e2f4d4cb24fe5f60b359e5962ad5498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the given operands match those of the given successor block.  <a href="namespacemlir_1_1detail.html#a2e2f4d4cb24fe5f60b359e5962ad5498">More...</a><br /></td></tr>
<tr class="separator:a2e2f4d4cb24fe5f60b359e5962ad5498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5372df7a0d717fe3ad6238640425402"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae5372df7a0d717fe3ad6238640425402">verifyBranchWeights</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ae5372df7a0d717fe3ad6238640425402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the branch weights attached to an operation implementing WeightedBranchOpInterface are correct.  <a href="namespacemlir_1_1detail.html#ae5372df7a0d717fe3ad6238640425402">More...</a><br /></td></tr>
<tr class="separator:ae5372df7a0d717fe3ad6238640425402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a3777b2ac1a4abcc61e74c35c7b997"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a25a3777b2ac1a4abcc61e74c35c7b997">verifyRegionBranchWeights</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a25a3777b2ac1a4abcc61e74c35c7b997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the region weights attached to an operation implementing WeightedRegiobBranchOpInterface are correct.  <a href="namespacemlir_1_1detail.html#a25a3777b2ac1a4abcc61e74c35c7b997">More...</a><br /></td></tr>
<tr class="separator:a25a3777b2ac1a4abcc61e74c35c7b997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4afbba3aecdff992f5fb31b086f9c12"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae4afbba3aecdff992f5fb31b086f9c12">verifyTypesAlongControlFlowEdges</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ae4afbba3aecdff992f5fb31b086f9c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that types match along control flow edges described the given op.  <a href="namespacemlir_1_1detail.html#ae4afbba3aecdff992f5fb31b086f9c12">More...</a><br /></td></tr>
<tr class="separator:ae4afbba3aecdff992f5fb31b086f9c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ca94416539c5fc8c1b2df637f6b522"><td class="memItemLeft" align="right" valign="top">llvm::TypeSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a87ca94416539c5fc8c1b2df637f6b522">getDefaultTypeSize</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> params)</td></tr>
<tr class="memdesc:a87ca94416539c5fc8c1b2df637f6b522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the type size request.  <a href="namespacemlir_1_1detail.html#a87ca94416539c5fc8c1b2df637f6b522">More...</a><br /></td></tr>
<tr class="separator:a87ca94416539c5fc8c1b2df637f6b522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cf52d46088967fe0b00f1a7f704eae"><td class="memItemLeft" align="right" valign="top">llvm::TypeSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a89cf52d46088967fe0b00f1a7f704eae">getDefaultTypeSizeInBits</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> params)</td></tr>
<tr class="memdesc:a89cf52d46088967fe0b00f1a7f704eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the type size in bits request.  <a href="namespacemlir_1_1detail.html#a89cf52d46088967fe0b00f1a7f704eae">More...</a><br /></td></tr>
<tr class="separator:a89cf52d46088967fe0b00f1a7f704eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8409dbc763fd806cdacab4558dd9e9f6"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a8409dbc763fd806cdacab4558dd9e9f6">getDefaultABIAlignment</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt; params)</td></tr>
<tr class="memdesc:a8409dbc763fd806cdacab4558dd9e9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the required alignment request.  <a href="namespacemlir_1_1detail.html#a8409dbc763fd806cdacab4558dd9e9f6">More...</a><br /></td></tr>
<tr class="separator:a8409dbc763fd806cdacab4558dd9e9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9812a6a269eaa19d0e843b22596578d0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a9812a6a269eaa19d0e843b22596578d0">getDefaultPreferredAlignment</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt; params)</td></tr>
<tr class="memdesc:a9812a6a269eaa19d0e843b22596578d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the preferred alignment request.  <a href="namespacemlir_1_1detail.html#a9812a6a269eaa19d0e843b22596578d0">More...</a><br /></td></tr>
<tr class="separator:a9812a6a269eaa19d0e843b22596578d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3919dd661434ca92b4ebe5a20e58b1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a1b3919dd661434ca92b4ebe5a20e58b1">getDefaultIndexBitwidth</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt; params)</td></tr>
<tr class="memdesc:a1b3919dd661434ca92b4ebe5a20e58b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the index bitwidth request.  <a href="namespacemlir_1_1detail.html#a1b3919dd661434ca92b4ebe5a20e58b1">More...</a><br /></td></tr>
<tr class="separator:a1b3919dd661434ca92b4ebe5a20e58b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc8e12b852a89dc2d49a19dab76bbf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a0fc8e12b852a89dc2d49a19dab76bbf8">getDefaultEndianness</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:a0fc8e12b852a89dc2d49a19dab76bbf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for endianness request.  <a href="namespacemlir_1_1detail.html#a0fc8e12b852a89dc2d49a19dab76bbf8">More...</a><br /></td></tr>
<tr class="separator:a0fc8e12b852a89dc2d49a19dab76bbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4b21752e6c90f16e818bb89b80df5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aeb4b21752e6c90f16e818bb89b80df5d">getDefaultMemorySpace</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:aeb4b21752e6c90f16e818bb89b80df5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the default memory space request.  <a href="namespacemlir_1_1detail.html#aeb4b21752e6c90f16e818bb89b80df5d">More...</a><br /></td></tr>
<tr class="separator:aeb4b21752e6c90f16e818bb89b80df5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d624115ea61e5b456d4c613a770631"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a04d624115ea61e5b456d4c613a770631">getDefaultAllocaMemorySpace</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:a04d624115ea61e5b456d4c613a770631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for alloca memory space request.  <a href="namespacemlir_1_1detail.html#a04d624115ea61e5b456d4c613a770631">More...</a><br /></td></tr>
<tr class="separator:a04d624115ea61e5b456d4c613a770631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c79ef12939d977e7a4632bcc8b75a31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a6c79ef12939d977e7a4632bcc8b75a31">getDefaultManglingMode</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:a6c79ef12939d977e7a4632bcc8b75a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for mangling mode request.  <a href="namespacemlir_1_1detail.html#a6c79ef12939d977e7a4632bcc8b75a31">More...</a><br /></td></tr>
<tr class="separator:a6c79ef12939d977e7a4632bcc8b75a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0937e5890b25f8114fefdfe666484ac5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a0937e5890b25f8114fefdfe666484ac5">getDefaultProgramMemorySpace</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:a0937e5890b25f8114fefdfe666484ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for program memory space request.  <a href="namespacemlir_1_1detail.html#a0937e5890b25f8114fefdfe666484ac5">More...</a><br /></td></tr>
<tr class="separator:a0937e5890b25f8114fefdfe666484ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbccfb558aabea7d6494d225b56446e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#acbccfb558aabea7d6494d225b56446e8">getDefaultGlobalMemorySpace</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:acbccfb558aabea7d6494d225b56446e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for global memory space request.  <a href="namespacemlir_1_1detail.html#acbccfb558aabea7d6494d225b56446e8">More...</a><br /></td></tr>
<tr class="separator:acbccfb558aabea7d6494d225b56446e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c14c1ac1334d61bf90aa4f60a5fa261"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a9c14c1ac1334d61bf90aa4f60a5fa261">getDefaultStackAlignment</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:a9c14c1ac1334d61bf90aa4f60a5fa261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the stack alignment request.  <a href="namespacemlir_1_1detail.html#a9c14c1ac1334d61bf90aa4f60a5fa261">More...</a><br /></td></tr>
<tr class="separator:a9c14c1ac1334d61bf90aa4f60a5fa261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af519cb1b89cef66201a509b636c0899a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#af519cb1b89cef66201a509b636c0899a">getDefaultFunctionPointerAlignment</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:af519cb1b89cef66201a509b636c0899a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the function pointer alignment request.  <a href="namespacemlir_1_1detail.html#af519cb1b89cef66201a509b636c0899a">More...</a><br /></td></tr>
<tr class="separator:af519cb1b89cef66201a509b636c0899a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86153589d0a1d2f1d462dee9d852646c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a86153589d0a1d2f1d462dee9d852646c">getDefaultLegalIntWidths</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:a86153589d0a1d2f1d462dee9d852646c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the legal int widths request.  <a href="namespacemlir_1_1detail.html#a86153589d0a1d2f1d462dee9d852646c">More...</a><br /></td></tr>
<tr class="separator:a86153589d0a1d2f1d462dee9d852646c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d552809ed611d55492c36bbb09886fe"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a5d552809ed611d55492c36bbb09886fe">getDevicePropertyValue</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:a5d552809ed611d55492c36bbb09886fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the property from the specified DataLayoutEntry.  <a href="namespacemlir_1_1detail.html#a5d552809ed611d55492c36bbb09886fe">More...</a><br /></td></tr>
<tr class="separator:a5d552809ed611d55492c36bbb09886fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d3a751d105f957d43b5ee8ad6ab047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a72a4f77607d05cf551b24ceb9362c034">DataLayoutEntryList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a31d3a751d105f957d43b5ee8ad6ab047">filterEntriesForType</a> (<a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> entries, <a class="el" href="classmlir_1_1TypeID.html">TypeID</a> typeID)</td></tr>
<tr class="memdesc:a31d3a751d105f957d43b5ee8ad6ab047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of data layout entries, returns a new list containing the entries with keys having the given type ID, i.e.  <a href="namespacemlir_1_1detail.html#a31d3a751d105f957d43b5ee8ad6ab047">More...</a><br /></td></tr>
<tr class="separator:a31d3a751d105f957d43b5ee8ad6ab047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ddc54fc9b6e82cf3b6a797a6bfefca"><td class="memItemLeft" align="right" valign="top">DataLayoutEntryInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#af7ddc54fc9b6e82cf3b6a797a6bfefca">filterEntryForIdentifier</a> (<a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a> entries, StringAttr id)</td></tr>
<tr class="memdesc:af7ddc54fc9b6e82cf3b6a797a6bfefca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of data layout entries, returns the entry that has the given identifier as key, if such an entry exists in the list.  <a href="namespacemlir_1_1detail.html#af7ddc54fc9b6e82cf3b6a797a6bfefca">More...</a><br /></td></tr>
<tr class="separator:af7ddc54fc9b6e82cf3b6a797a6bfefca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6142ce3e04093b8805b807bbade3ec01"><td class="memItemLeft" align="right" valign="top">TargetDeviceSpecInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a6142ce3e04093b8805b807bbade3ec01">filterEntryForIdentifier</a> (<a class="el" href="namespacemlir.html#aa90f8dcaf13650935b7e9a32ccf0c055">TargetDeviceSpecListRef</a> entries, StringAttr id)</td></tr>
<tr class="memdesc:a6142ce3e04093b8805b807bbade3ec01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of target device entries, returns the entry that has the given identifier as key, if such an entry exists in the list.  <a href="namespacemlir_1_1detail.html#a6142ce3e04093b8805b807bbade3ec01">More...</a><br /></td></tr>
<tr class="separator:a6142ce3e04093b8805b807bbade3ec01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3b9d7e0a9cd00a32827f48d4536850"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aee3b9d7e0a9cd00a32827f48d4536850">verifyDataLayoutOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:aee3b9d7e0a9cd00a32827f48d4536850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the operation implementing the data layout interface, or a module operation, is valid.  <a href="namespacemlir_1_1detail.html#aee3b9d7e0a9cd00a32827f48d4536850">More...</a><br /></td></tr>
<tr class="separator:aee3b9d7e0a9cd00a32827f48d4536850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a791a52efb3f0b9d61ca353b635e95"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#af3a791a52efb3f0b9d61ca353b635e95">verifyDataLayoutSpec</a> (DataLayoutSpecInterface spec, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:af3a791a52efb3f0b9d61ca353b635e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that a data layout spec is valid.  <a href="namespacemlir_1_1detail.html#af3a791a52efb3f0b9d61ca353b635e95">More...</a><br /></td></tr>
<tr class="separator:af3a791a52efb3f0b9d61ca353b635e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474ca87dcf5fa084441e1a1275852fbb"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a474ca87dcf5fa084441e1a1275852fbb">verifyTargetSystemSpec</a> (TargetSystemSpecInterface spec, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a474ca87dcf5fa084441e1a1275852fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that a target system desc spec is valid.  <a href="namespacemlir_1_1detail.html#a474ca87dcf5fa084441e1a1275852fbb">More...</a><br /></td></tr>
<tr class="separator:a474ca87dcf5fa084441e1a1275852fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a07efa628a8720c45b577162e4fe66"><td class="memItemLeft" align="right" valign="top">llvm::TypeSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a98a07efa628a8720c45b577162e4fe66">divideCeil</a> (llvm::TypeSize numerator, uint64_t denominator)</td></tr>
<tr class="memdesc:a98a07efa628a8720c45b577162e4fe66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the known min value of the numerator by the denominator and rounds the result up to the next integer.  <a href="namespacemlir_1_1detail.html#a98a07efa628a8720c45b577162e4fe66">More...</a><br /></td></tr>
<tr class="separator:a98a07efa628a8720c45b577162e4fe66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3a9033156fc6f0f4ee40b16eaa835c"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#abc3a9033156fc6f0f4ee40b16eaa835c">verifyDestinationStyleOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:abc3a9033156fc6f0f4ee40b16eaa835c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that <code>op</code> conforms to the invariants of DestinationStyleOpInterface.  <a href="namespacemlir_1_1detail.html#abc3a9033156fc6f0f4ee40b16eaa835c">More...</a><br /></td></tr>
<tr class="separator:abc3a9033156fc6f0f4ee40b16eaa835c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ee29379e4568366034d669b060a034"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a77ee29379e4568366034d669b060a034">verifyIndexingMapOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a77ee29379e4568366034d669b060a034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that <code>op</code> conforms to the invariants of StructuredOpInterface.  <a href="namespacemlir_1_1detail.html#a77ee29379e4568366034d669b060a034">More...</a><br /></td></tr>
<tr class="separator:a77ee29379e4568366034d669b060a034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a945b620206532de586bf2c444fa1e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a33a945b620206532de586bf2c444fa1e">inferReturnTensorTypes</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1ShapedTypeComponents.html">ShapedTypeComponents</a> &gt; retComponents, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;inferredReturnTypes)</td></tr>
<tr class="separator:a33a945b620206532de586bf2c444fa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad276c5acc7f5d475d0e1987a456a59e0"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ad276c5acc7f5d475d0e1987a456a59e0">verifyInferredResultTypes</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ad276c5acc7f5d475d0e1987a456a59e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the inferred result types match the actual result types for the op.  <a href="namespacemlir_1_1detail.html#ad276c5acc7f5d475d0e1987a456a59e0">More...</a><br /></td></tr>
<tr class="separator:ad276c5acc7f5d475d0e1987a456a59e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f85cda3d8183cca5b6c2766fddb2fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ab5f85cda3d8183cca5b6c2766fddb2fb">reportFatalInferReturnTypesError</a> (<a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;state)</td></tr>
<tr class="memdesc:ab5f85cda3d8183cca5b6c2766fddb2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report a fatal error indicating that the result types could not be inferred.  <a href="namespacemlir_1_1detail.html#ab5f85cda3d8183cca5b6c2766fddb2fb">More...</a><br /></td></tr>
<tr class="separator:ab5f85cda3d8183cca5b6c2766fddb2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960f17c15fd15a72390d00da41a4e12f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a960f17c15fd15a72390d00da41a4e12f">verifyLoopLikeOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a960f17c15fd15a72390d00da41a4e12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify invariants of the LoopLikeOpInterface.  <a href="namespacemlir_1_1detail.html#a960f17c15fd15a72390d00da41a4e12f">More...</a><br /></td></tr>
<tr class="separator:a960f17c15fd15a72390d00da41a4e12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad771bcf841b38d5c2ccca4417102863e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ad771bcf841b38d5c2ccca4417102863e">verifyMemorySpaceCastOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ad771bcf841b38d5c2ccca4417102863e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to verify the given memory space cast operation.  <a href="namespacemlir_1_1detail.html#ad771bcf841b38d5c2ccca4417102863e">More...</a><br /></td></tr>
<tr class="separator:ad771bcf841b38d5c2ccca4417102863e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb7be75817707a561386449c561cc31"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a7bb7be75817707a561386449c561cc31">bubbleDownInPlaceMemorySpaceCastImpl</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;operand, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> results)</td></tr>
<tr class="memdesc:a7bb7be75817707a561386449c561cc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to bubble-down inplace a <code>MemorySpaceCastOpInterface</code> operation referenced by <code>operand</code>.  <a href="namespacemlir_1_1detail.html#a7bb7be75817707a561386449c561cc31">More...</a><br /></td></tr>
<tr class="separator:a7bb7be75817707a561386449c561cc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09e6bd26baceff7935df426cf406496"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#af09e6bd26baceff7935df426cf406496">verifyInParallelOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:af09e6bd26baceff7935df426cf406496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819d12bc01c2443cfc1b72c4824bfaba"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a819d12bc01c2443cfc1b72c4824bfaba">verifyShapedDimOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a819d12bc01c2443cfc1b72c4824bfaba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify invariants of ops that implement the ShapedDimOpInterface.  <a href="namespacemlir_1_1detail.html#a819d12bc01c2443cfc1b72c4824bfaba">More...</a><br /></td></tr>
<tr class="separator:a819d12bc01c2443cfc1b72c4824bfaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af748f20e1dc2fc58d26e3d2257926385"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#af748f20e1dc2fc58d26e3d2257926385">defaultGetDestinationOperand</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:af748f20e1dc2fc58d26e3d2257926385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the destination/"init" operand of the op if it implements the <code>DestinationStyleOpInterface</code> and has exactly one "init" operand.  <a href="namespacemlir_1_1detail.html#af748f20e1dc2fc58d26e3d2257926385">More...</a><br /></td></tr>
<tr class="separator:af748f20e1dc2fc58d26e3d2257926385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac272571a0b927a2a4fa1debf78948bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aac272571a0b927a2a4fa1debf78948bb">defaultGetUpdatedDestination</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:aac272571a0b927a2a4fa1debf78948bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the updated destination result of the op if it implements the <code>DestinationStyleOpInterface</code>.  <a href="namespacemlir_1_1detail.html#aac272571a0b927a2a4fa1debf78948bb">More...</a><br /></td></tr>
<tr class="separator:aac272571a0b927a2a4fa1debf78948bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfec552c5927149bad3102177f1f161a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#adfec552c5927149bad3102177f1f161a">defaultIsEquivalentSubset</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> candidate, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; equivalenceFn)</td></tr>
<tr class="memdesc:adfec552c5927149bad3102177f1f161a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of <code>SubsetInsertionOpInterface::isEquivalentSubset</code>.  <a href="namespacemlir_1_1detail.html#adfec552c5927149bad3102177f1f161a">More...</a><br /></td></tr>
<tr class="separator:adfec552c5927149bad3102177f1f161a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8b66ba9169bfa2c09c598ccca039db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a3e8b66ba9169bfa2c09c598ccca039db">defaultOperatesOnEquivalentSubset</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, SubsetOpInterface candidate, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; equivalenceFn)</td></tr>
<tr class="memdesc:a3e8b66ba9169bfa2c09c598ccca039db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of <code>SubsetOpInterface::operatesOnEquivalentSubset</code>.  <a href="namespacemlir_1_1detail.html#a3e8b66ba9169bfa2c09c598ccca039db">More...</a><br /></td></tr>
<tr class="separator:a3e8b66ba9169bfa2c09c598ccca039db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f1363f8cb9bc8b135a3212569aaf37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a20f1363f8cb9bc8b135a3212569aaf37">defaultOperatesOnDisjointSubset</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, SubsetOpInterface candidate, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; equivalenceFn)</td></tr>
<tr class="memdesc:a20f1363f8cb9bc8b135a3212569aaf37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of <code>SubsetOpInterface::operatesOnDisjointSubset</code>.  <a href="namespacemlir_1_1detail.html#a20f1363f8cb9bc8b135a3212569aaf37">More...</a><br /></td></tr>
<tr class="separator:a20f1363f8cb9bc8b135a3212569aaf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6bd31c91df4b26794a88c1006e83ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a6f6bd31c91df4b26794a88c1006e83ef">getTensorContainer</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a6f6bd31c91df4b26794a88c1006e83ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the container that the given subset op is operating on.  <a href="namespacemlir_1_1detail.html#a6f6bd31c91df4b26794a88c1006e83ef">More...</a><br /></td></tr>
<tr class="separator:a6f6bd31c91df4b26794a88c1006e83ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9dcc8813e435202abcbb438f66d90a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aba9dcc8813e435202abcbb438f66d90a">verifySubsetOpInterface</a> (SubsetOpInterface op)</td></tr>
<tr class="memdesc:aba9dcc8813e435202abcbb438f66d90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify <code>SubsetOpInterface</code>.  <a href="namespacemlir_1_1detail.html#aba9dcc8813e435202abcbb438f66d90a">More...</a><br /></td></tr>
<tr class="separator:aba9dcc8813e435202abcbb438f66d90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebd9058172b2a090d824c6ab1841413"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a0ebd9058172b2a090d824c6ab1841413">verifySubsetExtractionOpInterface</a> (SubsetExtractionOpInterface op)</td></tr>
<tr class="memdesc:a0ebd9058172b2a090d824c6ab1841413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify <code>SubsetExtractionOpInterface</code>.  <a href="namespacemlir_1_1detail.html#a0ebd9058172b2a090d824c6ab1841413">More...</a><br /></td></tr>
<tr class="separator:a0ebd9058172b2a090d824c6ab1841413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebb54d50bfcc329f59aee2490b27c07"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#afebb54d50bfcc329f59aee2490b27c07">verifyOffsetSizeAndStrideOp</a> (OffsetSizeAndStrideOpInterface op)</td></tr>
<tr class="separator:afebb54d50bfcc329f59aee2490b27c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0caa43784c57086534e1833f66eaecfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a0caa43784c57086534e1833f66eaecfc">sameOffsetsSizesAndStrides</a> (OffsetSizeAndStrideOpInterface a, OffsetSizeAndStrideOpInterface b, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>)&gt; cmp)</td></tr>
<tr class="separator:a0caa43784c57086534e1833f66eaecfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbbaf06f702976f635516e2eec5c165"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a4bbbaf06f702976f635516e2eec5c165">getNumDynamicEntriesUpToIdx</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; staticVals, unsigned idx)</td></tr>
<tr class="memdesc:a4bbbaf06f702976f635516e2eec5c165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to compute the number of dynamic entries of <code>staticVals</code>, up to <code>idx</code>.  <a href="namespacemlir_1_1detail.html#a4bbbaf06f702976f635516e2eec5c165">More...</a><br /></td></tr>
<tr class="separator:a4bbbaf06f702976f635516e2eec5c165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad693ba34552063984c6685f93500c79f"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ad693ba34552063984c6685f93500c79f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ad693ba34552063984c6685f93500c79f">bindDims</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="separator:ad693ba34552063984c6685f93500c79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc67b3a3dac2996cc431f90b8658f6e6"><td class="memTemplParams" colspan="2">template&lt;int N, typename AffineExprTy , typename... AffineExprTy2&gt; </td></tr>
<tr class="memitem:adc67b3a3dac2996cc431f90b8658f6e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#adc67b3a3dac2996cc431f90b8658f6e6">bindDims</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;e, AffineExprTy2 &amp;...exprs)</td></tr>
<tr class="separator:adc67b3a3dac2996cc431f90b8658f6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb63088be1c8bff57b28cc3be96701b"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:addb63088be1c8bff57b28cc3be96701b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#addb63088be1c8bff57b28cc3be96701b">bindSymbols</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="separator:addb63088be1c8bff57b28cc3be96701b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0f1dec3bae54bd6eecd9e5abb59e4c"><td class="memTemplParams" colspan="2">template&lt;int N, typename AffineExprTy , typename... AffineExprTy2&gt; </td></tr>
<tr class="memitem:a2b0f1dec3bae54bd6eecd9e5abb59e4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a2b0f1dec3bae54bd6eecd9e5abb59e4c">bindSymbols</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;e, AffineExprTy2 &amp;...exprs)</td></tr>
<tr class="separator:a2b0f1dec3bae54bd6eecd9e5abb59e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc750046567479d1fdfa425bac17b32"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2bc750046567479d1fdfa425bac17b32"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a2bc750046567479d1fdfa425bac17b32">unwrapForCustomParse</a> (FailureOr&lt; T &gt; &amp;failureOr)</td></tr>
<tr class="separator:a2bc750046567479d1fdfa425bac17b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0ecdf07e5bd3e5496db1048d6b0beb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d0ecdf07e5bd3e5496db1048d6b0beb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a9d0ecdf07e5bd3e5496db1048d6b0beb">walkImmediateSubElementsImpl</a> (T derived, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt; walkAttrsFn, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Type.html">Type</a>)&gt; walkTypesFn)</td></tr>
<tr class="memdesc:a9d0ecdf07e5bd3e5496db1048d6b0beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides the underlying implementation for the SubElementInterface walk method, using the key type of the derived attribute/type to interact with the individual parameters.  <a href="namespacemlir_1_1detail.html#a9d0ecdf07e5bd3e5496db1048d6b0beb">More...</a><br /></td></tr>
<tr class="separator:a9d0ecdf07e5bd3e5496db1048d6b0beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451d8dc61974032518997d3f9935e53a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a451d8dc61974032518997d3f9935e53a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a451d8dc61974032518997d3f9935e53a">constructSubElementReplacement</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, Ts &amp;&amp;...params)</td></tr>
<tr class="memdesc:a451d8dc61974032518997d3f9935e53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function invokes the proper <code>get</code> method for a type <code>T</code> with the given values.  <a href="namespacemlir_1_1detail.html#a451d8dc61974032518997d3f9935e53a">More...</a><br /></td></tr>
<tr class="separator:a451d8dc61974032518997d3f9935e53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af776eda51700256b7c60deadcb4d25"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8af776eda51700256b7c60deadcb4d25"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a8af776eda51700256b7c60deadcb4d25">replaceImmediateSubElementsImpl</a> (T derived, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; &amp;replAttrs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;replTypes)</td></tr>
<tr class="memdesc:a8af776eda51700256b7c60deadcb4d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides the underlying implementation for the SubElementInterface replace method, using the key type of the derived attribute/type to interact with the individual parameters.  <a href="namespacemlir_1_1detail.html#a8af776eda51700256b7c60deadcb4d25">More...</a><br /></td></tr>
<tr class="separator:a8af776eda51700256b7c60deadcb4d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3315ae7edc12bed53da6a26424d047"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ada3315ae7edc12bed53da6a26424d047">verifyAffineMapAsLayout</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> m, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="separator:ada3315ae7edc12bed53da6a26424d047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767e521ae7755c29bc29daaeb840c238"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a767e521ae7755c29bc29daaeb840c238">getAffineMapStridesAndOffset</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;strides, int64_t &amp;offset)</td></tr>
<tr class="separator:a767e521ae7755c29bc29daaeb840c238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5492f1b5ad5a28391086b5b866d56cf"><td class="memTemplParams" colspan="2">template&lt;typename MatcherClass &gt; </td></tr>
<tr class="memitem:ac5492f1b5ad5a28391086b5b866d56cf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::is_detected&lt; <a class="el" href="namespacemlir_1_1detail.html#ad4b238e9d75ea8d492ed8460058770f1">detail::has_compatible_matcher_t</a>, MatcherClass, <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ac5492f1b5ad5a28391086b5b866d56cf">matchOperandOrValueAtIndex</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, unsigned idx, MatcherClass &amp;matcher)</td></tr>
<tr class="memdesc:ac5492f1b5ad5a28391086b5b866d56cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically switch to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> matcher.  <a href="namespacemlir_1_1detail.html#ac5492f1b5ad5a28391086b5b866d56cf">More...</a><br /></td></tr>
<tr class="separator:ac5492f1b5ad5a28391086b5b866d56cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7133556c1b0ae2fd063aff7d3639b9eb"><td class="memTemplParams" colspan="2">template&lt;typename MatcherClass &gt; </td></tr>
<tr class="memitem:a7133556c1b0ae2fd063aff7d3639b9eb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::is_detected&lt; <a class="el" href="namespacemlir_1_1detail.html#ad4b238e9d75ea8d492ed8460058770f1">detail::has_compatible_matcher_t</a>, MatcherClass, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a7133556c1b0ae2fd063aff7d3639b9eb">matchOperandOrValueAtIndex</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, unsigned idx, MatcherClass &amp;matcher)</td></tr>
<tr class="memdesc:a7133556c1b0ae2fd063aff7d3639b9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically switch to an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> matcher.  <a href="namespacemlir_1_1detail.html#a7133556c1b0ae2fd063aff7d3639b9eb">More...</a><br /></td></tr>
<tr class="separator:a7133556c1b0ae2fd063aff7d3639b9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baf9bf03348723f8d037a39800d69a7"><td class="memTemplParams" colspan="2">template&lt;typename TupleT , class CallbackT , std::size_t... Is&gt; </td></tr>
<tr class="memitem:a7baf9bf03348723f8d037a39800d69a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a7baf9bf03348723f8d037a39800d69a7">enumerateImpl</a> (TupleT &amp;&amp;tuple, CallbackT &amp;&amp;callback, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="separator:a7baf9bf03348723f8d037a39800d69a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7146031ab7f6bb4cdacc53c4f1e96aac"><td class="memTemplParams" colspan="2">template&lt;typename... Tys, typename CallbackT &gt; </td></tr>
<tr class="memitem:a7146031ab7f6bb4cdacc53c4f1e96aac"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a7146031ab7f6bb4cdacc53c4f1e96aac">enumerate</a> (std::tuple&lt; Tys... &gt; &amp;tuple, CallbackT &amp;&amp;callback)</td></tr>
<tr class="separator:a7146031ab7f6bb4cdacc53c4f1e96aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9dddc7a1f6dc8aa95eaa5b7910c76d5"><td class="memItemLeft" align="right" valign="top">llvm::unique_function&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ac9dddc7a1f6dc8aa95eaa5b7910c76d5">getDefaultDiagnosticEmitFn</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:ac9dddc7a1f6dc8aa95eaa5b7910c76d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to generate a callback that can be used to generate a diagnostic when checking the construction invariants of a storage object.  <a href="namespacemlir_1_1detail.html#ac9dddc7a1f6dc8aa95eaa5b7910c76d5">More...</a><br /></td></tr>
<tr class="separator:ac9dddc7a1f6dc8aa95eaa5b7910c76d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3379fc459c08af37eb4a514b0eadef2d"><td class="memItemLeft" align="right" valign="top">llvm::unique_function&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a3379fc459c08af37eb4a514b0eadef2d">getDefaultDiagnosticEmitFn</a> (const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;loc)</td></tr>
<tr class="separator:a3379fc459c08af37eb4a514b0eadef2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9f7283021fca39df8cf99bbd90cf4a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aea9f7283021fca39df8cf99bbd90cf4a">verifySymbolTable</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:aea9f7283021fca39df8cf99bbd90cf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e42f84b57ed10b489c12a7236bb356"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae8e42f84b57ed10b489c12a7236bb356">verifySymbol</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:ae8e42f84b57ed10b489c12a7236bb356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f65c29b00af55fbdff5cf2a1bfbbe17"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Arg , typename... Rest&gt; </td></tr>
<tr class="memitem:a6f65c29b00af55fbdff5cf2a1bfbbe17"><td class="memTemplItemLeft" align="right" valign="top">Arg&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a6f65c29b00af55fbdff5cf2a1bfbbe17">first_argument_type</a> (Ret(*)(Arg, Rest...))</td></tr>
<tr class="memdesc:a6f65c29b00af55fbdff5cf2a1bfbbe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper templates to deduce the first argument of a callback parameter.  <a href="namespacemlir_1_1detail.html#a6f65c29b00af55fbdff5cf2a1bfbbe17">More...</a><br /></td></tr>
<tr class="separator:a6f65c29b00af55fbdff5cf2a1bfbbe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b5b18be8ea226e9d3606f21c1a7a7e"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename F , typename Arg , typename... Rest&gt; </td></tr>
<tr class="memitem:ae4b5b18be8ea226e9d3606f21c1a7a7e"><td class="memTemplItemLeft" align="right" valign="top">Arg&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ae4b5b18be8ea226e9d3606f21c1a7a7e">first_argument_type</a> (Ret(F::*)(Arg, Rest...))</td></tr>
<tr class="separator:ae4b5b18be8ea226e9d3606f21c1a7a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152b851682ac1cad31c84dc1a6fc38cb"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a152b851682ac1cad31c84dc1a6fc38cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a152b851682ac1cad31c84dc1a6fc38cb">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="memdesc:a152b851682ac1cad31c84dc1a6fc38cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the regions, blocks, or operations nested under (and including) the given operation.  <a href="namespacemlir_1_1detail.html#a152b851682ac1cad31c84dc1a6fc38cb">More...</a><br /></td></tr>
<tr class="separator:a152b851682ac1cad31c84dc1a6fc38cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b337bcade50e3cd7191efec879db837"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a5b337bcade50e3cd7191efec879db837"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a5b337bcade50e3cd7191efec879db837">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Block.html">Block</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="separator:a5b337bcade50e3cd7191efec879db837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adcd8424919a733a4cce559560e5dd9"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a3adcd8424919a733a4cce559560e5dd9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a3adcd8424919a733a4cce559560e5dd9">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="separator:a3adcd8424919a733a4cce559560e5dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eda9acbea0f5326d02db4b99814395"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a08eda9acbea0f5326d02db4b99814395"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a08eda9acbea0f5326d02db4b99814395">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="memdesc:a08eda9acbea0f5326d02db4b99814395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the regions, blocks, or operations nested under (and including) the given operation.  <a href="namespacemlir_1_1detail.html#a08eda9acbea0f5326d02db4b99814395">More...</a><br /></td></tr>
<tr class="separator:a08eda9acbea0f5326d02db4b99814395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac791c882fa374a53b6a7ec0387586f59"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ac791c882fa374a53b6a7ec0387586f59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ac791c882fa374a53b6a7ec0387586f59">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Block.html">Block</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="separator:ac791c882fa374a53b6a7ec0387586f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e61da15ae81a346c6b060103d0ed54"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ab4e61da15ae81a346c6b060103d0ed54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ab4e61da15ae81a346c6b060103d0ed54">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="separator:ab4e61da15ae81a346c6b060103d0ed54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfa95ca210821ec266a0257fe9fe74f"><td class="memTemplParams" colspan="2">template&lt;WalkOrder Order = WalkOrder::PostOrder, typename Iterator  = ForwardIterator, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </td></tr>
<tr class="memitem:addfa95ca210821ec266a0257fe9fe74f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::is_one_of&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;::value, RetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#addfa95ca210821ec266a0257fe9fe74f">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:addfa95ca210821ec266a0257fe9fe74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the regions, blocks, or operations nested under (and including) the given operation.  <a href="namespacemlir_1_1detail.html#addfa95ca210821ec266a0257fe9fe74f">More...</a><br /></td></tr>
<tr class="separator:addfa95ca210821ec266a0257fe9fe74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b0cddf03280b10bdeecbfa002f2f4d"><td class="memTemplParams" colspan="2">template&lt;WalkOrder Order = WalkOrder::PostOrder, typename Iterator  = ForwardIterator, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </td></tr>
<tr class="memitem:a50b0cddf03280b10bdeecbfa002f2f4d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; !llvm::is_one_of&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;::value &amp;&amp;std::is_same&lt; RetT, void &gt;::value, RetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a50b0cddf03280b10bdeecbfa002f2f4d">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:a50b0cddf03280b10bdeecbfa002f2f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations of type 'ArgT' nested under and including the given operation.  <a href="namespacemlir_1_1detail.html#a50b0cddf03280b10bdeecbfa002f2f4d">More...</a><br /></td></tr>
<tr class="separator:a50b0cddf03280b10bdeecbfa002f2f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206f36bc38bdb9160771da18b198fa37"><td class="memTemplParams" colspan="2">template&lt;WalkOrder Order = WalkOrder::PostOrder, typename Iterator  = ForwardIterator, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </td></tr>
<tr class="memitem:a206f36bc38bdb9160771da18b198fa37"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; !llvm::is_one_of&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;::value &amp;&amp;std::is_same&lt; RetT, <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> &gt;::value, RetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a206f36bc38bdb9160771da18b198fa37">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:a206f36bc38bdb9160771da18b198fa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations of type 'ArgT' nested under and including the given operation.  <a href="namespacemlir_1_1detail.html#a206f36bc38bdb9160771da18b198fa37">More...</a><br /></td></tr>
<tr class="separator:a206f36bc38bdb9160771da18b198fa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7626abe27e64a0a166feedf7e829c968"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a7626abe27e64a0a166feedf7e829c968">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a> &amp;stage)&gt; callback)</td></tr>
<tr class="memdesc:a7626abe27e64a0a166feedf7e829c968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic walkers with stage aware callbacks.  <a href="namespacemlir_1_1detail.html#a7626abe27e64a0a166feedf7e829c968">More...</a><br /></td></tr>
<tr class="separator:a7626abe27e64a0a166feedf7e829c968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2adf6127282c5d8cd497d1eff1013c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aa2adf6127282c5d8cd497d1eff1013c1">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a> &amp;stage)&gt; callback)</td></tr>
<tr class="memdesc:aa2adf6127282c5d8cd497d1eff1013c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all the operations nested under (and including) the given operation, with the callback being invoked on each operation N+1 times, where N is the number of regions attached to the operation.  <a href="namespacemlir_1_1detail.html#aa2adf6127282c5d8cd497d1eff1013c1">More...</a><br /></td></tr>
<tr class="separator:aa2adf6127282c5d8cd497d1eff1013c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01044a915c1ef676b33a6720e791b8e"><td class="memTemplParams" colspan="2">template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </td></tr>
<tr class="memitem:ab01044a915c1ef676b33a6720e791b8e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value, RetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ab01044a915c1ef676b33a6720e791b8e">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:ab01044a915c1ef676b33a6720e791b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations nested under and including the given operation.  <a href="namespacemlir_1_1detail.html#ab01044a915c1ef676b33a6720e791b8e">More...</a><br /></td></tr>
<tr class="separator:ab01044a915c1ef676b33a6720e791b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeeca5f48ddcfddf532f009990fa9875"><td class="memTemplParams" colspan="2">template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </td></tr>
<tr class="memitem:afeeca5f48ddcfddf532f009990fa9875"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_same&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value &amp;&amp;std::is_same&lt; RetT, void &gt;::value, RetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#afeeca5f48ddcfddf532f009990fa9875">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:afeeca5f48ddcfddf532f009990fa9875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations of type 'ArgT' nested under and including the given operation.  <a href="namespacemlir_1_1detail.html#afeeca5f48ddcfddf532f009990fa9875">More...</a><br /></td></tr>
<tr class="separator:afeeca5f48ddcfddf532f009990fa9875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f69e037f4b2603ccae8184e60301649"><td class="memTemplParams" colspan="2">template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </td></tr>
<tr class="memitem:a7f69e037f4b2603ccae8184e60301649"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_same&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value &amp;&amp;std::is_same&lt; RetT, <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> &gt;::value, RetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a7f69e037f4b2603ccae8184e60301649">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:a7f69e037f4b2603ccae8184e60301649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations of type 'ArgT' nested under and including the given operation.  <a href="namespacemlir_1_1detail.html#a7f69e037f4b2603ccae8184e60301649">More...</a><br /></td></tr>
<tr class="separator:a7f69e037f4b2603ccae8184e60301649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c95cf9bfd21b06e858fb98892946015"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT &gt; </td></tr>
<tr class="memitem:a0c95cf9bfd21b06e858fb98892946015"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a0c95cf9bfd21b06e858fb98892946015">constructContainerOpForParserIfNecessary</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *parsedBlock, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1Location.html">Location</a> sourceFileLoc)</td></tr>
<tr class="memdesc:a0c95cf9bfd21b06e858fb98892946015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a block containing operations that have just been parsed, if the block contains a single operation of <code>ContainerOpT</code> type then remove it from the block and return it.  <a href="namespacemlir_1_1detail.html#a0c95cf9bfd21b06e858fb98892946015">More...</a><br /></td></tr>
<tr class="separator:a0c95cf9bfd21b06e858fb98892946015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6940e065f3d177504ccb642f8b611b"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT , typename... ParserArgs&gt; </td></tr>
<tr class="memitem:a6c6940e065f3d177504ccb642f8b611b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a6c6940e065f3d177504ccb642f8b611b">parseSourceFile</a> (const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="namespacemlir.html#a3ecea12db18ed347ea11d1d999237b24">config</a>, ParserArgs &amp;&amp;...args)</td></tr>
<tr class="memdesc:a6c6940e065f3d177504ccb642f8b611b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal implementation of the templated <code>parseSourceFile</code> methods below, that simply forwards to the non-templated version.  <a href="namespacemlir_1_1detail.html#a6c6940e065f3d177504ccb642f8b611b">More...</a><br /></td></tr>
<tr class="separator:a6c6940e065f3d177504ccb642f8b611b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493be0c467bac528a100115486f3ec69"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteType , typename ValueT , typename Traits , typename BaseType , template&lt; typename, template&lt; typename &gt; class &gt; class BaseTrait&gt; </td></tr>
<tr class="memitem:a493be0c467bac528a100115486f3ec69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a493be0c467bac528a100115486f3ec69">isInterfaceImpl</a> (<a class="el" href="classmlir_1_1detail_1_1Interface.html">Interface</a>&lt; ConcreteType, ValueT, Traits, <a class="el" href="classBaseType.html">BaseType</a>, <a class="el" href="classBaseTrait.html">BaseTrait</a> &gt; &amp;)</td></tr>
<tr class="separator:a493be0c467bac528a100115486f3ec69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696722e8ee5d8e85989184cb97756aaf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a696722e8ee5d8e85989184cb97756aaf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a696722e8ee5d8e85989184cb97756aaf">is_fully_resolved</a> ()</td></tr>
<tr class="separator:a696722e8ee5d8e85989184cb97756aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa8d1434e1b3803ac23826a07e75c68"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a3fa8d1434e1b3803ac23826a07e75c68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a3fa8d1434e1b3803ac23826a07e75c68">printDimensionList</a> (raw_ostream &amp;stream, <a class="el" href="structmlir_1_1Range.html">Range</a> &amp;&amp;shape)</td></tr>
<tr class="separator:a3fa8d1434e1b3803ac23826a07e75c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930d7a8089745af25248145b612493b4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a930d7a8089745af25248145b612493b4">getDenseElementBitWidth</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> eltType)</td></tr>
<tr class="memdesc:a930d7a8089745af25248145b612493b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bit width which <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> should use for this type.  <a href="namespacemlir_1_1detail.html#a930d7a8089745af25248145b612493b4">More...</a><br /></td></tr>
<tr class="separator:a930d7a8089745af25248145b612493b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4714fdeb9f7fa11cf2bd472a5ab6d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#aae4714fdeb9f7fa11cf2bd472a5ab6d3">isSupportedMemorySpace</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace)</td></tr>
<tr class="memdesc:aae4714fdeb9f7fa11cf2bd472a5ab6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the memorySpace has supported <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> type.  <a href="namespacemlir_1_1detail.html#aae4714fdeb9f7fa11cf2bd472a5ab6d3">More...</a><br /></td></tr>
<tr class="separator:aae4714fdeb9f7fa11cf2bd472a5ab6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f32721e9d15092545cf9ea586d6d7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a37f32721e9d15092545cf9ea586d6d7e">wrapIntegerMemorySpace</a> (unsigned memorySpace, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:a37f32721e9d15092545cf9ea586d6d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps deprecated integer memory space to the new <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> form.  <a href="namespacemlir_1_1detail.html#a37f32721e9d15092545cf9ea586d6d7e">More...</a><br /></td></tr>
<tr class="separator:a37f32721e9d15092545cf9ea586d6d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38aedb222d8f61891a51c10805e286c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#ab38aedb222d8f61891a51c10805e286c">skipDefaultMemorySpace</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace)</td></tr>
<tr class="memdesc:ab38aedb222d8f61891a51c10805e286c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces default memorySpace (integer == <code>0</code>) with empty <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <a href="namespacemlir_1_1detail.html#ab38aedb222d8f61891a51c10805e286c">More...</a><br /></td></tr>
<tr class="separator:ab38aedb222d8f61891a51c10805e286c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec833993e8780c005c1c18d054273b4"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a3ec833993e8780c005c1c18d054273b4">getMemorySpaceAsInt</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace)</td></tr>
<tr class="memdesc:a3ec833993e8780c005c1c18d054273b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">[deprecated] Returns the memory space in old raw integer representation.  <a href="namespacemlir_1_1detail.html#a3ec833993e8780c005c1c18d054273b4">More...</a><br /></td></tr>
<tr class="separator:a3ec833993e8780c005c1c18d054273b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a63c39ecb3618964551c0b29bc356b675"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a63c39ecb3618964551c0b29bc356b675"><td class="memTemplItemLeft" align="right" valign="top">decltype(first_argument_type(&amp;F::operator()))&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html#a63c39ecb3618964551c0b29bc356b675">first_argument_type</a> (F)</td></tr>
<tr class="separator:a63c39ecb3618964551c0b29bc356b675"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classmlir_1_1AttrTypeReplacer.html" title="This is an attribute/type replacer that is naively cached.">AttrTypeReplacer</a>. </p>
<p>Detect if any of the given parameter types has a sub-element handler. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aabbea31f5f9034714e29d3a49cae75a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbea31f5f9034714e29d3a49cae75a4">&#9670;&nbsp;</a></span>count_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Pred, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#aabbea31f5f9034714e29d3a49cae75a4">mlir::detail::count_if_t</a> = typedef <a class="el" href="structmlir_1_1detail_1_1count__if__t__impl.html">count_if_t_impl</a>&lt;Pred, 0, Ts...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InterfaceSupport_8h_source.html#l00153">153</a> of file <a class="el" href="InterfaceSupport_8h_source.html">InterfaceSupport.h</a>.</p>

</div>
</div>
<a id="a912e3cd5feea0574a2f3fce7c34dcefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912e3cd5feea0574a2f3fce7c34dcefd">&#9670;&nbsp;</a></span>DenseIterPtrAndSplat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a912e3cd5feea0574a2f3fce7c34dcefd">mlir::detail::DenseIterPtrAndSplat</a> = typedef std::pair&lt;const char *, bool&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pair of raw pointer and a boolean flag of whether the pointer holds a splat,. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00046">46</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ae2b75c9bae3caf1909b6d6277fb6ea61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b75c9bae3caf1909b6d6277fb6ea61">&#9670;&nbsp;</a></span>first_argument</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#ae2b75c9bae3caf1909b6d6277fb6ea61">mlir::detail::first_argument</a> = typedef decltype(<a class="el" href="namespacemlir_1_1detail.html#a63c39ecb3618964551c0b29bc356b675">first_argument_type</a>(std::declval&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> definition of the first argument to the given callable 'T'. </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00090">90</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="ad4b238e9d75ea8d492ed8460058770f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b238e9d75ea8d492ed8460058770f1">&#9670;&nbsp;</a></span>has_compatible_matcher_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MatchTarget &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#ad4b238e9d75ea8d492ed8460058770f1">mlir::detail::has_compatible_matcher_t</a> = typedef decltype(std::declval&lt;T&gt;().match(std::declval&lt;MatchTarget&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait to check whether T provides a 'match' method with type <code>MatchTarget</code> (<a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>, <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>, or <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>). </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00290">290</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a6674e02b9acfc220caf0a47e6dbab6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6674e02b9acfc220caf0a47e6dbab6ea">&#9670;&nbsp;</a></span>has_default_sub_element_handler_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a6674e02b9acfc220caf0a47e6dbab6ea">mlir::detail::has_default_sub_element_handler_t</a> = typedef decltype(T::DefaultHandlerTag)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00414">414</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

</div>
</div>
<a id="a3c91ce05af5c861e1d789201346c457c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c91ce05af5c861e1d789201346c457c">&#9670;&nbsp;</a></span>has_get_as_key</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a3c91ce05af5c861e1d789201346c457c">mlir::detail::has_get_as_key</a> = typedef decltype(std::declval&lt;T&gt;().getAsKey())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00512">512</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

</div>
</div>
<a id="aec637be4fc5a4b359ff417c0f44350b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec637be4fc5a4b359ff417c0f44350b4">&#9670;&nbsp;</a></span>has_get_method</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#aec637be4fc5a4b359ff417c0f44350b4">mlir::detail::has_get_method</a> = typedef decltype(T::get(std::declval&lt;Ts&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00510">510</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

</div>
</div>
<a id="a1be2dcfec91412eb27290aab9294b4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be2dcfec91412eb27290aab9294b4cc">&#9670;&nbsp;</a></span>has_impltype_getkey_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ImplTy , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a1be2dcfec91412eb27290aab9294b4cc">mlir::detail::has_impltype_getkey_t</a> = typedef decltype(ImplTy::getKey(std::declval&lt;Args&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait to check if ImplTy provides a 'getKey' method with types 'Args'. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00026">26</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="afb2713c77027515db7c2d5f698d0f33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2713c77027515db7c2d5f698d0f33c">&#9670;&nbsp;</a></span>has_impltype_hash_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ImplTy , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#afb2713c77027515db7c2d5f698d0f33c">mlir::detail::has_impltype_hash_t</a> = typedef decltype(ImplTy::hashKey(std::declval&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait to check if ImplTy provides a 'hashKey' method for 'T'. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00030">30</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="abea4de026e8ae1a9a190b47a066df22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea4de026e8ae1a9a190b47a066df22f">&#9670;&nbsp;</a></span>has_push_back_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#abea4de026e8ae1a9a190b47a066df22f">mlir::detail::has_push_back_t</a> = typedef decltype(std::declval&lt;T&gt;().push_back( std::declval&lt;typename T::value_type &amp;&amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectImplementation_8h_source.html#l00168">168</a> of file <a class="el" href="DialectImplementation_8h_source.html">DialectImplementation.h</a>.</p>

</div>
</div>
<a id="addf60d55489c71894501becbfaa8c21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf60d55489c71894501becbfaa8c21c">&#9670;&nbsp;</a></span>is_interface_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#addf60d55489c71894501becbfaa8c21c">mlir::detail::is_interface_t</a> = typedef decltype(<a class="el" href="namespacemlir_1_1detail.html#a493be0c467bac528a100115486f3ec69">isInterfaceImpl</a>(std::declval&lt;T &amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InterfaceSupport_8h_source.html#l00274">274</a> of file <a class="el" href="InterfaceSupport_8h_source.html">InterfaceSupport.h</a>.</p>

</div>
</div>
<a id="ae9b5779c5d7667528bc58cd2f184f180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b5779c5d7667528bc58cd2f184f180">&#9670;&nbsp;</a></span>IsInterface</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#ae9b5779c5d7667528bc58cd2f184f180">mlir::detail::IsInterface</a> = typedef llvm::is_detected&lt;<a class="el" href="namespacemlir_1_1detail.html#addf60d55489c71894501becbfaa8c21c">is_interface_t</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InterfaceSupport_8h_source.html#l00277">277</a> of file <a class="el" href="InterfaceSupport_8h_source.html">InterfaceSupport.h</a>.</p>

</div>
</div>
<a id="a5258e43cc82e8e9a4c2c605f10a16461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5258e43cc82e8e9a4c2c605f10a16461">&#9670;&nbsp;</a></span>walkResultType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FnT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1detail.html#a5258e43cc82e8e9a4c2c605f10a16461">mlir::detail::walkResultType</a> = typedef decltype(<a class="el" href="namespacemlir_1_1detail.html#a152b851682ac1cad31c84dc1a6fc38cb">walk</a>(nullptr, std::declval&lt;FnT&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to provide the return type of a templated walk method. </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00431">431</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a78296380781bb5c3af2dd2ad9b70c26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78296380781bb5c3af2dd2ad9b70c26f">&#9670;&nbsp;</a></span>OpProperties</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1detail.html#a78296380781bb5c3af2dd2ad9b70c26f">mlir::detail::OpProperties</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a "tag" used for mapping the properties storage in llvm::TrailingObjects. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8h_source.html#l00028">28</a> of file <a class="el" href="IR_2Operation_8h_source.html">Operation.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae964b04f941d43593051e7ffd751e6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae964b04f941d43593051e7ffd751e6c1">&#9670;&nbsp;</a></span>allocAligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;T *, T *&gt; mlir::detail::allocAligned </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ac9afb3b6f82b256aea9f20e913e8afd5">AllocFunType</a>&#160;</td>
          <td class="paramname"><em>allocFun</em> = <code>&amp;::malloc</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>std::optional&lt;uint64_t&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Align <code>nElements</code> of type T with an optional <code>alignment</code>. </p>
<p>This replaces a portable <code>posix_memalign</code>. <code>alignment</code> must be a power of 2 and greater than the size of T. By default the alignment is sizeof(T). </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00104">104</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00049">nextPowerOf2()</a>.</p>

</div>
</div>
<a id="ad693ba34552063984c6685f93500c79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad693ba34552063984c6685f93500c79f">&#9670;&nbsp;</a></span>bindDims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::bindDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00289">289</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00292">bindDims()</a>, and <a class="el" href="HoistPadding_8cpp_source.html#l00518">buildLoopIterationCount()</a>.</p>

</div>
</div>
<a id="adc67b3a3dac2996cc431f90b8658f6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc67b3a3dac2996cc431f90b8658f6e6">&#9670;&nbsp;</a></span>bindDims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename AffineExprTy , typename... AffineExprTy2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::bindDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy2 &amp;...&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00292">292</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00289">bindDims()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00619">mlir::getAffineDimExpr()</a>.</p>

</div>
</div>
<a id="addb63088be1c8bff57b28cc3be96701b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb63088be1c8bff57b28cc3be96701b">&#9670;&nbsp;</a></span>bindSymbols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::bindSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00298">298</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00301">bindSymbols()</a>, and <a class="el" href="HoistPadding_8cpp_source.html#l00518">buildLoopIterationCount()</a>.</p>

</div>
</div>
<a id="a2b0f1dec3bae54bd6eecd9e5abb59e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0f1dec3bae54bd6eecd9e5abb59e4c">&#9670;&nbsp;</a></span>bindSymbols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename AffineExprTy , typename... AffineExprTy2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::bindSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy2 &amp;...&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00301">301</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00298">bindSymbols()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00629">mlir::getAffineSymbolExpr()</a>.</p>

</div>
</div>
<a id="a7bb7be75817707a561386449c561cc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb7be75817707a561386449c561cc31">&#9670;&nbsp;</a></span>bubbleDownInPlaceMemorySpaceCastImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; &gt; mlir::detail::bubbleDownInPlaceMemorySpaceCastImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to bubble-down inplace a <code>MemorySpaceCastOpInterface</code> operation referenced by <code>operand</code>. </p>
<p>On success, it returns <code>std::nullopt</code>. It returns failure if <code>operand</code> doesn't reference a <code>MemorySpaceCastOpInterface</code> op. </p>

<p class="definition">Definition at line <a class="el" href="MemOpInterfaces_8cpp_source.html#l00059">59</a> of file <a class="el" href="MemOpInterfaces_8cpp_source.html">MemOpInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, and <a class="el" href="UseDefLists_8h_source.html#l00163">mlir::IROperand&lt; DerivedT, IRValueT &gt;::set()</a>.</p>

</div>
</div>
<a id="a0c95cf9bfd21b06e858fb98892946015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c95cf9bfd21b06e858fb98892946015">&#9670;&nbsp;</a></span>constructContainerOpForParserIfNecessary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::detail::constructContainerOpForParserIfNecessary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>parsedBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>sourceFileLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a block containing operations that have just been parsed, if the block contains a single operation of <code>ContainerOpT</code> type then remove it from the block and return it. </p>
<p>If the block does not contain just that operation, create a new operation instance of <code>ContainerOpT</code> and move all of the operations within <code>parsedBlock</code> into the first block of the first region. <code>ContainerOpT</code> is required to have a single region containing a single block, and must implement the <code>SingleBlockImplicitTerminator</code> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00038">38</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00143">mlir::Block::begin()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="Block_8h_source.html#l00153">mlir::Block::front()</a>, and <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>.</p>

</div>
</div>
<a id="a451d8dc61974032518997d3f9935e53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451d8dc61974032518997d3f9935e53a">&#9670;&nbsp;</a></span>constructSubElementReplacement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::detail::constructSubElementReplacement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function invokes the proper <code>get</code> method for a type <code>T</code> with the given values. </p>

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00539">539</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

</div>
</div>
<a id="af748f20e1dc2fc58d26e3d2257926385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af748f20e1dc2fc58d26e3d2257926385">&#9670;&nbsp;</a></span>defaultGetDestinationOperand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp; mlir::detail::defaultGetDestinationOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the destination/"init" operand of the op if it implements the <code>DestinationStyleOpInterface</code> and has exactly one "init" operand. </p>
<p>Asserts otherwise. </p>

<p class="definition">Definition at line <a class="el" href="SubsetOpInterface_8cpp_source.html#l00017">17</a> of file <a class="el" href="SubsetOpInterface_8cpp_source.html">SubsetOpInterface.cpp</a>.</p>

</div>
</div>
<a id="aac272571a0b927a2a4fa1debf78948bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac272571a0b927a2a4fa1debf78948bb">&#9670;&nbsp;</a></span>defaultGetUpdatedDestination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a> mlir::detail::defaultGetUpdatedDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the updated destination result of the op if it implements the <code>DestinationStyleOpInterface</code>. </p>

<p class="definition">Definition at line <a class="el" href="SubsetOpInterface_8cpp_source.html#l00026">26</a> of file <a class="el" href="SubsetOpInterface_8cpp_source.html">SubsetOpInterface.cpp</a>.</p>

</div>
</div>
<a id="adfec552c5927149bad3102177f1f161a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfec552c5927149bad3102177f1f161a">&#9670;&nbsp;</a></span>defaultIsEquivalentSubset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::detail::defaultIsEquivalentSubset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>candidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;&#160;</td>
          <td class="paramname"><em>equivalenceFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of <code>SubsetInsertionOpInterface::isEquivalentSubset</code>. </p>

<p class="definition">Definition at line <a class="el" href="SubsetOpInterface_8cpp_source.html#l00033">33</a> of file <a class="el" href="SubsetOpInterface_8cpp_source.html">SubsetOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>.</p>

</div>
</div>
<a id="a20f1363f8cb9bc8b135a3212569aaf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f1363f8cb9bc8b135a3212569aaf37">&#9670;&nbsp;</a></span>defaultOperatesOnDisjointSubset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::detail::defaultOperatesOnDisjointSubset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubsetOpInterface&#160;</td>
          <td class="paramname"><em>candidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;&#160;</td>
          <td class="paramname"><em>equivalenceFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of <code>SubsetOpInterface::operatesOnDisjointSubset</code>. </p>

<p class="definition">Definition at line <a class="el" href="SubsetOpInterface_8cpp_source.html#l00065">65</a> of file <a class="el" href="SubsetOpInterface_8cpp_source.html">SubsetOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00832">mlir::ValueBoundsConstraintSet::areOverlappingSlices()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>.</p>

</div>
</div>
<a id="a3e8b66ba9169bfa2c09c598ccca039db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8b66ba9169bfa2c09c598ccca039db">&#9670;&nbsp;</a></span>defaultOperatesOnEquivalentSubset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::detail::defaultOperatesOnEquivalentSubset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubsetOpInterface&#160;</td>
          <td class="paramname"><em>candidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;&#160;</td>
          <td class="paramname"><em>equivalenceFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of <code>SubsetOpInterface::operatesOnEquivalentSubset</code>. </p>

<p class="definition">Definition at line <a class="el" href="SubsetOpInterface_8cpp_source.html#l00044">44</a> of file <a class="el" href="SubsetOpInterface_8cpp_source.html">SubsetOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00896">mlir::ValueBoundsConstraintSet::areEquivalentSlices()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>.</p>

</div>
</div>
<a id="a98a07efa628a8720c45b577162e4fe66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a07efa628a8720c45b577162e4fe66">&#9670;&nbsp;</a></span>divideCeil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::TypeSize mlir::detail::divideCeil </td>
          <td>(</td>
          <td class="paramtype">llvm::TypeSize&#160;</td>
          <td class="paramname"><em>numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>denominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides the known min value of the numerator by the denominator and rounds the result up to the next integer. </p>
<p>Preserves the scalable flag. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00468">468</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00356">mlir::UnrankedMemRefDescriptor::computeSize()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00633">convertMFMAVectorOperand()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01942">generateCopy()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00078">getCompressedMaskOp()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00045">getDefaultTypeSize()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00116">getIntegerTypeABIAlignment()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00086">mlir::detail::DenseIntOrFPElementsAttrStorage::getKey()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00526">mlir::LLVMTypeConverter::getMemRefDescriptorSize()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01419">mlir::affine::getMemRefIntOrFloatEltSizeInBytes()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00558">mlir::LLVMTypeConverter::getUnrankedMemRefDescriptorSize()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01463">mappingHelper()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00572">readBits()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01311">writeAPIntsToBuffer()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00546">writeBits()</a>.</p>

</div>
</div>
<a id="a7146031ab7f6bb4cdacc53c4f1e96aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7146031ab7f6bb4cdacc53c4f1e96aac">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Tys, typename CallbackT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mlir::detail::enumerate </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Tys... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00344">344</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00336">enumerateImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerVectorContract_8cpp_source.html#l00045">adjustIter()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01516">mlir::alignAffineMapWithValues()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00058">mlir::PatternApplicator::applyCostModel()</a>, <a class="el" href="ReductionTreePass_8cpp_source.html#l00038">applyPatterns()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00420">buildCostGraph()</a>, <a class="el" href="IRCore_8cpp_source.html#l01841">mlir::python::PyOpView::buildGeneric()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00612">buildPredicateList()</a>, <a class="el" href="CFGToSCF_8cpp_source.html#l00477">calculateCycleEdges()</a>, <a class="el" href="VectorDropLeadUnitDim_8cpp_source.html#l00334">mlir::vector::castAwayContractionLeadingOneDim()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01424">mlir::transform::detail::checkNestedConsumption()</a>, <a class="el" href="ShardingInterface_8cpp_source.html#l00082">checkOperandAffineExpr()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00155">checkTileSizes()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01712">mlir::linalg::collapseOpIterationDims()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01196">composeAffineMapAndOperands()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00439">mlir::LLVM::composeValue()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00917">computeMemRefRankReductionMask()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00098">mlir::linalg::computePaddedShape()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00096">constifyIndexValues()</a>, <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l00154">constructResultVector()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01143">convertForOp()</a>, <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00098">convertIntrinsicResult()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l02844">convertOmpSimd()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l05538">convertOmpTarget()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l02199">convertOmpTaskOp()</a>, <a class="el" href="LLVMToLLVMIRTranslation_8cpp_source.html#l00376">convertOperationImpl()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01176">convertYieldOp()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00062">mlir::tensor::createDynamicDimValues()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00805">createExpandedGenericOp()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02660">createFullTiles()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00726">createInitialTensorsForTiling()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00190">mlir::ConvertToLLVMPattern::createMemRefDescriptor()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00023">mlir::tensor::createPadHighOp()</a>, <a class="el" href="Split_8cpp_source.html#l00032">createSplitPart()</a>, <a class="el" href="IRDLLoading_8cpp_source.html#l00271">mlir::irdl::createVerifier()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00084">deduceCanonicalResource()</a>, <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00063">deduplicateInputOperands()</a>, <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00231">mlir::linalg::deduplicateOperandsAndRemoveDeadResults()</a>, <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00106">deduplicateOutputOperands()</a>, <a class="el" href="Promotion_8cpp_source.html#l00088">defaultAllocBufferCallBack()</a>, <a class="el" href="ShardingInterface_8cpp_source.html#l00259">mlir::shard::detail::defaultGetShardingOption()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00840">delinearizeInductionVariable()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00336">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00075">doubleBuffer()</a>, <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00069">mlir::bufferization::dropEquivalentBufferResults()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00957">dropRedundantArguments()</a>, <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00649">dropSwitchCasesThatMatchDefault()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00384">mlir::linalg::dropUnitDims()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00941">mlir::affine::ComputationSliceState::dump()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00937">mlir::ValueBoundsConstraintSet::dump()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00953">emitElementwiseComputation()</a>, <a class="el" href="LoopEmitter_8cpp_source.html#l00539">mlir::sparse_tensor::LoopEmitter::enterCurrentCoIterationCase()</a>, <a class="el" href="Query_8cpp_source.html#l00032">mlir::query::extractFunction()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l05225">extractHostEvalClauses()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00077">mlir::findPositionsOfType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01709">foldExtractFromBroadcast()</a>, <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00684">foldSwitch()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00129">forEachIJPairInAllBuffers()</a>, <a class="el" href="SparseTensorIterator_8cpp_source.html#l01516">mlir::sparse_tensor::SparseIterationSpace::fromValues()</a>, <a class="el" href="Fusion_8cpp_source.html#l00173">fuse()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00339">mlir::linalg::fuseElementwiseOps()</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00166">fuseIfLegal()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00903">genCoIterationCase()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01586">generateCollapsedIndexingRegion()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00218">generateFusedElementwiseOpRegion()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00216">mlir::sparse_tensor::genReshapeDstShape()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00770">mlir::shard::Sharding::get()</a>, <a class="el" href="IRDLLoading_8cpp_source.html#l00431">getAttrOrTypeVerifier()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00157">mlir::AffineMap::getBroadcastDims()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01297">getCollapsableIterationSpaceDims()</a>, <a class="el" href="IRDLOps_8cpp_source.html#l00019">getConstraintIndicesForArgs()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00261">getConstraintPredicates()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01144">getDimMap()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00140">getDroppedDims()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00146">getDynamicSizes()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00138">mlir::AffineMap::getFilteredIdentityMap()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01295">getGenericEffectsImpl()</a>, <a class="el" href="Dialect_2Func_2Utils_2Utils_8cpp_source.html#l00038">getInverseMapping()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00088">getLinearIndexI32()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00549">mlir::getLinearizedDimensions()</a>, <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00185">mlir::bufferization::DeallocationState::getMemrefsAndConditionsToDeallocate()</a>, <a class="el" href="Mem2Reg_8cpp_source.html#l00528">getOrCreateBlockIndices()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05383">mlir::linalg::getPackOpResultTypeShape()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01082">getPackUnpackNormalizedPerm()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00808">getPHISourceValue()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00112">mlir::linalg::getPreservedProducerResults()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00920">mlir::linalg::getReassociationMapForFoldingUnitDims()</a>, <a class="el" href="IRDLLoading_8cpp_source.html#l00052">getSegmentSizesFromAttr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01133">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="Fusion_8cpp_source.html#l00058">getShapeDefiningLoopRange()</a>, <a class="el" href="ShardingInterface_8cpp_source.html#l00362">getSharding()</a>, <a class="el" href="ControlFlowSinkUtils_8cpp_source.html#l00140">mlir::getSinglyExecutedRegionsToSink()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00794">getSplitReductionIvs()</a>, <a class="el" href="LLVMMemorySlot_8cpp_source.html#l00766">getSubslotAccessInfo()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01051">getTensorExtractMemoryAccessPattern()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00474">getTileOffsetAndSizesWithForAllOp()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00110">getTreePredicates()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00101">getUserTileSizesAndNumThreads()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00192">gpuMmaUnrollOrder()</a>, <a class="el" href="IRNumbering_8cpp_source.html#l00081">groupByDialectPerByte()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00215">handleArgumentImpl()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00097">handleMultidimensionalVectors()</a>, <a class="el" href="VectorPattern_8cpp_source.html#l00080">mlir::LLVM::detail::handleMultidimensionalVectors()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00242">handleResultImpl()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00023">mlir::inferExpandShapeOutputShape()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01557">initPrivateVars()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00050">injectGpuIndexOperations()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01350">inlineOmpRegionCleanup()</a>, <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l00056">inlinePayload()</a>, <a class="el" href="MemoryPromotion_8cpp_source.html#l00030">insertCopyLoops()</a>, <a class="el" href="BasicPtxBuilderInterface_8cpp_source.html#l00138">mlir::NVVM::PtxBuilder::insertValue()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00206">mlir::invertPermutationVector()</a>, <a class="el" href="IRDLLoading_8cpp_source.html#l00031">irdlAttrOrTypeVerifier()</a>, <a class="el" href="IRDLLoading_8cpp_source.html#l00190">irdlOpVerifier()</a>, <a class="el" href="IRNumbering_8cpp_source.html#l00130">mlir::bytecode::detail::IRNumberingState::IRNumberingState()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01200">mlir::linalg::isDimSequencePreserved()</a>, <a class="el" href="VectorOps_8cpp_source.html#l03638">isIntegerArrayAttrConfinedToShape()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01586">isMaskTriviallyFoldable()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00172">mlir::AffineMap::isMinorIdentityWithBroadcasting()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00483">mlir::affine::isOpwiseShiftValid()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">mlir::AffineMap::isPermutationOfMinorIdentityWithBroadcasting()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00460">mlir::isReassociationValid()</a>, <a class="el" href="VectorOps_8cpp_source.html#l03661">isSumOfIntegerArrayAttrConfinedToShape()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00082">mlir::vector::isTranspose2DSlice()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l03215">isTrivialSubViewOp()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01325">mlir::spirv::linearizeIndex()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00231">lowerAsEntryFunction()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01808">mlir::makeStridedLinearLayoutMap()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00512">VectorizationState::maskOperation()</a>, <a class="el" href="Matchers_8h_source.html#l00354">mlir::detail::RecursivePatternMatcher&lt; OpType, OperandMatchers &gt;::match()</a>, <a class="el" href="WrapFuncInClass_8cpp_source.html#l00049">WrapFuncInClass::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00077">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00536">mlir::GPUPrintfOpToVPrintfLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00758">mlir::GPUReturnOpLowering::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00870">SliceDynamicSizeCanonicalization::matchAndRewrite()</a>, <a class="el" href="IR_8cpp_source.html#l00361">mlirLocationFusedGetLocations()</a>, <a class="el" href="DistributionUtils_8cpp_source.html#l00053">mlir::gpu::WarpDistributionPattern::moveRegionToNewWarpOpAndAppendReturns()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01465">mlir::normalizeForallOp()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01359">mlir::transform::ErrorCheckingTrackingListener::notifyPayloadReplacementNotFound()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01520">operator&lt;&lt;()</a>, <a class="el" href="KernelOutlining_8cpp_source.html#l00177">outlineKernelFuncImpl()</a>, <a class="el" href="ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00144">packFunctionArguments()</a>, <a class="el" href="Padding_8cpp_source.html#l00355">mlir::linalg::padAndHoistLinalgOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00090">parseOptionalKeywordAlternative()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01383">mlir::affine::permuteLoops()</a>, <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00119">permuteValues()</a>, <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00172">populateOpPayload()</a>, <a class="el" href="IRCore_8cpp_source.html#l01710">populateResultTypes()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01652">printAttributions()</a>, <a class="el" href="OpenACC_8cpp_source.html#l01534">printDeviceTypeOperandsWithSegment()</a>, <a class="el" href="OpenACC_8cpp_source.html#l02470">printGangClause()</a>, <a class="el" href="OpenACC_8cpp_source.html#l01471">printNumGangs()</a>, <a class="el" href="PassStatistics_8cpp_source.html#l00059">printResultsAsList()</a>, <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00556">printSwitchOpCases()</a>, <a class="el" href="OpenACC_8cpp_source.html#l01646">printWaitClause()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l02899">mlir::LLVM::ModuleImport::processFunction()</a>, <a class="el" href="Promotion_8cpp_source.html#l00237">mlir::linalg::promoteSubviewAsNewBuffer()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00715">pruneRedundantArguments()</a>, <a class="el" href="DLTI_8cpp_source.html#l00537">mlir::dlti::query()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01456">mlir::detail::ConversionPatternRewriterImpl::remapValues()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01061">replaceAffineMinBoundingBoxExpression()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01109">mlir::affine::replaceAllMemRefUsesWith()</a>, <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00096">replaceAndPropagateMemRefType()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00637">replaceForAllWithNewSignature()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00272">mlir::sparse_tensor::reshapeCvs()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00490">mlir::reshapeLikeShapesAreCompatible()</a>, <a class="el" href="Padding_8cpp_source.html#l00244">mlir::linalg::rewriteAsPaddedOp()</a>, <a class="el" href="LivenessAnalysis_8cpp_source.html#l00289">mlir::dataflow::RunLivenessAnalysis::RunLivenessAnalysis()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01504">mlir::transform::detail::setApplyToOneResults()</a>, <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00033">simplifyAffineMinMaxOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00925">simplifyMinOrMaxExprWithOperands()</a>, <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00851">simplifySwitchFromDefaultSwitchOnSameCondition()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00125">sizesForTensor()</a>, <a class="el" href="VectorUnroll_8cpp_source.html#l00059">sliceLoadStoreIndices()</a>, <a class="el" href="VectorUnroll_8cpp_source.html#l00030">sliceTransferIndices()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00030">mlir::linalg::splitReduction()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00526">mlir::sparse_tensor::storeAll()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l02191">mlir::scf::tileAndFuseConsumerOfSlices()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01720">mlir::scf::tileConsumerAndFuseProducersUsingSCF()</a>, <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01288">mlir::scf::tileReductionUsingScf()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01112">mlir::scf::tileUsingSCF()</a>, <a class="el" href="Tiling_8cpp_source.html#l00073">mlir::linalg::transformIndexOps()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00420">trimNonScalableUnitDims()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00052">updateFuncOp()</a>, <a class="el" href="BlockPackMatmul_8cpp_source.html#l00043">validateFullTilesOnDims()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00109">mlir::ValueBoundsConstraintSet::Variable::Variable()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01765">vectorizeAsTensorPackOp()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02442">vectorizePadOpPrecondition()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02177">verifyCollapsedShape()</a>, <a class="el" href="LoopLikeInterface_8cpp_source.html#l00055">verifyLoopLikeOpInterface()</a>, <a class="el" href="Dialect_2IRDL_2IR_2IRDL_8cpp_source.html#l00171">verifyNames()</a>, <a class="el" href="SMTOps_8cpp_source.html#l00321">verifyQuantifierRegions()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00138">mlir::verifyReshapeLikeTypes()</a>, <a class="el" href="Dialect_2PDL_2IR_2PDL_8cpp_source.html#l00184">verifyResultTypesAreInferrable()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l03250">verifyStructArrayConstant()</a>, <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00148">verifyTypesAlongAllEdges()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00107">wrapForExternalCallers()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l01451">mlir::scf::yieldReplacementForFusedProducer()</a>.</p>

</div>
</div>
<a id="a7baf9bf03348723f8d037a39800d69a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7baf9bf03348723f8d037a39800d69a7">&#9670;&nbsp;</a></span>enumerateImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleT , class CallbackT , std::size_t... Is&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void mlir::detail::enumerateImpl </td>
          <td>(</td>
          <td class="paramtype">TupleT &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00336">336</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Matchers_8h_source.html#l00344">enumerate()</a>.</p>

</div>
</div>
<a id="a31d3a751d105f957d43b5ee8ad6ab047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d3a751d105f957d43b5ee8ad6ab047">&#9670;&nbsp;</a></span>filterEntriesForType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a72a4f77607d05cf551b24ceb9362c034">DataLayoutEntryList</a> mlir::detail::filterEntriesForType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>typeID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of data layout entries, returns a new list containing the entries with keys having the given type ID, i.e. </p>
<p>belonging to the same type class. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00343">343</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

</div>
</div>
<a id="af7ddc54fc9b6e82cf3b6a797a6bfefca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ddc54fc9b6e82cf3b6a797a6bfefca">&#9670;&nbsp;</a></span>filterEntryForIdentifier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataLayoutEntryInterface mlir::detail::filterEntryForIdentifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of data layout entries, returns the entry that has the given identifier as key, if such an entry exists in the list. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00353">353</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a6142ce3e04093b8805b807bbade3ec01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6142ce3e04093b8805b807bbade3ec01">&#9670;&nbsp;</a></span>filterEntryForIdentifier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TargetDeviceSpecInterface mlir::detail::filterEntryForIdentifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aa90f8dcaf13650935b7e9a32ccf0c055">TargetDeviceSpecListRef</a>&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of target device entries, returns the entry that has the given identifier as key, if such an entry exists in the list. </p>

</div>
</div>
<a id="a6f65c29b00af55fbdff5cf2a1bfbbe17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f65c29b00af55fbdff5cf2a1bfbbe17">&#9670;&nbsp;</a></span>first_argument_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Arg , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Arg mlir::detail::first_argument_type </td>
          <td>(</td>
          <td class="paramtype">Ret(*)(Arg, Rest...)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper templates to deduce the first argument of a callback parameter. </p>

</div>
</div>
<a id="ae4b5b18be8ea226e9d3606f21c1a7a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b5b18be8ea226e9d3606f21c1a7a7e">&#9670;&nbsp;</a></span>first_argument_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename F , typename Arg , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Arg mlir::detail::first_argument_type </td>
          <td>(</td>
          <td class="paramtype">Ret(F::*)(Arg, Rest...)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a767e521ae7755c29bc29daaeb840c238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767e521ae7755c29bc29daaeb840c238">&#9670;&nbsp;</a></span>getAffineMapStridesAndOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::getAffineMapStridesAndOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00202">202</a> of file <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html">BuiltinAttributeInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, and <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00161">getStridesAndOffset()</a>.</p>

</div>
</div>
<a id="a083757618e89b0f53d587541eccf53e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083757618e89b0f53d587541eccf53e0">&#9670;&nbsp;</a></span>getBranchSuccessorArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt; mlir::detail::getBranchSuccessorArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> &amp;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>operandIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>successor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <code><a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a></code> corresponding to operand <code>operandIndex</code> in some successor if <code>operandIndex</code> is within the range of <code>operands</code>, or std::nullopt if <code>operandIndex</code> isn't a successor operand index. </p>
<p>Returns the <code><a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a></code> corresponding to operand <code>operandIndex</code> in some successor if 'operandIndex' is within the range of 'operands', or std::nullopt if <code>operandIndex</code> isn't a successor operand index. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00039">39</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00129">mlir::Block::getArgument()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00387">mlir::OperandRange::getBeginOperandIndex()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00083">mlir::SuccessorOperands::getForwardedOperands()</a>, and <a class="el" href="ControlFlowInterfaces_8h_source.html#l00065">mlir::SuccessorOperands::getProducedOperandCount()</a>.</p>

</div>
</div>
<a id="a8409dbc763fd806cdacab4558dd9e9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8409dbc763fd806cdacab4558dd9e9f6">&#9670;&nbsp;</a></span>getDefaultABIAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::detail::getDefaultABIAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the required alignment request. </p>
<p>Computes results for built-in types and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00140">140</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00131">getFloatTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00037">getIndexBitwidth()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00116">getIntegerTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00584">mlir::DataLayout::getTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00560">mlir::DataLayout::getTypeSize()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00026">reportMissingDataLayout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00584">mlir::DataLayout::getTypeABIAlignment()</a>.</p>

</div>
</div>
<a id="a04d624115ea61e5b456d4c613a770631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d624115ea61e5b456d4c613a770631">&#9670;&nbsp;</a></span>getDefaultAllocaMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultAllocaMemorySpace </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for alloca memory space request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00263">263</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00652">mlir::DataLayout::getAllocaMemorySpace()</a>.</p>

</div>
</div>
<a id="a3379fc459c08af37eb4a514b0eadef2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3379fc459c08af37eb4a514b0eadef2d">&#9670;&nbsp;</a></span>getDefaultDiagnosticEmitFn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::unique_function&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; mlir::detail::getDefaultDiagnosticEmitFn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l01272">1272</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>.</p>

</div>
</div>
<a id="ac9dddc7a1f6dc8aa95eaa5b7910c76d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9dddc7a1f6dc8aa95eaa5b7910c76d5">&#9670;&nbsp;</a></span>getDefaultDiagnosticEmitFn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::unique_function&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; mlir::detail::getDefaultDiagnosticEmitFn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to generate a callback that can be used to generate a diagnostic when checking the construction invariants of a storage object. </p>
<p>This is defined out-of-line to avoid the need to include <a class="el" href="Location_8h.html">Location.h</a>. </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l01268">1268</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, and <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExtensibleDialect_8cpp_source.html#l00126">mlir::DynamicType::get()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00177">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::get()</a>, and <a class="el" href="StorageUniquerSupport_8h_source.html#l00189">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getChecked()</a>.</p>

</div>
</div>
<a id="a0fc8e12b852a89dc2d49a19dab76bbf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc8e12b852a89dc2d49a19dab76bbf8">&#9670;&nbsp;</a></span>getDefaultEndianness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultEndianness </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for endianness request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00242">242</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00620">mlir::DataLayout::getEndianness()</a>.</p>

</div>
</div>
<a id="af519cb1b89cef66201a509b636c0899a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af519cb1b89cef66201a509b636c0899a">&#9670;&nbsp;</a></span>getDefaultFunctionPointerAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultFunctionPointerAlignment </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the function pointer alignment request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00317">317</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00732">mlir::DataLayout::getFunctionPointerAlignment()</a>.</p>

</div>
</div>
<a id="acbccfb558aabea7d6494d225b56446e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbccfb558aabea7d6494d225b56446e8">&#9670;&nbsp;</a></span>getDefaultGlobalMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultGlobalMemorySpace </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for global memory space request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00296">296</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00700">mlir::DataLayout::getGlobalMemorySpace()</a>.</p>

</div>
</div>
<a id="a1b3919dd661434ca92b4ebe5a20e58b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3919dd661434ca92b4ebe5a20e58b1">&#9670;&nbsp;</a></span>getDefaultIndexBitwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; uint64_t &gt; mlir::detail::getDefaultIndexBitwidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the index bitwidth request. </p>
<p>Computes the result for the built-in index type and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00224">224</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00037">getIndexBitwidth()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00608">mlir::DataLayout::getTypeIndexBitwidth()</a>.</p>

</div>
</div>
<a id="a86153589d0a1d2f1d462dee9d852646c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86153589d0a1d2f1d462dee9d852646c">&#9670;&nbsp;</a></span>getDefaultLegalIntWidths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultLegalIntWidths </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the legal int widths request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00328">328</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00749">mlir::DataLayout::getLegalIntWidths()</a>.</p>

</div>
</div>
<a id="a6c79ef12939d977e7a4632bcc8b75a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c79ef12939d977e7a4632bcc8b75a31">&#9670;&nbsp;</a></span>getDefaultManglingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultManglingMode </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for mangling mode request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00273">273</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00668">mlir::DataLayout::getManglingMode()</a>.</p>

</div>
</div>
<a id="aeb4b21752e6c90f16e818bb89b80df5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4b21752e6c90f16e818bb89b80df5d">&#9670;&nbsp;</a></span>getDefaultMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultMemorySpace </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the default memory space request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00252">252</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00636">mlir::DataLayout::getDefaultMemorySpace()</a>.</p>

</div>
</div>
<a id="a9812a6a269eaa19d0e843b22596578d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9812a6a269eaa19d0e843b22596578d0">&#9670;&nbsp;</a></span>getDefaultPreferredAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::detail::getDefaultPreferredAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the preferred alignment request. </p>
<p>Computes results for built-in types and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00194">194</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00185">getFloatTypePreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00037">getIndexBitwidth()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00175">getIntegerTypePreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00584">mlir::DataLayout::getTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00596">mlir::DataLayout::getTypePreferredAlignment()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00026">reportMissingDataLayout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00052">getDefaultTypeSizeInBits()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00596">mlir::DataLayout::getTypePreferredAlignment()</a>.</p>

</div>
</div>
<a id="a0937e5890b25f8114fefdfe666484ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0937e5890b25f8114fefdfe666484ac5">&#9670;&nbsp;</a></span>getDefaultProgramMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultProgramMemorySpace </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for program memory space request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00284">284</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00684">mlir::DataLayout::getProgramMemorySpace()</a>.</p>

</div>
</div>
<a id="a9c14c1ac1334d61bf90aa4f60a5fa261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c14c1ac1334d61bf90aa4f60a5fa261">&#9670;&nbsp;</a></span>getDefaultStackAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::detail::getDefaultStackAlignment </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the stack alignment request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00307">307</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00716">mlir::DataLayout::getStackAlignment()</a>.</p>

</div>
</div>
<a id="a87ca94416539c5fc8c1b2df637f6b522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ca94416539c5fc8c1b2df637f6b522">&#9670;&nbsp;</a></span>getDefaultTypeSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::TypeSize mlir::detail::getDefaultTypeSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the type size request. </p>
<p>Computes results for built-in types and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00045">45</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00468">divideCeil()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00052">getDefaultTypeSizeInBits()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00560">mlir::DataLayout::getTypeSize()</a>.</p>

</div>
</div>
<a id="a89cf52d46088967fe0b00f1a7f704eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cf52d46088967fe0b00f1a7f704eae">&#9670;&nbsp;</a></span>getDefaultTypeSizeInBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::TypeSize mlir::detail::getDefaultTypeSizeInBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a577834e9b93afb653df29d66a6975ecf">DataLayoutEntryListRef</a>&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the type size in bits request. </p>
<p>Computes results for built-in types and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00052">52</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00194">getDefaultPreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00037">getIndexBitwidth()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00122">mlir::Type::getIntOrFloatBitWidth()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00560">mlir::DataLayout::getTypeSize()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00572">mlir::DataLayout::getTypeSizeInBits()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00116">mlir::Type::isIntOrFloat()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00026">reportMissingDataLayout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00045">getDefaultTypeSize()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00572">mlir::DataLayout::getTypeSizeInBits()</a>.</p>

</div>
</div>
<a id="a930d7a8089745af25248145b612493b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930d7a8089745af25248145b612493b4">&#9670;&nbsp;</a></span>getDenseElementBitWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t mlir::detail::getDenseElementBitWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>eltType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bit width which <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> should use for this type. </p>

<p class="definition">Definition at line <a class="el" href="AttributeDetail_8h_source.html#l00034">34</a> of file <a class="el" href="AttributeDetail_8h_source.html">AttributeDetail.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00122">mlir::Type::getIntOrFloatBitWidth()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01267">mlir::DenseElementsAttr::bitcast()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00464">getDenseElementStorageWidth()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00086">mlir::detail::DenseIntOrFPElementsAttrStorage::getKey()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01117">isValidIntOrFloat()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01463">mappingHelper()</a>.</p>

</div>
</div>
<a id="a5d552809ed611d55492c36bbb09886fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d552809ed611d55492c36bbb09886fe">&#9670;&nbsp;</a></span>getDevicePropertyValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; mlir::detail::getDevicePropertyValue </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the property from the specified DataLayoutEntry. </p>
<p>If the property is missing from the entry, returns std::nullopt. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00335">335</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00765">mlir::DataLayout::getDevicePropertyValue()</a>.</p>

</div>
</div>
<a id="a3ec833993e8780c005c1c18d054273b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec833993e8780c005c1c18d054273b4">&#9670;&nbsp;</a></span>getMemorySpaceAsInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::detail::getMemorySpaceAsInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[deprecated] Returns the memory space in old raw integer representation. </p>
<p>New <code><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> getMemorySpace()</code> method should be used instead. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00554">554</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

</div>
</div>
<a id="a4bbbaf06f702976f635516e2eec5c165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbbaf06f702976f635516e2eec5c165">&#9670;&nbsp;</a></span>getNumDynamicEntriesUpToIdx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::detail::getNumDynamicEntriesUpToIdx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>staticVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to compute the number of dynamic entries of <code>staticVals</code>, up to <code>idx</code>. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00294">294</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

</div>
</div>
<a id="a6f6bd31c91df4b26794a88c1006e83ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6bd31c91df4b26794a88c1006e83ef">&#9670;&nbsp;</a></span>getTensorContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::detail::getTensorContainer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the container that the given subset op is operating on. </p>

<p class="definition">Definition at line <a class="el" href="SubsetOpInterface_8cpp_source.html#l00086">86</a> of file <a class="el" href="SubsetOpInterface_8cpp_source.html">SubsetOpInterface.cpp</a>.</p>

</div>
</div>
<a id="a33a945b620206532de586bf2c444fa1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a945b620206532de586bf2c444fa1e">&#9670;&nbsp;</a></span>inferReturnTensorTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::inferReturnTensorTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1ShapedTypeComponents.html">ShapedTypeComponents</a> &gt;&#160;</td>
          <td class="paramname"><em>retComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inferredReturnTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00211">211</a> of file <a class="el" href="InferTypeOpInterface_8cpp_source.html">InferTypeOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

</div>
</div>
<a id="a696722e8ee5d8e85989184cb97756aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696722e8ee5d8e85989184cb97756aaf">&#9670;&nbsp;</a></span>is_fully_resolved()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::detail::is_fully_resolved </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function for <a class="el" href="structmlir_1_1detail_1_1is__fully__resolved__t.html">is_fully_resolved_t</a>.</p>

<p class="definition">Definition at line <a class="el" href="TypeID_8h_source.html#l00186">186</a> of file <a class="el" href="TypeID_8h_source.html">TypeID.h</a>.</p>

</div>
</div>
<a id="a493be0c467bac528a100115486f3ec69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493be0c467bac528a100115486f3ec69">&#9670;&nbsp;</a></span>isInterfaceImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , typename ValueT , typename Traits , typename BaseType , template&lt; typename, template&lt; typename &gt; class &gt; class BaseTrait&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::isInterfaceImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1detail_1_1Interface.html">Interface</a>&lt; ConcreteType, ValueT, Traits, <a class="el" href="classBaseType.html">BaseType</a>, <a class="el" href="classBaseTrait.html">BaseTrait</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e92b3730d5a0d2e1c4f704cb4674d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e92b3730d5a0d2e1c4f704cb4674d1e">&#9670;&nbsp;</a></span>isPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool mlir::detail::isPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CRunnerUtils_8h_source.html#l00047">47</a> of file <a class="el" href="CRunnerUtils_8h_source.html">CRunnerUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CRunnerUtils_8h_source.html#l00049">nextPowerOf2()</a>.</p>

</div>
</div>
<a id="aae4714fdeb9f7fa11cf2bd472a5ab6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4714fdeb9f7fa11cf2bd472a5ab6d3">&#9670;&nbsp;</a></span>isSupportedMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::detail::isSupportedMemorySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the memorySpace has supported <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00522">522</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00058">mlir::Attribute::getDialect()</a>.</p>

</div>
</div>
<a id="ada8eaeb3d7b3be7839ef146f1f82a313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8eaeb3d7b3be7839ef146f1f82a313">&#9670;&nbsp;</a></span>makeStridedMemRefDescriptor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(N &gt;= 1), <a class="el" href="structStridedMemRefType.html">StridedMemRefType</a>&lt;T, N&gt; &gt;::type mlir::detail::makeStridedMemRefDescriptor </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>alignedPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shapeAlloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <code>StridedMemRefDescriptor&lt;T, N&gt;</code> that matches the MLIR ABI. </p>
<p>This is an implementation detail that is kept in sync with MLIR codegen conventions. Additionally takes a <code>shapeAlloc</code> array which is used instead of <code>shape</code> to allocate "more aligned" data and compute the corresponding strides. </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00066">66</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00132">StridedMemRefType&lt; T, N &gt;::basePtr</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00069">copy()</a>, <a class="el" href="CRunnerUtils_8h_source.html#l00133">StridedMemRefType&lt; T, N &gt;::data</a>, <a class="el" href="CRunnerUtils_8h_source.html#l00134">StridedMemRefType&lt; T, N &gt;::offset</a>, <a class="el" href="CRunnerUtils_8h_source.html#l00135">StridedMemRefType&lt; T, N &gt;::sizes</a>, and <a class="el" href="CRunnerUtils_8h_source.html#l00136">StridedMemRefType&lt; T, N &gt;::strides</a>.</p>

</div>
</div>
<a id="a1a76d14b47a24b32bcb01c58dced65f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a76d14b47a24b32bcb01c58dced65f8">&#9670;&nbsp;</a></span>makeStridedMemRefDescriptor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(N == 0), <a class="el" href="structStridedMemRefType.html">StridedMemRefType</a>&lt;T, 0&gt; &gt;::type mlir::detail::makeStridedMemRefDescriptor </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>alignedPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shapeAlloc</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <code>StridedMemRefDescriptor&lt;T, 0&gt;</code> that matches the MLIR ABI. </p>
<p>This is an implementation detail that is kept in sync with MLIR codegen conventions. Additionally takes a <code>shapeAlloc</code> array which is used instead of <code>shape</code> to allocate "more aligned" data and compute the corresponding strides. </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00087">87</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

</div>
</div>
<a id="ab48e4040142437e45b8fe0f83b837ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48e4040142437e45b8fe0f83b837ad9">&#9670;&nbsp;</a></span>makeStrides()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;int64_t, N&gt; mlir::detail::makeStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a shape with sizes greater than 0 along all dimensions, returns the distance, in number of elements, between a slice in a dimension and the next slice in the same dimension. </p>
<p>e.g. shape[3, 4, 5] -&gt; strides[20, 5, 1] </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00046">46</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

</div>
</div>
<a id="ac5492f1b5ad5a28391086b5b866d56cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5492f1b5ad5a28391086b5b866d56cf">&#9670;&nbsp;</a></span>matchOperandOrValueAtIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatcherClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;llvm::is_detected&lt;<a class="el" href="namespacemlir_1_1detail.html#ad4b238e9d75ea8d492ed8460058770f1">detail::has_compatible_matcher_t</a>, MatcherClass, <a class="el" href="classmlir_1_1Value.html">Value</a>&gt;::value, bool&gt; mlir::detail::matchOperandOrValueAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatcherClass &amp;&#160;</td>
          <td class="paramname"><em>matcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically switch to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> matcher. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00298">298</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Matchers_8h_source.html#l00354">mlir::detail::RecursivePatternMatcher&lt; OpType, OperandMatchers &gt;::match()</a>.</p>

</div>
</div>
<a id="a7133556c1b0ae2fd063aff7d3639b9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7133556c1b0ae2fd063aff7d3639b9eb">&#9670;&nbsp;</a></span>matchOperandOrValueAtIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatcherClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;llvm::is_detected&lt;<a class="el" href="namespacemlir_1_1detail.html#ad4b238e9d75ea8d492ed8460058770f1">detail::has_compatible_matcher_t</a>, MatcherClass, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;::value, bool&gt; mlir::detail::matchOperandOrValueAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatcherClass &amp;&#160;</td>
          <td class="paramname"><em>matcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically switch to an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> matcher. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00307">307</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>.</p>

</div>
</div>
<a id="a69a50c1b52f8e20f12e77716d79a5868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a50c1b52f8e20f12e77716d79a5868">&#9670;&nbsp;</a></span>nextPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned mlir::detail::nextPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CRunnerUtils_8h_source.html#l00049">49</a> of file <a class="el" href="CRunnerUtils_8h_source.html">CRunnerUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00047">isPowerOf2()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00104">allocAligned()</a>, <a class="el" href="CRunnerUtils_8h_source.html#l00058">mlir::detail::Vector1D&lt; T, Dim, true &gt;::Vector1D()</a>, and <a class="el" href="CRunnerUtils_8h_source.html#l00073">mlir::detail::Vector1D&lt; T, Dim, false &gt;::Vector1D()</a>.</p>

</div>
</div>
<a id="a6c6940e065f3d177504ccb642f8b611b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6940e065f3d177504ccb642f8b611b">&#9670;&nbsp;</a></span>parseSourceFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT , typename... ParserArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt;ContainerOpT&gt; mlir::detail::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParserArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The internal implementation of the templated <code>parseSourceFile</code> methods below, that simply forwards to the non-templated version. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00154">154</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">mlir::config</a>, and <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>.</p>

</div>
</div>
<a id="a3fa8d1434e1b3803ac23826a07e75c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa8d1434e1b3803ac23826a07e75c68">&#9670;&nbsp;</a></span>printDimensionList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::printDimensionList </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Range.html">Range</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l02035">2035</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsmPrinter_8cpp_source.html#l03021">mlir::AsmPrinter::printDimensionList()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l02947">mlir::AsmPrinter::Impl::printDimensionList()</a>.</p>

</div>
</div>
<a id="a8af776eda51700256b7c60deadcb4d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af776eda51700256b7c60deadcb4d25">&#9670;&nbsp;</a></span>replaceImmediateSubElementsImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::detail::replaceImmediateSubElementsImpl </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>derived</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>replAttrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>replTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides the underlying implementation for the SubElementInterface replace method, using the key type of the derived attribute/type to interact with the individual parameters. </p>

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00557">557</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

<p class="reference">References <a class="el" href="AttrTypeSubElements_8h_source.html#l00417">mlir::has_sub_attr_or_type_v</a>.</p>

<p class="reference">Referenced by <a class="el" href="StorageUniquerSupport_8h_source.html#l00142">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getReplaceImmediateSubElementsFn()</a>.</p>

</div>
</div>
<a id="ab5f85cda3d8183cca5b6c2766fddb2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f85cda3d8183cca5b6c2766fddb2fb">&#9670;&nbsp;</a></span>reportFatalInferReturnTypesError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::reportFatalInferReturnTypesError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report a fatal error indicating that the result types could not be inferred. </p>

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00243">243</a> of file <a class="el" href="InferTypeOpInterface_8cpp_source.html">InferTypeOpInterface.cpp</a>.</p>

</div>
</div>
<a id="a0caa43784c57086534e1833f66eaecfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0caa43784c57086534e1833f66eaecfc">&#9670;&nbsp;</a></span>sameOffsetsSizesAndStrides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::detail::sameOffsetsSizesAndStrides </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>)&gt;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00273">273</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

</div>
</div>
<a id="ab38aedb222d8f61891a51c10805e286c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38aedb222d8f61891a51c10805e286c">&#9670;&nbsp;</a></span>skipDefaultMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::skipDefaultMemorySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces default memorySpace (integer == <code>0</code>) with empty <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00546">546</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

</div>
</div>
<a id="a2bc750046567479d1fdfa425bac17b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc750046567479d1fdfa425bac17b32">&#9670;&nbsp;</a></span>unwrapForCustomParse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) mlir::detail::unwrapForCustomParse </td>
          <td>(</td>
          <td class="paramtype">FailureOr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>failureOr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttributeSupport_8h_source.html#l00316">316</a> of file <a class="el" href="AttributeSupport_8h_source.html">AttributeSupport.h</a>.</p>

</div>
</div>
<a id="ada3315ae7edc12bed53da6a26424d047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3315ae7edc12bed53da6a26424d047">&#9670;&nbsp;</a></span>verifyAffineMapAsLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyAffineMapAsLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00077">77</a> of file <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html">BuiltinAttributeInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>.</p>

</div>
</div>
<a id="a2e2f4d4cb24fe5f60b359e5962ad5498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2f4d4cb24fe5f60b359e5962ad5498">&#9670;&nbsp;</a></span>verifyBranchSuccessorOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyBranchSuccessorOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>succNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> &amp;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that the given operands match those of the given successor block. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00060">60</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00267">mlir::Operation::emitError()</a>, <a class="el" href="Block_8h_source.html#l00129">mlir::Block::getArgument()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getNumArguments()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00065">mlir::SuccessorOperands::getProducedOperandCount()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00708">mlir::Operation::getSuccessor()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>, and <a class="el" href="ControlFlowInterfaces_8h_source.html#l00056">mlir::SuccessorOperands::size()</a>.</p>

</div>
</div>
<a id="ae5372df7a0d717fe3ad6238640425402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5372df7a0d717fe3ad6238640425402">&#9670;&nbsp;</a></span>verifyBranchWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyBranchWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that the branch weights attached to an operation implementing WeightedBranchOpInterface are correct. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00106">106</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00706">mlir::Operation::getNumSuccessors()</a>, and <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00086">verifyWeights()</a>.</p>

</div>
</div>
<a id="aee3b9d7e0a9cd00a32827f48d4536850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3b9d7e0a9cd00a32827f48d4536850">&#9670;&nbsp;</a></span>verifyDataLayoutOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyDataLayoutOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that the operation implementing the data layout interface, or a module operation, is valid. </p>
<p>This calls the verifier of the spec attribute and checks if the layout is compatible with specs attached to the enclosing operations. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00446">446</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00386">collectParentLayouts()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00055">diag()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00267">mlir::Operation::emitError()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00417">getCombinedDataLayout()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00363">getSpec()</a>.</p>

</div>
</div>
<a id="af3a791a52efb3f0b9d61ca353b635e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a791a52efb3f0b9d61ca353b635e95">&#9670;&nbsp;</a></span>verifyDataLayoutSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyDataLayoutSpec </td>
          <td>(</td>
          <td class="paramtype">DataLayoutSpecInterface&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that a data layout spec is valid. </p>
<p>This dispatches to individual entry verifiers, and then to the verifiers implemented by the relevant type and dialect interfaces for type and identifier keys respectively. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00800">800</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, and <a class="el" href="IR_2Dialect_8h_source.html#l00054">mlir::Dialect::getNamespace()</a>.</p>

</div>
</div>
<a id="abc3a9033156fc6f0f4ee40b16eaa835c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3a9033156fc6f0f4ee40b16eaa835c">&#9670;&nbsp;</a></span>verifyDestinationStyleOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyDestinationStyleOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that <code>op</code> conforms to the invariants of DestinationStyleOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="DestinationStyleOpInterface_8cpp_source.html#l00029">29</a> of file <a class="el" href="DestinationStyleOpInterface_8cpp_source.html">DestinationStyleOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00672">mlir::Operation::emitOpError()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a77ee29379e4568366034d669b060a034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ee29379e4568366034d669b060a034">&#9670;&nbsp;</a></span>verifyIndexingMapOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyIndexingMapOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that <code>op</code> conforms to the invariants of StructuredOpInterface. </p>

</div>
</div>
<a id="ad276c5acc7f5d475d0e1987a456a59e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad276c5acc7f5d475d0e1987a456a59e0">&#9670;&nbsp;</a></span>verifyInferredResultTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyInferredResultTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that the inferred result types match the actual result types for the op. </p>
<p>Precondition: op implements InferTypeOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00230">230</a> of file <a class="el" href="InferTypeOpInterface_8cpp_source.html">InferTypeOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00672">mlir::Operation::emitOpError()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00900">mlir::Operation::getPropertiesStorage()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00509">mlir::Operation::getRawDictionaryAttrs()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00428">mlir::Operation::getResultTypes()</a>.</p>

</div>
</div>
<a id="af09e6bd26baceff7935df426cf406496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09e6bd26baceff7935df426cf406496">&#9670;&nbsp;</a></span>verifyInParallelOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyInParallelOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ParallelCombiningOpInterface_8cpp_source.html#l00018">18</a> of file <a class="el" href="ParallelCombiningOpInterface_8cpp_source.html">ParallelCombiningOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00267">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00674">mlir::Operation::getNumRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00686">mlir::Operation::getRegion()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00068">mlir::Region::hasOneBlock()</a>.</p>

</div>
</div>
<a id="a960f17c15fd15a72390d00da41a4e12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960f17c15fd15a72390d00da41a4e12f">&#9670;&nbsp;</a></span>verifyLoopLikeOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyLoopLikeOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify invariants of the LoopLikeOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="LoopLikeInterface_8cpp_source.html#l00055">55</a> of file <a class="el" href="LoopLikeInterface_8cpp_source.html">LoopLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00672">mlir::Operation::emitOpError()</a>, <a class="el" href="Matchers_8h_source.html#l00344">enumerate()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>.</p>

</div>
</div>
<a id="ad771bcf841b38d5c2ccca4417102863e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad771bcf841b38d5c2ccca4417102863e">&#9670;&nbsp;</a></span>verifyMemorySpaceCastOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyMemorySpaceCastOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to verify the given memory space cast operation. </p>

<p class="definition">Definition at line <a class="el" href="MemOpInterfaces_8cpp_source.html#l00017">17</a> of file <a class="el" href="MemOpInterfaces_8cpp_source.html">MemOpInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00267">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00101">mlir::Type::getTypeID()</a>.</p>

</div>
</div>
<a id="afebb54d50bfcc329f59aee2490b27c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afebb54d50bfcc329f59aee2490b27c07">&#9670;&nbsp;</a></span>verifyOffsetSizeAndStrideOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyOffsetSizeAndStrideOp </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00096">96</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, and <a class="el" href="ViewLikeInterface_8cpp_source.html#l00020">mlir::verifyListOfOperandsOrIntegers()</a>.</p>

</div>
</div>
<a id="a25a3777b2ac1a4abcc61e74c35c7b997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a3777b2ac1a4abcc61e74c35c7b997">&#9670;&nbsp;</a></span>verifyRegionBranchWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyRegionBranchWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that the region weights attached to an operation implementing WeightedRegiobBranchOpInterface are correct. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00117">117</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00674">mlir::Operation::getNumRegions()</a>, and <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00086">verifyWeights()</a>.</p>

</div>
</div>
<a id="a819d12bc01c2443cfc1b72c4824bfaba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819d12bc01c2443cfc1b72c4824bfaba">&#9670;&nbsp;</a></span>verifyShapedDimOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyShapedDimOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify invariants of ops that implement the ShapedDimOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="ShapedOpInterfaces_8cpp_source.html#l00017">17</a> of file <a class="el" href="ShapedOpInterfaces_8cpp_source.html">ShapedOpInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00267">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>.</p>

</div>
</div>
<a id="a0ebd9058172b2a090d824c6ab1841413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebd9058172b2a090d824c6ab1841413">&#9670;&nbsp;</a></span>verifySubsetExtractionOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifySubsetExtractionOpInterface </td>
          <td>(</td>
          <td class="paramtype">SubsetExtractionOpInterface&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify <code>SubsetExtractionOpInterface</code>. </p>

<p class="definition">Definition at line <a class="el" href="SubsetOpInterface_8cpp_source.html#l00102">102</a> of file <a class="el" href="SubsetOpInterface_8cpp_source.html">SubsetOpInterface.cpp</a>.</p>

</div>
</div>
<a id="aba9dcc8813e435202abcbb438f66d90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9dcc8813e435202abcbb438f66d90a">&#9670;&nbsp;</a></span>verifySubsetOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifySubsetOpInterface </td>
          <td>(</td>
          <td class="paramtype">SubsetOpInterface&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify <code>SubsetOpInterface</code>. </p>

<p class="definition">Definition at line <a class="el" href="SubsetOpInterface_8cpp_source.html#l00092">92</a> of file <a class="el" href="SubsetOpInterface_8cpp_source.html">SubsetOpInterface.cpp</a>.</p>

</div>
</div>
<a id="ae8e42f84b57ed10b489c12a7236bb356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e42f84b57ed10b489c12a7236bb356">&#9670;&nbsp;</a></span>verifySymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifySymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolTable_8cpp_source.html#l00523">523</a> of file <a class="el" href="SymbolTable_8cpp_source.html">SymbolTable.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00672">mlir::Operation::emitOpError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00534">mlir::Operation::getAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>, <a class="el" href="SymbolTable_8h_source.html#l00076">mlir::SymbolTable::getSymbolAttrName()</a>, and <a class="el" href="SymbolTable_8h_source.html#l00082">mlir::SymbolTable::getVisibilityAttrName()</a>.</p>

</div>
</div>
<a id="aea9f7283021fca39df8cf99bbd90cf4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9f7283021fca39df8cf99bbd90cf4a">&#9670;&nbsp;</a></span>verifySymbolTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifySymbolTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolTable_8cpp_source.html#l00482">482</a> of file <a class="el" href="SymbolTable_8cpp_source.html">SymbolTable.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00340">mlir::InFlightDiagnostic::append()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00267">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00672">mlir::Operation::emitOpError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00674">mlir::Operation::getNumRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00686">mlir::Operation::getRegion()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>, <a class="el" href="SymbolTable_8h_source.html#l00076">mlir::SymbolTable::getSymbolAttrName()</a>, <a class="el" href="IR_2Region_8h_source.html#l00068">mlir::Region::hasOneBlock()</a>, and <a class="el" href="SymbolTable_8cpp_source.html#l00080">walkSymbolTable()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolTable_8h_source.html#l00454">mlir::OpTrait::SymbolTable&lt; ConcreteType &gt;::verifyRegionTrait()</a>.</p>

</div>
</div>
<a id="a474ca87dcf5fa084441e1a1275852fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474ca87dcf5fa084441e1a1275852fbb">&#9670;&nbsp;</a></span>verifyTargetSystemSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyTargetSystemSpec </td>
          <td>(</td>
          <td class="paramtype">TargetSystemSpecInterface&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that a target system desc spec is valid. </p>
<p>This dispatches to individual entry verifiers, and then to the verifiers implemented by the relevant dialect interfaces for identifier keys. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00890">890</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, and <a class="el" href="IR_2Dialect_8h_source.html#l00054">mlir::Dialect::getNamespace()</a>.</p>

</div>
</div>
<a id="ae4afbba3aecdff992f5fb31b086f9c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4afbba3aecdff992f5fb31b086f9c12">&#9670;&nbsp;</a></span>verifyTypesAlongControlFlowEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyTypesAlongControlFlowEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that types match along control flow edges described the given op. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00187">187</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l00055">diag()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00672">mlir::Operation::emitOpError()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00222">mlir::RegionBranchPoint::parent()</a>, <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00127">printRegionEdgeName()</a>, and <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00148">verifyTypesAlongAllEdges()</a>.</p>

</div>
</div>
<a id="a5b337bcade50e3cd7191efec879db837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b337bcade50e3cd7191efec879db837">&#9670;&nbsp;</a></span>walk() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Block.html">Block</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00119">119</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">mlir::PostOrder</a>, and <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">mlir::PreOrder</a>.</p>

</div>
</div>
<a id="a3adcd8424919a733a4cce559560e5dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adcd8424919a733a4cce559560e5dd9">&#9670;&nbsp;</a></span>walk() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00136">136</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">mlir::PostOrder</a>, and <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">mlir::PreOrder</a>.</p>

</div>
</div>
<a id="a7626abe27e64a0a166feedf7e829c968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7626abe27e64a0a166feedf7e829c968">&#9670;&nbsp;</a></span>walk() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a> &amp;stage)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic walkers with stage aware callbacks. </p>
<p>Walk all the operations nested under (and including) the given operation, with the callback being invoked on each operation N+1 times, where N is the number of regions attached to the operation. The <code>stage</code> input to the callback indicates the current walk stage. This method is invoked for void returning callbacks. </p>

</div>
</div>
<a id="a152b851682ac1cad31c84dc1a6fc38cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152b851682ac1cad31c84dc1a6fc38cb">&#9670;&nbsp;</a></span>walk() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the regions, blocks, or operations nested under (and including) the given operation. </p>
<p>The order in which regions, blocks and operations at the same nesting level are visited (e.g., lexicographical or reverse lexicographical order) is determined by 'Iterator'. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'order'. These methods are invoked for void-returning callbacks. A callback on a block or operation is allowed to erase that block or operation only if the walk is in post-order. See non-void method for pre-order erasure. </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00102">102</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">mlir::PostOrder</a>, and <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">mlir::PreOrder</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttrTypeSubElements_8h_source.html#l00446">mlir::AttrTypeSubElementHandler&lt; ArrayRef&lt; T &gt;, std::enable_if_t&lt; has_sub_attr_or_type_v&lt; T &gt; &gt; &gt;::walk()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00825">mlir::Operation::walk()</a>, <a class="el" href="Visitors_8h_source.html#l00377">walk()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00119">mlir::PatternApplicator::walkAllPatterns()</a>, and <a class="el" href="AttrTypeSubElements_8h_source.html#l00518">walkImmediateSubElementsImpl()</a>.</p>

</div>
</div>
<a id="ac791c882fa374a53b6a7ec0387586f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac791c882fa374a53b6a7ec0387586f59">&#9670;&nbsp;</a></span>walk() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Block.html">Block</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00194">194</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">mlir::PostOrder</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">mlir::PreOrder</a>, <a class="el" href="WalkResult_8h_source.html#l00051">mlir::WalkResult::wasInterrupted()</a>, and <a class="el" href="WalkResult_8h_source.html#l00054">mlir::WalkResult::wasSkipped()</a>.</p>

</div>
</div>
<a id="ab4e61da15ae81a346c6b060103d0ed54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e61da15ae81a346c6b060103d0ed54">&#9670;&nbsp;</a></span>walk() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00222">222</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">mlir::PostOrder</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">mlir::PreOrder</a>, <a class="el" href="WalkResult_8h_source.html#l00051">mlir::WalkResult::wasInterrupted()</a>, and <a class="el" href="WalkResult_8h_source.html#l00054">mlir::WalkResult::wasSkipped()</a>.</p>

</div>
</div>
<a id="aa2adf6127282c5d8cd497d1eff1013c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2adf6127282c5d8cd497d1eff1013c1">&#9670;&nbsp;</a></span>walk() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a> &amp;stage)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all the operations nested under (and including) the given operation, with the callback being invoked on each operation N+1 times, where N is the number of regions attached to the operation. </p>
<p>The <code>stage</code> input to the callback indicates the current walk stage. This method is invoked for skippable or interruptible callbacks. </p>

</div>
</div>
<a id="a08eda9acbea0f5326d02db4b99814395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08eda9acbea0f5326d02db4b99814395">&#9670;&nbsp;</a></span>walk() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the regions, blocks, or operations nested under (and including) the given operation. </p>
<p>The order in which regions, blocks and operations at the same nesting level are visited (e.g., lexicographical or reverse lexicographical order) is determined by 'Iterator'. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'order'. This method is invoked for skippable or interruptible callbacks. A callback on a block or operation is allowed to erase that block or operation if either:</p><ul>
<li>the walk is in post-order, or</li>
<li>the walk is in pre-order and the walk is skipped after the erasure. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00166">166</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">mlir::PostOrder</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">mlir::PreOrder</a>, <a class="el" href="WalkResult_8h_source.html#l00051">mlir::WalkResult::wasInterrupted()</a>, and <a class="el" href="WalkResult_8h_source.html#l00054">mlir::WalkResult::wasSkipped()</a>.</p>

</div>
</div>
<a id="addfa95ca210821ec266a0257fe9fe74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfa95ca210821ec266a0257fe9fe74f">&#9670;&nbsp;</a></span>walk() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;WalkOrder Order = WalkOrder::PostOrder, typename Iterator  = ForwardIterator, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;llvm::is_one_of&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> *&gt;::value, RetT&gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the regions, blocks, or operations nested under (and including) the given operation. </p>
<p>The order in which regions, blocks and operations at the same nesting level are visited (e.g., lexicographical or reverse lexicographical order) is determined by 'Iterator'. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'Order' (post-order by default). A callback on a block or operation is allowed to erase that block or operation if either:</p><ul>
<li>the walk is in post-order, or</li>
<li>the walk is in pre-order and the walk is skipped after the erasure. This method is selected for callbacks that operate on Region*, Block*, and Operation*.</li>
</ul>
<p>Example: op-&gt;walk([](<a class="el" href="classmlir_1_1Region.html" title="This class contains a list of basic blocks and a link to the parent operation it is attached to.">Region</a> *r) { ... }); op-&gt;walk([](<a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a> *b) { ... }); op-&gt;walk([](<a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> *op) { ... }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00277">277</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="a50b0cddf03280b10bdeecbfa002f2f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b0cddf03280b10bdeecbfa002f2f4d">&#9670;&nbsp;</a></span>walk() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;WalkOrder Order = WalkOrder::PostOrder, typename Iterator  = ForwardIterator, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; !llvm::is_one_of&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> *&gt;::value &amp;&amp; std::is_same&lt;RetT, void&gt;::value, RetT&gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations of type 'ArgT' nested under and including the given operation. </p>
<p>The order in which regions, blocks and operations at the same nesting are visited (e.g., lexicographical or reverse lexicographical order) is determined by 'Iterator'. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'order' (post-order by default). This method is selected for void-returning callbacks that operate on a specific derived operation type. A callback on an operation is allowed to erase that operation only if the walk is in post-order. See non-void method for pre-order erasure.</p>
<p>Example: op-&gt;walk([](ReturnOp op) { ... }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00301">301</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="a206f36bc38bdb9160771da18b198fa37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206f36bc38bdb9160771da18b198fa37">&#9670;&nbsp;</a></span>walk() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;WalkOrder Order = WalkOrder::PostOrder, typename Iterator  = ForwardIterator, typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; !llvm::is_one_of&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> *&gt;::value &amp;&amp; std::is_same&lt;RetT, <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&gt;::value, RetT&gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations of type 'ArgT' nested under and including the given operation. </p>
<p>The order in which regions, blocks and operations at the same nesting are visited (e.g., lexicographical or reverse lexicographical order) is determined by 'Iterator'. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'Order' (post-order by default). This method is selected for WalkReturn returning skippable or interruptible callbacks that operate on a specific derived operation type. A callback on an operation is allowed to erase that operation if either:</p><ul>
<li>the walk is in post-order, or</li>
<li>the walk is in pre-order and the walk is skipped after the erasure.</li>
</ul>
<p>Example: op-&gt;walk([](ReturnOp op) { if (some_invariant) return <a class="el" href="classmlir_1_1WalkResult.html#a693d2ecca6f15d4d492c6ff2bea148d0">WalkResult::skip()</a>; if (another_invariant) return <a class="el" href="classmlir_1_1WalkResult.html#abab80dca5987e18f9abf08162cd3faaa">WalkResult::interrupt()</a>; return <a class="el" href="classmlir_1_1WalkResult.html#a97a7015a793bb5d2a97f08e358f42797">WalkResult::advance()</a>; }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00338">338</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>.</p>

</div>
</div>
<a id="ab01044a915c1ef676b33a6720e791b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01044a915c1ef676b33a6720e791b8e">&#9670;&nbsp;</a></span>walk() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_same&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;::value, RetT&gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations nested under and including the given operation. </p>
<p>This method is selected for stage-aware callbacks that operate on Operation*.</p>
<p>Example: op-&gt;walk([](<a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> *op, const <a class="el" href="classmlir_1_1WalkStage.html" title="A utility class to encode the current walk stage for &quot;generic&quot; walkers.">WalkStage</a> &amp;stage) { ... }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00377">377</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

</div>
</div>
<a id="afeeca5f48ddcfddf532f009990fa9875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeeca5f48ddcfddf532f009990fa9875">&#9670;&nbsp;</a></span>walk() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_same&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;::value &amp;&amp; std::is_same&lt;RetT, void&gt;::value, RetT&gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations of type 'ArgT' nested under and including the given operation. </p>
<p>This method is selected for void returning callbacks that operate on a specific derived operation type.</p>
<p>Example: op-&gt;walk([](ReturnOp op, const <a class="el" href="classmlir_1_1WalkStage.html" title="A utility class to encode the current walk stage for &quot;generic&quot; walkers.">WalkStage</a> &amp;stage) { ... }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00394">394</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

</div>
</div>
<a id="a7f69e037f4b2603ccae8184e60301649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f69e037f4b2603ccae8184e60301649">&#9670;&nbsp;</a></span>walk() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncTy , typename ArgT  = detail::first_argument&lt;FuncTy&gt;, typename RetT  = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_same&lt;ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;::value &amp;&amp; std::is_same&lt;RetT, <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&gt;::value, RetT&gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations of type 'ArgT' nested under and including the given operation. </p>
<p>This method is selected for WalkReturn returning interruptible callbacks that operate on a specific derived operation type.</p>
<p>Example: op-&gt;walk(op, [](ReturnOp op, const <a class="el" href="classmlir_1_1WalkStage.html" title="A utility class to encode the current walk stage for &quot;generic&quot; walkers.">WalkStage</a> &amp;stage) { if (some_invariant) return <a class="el" href="classmlir_1_1WalkResult.html#abab80dca5987e18f9abf08162cd3faaa">WalkResult::interrupt()</a>; return <a class="el" href="classmlir_1_1WalkResult.html#a97a7015a793bb5d2a97f08e358f42797">WalkResult::advance()</a>; }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00419">419</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, and <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

</div>
</div>
<a id="a9d0ecdf07e5bd3e5496db1048d6b0beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0ecdf07e5bd3e5496db1048d6b0beb">&#9670;&nbsp;</a></span>walkImmediateSubElementsImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::walkImmediateSubElementsImpl </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>derived</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;&#160;</td>
          <td class="paramname"><em>walkAttrsFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Type.html">Type</a>)&gt;&#160;</td>
          <td class="paramname"><em>walkTypesFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides the underlying implementation for the SubElementInterface walk method, using the key type of the derived attribute/type to interact with the individual parameters. </p>

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00518">518</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

<p class="reference">References <a class="el" href="AttrTypeSubElements_8h_source.html#l00417">mlir::has_sub_attr_or_type_v</a>, and <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StorageUniquerSupport_8h_source.html#l00132">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;::getWalkImmediateSubElementsFn()</a>.</p>

</div>
</div>
<a id="a37f32721e9d15092545cf9ea586d6d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f32721e9d15092545cf9ea586d6d7e">&#9670;&nbsp;</a></span>wrapIntegerMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::wrapIntegerMemorySpace </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>memorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps deprecated integer memory space to the new <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> form. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00538">538</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a63c39ecb3618964551c0b29bc356b675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c39ecb3618964551c0b29bc356b675">&#9670;&nbsp;</a></span>first_argument_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(first_argument_type(&amp;F::operator())) mlir::detail::first_argument_type(F) </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00086">86</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 27 2025 16:33:11 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
