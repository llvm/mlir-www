<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="namespacemlir_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mlir::detail Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classmlir_1_1AttrTypeReplacer.html" title="This is an attribute/type replacer that is naively cached.">AttrTypeReplacer</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:analysis_5Fimpl" id="r_analysis_5Fimpl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1analysis__impl.html">analysis_impl</a></td></tr>
<tr class="memitem:pass_5Foptions" id="r_pass_5Foptions"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1pass__options.html">pass_options</a></td></tr>
<tr class="memitem:storage_5Fuser_5Fbase_5Fimpl" id="r_storage_5Fuser_5Fbase_5Fimpl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1storage__user__base__impl.html">storage_user_base_impl</a></td></tr>
<tr class="memitem:StorageUserTrait" id="r_StorageUserTrait"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail_1_1StorageUserTrait.html">StorageUserTrait</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:AffineBinaryOpExprStorage" id="r_AffineBinaryOpExprStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineBinaryOpExprStorage.html">AffineBinaryOpExprStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binary operation appearing in an affine expression.  <a href="structmlir_1_1detail_1_1AffineBinaryOpExprStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineConstantExprStorage" id="r_AffineConstantExprStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineConstantExprStorage.html">AffineConstantExprStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer constant appearing in affine expression.  <a href="structmlir_1_1detail_1_1AffineConstantExprStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineDimExprStorage" id="r_AffineDimExprStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineDimExprStorage.html">AffineDimExprStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimensional or symbolic identifier appearing in an affine expression.  <a href="structmlir_1_1detail_1_1AffineDimExprStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineExprStorage" id="r_AffineExprStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineExprStorage.html">AffineExprStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage class appearing in an affine expression.  <a href="structmlir_1_1detail_1_1AffineExprStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineMapStorage" id="r_AffineMapStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AffineMapStorage.html">AffineMapStorage</a></td></tr>
<tr class="memitem:AliasAnalysisTraits" id="r_AliasAnalysisTraits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AliasAnalysisTraits.html">AliasAnalysisTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains various internal trait classes used by the main <a class="el" href="classmlir_1_1AliasAnalysis.html" title="This class represents the main alias analysis interface in MLIR.">AliasAnalysis</a> class below.  <a href="structmlir_1_1detail_1_1AliasAnalysisTraits.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnalysisConcept" id="r_AnalysisConcept"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AnalysisConcept.html">AnalysisConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract polymorphic base class representing an analysis.  <a href="structmlir_1_1detail_1_1AnalysisConcept.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnalysisMap" id="r_AnalysisMap"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AnalysisMap.html">AnalysisMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a cache of analyses for a single operation.  <a href="classmlir_1_1detail_1_1AnalysisMap.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnalysisModel" id="r_AnalysisModel"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AnalysisModel.html">AnalysisModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A derived analysis model used to hold a specific analysis object.  <a href="structmlir_1_1detail_1_1AnalysisModel.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnyCapturedValueMatcher" id="r_AnyCapturedValueMatcher"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AnyCapturedValueMatcher.html">AnyCapturedValueMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminal matcher, always returns true.  <a href="structmlir_1_1detail_1_1AnyCapturedValueMatcher.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnyValueMatcher" id="r_AnyValueMatcher"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AnyValueMatcher.html">AnyValueMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminal matcher, always returns true.  <a href="structmlir_1_1detail_1_1AnyValueMatcher.html#details">More...</a><br /></td></tr>
<tr class="memitem:AsmParserImpl" id="r_AsmParserImpl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AsmParserImpl.html">AsmParserImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the implementation of the generic parser methods within <a class="el" href="classmlir_1_1AsmParser.html" title="This base class exposes generic asm parser hooks, usable across the various derived parsers.">AsmParser</a>.  <a href="classmlir_1_1detail_1_1AsmParserImpl.html#details">More...</a><br /></td></tr>
<tr class="memitem:AsmStateImpl" id="r_AsmStateImpl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AsmStateImpl.html">AsmStateImpl</a></td></tr>
<tr class="memitem:attr_5Fvalue_5Fbinder" id="r_attr_5Fvalue_5Fbinder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1attr__value__binder.html">attr_value_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a certain kind of <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> and binds the value inside the <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <a href="structmlir_1_1detail_1_1attr__value__binder.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttributeUniquer" id="r_AttributeUniquer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AttributeUniquer.html">AttributeUniquer</a></td></tr>
<tr class="memitem:AttrOpBinder" id="r_AttrOpBinder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AttrOpBinder.html">AttrOpBinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the specified attribute name, and binds the attribute value.  <a href="structmlir_1_1detail_1_1AttrOpBinder.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrOpMatcher" id="r_AttrOpMatcher"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1AttrOpMatcher.html">AttrOpMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the specified attribute name.  <a href="structmlir_1_1detail_1_1AttrOpMatcher.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrTypeReplacerBase" id="r_AttrTypeReplacerBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1AttrTypeReplacerBase.html">AttrTypeReplacerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a base utility for replacing attributes/types, and their sub elements.  <a href="classmlir_1_1detail_1_1AttrTypeReplacerBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:BlockArgumentImpl" id="r_BlockArgumentImpl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1BlockArgumentImpl.html">BlockArgumentImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal implementation of a <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a>.  <a href="classmlir_1_1detail_1_1BlockArgumentImpl.html#details">More...</a><br /></td></tr>
<tr class="memitem:CallbackOstream" id="r_CallbackOstream"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1CallbackOstream.html">CallbackOstream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple raw ostream subclass that forwards write_impl calls to the user-supplied callback together with opaque user-supplied data.  <a href="classmlir_1_1detail_1_1CallbackOstream.html#details">More...</a><br /></td></tr>
<tr class="memitem:constant_5Ffloat_5Fpredicate_5Fmatcher" id="r_constant_5Ffloat_5Fpredicate_5Fmatcher"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html">constant_float_predicate_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a given target constant scalar / vector splat / tensor splat float value that fulfills a predicate.  <a href="structmlir_1_1detail_1_1constant__float__predicate__matcher.html#details">More...</a><br /></td></tr>
<tr class="memitem:constant_5Ffloat_5Fvalue_5Fbinder" id="r_constant_5Ffloat_5Fvalue_5Fbinder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__float__value__binder.html">constant_float_value_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a constant scalar / vector splat / tensor splat float <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> or <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> and binds the constant float value.  <a href="structmlir_1_1detail_1_1constant__float__value__binder.html#details">More...</a><br /></td></tr>
<tr class="memitem:constant_5Fint_5Fpredicate_5Fmatcher" id="r_constant_5Fint_5Fpredicate_5Fmatcher"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html">constant_int_predicate_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a given target constant scalar / vector splat / tensor splat integer value that fulfills a predicate.  <a href="structmlir_1_1detail_1_1constant__int__predicate__matcher.html#details">More...</a><br /></td></tr>
<tr class="memitem:constant_5Fint_5Frange_5Fpredicate_5Fmatcher" id="r_constant_5Fint_5Frange_5Fpredicate_5Fmatcher"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__int__range__predicate__matcher.html">constant_int_range_predicate_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matcher that matches a given a constant scalar / vector splat / tensor splat integer value or a constant integer range that fulfills a predicate.  <a href="structmlir_1_1detail_1_1constant__int__range__predicate__matcher.html#details">More...</a><br /></td></tr>
<tr class="memitem:constant_5Fint_5Fvalue_5Fbinder" id="r_constant_5Fint_5Fvalue_5Fbinder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__int__value__binder.html">constant_int_value_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a constant scalar / vector splat / tensor splat integer <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> or <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> and binds the constant integer value.  <a href="structmlir_1_1detail_1_1constant__int__value__binder.html#details">More...</a><br /></td></tr>
<tr class="memitem:constant_5Fop_5Fbinder" id="r_constant_5Fop_5Fbinder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">constant_op_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the <span class="tt">ConstantLike</span> trait, and binds the folded attribute value.  <a href="structmlir_1_1detail_1_1constant__op__binder.html#details">More...</a><br /></td></tr>
<tr class="memitem:constant_5Fop_5Fmatcher" id="r_constant_5Fop_5Fmatcher"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1constant__op__matcher.html">constant_op_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the <span class="tt">ConstantLike</span> trait.  <a href="structmlir_1_1detail_1_1constant__op__matcher.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConversionPatternRewriterImpl" id="r_ConversionPatternRewriterImpl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ConversionPatternRewriterImpl.html">ConversionPatternRewriterImpl</a></td></tr>
<tr class="memitem:count_5Fif_5Ft_5Fimpl" id="r_count_5Fif_5Ft_5Fimpl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1count__if__t__impl.html">count_if_t_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template utility that computes the number of elements within <span class="tt">T</span> that satisfy the given predicate.  <a href="structmlir_1_1detail_1_1count__if__t__impl.html#details">More...</a><br /></td></tr>
<tr class="memitem:count_5Fif_5Ft_5Fimpl_3C_20Pred_2C_20N_2C_20T_2C_20Us_2E_2E_2E_20_3E" id="r_count_5Fif_5Ft_5Fimpl_3C_20Pred_2C_20N_2C_20T_2C_20Us_2E_2E_2E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1count__if__t__impl_3_01Pred_00_01N_00_01T_00_01Us_8_8_8_01_4.html">count_if_t_impl&lt; Pred, N, T, Us... &gt;</a></td></tr>
<tr class="memitem:CreateAlgebraicOpForEndomorphismSimplification" id="r_CreateAlgebraicOpForEndomorphismSimplification"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1CreateAlgebraicOpForEndomorphismSimplification.html">CreateAlgebraicOpForEndomorphismSimplification</a></td></tr>
<tr class="memitem:DataLayoutEntryAttrStorage" id="r_DataLayoutEntryAttrStorage"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DataLayoutEntryAttrStorage.html">DataLayoutEntryAttrStorage</a></td></tr>
<tr class="memitem:DefaultTimingManagerImpl" id="r_DefaultTimingManagerImpl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DefaultTimingManagerImpl.html">DefaultTimingManagerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation details of the <span class="tt"><a class="el" href="classmlir_1_1DefaultTimingManager.html" title="Facilities for time measurement and report printing to an output stream.">DefaultTimingManager</a></span>.  <a href="classmlir_1_1detail_1_1DefaultTimingManagerImpl.html#details">More...</a><br /></td></tr>
<tr class="memitem:DenseArrayAttrImpl" id="r_DenseArrayAttrImpl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html">DenseArrayAttrImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for DenseArrayAttr that is instantiated and specialized for each supported element type below.  <a href="classmlir_1_1detail_1_1DenseArrayAttrImpl.html#details">More...</a><br /></td></tr>
<tr class="memitem:DenseElementIndexedIteratorImpl" id="r_DenseElementIndexedIteratorImpl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DenseElementIndexedIteratorImpl.html">DenseElementIndexedIteratorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impl iterator for indexed <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> iterators that records a data pointer and data index that is adjusted for the case of a splat attribute.  <a href="classmlir_1_1detail_1_1DenseElementIndexedIteratorImpl.html#details">More...</a><br /></td></tr>
<tr class="memitem:DenseElementsAttributeStorage" id="r_DenseElementsAttributeStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DenseElementsAttributeStorage.html">DenseElementsAttributeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute representing a reference to a dense vector or tensor object.  <a href="structmlir_1_1detail_1_1DenseElementsAttributeStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:DenseIntOrFPElementsAttrStorage" id="r_DenseIntOrFPElementsAttrStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DenseIntOrFPElementsAttrStorage.html">DenseIntOrFPElementsAttrStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute representing a reference to a dense vector or tensor object.  <a href="structmlir_1_1detail_1_1DenseIntOrFPElementsAttrStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:DenseResourceElementsAttrBase" id="r_DenseResourceElementsAttrBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html">DenseResourceElementsAttrBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for DenseResourceElementsAttr that is instantiated and specialized for each supported element type below.  <a href="classmlir_1_1detail_1_1DenseResourceElementsAttrBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:DenseStringElementsAttrStorage" id="r_DenseStringElementsAttrStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DenseStringElementsAttrStorage.html">DenseStringElementsAttrStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute representing a reference to a dense vector or tensor object containing strings.  <a href="structmlir_1_1detail_1_1DenseStringElementsAttrStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:DiagnosticEngineImpl" id="r_DiagnosticEngineImpl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DiagnosticEngineImpl.html">DiagnosticEngineImpl</a></td></tr>
<tr class="memitem:DialectInterfaceBase" id="r_DialectInterfaceBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DialectInterfaceBase.html">DialectInterfaceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class used for all derived interface types.  <a href="classmlir_1_1detail_1_1DialectInterfaceBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:DialectInterfaceCollectionBase" id="r_DialectInterfaceCollectionBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DialectInterfaceCollectionBase.html">DialectInterfaceCollectionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the base class for a collection of instances for a specific interface kind.  <a href="classmlir_1_1detail_1_1DialectInterfaceCollectionBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:DistinctAttributeAllocator" id="r_DistinctAttributeAllocator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DistinctAttributeAllocator.html">DistinctAttributeAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An allocator for distinct attribute storage instances.  <a href="classmlir_1_1detail_1_1DistinctAttributeAllocator.html#details">More...</a><br /></td></tr>
<tr class="memitem:DistinctAttributeUniquer" id="r_DistinctAttributeUniquer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DistinctAttributeUniquer.html">DistinctAttributeUniquer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialized attribute uniquer for distinct attributes that always allocates since the distinct attribute instances use the address of their storage as unique identifier.  <a href="classmlir_1_1detail_1_1DistinctAttributeUniquer.html#details">More...</a><br /></td></tr>
<tr class="memitem:DistinctAttrStorage" id="r_DistinctAttrStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DistinctAttrStorage.html">DistinctAttrStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute to store a distinct reference to another attribute.  <a href="structmlir_1_1detail_1_1DistinctAttrStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:DominanceInfoBase" id="r_DominanceInfoBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1DominanceInfoBase.html">DominanceInfoBase</a></td></tr>
<tr class="memitem:DynamicAttrStorage" id="r_DynamicAttrStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DynamicAttrStorage.html">DynamicAttrStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of <a class="el" href="classmlir_1_1DynamicAttr.html" title="A dynamic attribute instance.">DynamicAttr</a>.  <a href="structmlir_1_1detail_1_1DynamicAttrStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:DynamicTypeStorage" id="r_DynamicTypeStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1DynamicTypeStorage.html">DynamicTypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of <a class="el" href="classmlir_1_1DynamicType.html" title="A dynamic type instance.">DynamicType</a>.  <a href="structmlir_1_1detail_1_1DynamicTypeStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:ElementsAttrIndexer" id="r_ElementsAttrIndexer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ElementsAttrIndexer.html">ElementsAttrIndexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides support for indexing into the element range of an ElementsAttr.  <a href="structmlir_1_1detail_1_1ElementsAttrIndexer.html#details">More...</a><br /></td></tr>
<tr class="memitem:ElementsAttrIterator" id="r_ElementsAttrIterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1ElementsAttrIterator.html">ElementsAttrIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a generic iterator for ElementsAttr.  <a href="classmlir_1_1detail_1_1ElementsAttrIterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:ElementsAttrRange" id="r_ElementsAttrRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1ElementsAttrRange.html">ElementsAttrRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides iterator utilities for an ElementsAttr range.  <a href="classmlir_1_1detail_1_1ElementsAttrRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpectedDiag" id="r_ExpectedDiag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ExpectedDiag.html">ExpectedDiag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an expected output diagnostic.  <a href="structmlir_1_1detail_1_1ExpectedDiag.html#details">More...</a><br /></td></tr>
<tr class="memitem:FallbackTypeIDResolver" id="r_FallbackTypeIDResolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1FallbackTypeIDResolver.html">FallbackTypeIDResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a fallback for resolving TypeIDs.  <a href="classmlir_1_1detail_1_1FallbackTypeIDResolver.html#details">More...</a><br /></td></tr>
<tr class="memitem:FileLineColRangeAttrStorage" id="r_FileLineColRangeAttrStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1FileLineColRangeAttrStorage.html">FileLineColRangeAttrStorage</a></td></tr>
<tr class="memitem:FunctionTypeStorage" id="r_FunctionTypeStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1FunctionTypeStorage.html">FunctionTypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> Storage and Uniquing.  <a href="structmlir_1_1detail_1_1FunctionTypeStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:infer_5Fint_5Frange_5Fop_5Fbinder" id="r_infer_5Fint_5Frange_5Fop_5Fbinder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1infer__int__range__op__binder.html">infer_int_range_op_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matcher that matches operations that implement the <span class="tt">InferIntRangeInterface</span> interface, and binds the inferred range.  <a href="structmlir_1_1detail_1_1infer__int__range__op__binder.html#details">More...</a><br /></td></tr>
<tr class="memitem:InlineOpResult" id="r_InlineOpResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1InlineOpResult.html">InlineOpResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the implementation for an operation result whose index can be represented "inline" in the underlying <a class="el" href="classmlir_1_1detail_1_1ValueImpl.html" title="The base class for all derived Value classes.">ValueImpl</a>.  <a href="structmlir_1_1detail_1_1InlineOpResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:InlineTypeIDResolver" id="r_InlineTypeIDResolver"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1InlineTypeIDResolver.html">InlineTypeIDResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides utilities for resolving the <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a> of a class that provides a <span class="tt">static <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a> <a class="el" href="structmlir_1_1detail_1_1InlineTypeIDResolver.html#a94343b857aec8e86b6000bbd453f786b">resolveTypeID()</a></span> method.  <a href="structmlir_1_1detail_1_1InlineTypeIDResolver.html#details">More...</a><br /></td></tr>
<tr class="memitem:IntegerSetStorage" id="r_IntegerSetStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1IntegerSetStorage.html">IntegerSetStorage</a></td></tr>
<tr class="memitem:IntegerTypeStorage" id="r_IntegerTypeStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1IntegerTypeStorage.html">IntegerTypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> Storage and Uniquing.  <a href="structmlir_1_1detail_1_1IntegerTypeStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:Interface" id="r_Interface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Interface.html">Interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an abstract interface.  <a href="classmlir_1_1detail_1_1Interface.html#details">More...</a><br /></td></tr>
<tr class="memitem:InterfaceMap" id="r_InterfaceMap"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1InterfaceMap.html">InterfaceMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an efficient mapping between a given <span class="tt"><a class="el" href="classmlir_1_1detail_1_1Interface.html" title="This class represents an abstract interface.">Interface</a></span> type, and a particular implementation of its concept.  <a href="classmlir_1_1detail_1_1InterfaceMap.html#details">More...</a><br /></td></tr>
<tr class="memitem:IROperandBase" id="r_IROperandBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1IROperandBase.html">IROperandBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the base for <a class="el" href="classmlir_1_1IROperand.html" title="A reference to a value, suitable for use as an operand of an operation.">IROperand</a>, and provides all of the non-templated facilities for operand use management.  <a href="classmlir_1_1detail_1_1IROperandBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fcomplex_5Ft" id="r_is_5Fcomplex_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__complex__t.html">is_complex_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> trait detector that checks if a given type T is a complex type.  <a href="structmlir_1_1detail_1_1is__complex__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fcomplex_5Ft_3C_20std_3A_3Acomplex_3C_20T_20_3E_20_3E" id="r_is_5Fcomplex_5Ft_3C_20std_3A_3Acomplex_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__complex__t_3_01std_1_1complex_3_01T_01_4_01_4.html">is_complex_t&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:is_5Ffully_5Fresolved_5Ft" id="r_is_5Ffully_5Fresolved_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__fully__resolved__t.html">is_fully_resolved_t</a></td></tr>
<tr class="memitem:is_5Fpair" id="r_is_5Fpair"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__pair.html">is_pair</a></td></tr>
<tr class="memitem:is_5Fpair_3C_20std_3A_3Apair_3C_20Ts_2E_2E_2E_20_3E_20_3E" id="r_is_5Fpair_3C_20std_3A_3Apair_3C_20Ts_2E_2E_2E_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__pair_3_01std_1_1pair_3_01Ts_8_8_8_01_4_01_4.html">is_pair&lt; std::pair&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memitem:is_5Ftuple" id="r_is_5Ftuple"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__tuple.html">is_tuple</a></td></tr>
<tr class="memitem:is_5Ftuple_3C_20std_3A_3Atuple_3C_20Ts_2E_2E_2E_20_3E_20_3E" id="r_is_5Ftuple_3C_20std_3A_3Atuple_3C_20Ts_2E_2E_2E_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1is__tuple_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">is_tuple&lt; std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memitem:NameOpMatcher" id="r_NameOpMatcher"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1NameOpMatcher.html">NameOpMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches operations that have the specified op name.  <a href="structmlir_1_1detail_1_1NameOpMatcher.html#details">More...</a><br /></td></tr>
<tr class="memitem:NestedAnalysisMap" id="r_NestedAnalysisMap"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1NestedAnalysisMap.html">NestedAnalysisMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An analysis map that contains a map for the current operation, and a set of maps for any child operations.  <a href="structmlir_1_1detail_1_1NestedAnalysisMap.html#details">More...</a><br /></td></tr>
<tr class="memitem:op_5Ffilter_5Fiterator" id="r_op_5Ffilter_5Fiterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1op__filter__iterator.html">op_filter_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility iterator that filters out operations that are not 'OpT'.  <a href="classmlir_1_1detail_1_1op__filter__iterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:op_5Fiterator" id="r_op_5Fiterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1op__iterator.html">op_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides iteration over the held operations of a block for a specific operation type.  <a href="classmlir_1_1detail_1_1op__iterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:op_5Fmatcher" id="r_op_5Fmatcher"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">op_matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matcher that matches a certain kind of op.  <a href="structmlir_1_1detail_1_1op__matcher.html#details">More...</a><br /></td></tr>
<tr class="memitem:OperandStorage" id="r_OperandStorage"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1OperandStorage.html">OperandStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class handles the management of operation operands.  <a href="classmlir_1_1detail_1_1OperandStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpOrInterfaceRewritePatternBase" id="r_OpOrInterfaceRewritePatternBase"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1OpOrInterfaceRewritePatternBase.html">OpOrInterfaceRewritePatternBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1detail_1_1OpOrInterfaceRewritePatternBase.html" title="OpOrInterfaceRewritePatternBase is a wrapper around RewritePattern that allows for matching and rewri...">OpOrInterfaceRewritePatternBase</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements.">RewritePattern</a> that allows for matching and rewriting against an instance of a derived operation class or <a class="el" href="classmlir_1_1detail_1_1Interface.html" title="This class represents an abstract interface.">Interface</a>.  <a href="structmlir_1_1detail_1_1OpOrInterfaceRewritePatternBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpPassManagerImpl" id="r_OpPassManagerImpl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1OpPassManagerImpl.html">OpPassManagerImpl</a></td></tr>
<tr class="memitem:OpResultImpl" id="r_OpResultImpl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1OpResultImpl.html">OpResultImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the implementation for an operation result.  <a href="classmlir_1_1detail_1_1OpResultImpl.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpToOpPassAdaptor" id="r_OpToOpPassAdaptor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1OpToOpPassAdaptor.html">OpToOpPassAdaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptor pass used to run operation passes over nested operations.  <a href="classmlir_1_1detail_1_1OpToOpPassAdaptor.html#details">More...</a><br /></td></tr>
<tr class="memitem:OutOfLineOpResult" id="r_OutOfLineOpResult"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1OutOfLineOpResult.html">OutOfLineOpResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the implementation for an operation result whose index cannot be represented "inline", and thus requires an additional index field.  <a href="classmlir_1_1detail_1_1OutOfLineOpResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:ParallelDiagnosticHandlerImpl" id="r_ParallelDiagnosticHandlerImpl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ParallelDiagnosticHandlerImpl.html">ParallelDiagnosticHandlerImpl</a></td></tr>
<tr class="memitem:Parser" id="r_Parser"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html">Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implement support for parsing global entities like attributes and types.  <a href="classmlir_1_1detail_1_1Parser.html#details">More...</a><br /></td></tr>
<tr class="memitem:ParserState" id="r_ParserState"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1ParserState.html">ParserState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class refers to all of the state maintained globally by the parser, such as the current lexer position etc.  <a href="structmlir_1_1detail_1_1ParserState.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassCrashReproducerGenerator" id="r_PassCrashReproducerGenerator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PassCrashReproducerGenerator.html">PassCrashReproducerGenerator</a></td></tr>
<tr class="memitem:PassExecutionState" id="r_PassExecutionState"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1PassExecutionState.html">PassExecutionState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state for a single execution of a pass.  <a href="structmlir_1_1detail_1_1PassExecutionState.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassInstrumentorImpl" id="r_PassInstrumentorImpl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1PassInstrumentorImpl.html">PassInstrumentorImpl</a></td></tr>
<tr class="memitem:PassOptions" id="r_PassOptions"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PassOptions.html">PassOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base container class and manager for all pass options.  <a href="classmlir_1_1detail_1_1PassOptions.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassPipelineCLParserImpl" id="r_PassPipelineCLParserImpl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1PassPipelineCLParserImpl.html">PassPipelineCLParserImpl</a></td></tr>
<tr class="memitem:PatternMatcherValue" id="r_PatternMatcherValue"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1PatternMatcherValue.html">PatternMatcherValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds to a specific value and matches it.  <a href="structmlir_1_1detail_1_1PatternMatcherValue.html#details">More...</a><br /></td></tr>
<tr class="memitem:PDLByteCode" id="r_PDLByteCode"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PDLByteCode.html">PDLByteCode</a></td></tr>
<tr class="memitem:PDLByteCodeMutableState" id="r_PDLByteCodeMutableState"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PDLByteCodeMutableState.html">PDLByteCodeMutableState</a></td></tr>
<tr class="memitem:PDLByteCodePattern" id="r_PDLByteCodePattern"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PDLByteCodePattern.html">PDLByteCodePattern</a></td></tr>
<tr class="memitem:PreservedAnalyses" id="r_PreservedAnalyses"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1PreservedAnalyses.html">PreservedAnalyses</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to represent the analyses that are known to be preserved.  <a href="classmlir_1_1detail_1_1PreservedAnalyses.html#details">More...</a><br /></td></tr>
<tr class="memitem:RecoveryReproducerContext" id="r_RecoveryReproducerContext"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1RecoveryReproducerContext.html">RecoveryReproducerContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the context for generating a recovery reproducer.  <a href="structmlir_1_1detail_1_1RecoveryReproducerContext.html#details">More...</a><br /></td></tr>
<tr class="memitem:RecursivePatternMatcher" id="r_RecursivePatternMatcher"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1RecursivePatternMatcher.html">RecursivePatternMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1detail_1_1RecursivePatternMatcher.html" title="RecursivePatternMatcher that composes.">RecursivePatternMatcher</a> that composes.  <a href="structmlir_1_1detail_1_1RecursivePatternMatcher.html#details">More...</a><br /></td></tr>
<tr class="memitem:SourceMgrDiagnosticHandlerImpl" id="r_SourceMgrDiagnosticHandlerImpl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1SourceMgrDiagnosticHandlerImpl.html">SourceMgrDiagnosticHandlerImpl</a></td></tr>
<tr class="memitem:SourceMgrDiagnosticVerifierHandlerImpl" id="r_SourceMgrDiagnosticVerifierHandlerImpl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1SourceMgrDiagnosticVerifierHandlerImpl.html">SourceMgrDiagnosticVerifierHandlerImpl</a></td></tr>
<tr class="memitem:StorageUniquerImpl" id="r_StorageUniquerImpl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1StorageUniquerImpl.html">StorageUniquerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the implementation of the <a class="el" href="classmlir_1_1StorageUniquer.html" title="A utility class to get or create instances of &quot;storage classes&quot;.">StorageUniquer</a> class.  <a href="structmlir_1_1detail_1_1StorageUniquerImpl.html#details">More...</a><br /></td></tr>
<tr class="memitem:StorageUserBase" id="r_StorageUserBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">StorageUserBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for implementing users of storage classes uniqued by a <a class="el" href="classmlir_1_1StorageUniquer.html" title="A utility class to get or create instances of &quot;storage classes&quot;.">StorageUniquer</a>.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:StorageUserTraitBase" id="r_StorageUserTraitBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserTraitBase.html">StorageUserTraitBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for implementing traits for storage classes.  <a href="classmlir_1_1detail_1_1StorageUserTraitBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:StringAttrStorage" id="r_StringAttrStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1StringAttrStorage.html">StringAttrStorage</a></td></tr>
<tr class="memitem:SymbolState" id="r_SymbolState"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1SymbolState.html">SymbolState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains record of any parsed top-level symbols.  <a href="structmlir_1_1detail_1_1SymbolState.html#details">More...</a><br /></td></tr>
<tr class="memitem:TileOffsetRangeImpl" id="r_TileOffsetRangeImpl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1TileOffsetRangeImpl.html">TileOffsetRangeImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the set of parameters that are used to make tile offset calculations in the <a class="el" href="classmlir_1_1detail_1_1TileOffsetRangeIterator.html" title="The STL-style iterator implementation for StaticTileOffsetRange.">TileOffsetRangeIterator</a>.  <a href="classmlir_1_1detail_1_1TileOffsetRangeImpl.html#details">More...</a><br /></td></tr>
<tr class="memitem:TileOffsetRangeIterator" id="r_TileOffsetRangeIterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1TileOffsetRangeIterator.html">TileOffsetRangeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The STL-style iterator implementation for <a class="el" href="classmlir_1_1StaticTileOffsetRange.html" title="A range-style iterator that allows for iterating over the offsets of all potential tiles of size tile...">StaticTileOffsetRange</a>.  <a href="classmlir_1_1detail_1_1TileOffsetRangeIterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:TimingManagerImpl" id="r_TimingManagerImpl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1TimingManagerImpl.html">TimingManagerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private implementation details of the <span class="tt"><a class="el" href="classmlir_1_1TimingManager.html" title="This class represents facilities to measure execution time.">TimingManager</a></span>.  <a href="classmlir_1_1detail_1_1TimingManagerImpl.html#details">More...</a><br /></td></tr>
<tr class="memitem:TupleTypeStorage" id="r_TupleTypeStorage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1TupleTypeStorage.html">TupleTypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing a collection of other types.  <a href="structmlir_1_1detail_1_1TupleTypeStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypedValue" id="r_TypedValue"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1TypedValue.html">TypedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1detail_1_1TypedValue.html" title="TypedValue is a Value with a statically know type.">TypedValue</a> is a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> with a statically know type.  <a href="structmlir_1_1detail_1_1TypedValue.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypeIDResolver" id="r_TypeIDResolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1TypeIDResolver.html">TypeIDResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a resolver for getting the ID for a given class T.  <a href="classmlir_1_1detail_1_1TypeIDResolver.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypeIDResolver_3C_20T_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20InlineTypeIDResolver_3A_3Ahas_5Fresolve_5Ftypeid_3C_20T_20_3E_3A_3Avalue_20_3E_20_3E" id="r_TypeIDResolver_3C_20T_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20InlineTypeIDResolver_3A_3Ahas_5Fresolve_5Ftypeid_3C_20T_20_3E_3A_3Avalue_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1TypeIDResolver_3_01T_00_01std_1_1enable__if__t_3_01InlineTypeIDResolver_1d0aed3a2268b37a1e2af8caec7ea91e4.html">TypeIDResolver&lt; T, std::enable_if_t&lt; InlineTypeIDResolver::has_resolve_typeid&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a resolver for getting the ID for a given class T, when the class provides a <span class="tt">static <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a> <a class="el" href="classmlir_1_1detail_1_1TypeIDResolver_3_01T_00_01std_1_1enable__if__t_3_01InlineTypeIDResolver_1d0aed3a2268b37a1e2af8caec7ea91e4.html#a44f66ca9f3d85b18a223313feb90f7e7">resolveTypeID()</a></span> method.  <a href="classmlir_1_1detail_1_1TypeIDResolver_3_01T_00_01std_1_1enable__if__t_3_01InlineTypeIDResolver_1d0aed3a2268b37a1e2af8caec7ea91e4.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypeUniquer" id="r_TypeUniquer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html">TypeUniquer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to get, or create, unique instances of types within an <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a>.  <a href="structmlir_1_1detail_1_1TypeUniquer.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueImpl" id="r_ValueImpl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1ValueImpl.html">ValueImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all derived <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> classes.  <a href="classmlir_1_1detail_1_1ValueImpl.html#details">More...</a><br /></td></tr>
<tr class="memitem:Vector1D" id="r_Vector1D"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1Vector1D.html">Vector1D</a></td></tr>
<tr class="memitem:Vector1D_3C_20T_2C_20Dim_2C_20false_20_3E" id="r_Vector1D_3C_20T_2C_20Dim_2C_20false_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1Vector1D_3_01T_00_01Dim_00_01false_01_4.html">Vector1D&lt; T, Dim, false &gt;</a></td></tr>
<tr class="memitem:Vector1D_3C_20T_2C_20Dim_2C_20true_20_3E" id="r_Vector1D_3C_20T_2C_20Dim_2C_20true_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1detail_1_1Vector1D_3_01T_00_01Dim_00_01true_01_4.html">Vector1D&lt; T, Dim, true &gt;</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad7ac71b8ff8edaf597280cb4777d109c" id="r_ad7ac71b8ff8edaf597280cb4777d109c"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ad7ac71b8ff8edaf597280cb4777d109c template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7ac71b8ff8edaf597280cb4777d109c">has_default_sub_element_handler_t</a> = decltype(T::DefaultHandlerTag)</td></tr>
<tr class="memitem:a52f40d76f108bee8a165fccb14a8e4fc" id="r_a52f40d76f108bee8a165fccb14a8e4fc"><td class="memTemplParams" colspan="2">template&lt;typename T, typename... Ts&gt; </td></tr>
<tr class="memitem:a52f40d76f108bee8a165fccb14a8e4fc template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52f40d76f108bee8a165fccb14a8e4fc">has_get_method</a> = decltype(T::get(std::declval&lt;Ts&gt;()...))</td></tr>
<tr class="memitem:a4ff923a0f002b0fe1658b5b423390158" id="r_a4ff923a0f002b0fe1658b5b423390158"><td class="memTemplParams" colspan="2">template&lt;typename T, typename... Ts&gt; </td></tr>
<tr class="memitem:a4ff923a0f002b0fe1658b5b423390158 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ff923a0f002b0fe1658b5b423390158">has_get_as_key</a> = decltype(std::declval&lt;T&gt;().getAsKey())</td></tr>
<tr class="memitem:a62f1cd89e40ee6862af85b5d7a1257bc" id="r_a62f1cd89e40ee6862af85b5d7a1257bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62f1cd89e40ee6862af85b5d7a1257bc">DenseIterPtrAndSplat</a> = std::pair&lt;const char *, <a class="el" href="classbool.html">bool</a>&gt;</td></tr>
<tr class="memdesc:a62f1cd89e40ee6862af85b5d7a1257bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair of raw pointer and a boolean flag of whether the pointer holds a splat,.  <br /></td></tr>
<tr class="memitem:a0aacd4fdb1cb9c49acee59175eb094ce" id="r_a0aacd4fdb1cb9c49acee59175eb094ce"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a0aacd4fdb1cb9c49acee59175eb094ce template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0aacd4fdb1cb9c49acee59175eb094ce">has_push_back_t</a></td></tr>
<tr class="memitem:a116eb8f6bf6d8b1f5aea178489d35e6f" id="r_a116eb8f6bf6d8b1f5aea178489d35e6f"><td class="memTemplParams" colspan="2">template&lt;typename T, typename MatchTarget&gt; </td></tr>
<tr class="memitem:a116eb8f6bf6d8b1f5aea178489d35e6f template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a116eb8f6bf6d8b1f5aea178489d35e6f">has_compatible_matcher_t</a></td></tr>
<tr class="memdesc:a116eb8f6bf6d8b1f5aea178489d35e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check whether T provides a 'match' method with type <span class="tt">MatchTarget</span> (<a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>, <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>, or <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>).  <br /></td></tr>
<tr class="memitem:a1835ccfb3b99b36cc72132d2b3b4e3f4" id="r_a1835ccfb3b99b36cc72132d2b3b4e3f4"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a1835ccfb3b99b36cc72132d2b3b4e3f4 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1835ccfb3b99b36cc72132d2b3b4e3f4">first_argument</a> = decltype(<a class="el" href="#a6f65c29b00af55fbdff5cf2a1bfbbe17">first_argument_type</a>(std::declval&lt;T&gt;()))</td></tr>
<tr class="memdesc:a1835ccfb3b99b36cc72132d2b3b4e3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> definition of the first argument to the given callable 'T'.  <br /></td></tr>
<tr class="memitem:ae9a8ec980b37f33d00ed9120a4910932" id="r_ae9a8ec980b37f33d00ed9120a4910932"><td class="memTemplParams" colspan="2">template&lt;typename FnT&gt; </td></tr>
<tr class="memitem:ae9a8ec980b37f33d00ed9120a4910932 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9a8ec980b37f33d00ed9120a4910932">walkResultType</a> = decltype(<a class="el" href="#a152b851682ac1cad31c84dc1a6fc38cb">walk</a>(<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, std::declval&lt;FnT&gt;()))</td></tr>
<tr class="memdesc:ae9a8ec980b37f33d00ed9120a4910932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to provide the return type of a templated walk method.  <br /></td></tr>
<tr class="memitem:a5f8c42f8d912c7222328140748adcf48" id="r_a5f8c42f8d912c7222328140748adcf48"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class Pred, typename... Ts&gt; </td></tr>
<tr class="memitem:a5f8c42f8d912c7222328140748adcf48 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f8c42f8d912c7222328140748adcf48">count_if_t</a> = <a class="el" href="structmlir_1_1detail_1_1count__if__t__impl.html">count_if_t_impl</a>&lt;Pred, 0, Ts...&gt;</td></tr>
<tr class="memitem:a198c9063c94c028d50df8656604ba471" id="r_a198c9063c94c028d50df8656604ba471"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a198c9063c94c028d50df8656604ba471 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a198c9063c94c028d50df8656604ba471">is_interface_t</a> = decltype(<a class="el" href="#a493be0c467bac528a100115486f3ec69">isInterfaceImpl</a>(std::declval&lt;T &amp;&gt;()))</td></tr>
<tr class="memitem:a46beaca96aec31996e37bd9a012dc794" id="r_a46beaca96aec31996e37bd9a012dc794"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a46beaca96aec31996e37bd9a012dc794 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46beaca96aec31996e37bd9a012dc794">IsInterface</a> = llvm::is_detected&lt;<a class="el" href="#a198c9063c94c028d50df8656604ba471">is_interface_t</a>, T&gt;</td></tr>
<tr class="memitem:a382136bcf1f5918063ae380d964d3ca5" id="r_a382136bcf1f5918063ae380d964d3ca5"><td class="memTemplParams" colspan="2">template&lt;typename ImplTy, typename... Args&gt; </td></tr>
<tr class="memitem:a382136bcf1f5918063ae380d964d3ca5 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a382136bcf1f5918063ae380d964d3ca5">has_impltype_getkey_t</a> = decltype(ImplTy::getKey(std::declval&lt;Args&gt;()...))</td></tr>
<tr class="memdesc:a382136bcf1f5918063ae380d964d3ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if ImplTy provides a 'getKey' method with types 'Args'.  <br /></td></tr>
<tr class="memitem:a8b735a3eb149ca609203004fcd188cd1" id="r_a8b735a3eb149ca609203004fcd188cd1"><td class="memTemplParams" colspan="2">template&lt;typename ImplTy, typename T&gt; </td></tr>
<tr class="memitem:a8b735a3eb149ca609203004fcd188cd1 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b735a3eb149ca609203004fcd188cd1">has_impltype_hash_t</a> = decltype(ImplTy::hashKey(std::declval&lt;T&gt;()))</td></tr>
<tr class="memdesc:a8b735a3eb149ca609203004fcd188cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if ImplTy provides a 'hashKey' method for 'T'.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a78296380781bb5c3af2dd2ad9b70c26f" id="r_a78296380781bb5c3af2dd2ad9b70c26f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78296380781bb5c3af2dd2ad9b70c26f">OpProperties</a> : char </td></tr>
<tr class="memdesc:a78296380781bb5c3af2dd2ad9b70c26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "tag" used for mapping the properties storage in llvm::TrailingObjects.  <a href="#a78296380781bb5c3af2dd2ad9b70c26f">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1e92b3730d5a0d2e1c4f704cb4674d1e" id="r_a1e92b3730d5a0d2e1c4f704cb4674d1e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e92b3730d5a0d2e1c4f704cb4674d1e">isPowerOf2</a> (int n)</td></tr>
<tr class="memitem:a69a50c1b52f8e20f12e77716d79a5868" id="r_a69a50c1b52f8e20f12e77716d79a5868"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69a50c1b52f8e20f12e77716d79a5868">nextPowerOf2</a> (int n)</td></tr>
<tr class="memitem:a927870022d523a348748e4824f220c4e" id="r_a927870022d523a348748e4824f220c4e"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a927870022d523a348748e4824f220c4e template"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="classint64__t.html">int64_t</a>, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a927870022d523a348748e4824f220c4e">makeStrides</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; shape)</td></tr>
<tr class="memdesc:a927870022d523a348748e4824f220c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a shape with sizes greater than 0 along all dimensions, returns the distance, in number of elements, between a slice in a dimension and the next slice in the same dimension.  <br /></td></tr>
<tr class="memitem:ad345cebe040768a8cecdf87b398cd223" id="r_ad345cebe040768a8cecdf87b398cd223"><td class="memTemplParams" colspan="2">template&lt;int N, typename T&gt; </td></tr>
<tr class="memitem:ad345cebe040768a8cecdf87b398cd223 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;(N &gt;=1), <a class="el" href="structStridedMemRefType.html">StridedMemRefType</a>&lt; T, N &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad345cebe040768a8cecdf87b398cd223">makeStridedMemRefDescriptor</a> (T *ptr, T *alignedPtr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; shape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; shapeAlloc)</td></tr>
<tr class="memdesc:ad345cebe040768a8cecdf87b398cd223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <span class="tt">StridedMemRefDescriptor&lt;T, N&gt;</span> that matches the MLIR ABI.  <br /></td></tr>
<tr class="memitem:a7275c4b97f04286385a44690c219074f" id="r_a7275c4b97f04286385a44690c219074f"><td class="memTemplParams" colspan="2">template&lt;int N, typename T&gt; </td></tr>
<tr class="memitem:a7275c4b97f04286385a44690c219074f template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt;(N==0), <a class="el" href="structStridedMemRefType.html">StridedMemRefType</a>&lt; T, 0 &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7275c4b97f04286385a44690c219074f">makeStridedMemRefDescriptor</a> (T *ptr, T *alignedPtr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; shape={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; shapeAlloc={})</td></tr>
<tr class="memdesc:a7275c4b97f04286385a44690c219074f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <span class="tt">StridedMemRefDescriptor&lt;T, 0&gt;</span> that matches the MLIR ABI.  <br /></td></tr>
<tr class="memitem:a70490ffb8ad6edf1d2625dcf89d4b61b" id="r_a70490ffb8ad6edf1d2625dcf89d4b61b"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a70490ffb8ad6edf1d2625dcf89d4b61b template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; T *, T * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70490ffb8ad6edf1d2625dcf89d4b61b">allocAligned</a> (size_t nElements, <a class="el" href="namespacemlir.html#a044e19a45e06290430f27c9c818bf71a">AllocFunType</a> allocFun=&amp;::malloc, std::optional&lt; uint64_t &gt; alignment=std::optional&lt; uint64_t &gt;())</td></tr>
<tr class="memdesc:a70490ffb8ad6edf1d2625dcf89d4b61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align <span class="tt">nElements</span> of type T with an optional <span class="tt">alignment</span>.  <br /></td></tr>
<tr class="memitem:a083757618e89b0f53d587541eccf53e0" id="r_a083757618e89b0f53d587541eccf53e0"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a083757618e89b0f53d587541eccf53e0">getBranchSuccessorArgument</a> (const <a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> &amp;operands, <a class="el" href="classunsigned.html">unsigned</a> operandIndex, <a class="el" href="classmlir_1_1Block.html">Block</a> *successor)</td></tr>
<tr class="memdesc:a083757618e89b0f53d587541eccf53e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <span class="tt"><a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a></span> corresponding to operand <span class="tt">operandIndex</span> in some successor if <span class="tt">operandIndex</span> is within the range of <span class="tt">operands</span>, or std::nullopt if <span class="tt">operandIndex</span> isn't a successor operand index.  <br /></td></tr>
<tr class="memitem:a2e2f4d4cb24fe5f60b359e5962ad5498" id="r_a2e2f4d4cb24fe5f60b359e5962ad5498"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e2f4d4cb24fe5f60b359e5962ad5498">verifyBranchSuccessorOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> succNo, const <a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> &amp;operands)</td></tr>
<tr class="memdesc:a2e2f4d4cb24fe5f60b359e5962ad5498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the given operands match those of the given successor block.  <br /></td></tr>
<tr class="memitem:ae5372df7a0d717fe3ad6238640425402" id="r_ae5372df7a0d717fe3ad6238640425402"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5372df7a0d717fe3ad6238640425402">verifyBranchWeights</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ae5372df7a0d717fe3ad6238640425402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the branch weights attached to an operation implementing WeightedBranchOpInterface are correct.  <br /></td></tr>
<tr class="memitem:a25a3777b2ac1a4abcc61e74c35c7b997" id="r_a25a3777b2ac1a4abcc61e74c35c7b997"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25a3777b2ac1a4abcc61e74c35c7b997">verifyRegionBranchWeights</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a25a3777b2ac1a4abcc61e74c35c7b997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the region weights attached to an operation implementing WeightedRegiobBranchOpInterface are correct.  <br /></td></tr>
<tr class="memitem:ae4afbba3aecdff992f5fb31b086f9c12" id="r_ae4afbba3aecdff992f5fb31b086f9c12"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4afbba3aecdff992f5fb31b086f9c12">verifyTypesAlongControlFlowEdges</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ae4afbba3aecdff992f5fb31b086f9c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that types match along control flow edges described the given op.  <br /></td></tr>
<tr class="memitem:a87ca94416539c5fc8c1b2df637f6b522" id="r_a87ca94416539c5fc8c1b2df637f6b522"><td class="memItemLeft" align="right" valign="top">llvm::TypeSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87ca94416539c5fc8c1b2df637f6b522">getDefaultTypeSize</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="namespacemlir.html#aca03ba5e554abcffe4c1d89c53424982">DataLayoutEntryListRef</a> params)</td></tr>
<tr class="memdesc:a87ca94416539c5fc8c1b2df637f6b522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the type size request.  <br /></td></tr>
<tr class="memitem:a89cf52d46088967fe0b00f1a7f704eae" id="r_a89cf52d46088967fe0b00f1a7f704eae"><td class="memItemLeft" align="right" valign="top">llvm::TypeSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89cf52d46088967fe0b00f1a7f704eae">getDefaultTypeSizeInBits</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="namespacemlir.html#aca03ba5e554abcffe4c1d89c53424982">DataLayoutEntryListRef</a> params)</td></tr>
<tr class="memdesc:a89cf52d46088967fe0b00f1a7f704eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the type size in bits request.  <br /></td></tr>
<tr class="memitem:a8409dbc763fd806cdacab4558dd9e9f6" id="r_a8409dbc763fd806cdacab4558dd9e9f6"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8409dbc763fd806cdacab4558dd9e9f6">getDefaultABIAlignment</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt; params)</td></tr>
<tr class="memdesc:a8409dbc763fd806cdacab4558dd9e9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the required alignment request.  <br /></td></tr>
<tr class="memitem:a9812a6a269eaa19d0e843b22596578d0" id="r_a9812a6a269eaa19d0e843b22596578d0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9812a6a269eaa19d0e843b22596578d0">getDefaultPreferredAlignment</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt; params)</td></tr>
<tr class="memdesc:a9812a6a269eaa19d0e843b22596578d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the preferred alignment request.  <br /></td></tr>
<tr class="memitem:a1b3919dd661434ca92b4ebe5a20e58b1" id="r_a1b3919dd661434ca92b4ebe5a20e58b1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b3919dd661434ca92b4ebe5a20e58b1">getDefaultIndexBitwidth</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;dataLayout, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt; params)</td></tr>
<tr class="memdesc:a1b3919dd661434ca92b4ebe5a20e58b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the index bitwidth request.  <br /></td></tr>
<tr class="memitem:a0fc8e12b852a89dc2d49a19dab76bbf8" id="r_a0fc8e12b852a89dc2d49a19dab76bbf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fc8e12b852a89dc2d49a19dab76bbf8">getDefaultEndianness</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:a0fc8e12b852a89dc2d49a19dab76bbf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for endianness request.  <br /></td></tr>
<tr class="memitem:aeb4b21752e6c90f16e818bb89b80df5d" id="r_aeb4b21752e6c90f16e818bb89b80df5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb4b21752e6c90f16e818bb89b80df5d">getDefaultMemorySpace</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:aeb4b21752e6c90f16e818bb89b80df5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the default memory space request.  <br /></td></tr>
<tr class="memitem:a04d624115ea61e5b456d4c613a770631" id="r_a04d624115ea61e5b456d4c613a770631"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04d624115ea61e5b456d4c613a770631">getDefaultAllocaMemorySpace</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:a04d624115ea61e5b456d4c613a770631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for alloca memory space request.  <br /></td></tr>
<tr class="memitem:a6c79ef12939d977e7a4632bcc8b75a31" id="r_a6c79ef12939d977e7a4632bcc8b75a31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c79ef12939d977e7a4632bcc8b75a31">getDefaultManglingMode</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:a6c79ef12939d977e7a4632bcc8b75a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for mangling mode request.  <br /></td></tr>
<tr class="memitem:a0937e5890b25f8114fefdfe666484ac5" id="r_a0937e5890b25f8114fefdfe666484ac5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0937e5890b25f8114fefdfe666484ac5">getDefaultProgramMemorySpace</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:a0937e5890b25f8114fefdfe666484ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for program memory space request.  <br /></td></tr>
<tr class="memitem:acbccfb558aabea7d6494d225b56446e8" id="r_acbccfb558aabea7d6494d225b56446e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbccfb558aabea7d6494d225b56446e8">getDefaultGlobalMemorySpace</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:acbccfb558aabea7d6494d225b56446e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for global memory space request.  <br /></td></tr>
<tr class="memitem:a9c14c1ac1334d61bf90aa4f60a5fa261" id="r_a9c14c1ac1334d61bf90aa4f60a5fa261"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c14c1ac1334d61bf90aa4f60a5fa261">getDefaultStackAlignment</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:a9c14c1ac1334d61bf90aa4f60a5fa261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the stack alignment request.  <br /></td></tr>
<tr class="memitem:af519cb1b89cef66201a509b636c0899a" id="r_af519cb1b89cef66201a509b636c0899a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af519cb1b89cef66201a509b636c0899a">getDefaultFunctionPointerAlignment</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:af519cb1b89cef66201a509b636c0899a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the function pointer alignment request.  <br /></td></tr>
<tr class="memitem:a86153589d0a1d2f1d462dee9d852646c" id="r_a86153589d0a1d2f1d462dee9d852646c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86153589d0a1d2f1d462dee9d852646c">getDefaultLegalIntWidths</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:a86153589d0a1d2f1d462dee9d852646c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler for the legal int widths request.  <br /></td></tr>
<tr class="memitem:a5d552809ed611d55492c36bbb09886fe" id="r_a5d552809ed611d55492c36bbb09886fe"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d552809ed611d55492c36bbb09886fe">getDevicePropertyValue</a> (DataLayoutEntryInterface entry)</td></tr>
<tr class="memdesc:a5d552809ed611d55492c36bbb09886fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the property from the specified DataLayoutEntry.  <br /></td></tr>
<tr class="memitem:a31d3a751d105f957d43b5ee8ad6ab047" id="r_a31d3a751d105f957d43b5ee8ad6ab047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a17d2b8b3bf4e818da2900efa145bd05b">DataLayoutEntryList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31d3a751d105f957d43b5ee8ad6ab047">filterEntriesForType</a> (<a class="el" href="namespacemlir.html#aca03ba5e554abcffe4c1d89c53424982">DataLayoutEntryListRef</a> entries, <a class="el" href="classmlir_1_1TypeID.html">TypeID</a> typeID)</td></tr>
<tr class="memdesc:a31d3a751d105f957d43b5ee8ad6ab047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of data layout entries, returns a new list containing the entries with keys having the given type ID, i.e.  <br /></td></tr>
<tr class="memitem:af7ddc54fc9b6e82cf3b6a797a6bfefca" id="r_af7ddc54fc9b6e82cf3b6a797a6bfefca"><td class="memItemLeft" align="right" valign="top">DataLayoutEntryInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7ddc54fc9b6e82cf3b6a797a6bfefca">filterEntryForIdentifier</a> (<a class="el" href="namespacemlir.html#aca03ba5e554abcffe4c1d89c53424982">DataLayoutEntryListRef</a> entries, StringAttr id)</td></tr>
<tr class="memdesc:af7ddc54fc9b6e82cf3b6a797a6bfefca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of data layout entries, returns the entry that has the given identifier as key, if such an entry exists in the list.  <br /></td></tr>
<tr class="memitem:a6142ce3e04093b8805b807bbade3ec01" id="r_a6142ce3e04093b8805b807bbade3ec01"><td class="memItemLeft" align="right" valign="top">TargetDeviceSpecInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6142ce3e04093b8805b807bbade3ec01">filterEntryForIdentifier</a> (<a class="el" href="namespacemlir.html#a4bd203358eecf2493ba5344cd392aa65">TargetDeviceSpecListRef</a> entries, StringAttr id)</td></tr>
<tr class="memdesc:a6142ce3e04093b8805b807bbade3ec01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of target device entries, returns the entry that has the given identifier as key, if such an entry exists in the list.  <br /></td></tr>
<tr class="memitem:aee3b9d7e0a9cd00a32827f48d4536850" id="r_aee3b9d7e0a9cd00a32827f48d4536850"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee3b9d7e0a9cd00a32827f48d4536850">verifyDataLayoutOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:aee3b9d7e0a9cd00a32827f48d4536850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the operation implementing the data layout interface, or a module operation, is valid.  <br /></td></tr>
<tr class="memitem:af3a791a52efb3f0b9d61ca353b635e95" id="r_af3a791a52efb3f0b9d61ca353b635e95"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3a791a52efb3f0b9d61ca353b635e95">verifyDataLayoutSpec</a> (DataLayoutSpecInterface spec, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:af3a791a52efb3f0b9d61ca353b635e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that a data layout spec is valid.  <br /></td></tr>
<tr class="memitem:a474ca87dcf5fa084441e1a1275852fbb" id="r_a474ca87dcf5fa084441e1a1275852fbb"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a474ca87dcf5fa084441e1a1275852fbb">verifyTargetSystemSpec</a> (TargetSystemSpecInterface spec, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a474ca87dcf5fa084441e1a1275852fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that a target system desc spec is valid.  <br /></td></tr>
<tr class="memitem:a98a07efa628a8720c45b577162e4fe66" id="r_a98a07efa628a8720c45b577162e4fe66"><td class="memItemLeft" align="right" valign="top">llvm::TypeSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98a07efa628a8720c45b577162e4fe66">divideCeil</a> (llvm::TypeSize numerator, uint64_t denominator)</td></tr>
<tr class="memdesc:a98a07efa628a8720c45b577162e4fe66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the known min value of the numerator by the denominator and rounds the result up to the next integer.  <br /></td></tr>
<tr class="memitem:abc3a9033156fc6f0f4ee40b16eaa835c" id="r_abc3a9033156fc6f0f4ee40b16eaa835c"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc3a9033156fc6f0f4ee40b16eaa835c">verifyDestinationStyleOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:abc3a9033156fc6f0f4ee40b16eaa835c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that <span class="tt">op</span> conforms to the invariants of DestinationStyleOpInterface.  <br /></td></tr>
<tr class="memitem:a77ee29379e4568366034d669b060a034" id="r_a77ee29379e4568366034d669b060a034"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77ee29379e4568366034d669b060a034">verifyIndexingMapOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a77ee29379e4568366034d669b060a034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that <span class="tt">op</span> conforms to the invariants of StructuredOpInterface.  <br /></td></tr>
<tr class="memitem:a33a945b620206532de586bf2c444fa1e" id="r_a33a945b620206532de586bf2c444fa1e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33a945b620206532de586bf2c444fa1e">inferReturnTensorTypes</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1ShapedTypeComponents.html">ShapedTypeComponents</a> &gt; retComponents, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;inferredReturnTypes)</td></tr>
<tr class="memitem:ad276c5acc7f5d475d0e1987a456a59e0" id="r_ad276c5acc7f5d475d0e1987a456a59e0"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad276c5acc7f5d475d0e1987a456a59e0">verifyInferredResultTypes</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ad276c5acc7f5d475d0e1987a456a59e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies that the inferred result types match the actual result types for the op.  <br /></td></tr>
<tr class="memitem:ab5f85cda3d8183cca5b6c2766fddb2fb" id="r_ab5f85cda3d8183cca5b6c2766fddb2fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5f85cda3d8183cca5b6c2766fddb2fb">reportFatalInferReturnTypesError</a> (<a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;state)</td></tr>
<tr class="memdesc:ab5f85cda3d8183cca5b6c2766fddb2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report a fatal error indicating that the result types could not be inferred.  <br /></td></tr>
<tr class="memitem:a960f17c15fd15a72390d00da41a4e12f" id="r_a960f17c15fd15a72390d00da41a4e12f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a960f17c15fd15a72390d00da41a4e12f">verifyLoopLikeOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a960f17c15fd15a72390d00da41a4e12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify invariants of the LoopLikeOpInterface.  <br /></td></tr>
<tr class="memitem:ad771bcf841b38d5c2ccca4417102863e" id="r_ad771bcf841b38d5c2ccca4417102863e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad771bcf841b38d5c2ccca4417102863e">verifyMemorySpaceCastOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ad771bcf841b38d5c2ccca4417102863e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to verify the given memory space cast operation.  <br /></td></tr>
<tr class="memitem:a7bb7be75817707a561386449c561cc31" id="r_a7bb7be75817707a561386449c561cc31"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bb7be75817707a561386449c561cc31">bubbleDownInPlaceMemorySpaceCastImpl</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;operand, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> results)</td></tr>
<tr class="memdesc:a7bb7be75817707a561386449c561cc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to bubble-down inplace a <span class="tt">MemorySpaceCastOpInterface</span> operation referenced by <span class="tt">operand</span>.  <br /></td></tr>
<tr class="memitem:af09e6bd26baceff7935df426cf406496" id="r_af09e6bd26baceff7935df426cf406496"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af09e6bd26baceff7935df426cf406496">verifyInParallelOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a819d12bc01c2443cfc1b72c4824bfaba" id="r_a819d12bc01c2443cfc1b72c4824bfaba"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a819d12bc01c2443cfc1b72c4824bfaba">verifyShapedDimOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a819d12bc01c2443cfc1b72c4824bfaba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify invariants of ops that implement the ShapedDimOpInterface.  <br /></td></tr>
<tr class="memitem:af748f20e1dc2fc58d26e3d2257926385" id="r_af748f20e1dc2fc58d26e3d2257926385"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af748f20e1dc2fc58d26e3d2257926385">defaultGetDestinationOperand</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:af748f20e1dc2fc58d26e3d2257926385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the destination/"init" operand of the op if it implements the <span class="tt">DestinationStyleOpInterface</span> and has exactly one "init" operand.  <br /></td></tr>
<tr class="memitem:aac272571a0b927a2a4fa1debf78948bb" id="r_aac272571a0b927a2a4fa1debf78948bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac272571a0b927a2a4fa1debf78948bb">defaultGetUpdatedDestination</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:aac272571a0b927a2a4fa1debf78948bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the updated destination result of the op if it implements the <span class="tt">DestinationStyleOpInterface</span>.  <br /></td></tr>
<tr class="memitem:adfec552c5927149bad3102177f1f161a" id="r_adfec552c5927149bad3102177f1f161a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfec552c5927149bad3102177f1f161a">defaultIsEquivalentSubset</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> candidate, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; equivalenceFn)</td></tr>
<tr class="memdesc:adfec552c5927149bad3102177f1f161a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of <span class="tt">SubsetInsertionOpInterface::isEquivalentSubset</span>.  <br /></td></tr>
<tr class="memitem:a3e8b66ba9169bfa2c09c598ccca039db" id="r_a3e8b66ba9169bfa2c09c598ccca039db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e8b66ba9169bfa2c09c598ccca039db">defaultOperatesOnEquivalentSubset</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, SubsetOpInterface candidate, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; equivalenceFn)</td></tr>
<tr class="memdesc:a3e8b66ba9169bfa2c09c598ccca039db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of <span class="tt">SubsetOpInterface::operatesOnEquivalentSubset</span>.  <br /></td></tr>
<tr class="memitem:a20f1363f8cb9bc8b135a3212569aaf37" id="r_a20f1363f8cb9bc8b135a3212569aaf37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20f1363f8cb9bc8b135a3212569aaf37">defaultOperatesOnDisjointSubset</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, SubsetOpInterface candidate, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; equivalenceFn)</td></tr>
<tr class="memdesc:a20f1363f8cb9bc8b135a3212569aaf37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of <span class="tt">SubsetOpInterface::operatesOnDisjointSubset</span>.  <br /></td></tr>
<tr class="memitem:a6f6bd31c91df4b26794a88c1006e83ef" id="r_a6f6bd31c91df4b26794a88c1006e83ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f6bd31c91df4b26794a88c1006e83ef">getTensorContainer</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a6f6bd31c91df4b26794a88c1006e83ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the container that the given subset op is operating on.  <br /></td></tr>
<tr class="memitem:aba9dcc8813e435202abcbb438f66d90a" id="r_aba9dcc8813e435202abcbb438f66d90a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba9dcc8813e435202abcbb438f66d90a">verifySubsetOpInterface</a> (SubsetOpInterface op)</td></tr>
<tr class="memdesc:aba9dcc8813e435202abcbb438f66d90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify <span class="tt">SubsetOpInterface</span>.  <br /></td></tr>
<tr class="memitem:a0ebd9058172b2a090d824c6ab1841413" id="r_a0ebd9058172b2a090d824c6ab1841413"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ebd9058172b2a090d824c6ab1841413">verifySubsetExtractionOpInterface</a> (SubsetExtractionOpInterface op)</td></tr>
<tr class="memdesc:a0ebd9058172b2a090d824c6ab1841413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify <span class="tt">SubsetExtractionOpInterface</span>.  <br /></td></tr>
<tr class="memitem:afebb54d50bfcc329f59aee2490b27c07" id="r_afebb54d50bfcc329f59aee2490b27c07"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afebb54d50bfcc329f59aee2490b27c07">verifyOffsetSizeAndStrideOp</a> (OffsetSizeAndStrideOpInterface op)</td></tr>
<tr class="memitem:a0caa43784c57086534e1833f66eaecfc" id="r_a0caa43784c57086534e1833f66eaecfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0caa43784c57086534e1833f66eaecfc">sameOffsetsSizesAndStrides</a> (OffsetSizeAndStrideOpInterface a, OffsetSizeAndStrideOpInterface <a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>)&gt; cmp)</td></tr>
<tr class="memitem:a4bbbaf06f702976f635516e2eec5c165" id="r_a4bbbaf06f702976f635516e2eec5c165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bbbaf06f702976f635516e2eec5c165">getNumDynamicEntriesUpToIdx</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; staticVals, <a class="el" href="classunsigned.html">unsigned</a> idx)</td></tr>
<tr class="memdesc:a4bbbaf06f702976f635516e2eec5c165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to compute the number of dynamic entries of <span class="tt">staticVals</span>, up to <span class="tt">idx</span>.  <br /></td></tr>
<tr class="memitem:ad693ba34552063984c6685f93500c79f" id="r_ad693ba34552063984c6685f93500c79f"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ad693ba34552063984c6685f93500c79f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad693ba34552063984c6685f93500c79f">bindDims</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memitem:adc67b3a3dac2996cc431f90b8658f6e6" id="r_adc67b3a3dac2996cc431f90b8658f6e6"><td class="memTemplParams" colspan="2">template&lt;int N, typename AffineExprTy, typename... AffineExprTy2&gt; </td></tr>
<tr class="memitem:adc67b3a3dac2996cc431f90b8658f6e6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc67b3a3dac2996cc431f90b8658f6e6">bindDims</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;e, AffineExprTy2 &amp;...exprs)</td></tr>
<tr class="memitem:addb63088be1c8bff57b28cc3be96701b" id="r_addb63088be1c8bff57b28cc3be96701b"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:addb63088be1c8bff57b28cc3be96701b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addb63088be1c8bff57b28cc3be96701b">bindSymbols</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memitem:a2b0f1dec3bae54bd6eecd9e5abb59e4c" id="r_a2b0f1dec3bae54bd6eecd9e5abb59e4c"><td class="memTemplParams" colspan="2">template&lt;int N, typename AffineExprTy, typename... AffineExprTy2&gt; </td></tr>
<tr class="memitem:a2b0f1dec3bae54bd6eecd9e5abb59e4c template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b0f1dec3bae54bd6eecd9e5abb59e4c">bindSymbols</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;e, AffineExprTy2 &amp;...exprs)</td></tr>
<tr class="memitem:a2bc750046567479d1fdfa425bac17b32" id="r_a2bc750046567479d1fdfa425bac17b32"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a2bc750046567479d1fdfa425bac17b32 template"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bc750046567479d1fdfa425bac17b32">unwrapForCustomParse</a> (FailureOr&lt; T &gt; &amp;failureOr)</td></tr>
<tr class="memitem:a9d0ecdf07e5bd3e5496db1048d6b0beb" id="r_a9d0ecdf07e5bd3e5496db1048d6b0beb"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a9d0ecdf07e5bd3e5496db1048d6b0beb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d0ecdf07e5bd3e5496db1048d6b0beb">walkImmediateSubElementsImpl</a> (T derived, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt; walkAttrsFn, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Type.html">Type</a>)&gt; walkTypesFn)</td></tr>
<tr class="memdesc:a9d0ecdf07e5bd3e5496db1048d6b0beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides the underlying implementation for the SubElementInterface walk method, using the key type of the derived attribute/type to interact with the individual parameters.  <br /></td></tr>
<tr class="memitem:a451d8dc61974032518997d3f9935e53a" id="r_a451d8dc61974032518997d3f9935e53a"><td class="memTemplParams" colspan="2">template&lt;typename T, typename... Ts&gt; </td></tr>
<tr class="memitem:a451d8dc61974032518997d3f9935e53a template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a451d8dc61974032518997d3f9935e53a">constructSubElementReplacement</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, Ts &amp;&amp;...params)</td></tr>
<tr class="memdesc:a451d8dc61974032518997d3f9935e53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function invokes the proper <span class="tt">get</span> method for a type <span class="tt">T</span> with the given values.  <br /></td></tr>
<tr class="memitem:a8af776eda51700256b7c60deadcb4d25" id="r_a8af776eda51700256b7c60deadcb4d25"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a8af776eda51700256b7c60deadcb4d25 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8af776eda51700256b7c60deadcb4d25">replaceImmediateSubElementsImpl</a> (T derived, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; &amp;replAttrs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;replTypes)</td></tr>
<tr class="memdesc:a8af776eda51700256b7c60deadcb4d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides the underlying implementation for the SubElementInterface replace method, using the key type of the derived attribute/type to interact with the individual parameters.  <br /></td></tr>
<tr class="memitem:ada3315ae7edc12bed53da6a26424d047" id="r_ada3315ae7edc12bed53da6a26424d047"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada3315ae7edc12bed53da6a26424d047">verifyAffineMapAsLayout</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> m, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; shape, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="memitem:a767e521ae7755c29bc29daaeb840c238" id="r_a767e521ae7755c29bc29daaeb840c238"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a767e521ae7755c29bc29daaeb840c238">getAffineMapStridesAndOffset</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; shape, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;strides, <a class="el" href="classint64__t.html">int64_t</a> &amp;offset)</td></tr>
<tr class="memitem:ab843225909c16d7b47091b66701c59ab" id="r_ab843225909c16d7b47091b66701c59ab"><td class="memTemplParams" colspan="2">template&lt;typename MatcherClass&gt; </td></tr>
<tr class="memitem:ab843225909c16d7b47091b66701c59ab template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::is_detected&lt; <a class="el" href="#a116eb8f6bf6d8b1f5aea178489d35e6f">detail::has_compatible_matcher_t</a>, MatcherClass, <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;::value, <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab843225909c16d7b47091b66701c59ab">matchOperandOrValueAtIndex</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> idx, MatcherClass &amp;matcher)</td></tr>
<tr class="memdesc:ab843225909c16d7b47091b66701c59ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically switch to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> matcher.  <br /></td></tr>
<tr class="memitem:a5854f70c611fd1abd8caf893a0fe036a" id="r_a5854f70c611fd1abd8caf893a0fe036a"><td class="memTemplParams" colspan="2">template&lt;typename MatcherClass&gt; </td></tr>
<tr class="memitem:a5854f70c611fd1abd8caf893a0fe036a template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::is_detected&lt; <a class="el" href="#a116eb8f6bf6d8b1f5aea178489d35e6f">detail::has_compatible_matcher_t</a>, MatcherClass, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value, <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5854f70c611fd1abd8caf893a0fe036a">matchOperandOrValueAtIndex</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> idx, MatcherClass &amp;matcher)</td></tr>
<tr class="memdesc:a5854f70c611fd1abd8caf893a0fe036a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically switch to an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> matcher.  <br /></td></tr>
<tr class="memitem:a7baf9bf03348723f8d037a39800d69a7" id="r_a7baf9bf03348723f8d037a39800d69a7"><td class="memTemplParams" colspan="2">template&lt;typename TupleT, class CallbackT, std::size_t... Is&gt; </td></tr>
<tr class="memitem:a7baf9bf03348723f8d037a39800d69a7 template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7baf9bf03348723f8d037a39800d69a7">enumerateImpl</a> (TupleT &amp;&amp;tuple, CallbackT &amp;&amp;callback, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memitem:a7146031ab7f6bb4cdacc53c4f1e96aac" id="r_a7146031ab7f6bb4cdacc53c4f1e96aac"><td class="memTemplParams" colspan="2">template&lt;typename... Tys, typename CallbackT&gt; </td></tr>
<tr class="memitem:a7146031ab7f6bb4cdacc53c4f1e96aac template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7146031ab7f6bb4cdacc53c4f1e96aac">enumerate</a> (std::tuple&lt; Tys... &gt; &amp;tuple, CallbackT &amp;&amp;callback)</td></tr>
<tr class="memitem:ac9dddc7a1f6dc8aa95eaa5b7910c76d5" id="r_ac9dddc7a1f6dc8aa95eaa5b7910c76d5"><td class="memItemLeft" align="right" valign="top">llvm::unique_function&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9dddc7a1f6dc8aa95eaa5b7910c76d5">getDefaultDiagnosticEmitFn</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:ac9dddc7a1f6dc8aa95eaa5b7910c76d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to generate a callback that can be used to generate a diagnostic when checking the construction invariants of a storage object.  <br /></td></tr>
<tr class="memitem:a3379fc459c08af37eb4a514b0eadef2d" id="r_a3379fc459c08af37eb4a514b0eadef2d"><td class="memItemLeft" align="right" valign="top">llvm::unique_function&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3379fc459c08af37eb4a514b0eadef2d">getDefaultDiagnosticEmitFn</a> (const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;loc)</td></tr>
<tr class="memitem:aea9f7283021fca39df8cf99bbd90cf4a" id="r_aea9f7283021fca39df8cf99bbd90cf4a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea9f7283021fca39df8cf99bbd90cf4a">verifySymbolTable</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:ae8e42f84b57ed10b489c12a7236bb356" id="r_ae8e42f84b57ed10b489c12a7236bb356"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8e42f84b57ed10b489c12a7236bb356">verifySymbol</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a6f65c29b00af55fbdff5cf2a1bfbbe17" id="r_a6f65c29b00af55fbdff5cf2a1bfbbe17"><td class="memTemplParams" colspan="2">template&lt;typename Ret, typename Arg, typename... Rest&gt; </td></tr>
<tr class="memitem:a6f65c29b00af55fbdff5cf2a1bfbbe17 template"><td class="memItemLeft" align="right" valign="top">Arg&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f65c29b00af55fbdff5cf2a1bfbbe17">first_argument_type</a> (Ret(*)(Arg, Rest...))</td></tr>
<tr class="memdesc:a6f65c29b00af55fbdff5cf2a1bfbbe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper templates to deduce the first argument of a callback parameter.  <br /></td></tr>
<tr class="memitem:ae4b5b18be8ea226e9d3606f21c1a7a7e" id="r_ae4b5b18be8ea226e9d3606f21c1a7a7e"><td class="memTemplParams" colspan="2">template&lt;typename Ret, typename F, typename Arg, typename... Rest&gt; </td></tr>
<tr class="memitem:ae4b5b18be8ea226e9d3606f21c1a7a7e template"><td class="memItemLeft" align="right" valign="top">Arg&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4b5b18be8ea226e9d3606f21c1a7a7e">first_argument_type</a> (Ret(F::*)(Arg, Rest...))</td></tr>
<tr class="memitem:a8e7cbf6a1d5e4d34d6b847b7bceeb9c0" id="r_a8e7cbf6a1d5e4d34d6b847b7bceeb9c0"><td class="memTemplParams" colspan="2">template&lt;typename F&gt; </td></tr>
<tr class="memitem:a8e7cbf6a1d5e4d34d6b847b7bceeb9c0 template"><td class="memItemLeft" align="right" valign="top">decltype(first_argument_type(&amp;F::operator()))&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e7cbf6a1d5e4d34d6b847b7bceeb9c0">first_argument_type</a> (F)</td></tr>
<tr class="memitem:a152b851682ac1cad31c84dc1a6fc38cb" id="r_a152b851682ac1cad31c84dc1a6fc38cb"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a152b851682ac1cad31c84dc1a6fc38cb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a152b851682ac1cad31c84dc1a6fc38cb">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="memdesc:a152b851682ac1cad31c84dc1a6fc38cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the regions, blocks, or operations nested under (and including) the given operation.  <br /></td></tr>
<tr class="memitem:a5b337bcade50e3cd7191efec879db837" id="r_a5b337bcade50e3cd7191efec879db837"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a5b337bcade50e3cd7191efec879db837 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b337bcade50e3cd7191efec879db837">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Block.html">Block</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="memitem:a3adcd8424919a733a4cce559560e5dd9" id="r_a3adcd8424919a733a4cce559560e5dd9"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a3adcd8424919a733a4cce559560e5dd9 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3adcd8424919a733a4cce559560e5dd9">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="memitem:a08eda9acbea0f5326d02db4b99814395" id="r_a08eda9acbea0f5326d02db4b99814395"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:a08eda9acbea0f5326d02db4b99814395 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08eda9acbea0f5326d02db4b99814395">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="memdesc:a08eda9acbea0f5326d02db4b99814395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the regions, blocks, or operations nested under (and including) the given operation.  <br /></td></tr>
<tr class="memitem:ac791c882fa374a53b6a7ec0387586f59" id="r_ac791c882fa374a53b6a7ec0387586f59"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:ac791c882fa374a53b6a7ec0387586f59 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac791c882fa374a53b6a7ec0387586f59">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Block.html">Block</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="memitem:ab4e61da15ae81a346c6b060103d0ed54" id="r_ab4e61da15ae81a346c6b060103d0ed54"><td class="memTemplParams" colspan="2">template&lt;typename Iterator&gt; </td></tr>
<tr class="memitem:ab4e61da15ae81a346c6b060103d0ed54 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4e61da15ae81a346c6b060103d0ed54">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; callback, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> order)</td></tr>
<tr class="memitem:ae7fb4b0d0a078cc3764b8e4a78205aba" id="r_ae7fb4b0d0a078cc3764b8e4a78205aba"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> Order = WalkOrder::PostOrder, typename Iterator = ForwardIterator, typename FuncTy, typename ArgT = detail::first_argument&lt;FuncTy&gt;, typename RetT = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </td></tr>
<tr class="memitem:ae7fb4b0d0a078cc3764b8e4a78205aba template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::is_one_of&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;::value, RetT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7fb4b0d0a078cc3764b8e4a78205aba">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:ae7fb4b0d0a078cc3764b8e4a78205aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the regions, blocks, or operations nested under (and including) the given operation.  <br /></td></tr>
<tr class="memitem:a0bcb55459dcace8bc159f9cf642ec047" id="r_a0bcb55459dcace8bc159f9cf642ec047"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> Order = WalkOrder::PostOrder, typename Iterator = ForwardIterator, typename FuncTy, typename ArgT = detail::first_argument&lt;FuncTy&gt;, typename RetT = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </td></tr>
<tr class="memitem:a0bcb55459dcace8bc159f9cf642ec047 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; !llvm::is_one_of&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;::value &amp;&amp;std::is_same&lt; RetT, <a class="el" href="classvoid.html">void</a> &gt;::value, RetT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bcb55459dcace8bc159f9cf642ec047">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:a0bcb55459dcace8bc159f9cf642ec047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations of type 'ArgT' nested under and including the given operation.  <br /></td></tr>
<tr class="memitem:a5f537fb0b2bd29ab4cf6e27ef6c7137a" id="r_a5f537fb0b2bd29ab4cf6e27ef6c7137a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> Order = WalkOrder::PostOrder, typename Iterator = ForwardIterator, typename FuncTy, typename ArgT = detail::first_argument&lt;FuncTy&gt;, typename RetT = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </td></tr>
<tr class="memitem:a5f537fb0b2bd29ab4cf6e27ef6c7137a template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; !llvm::is_one_of&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;::value &amp;&amp;std::is_same&lt; RetT, <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> &gt;::value, RetT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f537fb0b2bd29ab4cf6e27ef6c7137a">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:a5f537fb0b2bd29ab4cf6e27ef6c7137a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations of type 'ArgT' nested under and including the given operation.  <br /></td></tr>
<tr class="memitem:a7626abe27e64a0a166feedf7e829c968" id="r_a7626abe27e64a0a166feedf7e829c968"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7626abe27e64a0a166feedf7e829c968">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a> &amp;stage)&gt; callback)</td></tr>
<tr class="memdesc:a7626abe27e64a0a166feedf7e829c968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic walkers with stage aware callbacks.  <br /></td></tr>
<tr class="memitem:aa2adf6127282c5d8cd497d1eff1013c1" id="r_aa2adf6127282c5d8cd497d1eff1013c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2adf6127282c5d8cd497d1eff1013c1">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a> &amp;stage)&gt; callback)</td></tr>
<tr class="memdesc:aa2adf6127282c5d8cd497d1eff1013c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all the operations nested under (and including) the given operation, with the callback being invoked on each operation N+1 times, where N is the number of regions attached to the operation.  <br /></td></tr>
<tr class="memitem:af31a4cf656e761cf8a04760f12de30f8" id="r_af31a4cf656e761cf8a04760f12de30f8"><td class="memTemplParams" colspan="2">template&lt;typename FuncTy, typename ArgT = detail::first_argument&lt;FuncTy&gt;, typename RetT = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </td></tr>
<tr class="memitem:af31a4cf656e761cf8a04760f12de30f8 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value, RetT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af31a4cf656e761cf8a04760f12de30f8">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:af31a4cf656e761cf8a04760f12de30f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations nested under and including the given operation.  <br /></td></tr>
<tr class="memitem:a3285200671885c53b9a0897a36a36e89" id="r_a3285200671885c53b9a0897a36a36e89"><td class="memTemplParams" colspan="2">template&lt;typename FuncTy, typename ArgT = detail::first_argument&lt;FuncTy&gt;, typename RetT = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </td></tr>
<tr class="memitem:a3285200671885c53b9a0897a36a36e89 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_same&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value &amp;&amp;std::is_same&lt; RetT, <a class="el" href="classvoid.html">void</a> &gt;::value, RetT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3285200671885c53b9a0897a36a36e89">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:a3285200671885c53b9a0897a36a36e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations of type 'ArgT' nested under and including the given operation.  <br /></td></tr>
<tr class="memitem:a5b2fed9675957963fd823d25c6a77ee0" id="r_a5b2fed9675957963fd823d25c6a77ee0"><td class="memTemplParams" colspan="2">template&lt;typename FuncTy, typename ArgT = detail::first_argument&lt;FuncTy&gt;, typename RetT = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </td></tr>
<tr class="memitem:a5b2fed9675957963fd823d25c6a77ee0 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_same&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value &amp;&amp;std::is_same&lt; RetT, <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> &gt;::value, RetT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b2fed9675957963fd823d25c6a77ee0">walk</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, FuncTy &amp;&amp;callback)</td></tr>
<tr class="memdesc:a5b2fed9675957963fd823d25c6a77ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the operations of type 'ArgT' nested under and including the given operation.  <br /></td></tr>
<tr class="memitem:adec284b0d601db56a7d987e555aae150" id="r_adec284b0d601db56a7d987e555aae150"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT&gt; </td></tr>
<tr class="memitem:adec284b0d601db56a7d987e555aae150 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adec284b0d601db56a7d987e555aae150">constructContainerOpForParserIfNecessary</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *parsedBlock, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1Location.html">Location</a> sourceFileLoc)</td></tr>
<tr class="memdesc:adec284b0d601db56a7d987e555aae150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a block containing operations that have just been parsed, if the block contains a single operation of <span class="tt">ContainerOpT</span> type then remove it from the block and return it.  <br /></td></tr>
<tr class="memitem:a6dda0e928632de69c9afa0f01948f418" id="r_a6dda0e928632de69c9afa0f01948f418"><td class="memTemplParams" colspan="2">template&lt;typename ContainerOpT, typename... ParserArgs&gt; </td></tr>
<tr class="memitem:a6dda0e928632de69c9afa0f01948f418 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dda0e928632de69c9afa0f01948f418">parseSourceFile</a> (const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;<a class="el" href="namespacemlir.html#a3ecea12db18ed347ea11d1d999237b24">config</a>, ParserArgs &amp;&amp;...args)</td></tr>
<tr class="memdesc:a6dda0e928632de69c9afa0f01948f418"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal implementation of the templated <span class="tt">parseSourceFile</span> methods below, that simply forwards to the non-templated version.  <br /></td></tr>
<tr class="memitem:a493be0c467bac528a100115486f3ec69" id="r_a493be0c467bac528a100115486f3ec69"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteType, typename ValueT, typename Traits, typename BaseType, template&lt; typename, template&lt; typename &gt; class &gt; class BaseTrait&gt; </td></tr>
<tr class="memitem:a493be0c467bac528a100115486f3ec69 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a493be0c467bac528a100115486f3ec69">isInterfaceImpl</a> (<a class="el" href="classmlir_1_1detail_1_1Interface.html">Interface</a>&lt; ConcreteType, ValueT, Traits, BaseType, <a class="el" href="classBaseTrait.html">BaseTrait</a> &gt; &amp;)</td></tr>
<tr class="memitem:a696722e8ee5d8e85989184cb97756aaf" id="r_a696722e8ee5d8e85989184cb97756aaf"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a696722e8ee5d8e85989184cb97756aaf template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a696722e8ee5d8e85989184cb97756aaf">is_fully_resolved</a> ()</td></tr>
<tr class="memitem:a139c1fb115a13686889ea9fc57208a59" id="r_a139c1fb115a13686889ea9fc57208a59"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="structmlir_1_1Range.html">Range</a>&gt; </td></tr>
<tr class="memitem:a139c1fb115a13686889ea9fc57208a59 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a139c1fb115a13686889ea9fc57208a59">printDimensionList</a> (<a class="el" href="classmlir_1_1raw__ostream.html">raw_ostream</a> &amp;stream, <a class="el" href="structmlir_1_1Range.html">Range</a> &amp;&amp;shape)</td></tr>
<tr class="memitem:a930d7a8089745af25248145b612493b4" id="r_a930d7a8089745af25248145b612493b4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a930d7a8089745af25248145b612493b4">getDenseElementBitWidth</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> eltType)</td></tr>
<tr class="memdesc:a930d7a8089745af25248145b612493b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bit width which <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> should use for this type.  <br /></td></tr>
<tr class="memitem:aae4714fdeb9f7fa11cf2bd472a5ab6d3" id="r_aae4714fdeb9f7fa11cf2bd472a5ab6d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae4714fdeb9f7fa11cf2bd472a5ab6d3">isSupportedMemorySpace</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace)</td></tr>
<tr class="memdesc:aae4714fdeb9f7fa11cf2bd472a5ab6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the memorySpace has supported <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> type.  <br /></td></tr>
<tr class="memitem:a37f32721e9d15092545cf9ea586d6d7e" id="r_a37f32721e9d15092545cf9ea586d6d7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37f32721e9d15092545cf9ea586d6d7e">wrapIntegerMemorySpace</a> (<a class="el" href="classunsigned.html">unsigned</a> memorySpace, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:a37f32721e9d15092545cf9ea586d6d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps deprecated integer memory space to the new <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> form.  <br /></td></tr>
<tr class="memitem:ab38aedb222d8f61891a51c10805e286c" id="r_ab38aedb222d8f61891a51c10805e286c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab38aedb222d8f61891a51c10805e286c">skipDefaultMemorySpace</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace)</td></tr>
<tr class="memdesc:ab38aedb222d8f61891a51c10805e286c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces default memorySpace (integer == <span class="tt">0</span>) with empty <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <br /></td></tr>
<tr class="memitem:a3ec833993e8780c005c1c18d054273b4" id="r_a3ec833993e8780c005c1c18d054273b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ec833993e8780c005c1c18d054273b4">getMemorySpaceAsInt</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace)</td></tr>
<tr class="memdesc:a3ec833993e8780c005c1c18d054273b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">[deprecated] Returns the memory space in old raw integer representation.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classmlir_1_1AttrTypeReplacer.html" title="This is an attribute/type replacer that is naively cached.">AttrTypeReplacer</a>. </p>
<p>Detect if any of the given parameter types has a sub-element handler. </p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a5f8c42f8d912c7222328140748adcf48" name="a5f8c42f8d912c7222328140748adcf48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8c42f8d912c7222328140748adcf48">&#9670;&#160;</a></span>count_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Pred, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5f8c42f8d912c7222328140748adcf48">mlir::detail::count_if_t</a> = <a class="el" href="structmlir_1_1detail_1_1count__if__t__impl.html">count_if_t_impl</a>&lt;Pred, 0, Ts...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InterfaceSupport_8h_source.html#l00153">153</a> of file <a class="el" href="InterfaceSupport_8h_source.html">InterfaceSupport.h</a>.</p>

</div>
</div>
<a id="a62f1cd89e40ee6862af85b5d7a1257bc" name="a62f1cd89e40ee6862af85b5d7a1257bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f1cd89e40ee6862af85b5d7a1257bc">&#9670;&#160;</a></span>DenseIterPtrAndSplat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a62f1cd89e40ee6862af85b5d7a1257bc">mlir::detail::DenseIterPtrAndSplat</a> = std::pair&lt;const char *, <a class="el" href="classbool.html">bool</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pair of raw pointer and a boolean flag of whether the pointer holds a splat,. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00046">46</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a1835ccfb3b99b36cc72132d2b3b4e3f4" name="a1835ccfb3b99b36cc72132d2b3b4e3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1835ccfb3b99b36cc72132d2b3b4e3f4">&#9670;&#160;</a></span>first_argument</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1835ccfb3b99b36cc72132d2b3b4e3f4">mlir::detail::first_argument</a> = decltype(<a class="el" href="#a6f65c29b00af55fbdff5cf2a1bfbbe17">first_argument_type</a>(std::declval&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> definition of the first argument to the given callable 'T'. </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00090">90</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a id="a116eb8f6bf6d8b1f5aea178489d35e6f" name="a116eb8f6bf6d8b1f5aea178489d35e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116eb8f6bf6d8b1f5aea178489d35e6f">&#9670;&#160;</a></span>has_compatible_matcher_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename MatchTarget&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a116eb8f6bf6d8b1f5aea178489d35e6f">mlir::detail::has_compatible_matcher_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <span class="keyword">decltype</span>(std::declval&lt;T&gt;().match(std::declval&lt;MatchTarget&gt;()))</div>
</div><!-- fragment -->
<p>Trait to check whether T provides a 'match' method with type <span class="tt">MatchTarget</span> (<a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>, <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>, or <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>). </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00290">290</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="ad7ac71b8ff8edaf597280cb4777d109c" name="ad7ac71b8ff8edaf597280cb4777d109c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ac71b8ff8edaf597280cb4777d109c">&#9670;&#160;</a></span>has_default_sub_element_handler_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad7ac71b8ff8edaf597280cb4777d109c">mlir::detail::has_default_sub_element_handler_t</a> = decltype(T::DefaultHandlerTag)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00414">414</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

</div>
</div>
<a id="a4ff923a0f002b0fe1658b5b423390158" name="a4ff923a0f002b0fe1658b5b423390158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff923a0f002b0fe1658b5b423390158">&#9670;&#160;</a></span>has_get_as_key</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4ff923a0f002b0fe1658b5b423390158">mlir::detail::has_get_as_key</a> = decltype(std::declval&lt;T&gt;().getAsKey())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00512">512</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

</div>
</div>
<a id="a52f40d76f108bee8a165fccb14a8e4fc" name="a52f40d76f108bee8a165fccb14a8e4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f40d76f108bee8a165fccb14a8e4fc">&#9670;&#160;</a></span>has_get_method</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a52f40d76f108bee8a165fccb14a8e4fc">mlir::detail::has_get_method</a> = decltype(T::get(std::declval&lt;Ts&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00510">510</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

</div>
</div>
<a id="a382136bcf1f5918063ae380d964d3ca5" name="a382136bcf1f5918063ae380d964d3ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382136bcf1f5918063ae380d964d3ca5">&#9670;&#160;</a></span>has_impltype_getkey_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ImplTy, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a382136bcf1f5918063ae380d964d3ca5">mlir::detail::has_impltype_getkey_t</a> = decltype(ImplTy::getKey(std::declval&lt;Args&gt;()...))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait to check if ImplTy provides a 'getKey' method with types 'Args'. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00026">26</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="a8b735a3eb149ca609203004fcd188cd1" name="a8b735a3eb149ca609203004fcd188cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b735a3eb149ca609203004fcd188cd1">&#9670;&#160;</a></span>has_impltype_hash_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ImplTy, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8b735a3eb149ca609203004fcd188cd1">mlir::detail::has_impltype_hash_t</a> = decltype(ImplTy::hashKey(std::declval&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait to check if ImplTy provides a 'hashKey' method for 'T'. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00030">30</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="a0aacd4fdb1cb9c49acee59175eb094ce" name="a0aacd4fdb1cb9c49acee59175eb094ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aacd4fdb1cb9c49acee59175eb094ce">&#9670;&#160;</a></span>has_push_back_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0aacd4fdb1cb9c49acee59175eb094ce">mlir::detail::has_push_back_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <span class="keyword">decltype</span>(std::declval&lt;T&gt;().push_back(</div>
<div class="line">    std::declval&lt;typename T::value_type &amp;&amp;&gt;()))</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="DialectImplementation_8h_source.html#l00168">168</a> of file <a class="el" href="DialectImplementation_8h_source.html">DialectImplementation.h</a>.</p>

</div>
</div>
<a id="a198c9063c94c028d50df8656604ba471" name="a198c9063c94c028d50df8656604ba471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198c9063c94c028d50df8656604ba471">&#9670;&#160;</a></span>is_interface_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a198c9063c94c028d50df8656604ba471">mlir::detail::is_interface_t</a> = decltype(<a class="el" href="#a493be0c467bac528a100115486f3ec69">isInterfaceImpl</a>(std::declval&lt;T &amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InterfaceSupport_8h_source.html#l00274">274</a> of file <a class="el" href="InterfaceSupport_8h_source.html">InterfaceSupport.h</a>.</p>

</div>
</div>
<a id="a46beaca96aec31996e37bd9a012dc794" name="a46beaca96aec31996e37bd9a012dc794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46beaca96aec31996e37bd9a012dc794">&#9670;&#160;</a></span>IsInterface</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a46beaca96aec31996e37bd9a012dc794">mlir::detail::IsInterface</a> = llvm::is_detected&lt;<a class="el" href="#a198c9063c94c028d50df8656604ba471">is_interface_t</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InterfaceSupport_8h_source.html#l00277">277</a> of file <a class="el" href="InterfaceSupport_8h_source.html">InterfaceSupport.h</a>.</p>

</div>
</div>
<a id="ae9a8ec980b37f33d00ed9120a4910932" name="ae9a8ec980b37f33d00ed9120a4910932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a8ec980b37f33d00ed9120a4910932">&#9670;&#160;</a></span>walkResultType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FnT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae9a8ec980b37f33d00ed9120a4910932">mlir::detail::walkResultType</a> = decltype(<a class="el" href="#a152b851682ac1cad31c84dc1a6fc38cb">walk</a>(<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, std::declval&lt;FnT&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to provide the return type of a templated walk method. </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00431">431</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a78296380781bb5c3af2dd2ad9b70c26f" name="a78296380781bb5c3af2dd2ad9b70c26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78296380781bb5c3af2dd2ad9b70c26f">&#9670;&#160;</a></span>OpProperties</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a78296380781bb5c3af2dd2ad9b70c26f">mlir::detail::OpProperties</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a "tag" used for mapping the properties storage in llvm::TrailingObjects. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8h_source.html#l00028">28</a> of file <a class="el" href="IR_2Operation_8h_source.html">Operation.h</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a70490ffb8ad6edf1d2625dcf89d4b61b" name="a70490ffb8ad6edf1d2625dcf89d4b61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70490ffb8ad6edf1d2625dcf89d4b61b">&#9670;&#160;</a></span>allocAligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; T *, T * &gt; mlir::detail::allocAligned </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nElements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a044e19a45e06290430f27c9c818bf71a">AllocFunType</a></td>          <td class="paramname"><span class="paramname"><em>allocFun</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&amp;::malloc</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; uint64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::optional&lt;uint64_t&gt;()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Align <span class="tt">nElements</span> of type T with an optional <span class="tt">alignment</span>. </p>
<p>This replaces a portable <span class="tt">posix_memalign</span>. <span class="tt">alignment</span> must be a power of 2 and greater than the size of T. By default the alignment is sizeof(T). </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00104">104</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00049">nextPowerOf2()</a>, and <a class="el" href="XeGPUDialect_8cpp_source.html#l00968">rem</a>.</p>

</div>
</div>
<a id="ad693ba34552063984c6685f93500c79f" name="ad693ba34552063984c6685f93500c79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad693ba34552063984c6685f93500c79f">&#9670;&#160;</a></span>bindDims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::bindDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00289">289</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, and <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00292">bindDims()</a>.</p>

</div>
</div>
<a id="adc67b3a3dac2996cc431f90b8658f6e6" name="adc67b3a3dac2996cc431f90b8658f6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc67b3a3dac2996cc431f90b8658f6e6">&#9670;&#160;</a></span>bindDims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename AffineExprTy, typename... AffineExprTy2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::bindDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy2 &amp;...</td>          <td class="paramname"><span class="paramname"><em>exprs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00292">292</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00289">bindDims()</a>, and <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>.</p>

</div>
</div>
<a id="addb63088be1c8bff57b28cc3be96701b" name="addb63088be1c8bff57b28cc3be96701b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb63088be1c8bff57b28cc3be96701b">&#9670;&#160;</a></span>bindSymbols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::bindSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00298">298</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, and <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00301">bindSymbols()</a>.</p>

</div>
</div>
<a id="a2b0f1dec3bae54bd6eecd9e5abb59e4c" name="a2b0f1dec3bae54bd6eecd9e5abb59e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0f1dec3bae54bd6eecd9e5abb59e4c">&#9670;&#160;</a></span>bindSymbols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename AffineExprTy, typename... AffineExprTy2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::bindSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy2 &amp;...</td>          <td class="paramname"><span class="paramname"><em>exprs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00301">301</a> of file <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00298">bindSymbols()</a>, and <a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">mlir::getAffineSymbolExpr()</a>.</p>

</div>
</div>
<a id="a7bb7be75817707a561386449c561cc31" name="a7bb7be75817707a561386449c561cc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb7be75817707a561386449c561cc31">&#9670;&#160;</a></span>bubbleDownInPlaceMemorySpaceCastImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; &gt; mlir::detail::bubbleDownInPlaceMemorySpaceCastImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>operand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>results</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to bubble-down inplace a <span class="tt">MemorySpaceCastOpInterface</span> operation referenced by <span class="tt">operand</span>. </p>
<p>On success, it returns <span class="tt">std::nullopt</span>. It returns failure if <span class="tt">operand</span> doesn't reference a <span class="tt">MemorySpaceCastOpInterface</span> op. </p>

<p class="definition">Definition at line <a class="el" href="MemOpInterfaces_8cpp_source.html#l00059">59</a> of file <a class="el" href="MemOpInterfaces_8cpp_source.html">MemOpInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, and <a class="el" href="UseDefLists_8h_source.html#l00163">mlir::IROperand&lt; DerivedT, IRValueT &gt;::set()</a>.</p>

</div>
</div>
<a id="adec284b0d601db56a7d987e555aae150" name="adec284b0d601db56a7d987e555aae150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec284b0d601db56a7d987e555aae150">&#9670;&#160;</a></span>constructContainerOpForParserIfNecessary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt; mlir::detail::constructContainerOpForParserIfNecessary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>parsedBlock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>sourceFileLoc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a block containing operations that have just been parsed, if the block contains a single operation of <span class="tt">ContainerOpT</span> type then remove it from the block and return it. </p>
<p>If the block does not contain just that operation, create a new operation instance of <span class="tt">ContainerOpT</span> and move all of the operations within <span class="tt">parsedBlock</span> into the first block of the first region. <span class="tt">ContainerOpT</span> is required to have a single region containing a single block, and must implement the <span class="tt">SingleBlockImplicitTerminator</span> trait. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00038">38</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00143">mlir::Block::begin()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">mlir::emitError()</a>, <a class="el" href="Block_8h_source.html#l00153">mlir::Block::front()</a>, and <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00154">parseSourceFile()</a>, and <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00244">mlir::parseSourceString()</a>.</p>

</div>
</div>
<a id="a451d8dc61974032518997d3f9935e53a" name="a451d8dc61974032518997d3f9935e53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451d8dc61974032518997d3f9935e53a">&#9670;&#160;</a></span>constructSubElementReplacement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::detail::constructSubElementReplacement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function invokes the proper <span class="tt">get</span> method for a type <span class="tt">T</span> with the given values. </p>

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00539">539</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttrTypeSubElements_8h_source.html#l00557">replaceImmediateSubElementsImpl()</a>.</p>

</div>
</div>
<a id="af748f20e1dc2fc58d26e3d2257926385" name="af748f20e1dc2fc58d26e3d2257926385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af748f20e1dc2fc58d26e3d2257926385">&#9670;&#160;</a></span>defaultGetDestinationOperand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp; mlir::detail::defaultGetDestinationOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the destination/"init" operand of the op if it implements the <span class="tt">DestinationStyleOpInterface</span> and has exactly one "init" operand. </p>
<p>Asserts otherwise. </p>

<p class="definition">Definition at line <a class="el" href="SubsetOpInterface_8cpp_source.html#l00017">17</a> of file <a class="el" href="SubsetOpInterface_8cpp_source.html">SubsetOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="SubsetOpInterface_8cpp_source.html#l00017">defaultGetDestinationOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SubsetOpInterface_8cpp_source.html#l00017">defaultGetDestinationOperand()</a>.</p>

</div>
</div>
<a id="aac272571a0b927a2a4fa1debf78948bb" name="aac272571a0b927a2a4fa1debf78948bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac272571a0b927a2a4fa1debf78948bb">&#9670;&#160;</a></span>defaultGetUpdatedDestination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a> mlir::detail::defaultGetUpdatedDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the updated destination result of the op if it implements the <span class="tt">DestinationStyleOpInterface</span>. </p>

<p class="definition">Definition at line <a class="el" href="SubsetOpInterface_8cpp_source.html#l00026">26</a> of file <a class="el" href="SubsetOpInterface_8cpp_source.html">SubsetOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="SubsetOpInterface_8cpp_source.html#l00026">defaultGetUpdatedDestination()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SubsetOpInterface_8cpp_source.html#l00026">defaultGetUpdatedDestination()</a>.</p>

</div>
</div>
<a id="adfec552c5927149bad3102177f1f161a" name="adfec552c5927149bad3102177f1f161a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfec552c5927149bad3102177f1f161a">&#9670;&#160;</a></span>defaultIsEquivalentSubset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::detail::defaultIsEquivalentSubset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>candidate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>equivalenceFn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of <span class="tt">SubsetInsertionOpInterface::isEquivalentSubset</span>. </p>

<p class="definition">Definition at line <a class="el" href="SubsetOpInterface_8cpp_source.html#l00033">33</a> of file <a class="el" href="SubsetOpInterface_8cpp_source.html">SubsetOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="SubsetOpInterface_8cpp_source.html#l00033">defaultIsEquivalentSubset()</a>, and <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SubsetOpInterface_8cpp_source.html#l00033">defaultIsEquivalentSubset()</a>.</p>

</div>
</div>
<a id="a20f1363f8cb9bc8b135a3212569aaf37" name="a20f1363f8cb9bc8b135a3212569aaf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f1363f8cb9bc8b135a3212569aaf37">&#9670;&#160;</a></span>defaultOperatesOnDisjointSubset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::detail::defaultOperatesOnDisjointSubset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubsetOpInterface</td>          <td class="paramname"><span class="paramname"><em>candidate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>equivalenceFn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of <span class="tt">SubsetOpInterface::operatesOnDisjointSubset</span>. </p>

<p class="definition">Definition at line <a class="el" href="SubsetOpInterface_8cpp_source.html#l00065">65</a> of file <a class="el" href="SubsetOpInterface_8cpp_source.html">SubsetOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00826">mlir::ValueBoundsConstraintSet::areOverlappingSlices()</a>, <a class="el" href="SubsetOpInterface_8cpp_source.html#l00065">defaultOperatesOnDisjointSubset()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SubsetOpInterface_8cpp_source.html#l00065">defaultOperatesOnDisjointSubset()</a>.</p>

</div>
</div>
<a id="a3e8b66ba9169bfa2c09c598ccca039db" name="a3e8b66ba9169bfa2c09c598ccca039db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8b66ba9169bfa2c09c598ccca039db">&#9670;&#160;</a></span>defaultOperatesOnEquivalentSubset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::detail::defaultOperatesOnEquivalentSubset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubsetOpInterface</td>          <td class="paramname"><span class="paramname"><em>candidate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>equivalenceFn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of <span class="tt">SubsetOpInterface::operatesOnEquivalentSubset</span>. </p>

<p class="definition">Definition at line <a class="el" href="SubsetOpInterface_8cpp_source.html#l00044">44</a> of file <a class="el" href="SubsetOpInterface_8cpp_source.html">SubsetOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00890">mlir::ValueBoundsConstraintSet::areEquivalentSlices()</a>, <a class="el" href="SubsetOpInterface_8cpp_source.html#l00044">defaultOperatesOnEquivalentSubset()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SubsetOpInterface_8cpp_source.html#l00044">defaultOperatesOnEquivalentSubset()</a>.</p>

</div>
</div>
<a id="a98a07efa628a8720c45b577162e4fe66" name="a98a07efa628a8720c45b577162e4fe66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a07efa628a8720c45b577162e4fe66">&#9670;&#160;</a></span>divideCeil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::TypeSize mlir::detail::divideCeil </td>
          <td>(</td>
          <td class="paramtype">llvm::TypeSize</td>          <td class="paramname"><span class="paramname"><em>numerator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>denominator</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides the known min value of the numerator by the denominator and rounds the result up to the next integer. </p>
<p>Preserves the scalable flag. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00465">465</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00045">getDefaultTypeSize()</a>.</p>

</div>
</div>
<a id="a7146031ab7f6bb4cdacc53c4f1e96aac" name="a7146031ab7f6bb4cdacc53c4f1e96aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7146031ab7f6bb4cdacc53c4f1e96aac">&#9670;&#160;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Tys, typename CallbackT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::enumerate </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Tys... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tuple</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00344">344</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00336">enumerateImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Matchers_8h_source.html#l00354">mlir::detail::RecursivePatternMatcher&lt; OpType, OperandMatchers &gt;::match()</a>.</p>

</div>
</div>
<a id="a7baf9bf03348723f8d037a39800d69a7" name="a7baf9bf03348723f8d037a39800d69a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7baf9bf03348723f8d037a39800d69a7">&#9670;&#160;</a></span>enumerateImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleT, class CallbackT, std::size_t... Is&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::enumerateImpl </td>
          <td>(</td>
          <td class="paramtype">TupleT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>tuple</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00336">336</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Matchers_8h_source.html#l00344">enumerate()</a>.</p>

</div>
</div>
<a id="a31d3a751d105f957d43b5ee8ad6ab047" name="a31d3a751d105f957d43b5ee8ad6ab047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d3a751d105f957d43b5ee8ad6ab047">&#9670;&#160;</a></span>filterEntriesForType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a17d2b8b3bf4e818da2900efa145bd05b">DataLayoutEntryList</a> mlir::detail::filterEntriesForType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aca03ba5e554abcffe4c1d89c53424982">DataLayoutEntryListRef</a></td>          <td class="paramname"><span class="paramname"><em>entries</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a></td>          <td class="paramname"><span class="paramname"><em>typeID</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of data layout entries, returns a new list containing the entries with keys having the given type ID, i.e. </p>
<p>belonging to the same type class. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00343">343</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

</div>
</div>
<a id="af7ddc54fc9b6e82cf3b6a797a6bfefca" name="af7ddc54fc9b6e82cf3b6a797a6bfefca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ddc54fc9b6e82cf3b6a797a6bfefca">&#9670;&#160;</a></span>filterEntryForIdentifier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataLayoutEntryInterface mlir::detail::filterEntryForIdentifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aca03ba5e554abcffe4c1d89c53424982">DataLayoutEntryListRef</a></td>          <td class="paramname"><span class="paramname"><em>entries</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr</td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of data layout entries, returns the entry that has the given identifier as key, if such an entry exists in the list. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00353">353</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a6142ce3e04093b8805b807bbade3ec01" name="a6142ce3e04093b8805b807bbade3ec01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6142ce3e04093b8805b807bbade3ec01">&#9670;&#160;</a></span>filterEntryForIdentifier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TargetDeviceSpecInterface mlir::detail::filterEntryForIdentifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a4bd203358eecf2493ba5344cd392aa65">TargetDeviceSpecListRef</a></td>          <td class="paramname"><span class="paramname"><em>entries</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr</td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of target device entries, returns the entry that has the given identifier as key, if such an entry exists in the list. </p>

</div>
</div>
<a id="a8e7cbf6a1d5e4d34d6b847b7bceeb9c0" name="a8e7cbf6a1d5e4d34d6b847b7bceeb9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7cbf6a1d5e4d34d6b847b7bceeb9c0">&#9670;&#160;</a></span>first_argument_type() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(first_argument_type(&amp;F::operator())) mlir::detail::first_argument_type </td>
          <td>(</td>
          <td class="paramtype">F</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f65c29b00af55fbdff5cf2a1bfbbe17" name="a6f65c29b00af55fbdff5cf2a1bfbbe17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f65c29b00af55fbdff5cf2a1bfbbe17">&#9670;&#160;</a></span>first_argument_type() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret, typename Arg, typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Arg mlir::detail::first_argument_type </td>
          <td>(</td>
          <td class="paramtype">Ret(*</td>          <td class="paramname"><span class="paramname"><em>&#160;</em></span>)(Arg, Rest...)</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper templates to deduce the first argument of a callback parameter. </p>

</div>
</div>
<a id="ae4b5b18be8ea226e9d3606f21c1a7a7e" name="ae4b5b18be8ea226e9d3606f21c1a7a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b5b18be8ea226e9d3606f21c1a7a7e">&#9670;&#160;</a></span>first_argument_type() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret, typename F, typename Arg, typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Arg mlir::detail::first_argument_type </td>
          <td>(</td>
          <td class="paramtype">Ret(F::*</td>          <td class="paramname"><span class="paramname"><em>&#160;</em></span>)(Arg, Rest...)</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a767e521ae7755c29bc29daaeb840c238" name="a767e521ae7755c29bc29daaeb840c238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767e521ae7755c29bc29daaeb840c238">&#9670;&#160;</a></span>getAffineMapStridesAndOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::getAffineMapStridesAndOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00202">202</a> of file <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html">BuiltinAttributeInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00161">getStridesAndOffset()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a083757618e89b0f53d587541eccf53e0" name="a083757618e89b0f53d587541eccf53e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083757618e89b0f53d587541eccf53e0">&#9670;&#160;</a></span>getBranchSuccessorArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt; mlir::detail::getBranchSuccessorArgument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>operandIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>successor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <span class="tt"><a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a></span> corresponding to operand <span class="tt">operandIndex</span> in some successor if <span class="tt">operandIndex</span> is within the range of <span class="tt">operands</span>, or std::nullopt if <span class="tt">operandIndex</span> isn't a successor operand index. </p>
<p>Returns the <span class="tt"><a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a></span> corresponding to operand <span class="tt">operandIndex</span> in some successor if 'operandIndex' is within the range of 'operands', or std::nullopt if <span class="tt">operandIndex</span> isn't a successor operand index. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00041">41</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00129">mlir::Block::getArgument()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00387">mlir::OperandRange::getBeginOperandIndex()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00088">mlir::SuccessorOperands::getForwardedOperands()</a>, and <a class="el" href="ControlFlowInterfaces_8h_source.html#l00070">mlir::SuccessorOperands::getProducedOperandCount()</a>.</p>

</div>
</div>
<a id="a8409dbc763fd806cdacab4558dd9e9f6" name="a8409dbc763fd806cdacab4558dd9e9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8409dbc763fd806cdacab4558dd9e9f6">&#9670;&#160;</a></span>getDefaultABIAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::detail::getDefaultABIAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dataLayout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the required alignment request. </p>
<p>Computes results for built-in types and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00140">140</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00140">getDefaultABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00131">getFloatTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00037">getIndexBitwidth()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00116">getIntegerTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00581">mlir::DataLayout::getTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00557">mlir::DataLayout::getTypeSize()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00026">reportMissingDataLayout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00140">getDefaultABIAlignment()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00581">mlir::DataLayout::getTypeABIAlignment()</a>.</p>

</div>
</div>
<a id="a04d624115ea61e5b456d4c613a770631" name="a04d624115ea61e5b456d4c613a770631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d624115ea61e5b456d4c613a770631">&#9670;&#160;</a></span>getDefaultAllocaMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultAllocaMemorySpace </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for alloca memory space request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00263">263</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00649">mlir::DataLayout::getAllocaMemorySpace()</a>.</p>

</div>
</div>
<a id="a3379fc459c08af37eb4a514b0eadef2d" name="a3379fc459c08af37eb4a514b0eadef2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3379fc459c08af37eb4a514b0eadef2d">&#9670;&#160;</a></span>getDefaultDiagnosticEmitFn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::unique_function&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; mlir::detail::getDefaultDiagnosticEmitFn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>loc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l01275">1275</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">mlir::emitError()</a>.</p>

</div>
</div>
<a id="ac9dddc7a1f6dc8aa95eaa5b7910c76d5" name="ac9dddc7a1f6dc8aa95eaa5b7910c76d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9dddc7a1f6dc8aa95eaa5b7910c76d5">&#9670;&#160;</a></span>getDefaultDiagnosticEmitFn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::unique_function&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; mlir::detail::getDefaultDiagnosticEmitFn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to generate a callback that can be used to generate a diagnostic when checking the construction invariants of a storage object. </p>
<p>This is defined out-of-line to avoid the need to include <a class="el" href="Location_8h.html">Location.h</a>. </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l01271">1271</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">mlir::emitError()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StorageUniquerSupport_8h_source.html#l00177">mlir::detail::StorageUserBase&lt; ConcreteType, BaseType, StorageType, detail::AttributeUniquer, Traits... &gt;::get()</a>, <a class="el" href="ExtensibleDialect_8cpp_source.html#l00126">mlir::DynamicType::get()</a>, and <a class="el" href="StorageUniquerSupport_8h_source.html#l00189">mlir::detail::StorageUserBase&lt; ConcreteType, BaseType, StorageType, detail::AttributeUniquer, Traits... &gt;::getChecked()</a>.</p>

</div>
</div>
<a id="a0fc8e12b852a89dc2d49a19dab76bbf8" name="a0fc8e12b852a89dc2d49a19dab76bbf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc8e12b852a89dc2d49a19dab76bbf8">&#9670;&#160;</a></span>getDefaultEndianness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultEndianness </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for endianness request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00242">242</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00617">mlir::DataLayout::getEndianness()</a>.</p>

</div>
</div>
<a id="af519cb1b89cef66201a509b636c0899a" name="af519cb1b89cef66201a509b636c0899a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af519cb1b89cef66201a509b636c0899a">&#9670;&#160;</a></span>getDefaultFunctionPointerAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultFunctionPointerAlignment </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the function pointer alignment request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00317">317</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00729">mlir::DataLayout::getFunctionPointerAlignment()</a>.</p>

</div>
</div>
<a id="acbccfb558aabea7d6494d225b56446e8" name="acbccfb558aabea7d6494d225b56446e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbccfb558aabea7d6494d225b56446e8">&#9670;&#160;</a></span>getDefaultGlobalMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultGlobalMemorySpace </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for global memory space request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00296">296</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00697">mlir::DataLayout::getGlobalMemorySpace()</a>.</p>

</div>
</div>
<a id="a1b3919dd661434ca92b4ebe5a20e58b1" name="a1b3919dd661434ca92b4ebe5a20e58b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3919dd661434ca92b4ebe5a20e58b1">&#9670;&#160;</a></span>getDefaultIndexBitwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; uint64_t &gt; mlir::detail::getDefaultIndexBitwidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dataLayout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the index bitwidth request. </p>
<p>Computes the result for the built-in index type and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00224">224</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00037">getIndexBitwidth()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00605">mlir::DataLayout::getTypeIndexBitwidth()</a>.</p>

</div>
</div>
<a id="a86153589d0a1d2f1d462dee9d852646c" name="a86153589d0a1d2f1d462dee9d852646c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86153589d0a1d2f1d462dee9d852646c">&#9670;&#160;</a></span>getDefaultLegalIntWidths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultLegalIntWidths </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the legal int widths request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00328">328</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00746">mlir::DataLayout::getLegalIntWidths()</a>.</p>

</div>
</div>
<a id="a6c79ef12939d977e7a4632bcc8b75a31" name="a6c79ef12939d977e7a4632bcc8b75a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c79ef12939d977e7a4632bcc8b75a31">&#9670;&#160;</a></span>getDefaultManglingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultManglingMode </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for mangling mode request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00273">273</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00665">mlir::DataLayout::getManglingMode()</a>.</p>

</div>
</div>
<a id="aeb4b21752e6c90f16e818bb89b80df5d" name="aeb4b21752e6c90f16e818bb89b80df5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4b21752e6c90f16e818bb89b80df5d">&#9670;&#160;</a></span>getDefaultMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultMemorySpace </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the default memory space request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00252">252</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00633">mlir::DataLayout::getDefaultMemorySpace()</a>.</p>

</div>
</div>
<a id="a9812a6a269eaa19d0e843b22596578d0" name="a9812a6a269eaa19d0e843b22596578d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9812a6a269eaa19d0e843b22596578d0">&#9670;&#160;</a></span>getDefaultPreferredAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::detail::getDefaultPreferredAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dataLayout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; DataLayoutEntryInterface &gt;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the preferred alignment request. </p>
<p>Computes results for built-in types and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00194">194</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00194">getDefaultPreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00185">getFloatTypePreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00037">getIndexBitwidth()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00175">getIntegerTypePreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00581">mlir::DataLayout::getTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00593">mlir::DataLayout::getTypePreferredAlignment()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00026">reportMissingDataLayout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00194">getDefaultPreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00052">getDefaultTypeSizeInBits()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00593">mlir::DataLayout::getTypePreferredAlignment()</a>.</p>

</div>
</div>
<a id="a0937e5890b25f8114fefdfe666484ac5" name="a0937e5890b25f8114fefdfe666484ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0937e5890b25f8114fefdfe666484ac5">&#9670;&#160;</a></span>getDefaultProgramMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::getDefaultProgramMemorySpace </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for program memory space request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00284">284</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00681">mlir::DataLayout::getProgramMemorySpace()</a>.</p>

</div>
</div>
<a id="a9c14c1ac1334d61bf90aa4f60a5fa261" name="a9c14c1ac1334d61bf90aa4f60a5fa261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c14c1ac1334d61bf90aa4f60a5fa261">&#9670;&#160;</a></span>getDefaultStackAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::detail::getDefaultStackAlignment </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the stack alignment request. </p>
<p>Dispatches to the DataLayoutInterface if specified, otherwise returns the default. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00307">307</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00713">mlir::DataLayout::getStackAlignment()</a>.</p>

</div>
</div>
<a id="a87ca94416539c5fc8c1b2df637f6b522" name="a87ca94416539c5fc8c1b2df637f6b522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ca94416539c5fc8c1b2df637f6b522">&#9670;&#160;</a></span>getDefaultTypeSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::TypeSize mlir::detail::getDefaultTypeSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dataLayout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aca03ba5e554abcffe4c1d89c53424982">DataLayoutEntryListRef</a></td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the type size request. </p>
<p>Computes results for built-in types and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00045">45</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00465">divideCeil()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00052">getDefaultTypeSizeInBits()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00557">mlir::DataLayout::getTypeSize()</a>.</p>

</div>
</div>
<a id="a89cf52d46088967fe0b00f1a7f704eae" name="a89cf52d46088967fe0b00f1a7f704eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cf52d46088967fe0b00f1a7f704eae">&#9670;&#160;</a></span>getDefaultTypeSizeInBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::TypeSize mlir::detail::getDefaultTypeSizeInBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dataLayout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aca03ba5e554abcffe4c1d89c53424982">DataLayoutEntryListRef</a></td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default handler for the type size in bits request. </p>
<p>Computes results for built-in types and dispatches to the DataLayoutTypeInterface for other types. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00052">52</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00194">getDefaultPreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00052">getDefaultTypeSizeInBits()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00037">getIndexBitwidth()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00122">mlir::Type::getIntOrFloatBitWidth()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00557">mlir::DataLayout::getTypeSize()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00569">mlir::DataLayout::getTypeSizeInBits()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00116">mlir::Type::isIntOrFloat()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00026">reportMissingDataLayout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00045">getDefaultTypeSize()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00052">getDefaultTypeSizeInBits()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00569">mlir::DataLayout::getTypeSizeInBits()</a>.</p>

</div>
</div>
<a id="a930d7a8089745af25248145b612493b4" name="a930d7a8089745af25248145b612493b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930d7a8089745af25248145b612493b4">&#9670;&#160;</a></span>getDenseElementBitWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t mlir::detail::getDenseElementBitWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>eltType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bit width which <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> should use for this type. </p>

<p class="definition">Definition at line <a class="el" href="AttributeDetail_8h_source.html#l00034">34</a> of file <a class="el" href="AttributeDetail_8h_source.html">AttributeDetail.h</a>.</p>

<p class="reference">References <a class="el" href="AttributeDetail_8h_source.html#l00034">getDenseElementBitWidth()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00122">mlir::Type::getIntOrFloatBitWidth()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01267">mlir::DenseElementsAttr::bitcast()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00034">getDenseElementBitWidth()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00464">getDenseElementStorageWidth()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00086">mlir::detail::DenseIntOrFPElementsAttrStorage::getKey()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01117">isValidIntOrFloat()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01463">mappingHelper()</a>.</p>

</div>
</div>
<a id="a5d552809ed611d55492c36bbb09886fe" name="a5d552809ed611d55492c36bbb09886fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d552809ed611d55492c36bbb09886fe">&#9670;&#160;</a></span>getDevicePropertyValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; mlir::detail::getDevicePropertyValue </td>
          <td>(</td>
          <td class="paramtype">DataLayoutEntryInterface</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the property from the specified DataLayoutEntry. </p>
<p>If the property is missing from the entry, returns std::nullopt. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00335">335</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00762">mlir::DataLayout::getDevicePropertyValue()</a>.</p>

</div>
</div>
<a id="a3ec833993e8780c005c1c18d054273b4" name="a3ec833993e8780c005c1c18d054273b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec833993e8780c005c1c18d054273b4">&#9670;&#160;</a></span>getMemorySpaceAsInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::detail::getMemorySpaceAsInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>memorySpace</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[deprecated] Returns the memory space in old raw integer representation. </p>
<p>New <span class="tt"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> getMemorySpace()</span> method should be used instead. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00554">554</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

</div>
</div>
<a id="a4bbbaf06f702976f635516e2eec5c165" name="a4bbbaf06f702976f635516e2eec5c165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbbaf06f702976f635516e2eec5c165">&#9670;&#160;</a></span>getNumDynamicEntriesUpToIdx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::detail::getNumDynamicEntriesUpToIdx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>staticVals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to compute the number of dynamic entries of <span class="tt">staticVals</span>, up to <span class="tt">idx</span>. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00294">294</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

</div>
</div>
<a id="a6f6bd31c91df4b26794a88c1006e83ef" name="a6f6bd31c91df4b26794a88c1006e83ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6bd31c91df4b26794a88c1006e83ef">&#9670;&#160;</a></span>getTensorContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::detail::getTensorContainer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the container that the given subset op is operating on. </p>

<p class="definition">Definition at line <a class="el" href="SubsetOpInterface_8cpp_source.html#l00086">86</a> of file <a class="el" href="SubsetOpInterface_8cpp_source.html">SubsetOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="SubsetOpInterface_8cpp_source.html#l00086">getTensorContainer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SubsetOpInterface_8cpp_source.html#l00086">getTensorContainer()</a>.</p>

</div>
</div>
<a id="a33a945b620206532de586bf2c444fa1e" name="a33a945b620206532de586bf2c444fa1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a945b620206532de586bf2c444fa1e">&#9670;&#160;</a></span>inferReturnTensorTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::inferReturnTensorTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1ShapedTypeComponents.html">ShapedTypeComponents</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>retComponents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inferredReturnTypes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00227">227</a> of file <a class="el" href="InferTypeOpInterface_8cpp_source.html">InferTypeOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a696722e8ee5d8e85989184cb97756aaf" name="a696722e8ee5d8e85989184cb97756aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696722e8ee5d8e85989184cb97756aaf">&#9670;&#160;</a></span>is_fully_resolved()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::detail::is_fully_resolved </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function for <a class="el" href="structmlir_1_1detail_1_1is__fully__resolved__t.html">is_fully_resolved_t</a>.</p>

<p class="definition">Definition at line <a class="el" href="TypeID_8h_source.html#l00186">186</a> of file <a class="el" href="TypeID_8h_source.html">TypeID.h</a>.</p>

<p class="reference">References <a class="el" href="TypeID_8h_source.html#l00182">mlir::detail::is_fully_resolved_t&lt; T &gt;::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeID_8h_source.html#l00205">mlir::detail::TypeIDResolver&lt; T, Enable &gt;::resolveTypeID()</a>.</p>

</div>
</div>
<a id="a493be0c467bac528a100115486f3ec69" name="a493be0c467bac528a100115486f3ec69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493be0c467bac528a100115486f3ec69">&#9670;&#160;</a></span>isInterfaceImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, typename ValueT, typename Traits, typename BaseType, template&lt; typename, template&lt; typename &gt; class &gt; class BaseTrait&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::isInterfaceImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1detail_1_1Interface.html">Interface</a>&lt; ConcreteType, ValueT, Traits, BaseType, <a class="el" href="classBaseTrait.html">BaseTrait</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="#a493be0c467bac528a100115486f3ec69">isInterfaceImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="#a493be0c467bac528a100115486f3ec69">isInterfaceImpl()</a>.</p>

</div>
</div>
<a id="a1e92b3730d5a0d2e1c4f704cb4674d1e" name="a1e92b3730d5a0d2e1c4f704cb4674d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e92b3730d5a0d2e1c4f704cb4674d1e">&#9670;&#160;</a></span>isPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::detail::isPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CRunnerUtils_8h_source.html#l00047">47</a> of file <a class="el" href="CRunnerUtils_8h_source.html">CRunnerUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CRunnerUtils_8h_source.html#l00049">nextPowerOf2()</a>.</p>

</div>
</div>
<a id="aae4714fdeb9f7fa11cf2bd472a5ab6d3" name="aae4714fdeb9f7fa11cf2bd472a5ab6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4714fdeb9f7fa11cf2bd472a5ab6d3">&#9670;&#160;</a></span>isSupportedMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::detail::isSupportedMemorySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>memorySpace</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the memorySpace has supported <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00522">522</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00058">mlir::Attribute::getDialect()</a>.</p>

</div>
</div>
<a id="ad345cebe040768a8cecdf87b398cd223" name="ad345cebe040768a8cecdf87b398cd223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad345cebe040768a8cecdf87b398cd223">&#9670;&#160;</a></span>makeStridedMemRefDescriptor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(N &gt;=1), <a class="el" href="structStridedMemRefType.html">StridedMemRefType</a>&lt; T, N &gt; &gt;::type mlir::detail::makeStridedMemRefDescriptor </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>alignedPtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>shapeAlloc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <span class="tt">StridedMemRefDescriptor&lt;T, N&gt;</span> that matches the MLIR ABI. </p>
<p>This is an implementation detail that is kept in sync with MLIR codegen conventions. Additionally takes a <span class="tt">shapeAlloc</span> array which is used instead of <span class="tt">shape</span> to allocate "more aligned" data and compute the corresponding strides. </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00066">66</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00132">StridedMemRefType&lt; T, N &gt;::basePtr</a>, <a class="el" href="CRunnerUtils_8h_source.html#l00133">StridedMemRefType&lt; T, N &gt;::data</a>, <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00046">makeStrides()</a>, <a class="el" href="CRunnerUtils_8h_source.html#l00134">StridedMemRefType&lt; T, N &gt;::offset</a>, <a class="el" href="CRunnerUtils_8h_source.html#l00135">StridedMemRefType&lt; T, N &gt;::sizes</a>, and <a class="el" href="CRunnerUtils_8h_source.html#l00136">StridedMemRefType&lt; T, N &gt;::strides</a>.</p>

</div>
</div>
<a id="a7275c4b97f04286385a44690c219074f" name="a7275c4b97f04286385a44690c219074f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7275c4b97f04286385a44690c219074f">&#9670;&#160;</a></span>makeStridedMemRefDescriptor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(N==0), <a class="el" href="structStridedMemRefType.html">StridedMemRefType</a>&lt; T, 0 &gt; &gt;::type mlir::detail::makeStridedMemRefDescriptor </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>alignedPtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>shapeAlloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <span class="tt">StridedMemRefDescriptor&lt;T, 0&gt;</span> that matches the MLIR ABI. </p>
<p>This is an implementation detail that is kept in sync with MLIR codegen conventions. Additionally takes a <span class="tt">shapeAlloc</span> array which is used instead of <span class="tt">shape</span> to allocate "more aligned" data and compute the corresponding strides. </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00087">87</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

</div>
</div>
<a id="a927870022d523a348748e4824f220c4e" name="a927870022d523a348748e4824f220c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927870022d523a348748e4824f220c4e">&#9670;&#160;</a></span>makeStrides()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="classint64__t.html">int64_t</a>, N &gt; mlir::detail::makeStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a shape with sizes greater than 0 along all dimensions, returns the distance, in number of elements, between a slice in a dimension and the next slice in the same dimension. </p>
<p>e.g. shape[3, 4, 5] -&gt; strides[20, 5, 1] </p>

<p class="definition">Definition at line <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00046">46</a> of file <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00066">makeStridedMemRefDescriptor()</a>.</p>

</div>
</div>
<a id="ab843225909c16d7b47091b66701c59ab" name="ab843225909c16d7b47091b66701c59ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab843225909c16d7b47091b66701c59ab">&#9670;&#160;</a></span>matchOperandOrValueAtIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatcherClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; llvm::is_detected&lt; <a class="el" href="#a116eb8f6bf6d8b1f5aea178489d35e6f">detail::has_compatible_matcher_t</a>, MatcherClass, <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;::value, <a class="el" href="classbool.html">bool</a> &gt; mlir::detail::matchOperandOrValueAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatcherClass &amp;</td>          <td class="paramname"><span class="paramname"><em>matcher</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically switch to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> matcher. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00298">298</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Matchers_8h_source.html#l00354">mlir::detail::RecursivePatternMatcher&lt; OpType, OperandMatchers &gt;::match()</a>.</p>

</div>
</div>
<a id="a5854f70c611fd1abd8caf893a0fe036a" name="a5854f70c611fd1abd8caf893a0fe036a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5854f70c611fd1abd8caf893a0fe036a">&#9670;&#160;</a></span>matchOperandOrValueAtIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatcherClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; llvm::is_detected&lt; <a class="el" href="#a116eb8f6bf6d8b1f5aea178489d35e6f">detail::has_compatible_matcher_t</a>, MatcherClass, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value, <a class="el" href="classbool.html">bool</a> &gt; mlir::detail::matchOperandOrValueAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatcherClass &amp;</td>          <td class="paramname"><span class="paramname"><em>matcher</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically switch to an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> matcher. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00307">307</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>.</p>

</div>
</div>
<a id="a69a50c1b52f8e20f12e77716d79a5868" name="a69a50c1b52f8e20f12e77716d79a5868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a50c1b52f8e20f12e77716d79a5868">&#9670;&#160;</a></span>nextPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::detail::nextPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CRunnerUtils_8h_source.html#l00049">49</a> of file <a class="el" href="CRunnerUtils_8h_source.html">CRunnerUtils.h</a>.</p>

<p class="reference">References <a class="el" href="CRunnerUtils_8h_source.html#l00047">isPowerOf2()</a>, and <a class="el" href="CRunnerUtils_8h_source.html#l00049">nextPowerOf2()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExecutionEngine_2MemRefUtils_8h_source.html#l00104">allocAligned()</a>, <a class="el" href="CRunnerUtils_8h_source.html#l00049">nextPowerOf2()</a>, <a class="el" href="CRunnerUtils_8h_source.html#l00073">mlir::detail::Vector1D&lt; T, Dim, false &gt;::Vector1D()</a>, and <a class="el" href="CRunnerUtils_8h_source.html#l00058">mlir::detail::Vector1D&lt; T, Dim, true &gt;::Vector1D()</a>.</p>

</div>
</div>
<a id="a6dda0e928632de69c9afa0f01948f418" name="a6dda0e928632de69c9afa0f01948f418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dda0e928632de69c9afa0f01948f418">&#9670;&#160;</a></span>parseSourceFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerOpT, typename... ParserArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ContainerOpT &gt; mlir::detail::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ParserConfig.html">ParserConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParserArgs &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The internal implementation of the templated <span class="tt">parseSourceFile</span> methods below, that simply forwards to the non-templated version. </p>

<p class="definition">Definition at line <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00154">154</a> of file <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00284">mlir::config</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00038">constructContainerOpForParserIfNecessary()</a>, and <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00154">parseSourceFile()</a>.</p>

<p class="reference">Referenced by <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00154">parseSourceFile()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00176">mlir::parseSourceFile()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00186">mlir::parseSourceFile()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00226">mlir::parseSourceFile()</a>, <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00214">mlir::parseSourceFile()</a>, and <a class="el" href="include_2mlir_2Parser_2Parser_8h_source.html#l00200">mlir::parseSourceFile()</a>.</p>

</div>
</div>
<a id="a139c1fb115a13686889ea9fc57208a59" name="a139c1fb115a13686889ea9fc57208a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139c1fb115a13686889ea9fc57208a59">&#9670;&#160;</a></span>printDimensionList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="structmlir_1_1Range.html">Range</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::printDimensionList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1raw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Range.html">Range</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l02035">2035</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsmPrinter_8cpp_source.html#l02946">mlir::AsmPrinter::Impl::printDimensionList()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l03020">mlir::AsmPrinter::printDimensionList()</a>.</p>

</div>
</div>
<a id="a8af776eda51700256b7c60deadcb4d25" name="a8af776eda51700256b7c60deadcb4d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af776eda51700256b7c60deadcb4d25">&#9670;&#160;</a></span>replaceImmediateSubElementsImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::detail::replaceImmediateSubElementsImpl </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>derived</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>replAttrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>replTypes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides the underlying implementation for the SubElementInterface replace method, using the key type of the derived attribute/type to interact with the individual parameters. </p>

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00557">557</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

<p class="reference">References <a class="el" href="AttrTypeSubElements_8h_source.html#l00539">constructSubElementReplacement()</a>, and <a class="el" href="AttrTypeSubElements_8h_source.html#l00417">mlir::has_sub_attr_or_type_v</a>.</p>

</div>
</div>
<a id="ab5f85cda3d8183cca5b6c2766fddb2fb" name="ab5f85cda3d8183cca5b6c2766fddb2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f85cda3d8183cca5b6c2766fddb2fb">&#9670;&#160;</a></span>reportFatalInferReturnTypesError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::reportFatalInferReturnTypesError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report a fatal error indicating that the result types could not be inferred. </p>

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00259">259</a> of file <a class="el" href="InferTypeOpInterface_8cpp_source.html">InferTypeOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00954">mlir::OperationState::attributes</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00346">mlir::emitRemark()</a>, <a class="el" href="Location_8h_source.html#l00086">mlir::Location::getContext()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00054">mlir::NamedAttrList::getDictionary()</a>, <a class="el" href="OperationSupport_8h_source.html#l00949">mlir::OperationState::location</a>, <a class="el" href="OperationSupport_8h_source.html#l00950">mlir::OperationState::name</a>, and <a class="el" href="OperationSupport_8h_source.html#l00951">mlir::OperationState::operands</a>.</p>

</div>
</div>
<a id="a0caa43784c57086534e1833f66eaecfc" name="a0caa43784c57086534e1833f66eaecfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0caa43784c57086534e1833f66eaecfc">&#9670;&#160;</a></span>sameOffsetsSizesAndStrides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::detail::sameOffsetsSizesAndStrides </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>cmp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00273">273</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>.</p>

</div>
</div>
<a id="ab38aedb222d8f61891a51c10805e286c" name="ab38aedb222d8f61891a51c10805e286c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38aedb222d8f61891a51c10805e286c">&#9670;&#160;</a></span>skipDefaultMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::skipDefaultMemorySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>memorySpace</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces default memorySpace (integer == <span class="tt">0</span>) with empty <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00546">546</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

</div>
</div>
<a id="a2bc750046567479d1fdfa425bac17b32" name="a2bc750046567479d1fdfa425bac17b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc750046567479d1fdfa425bac17b32">&#9670;&#160;</a></span>unwrapForCustomParse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) mlir::detail::unwrapForCustomParse </td>
          <td>(</td>
          <td class="paramtype">FailureOr&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>failureOr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttributeSupport_8h_source.html#l00316">316</a> of file <a class="el" href="AttributeSupport_8h_source.html">AttributeSupport.h</a>.</p>

</div>
</div>
<a id="ada3315ae7edc12bed53da6a26424d047" name="ada3315ae7edc12bed53da6a26424d047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3315ae7edc12bed53da6a26424d047">&#9670;&#160;</a></span>verifyAffineMapAsLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyAffineMapAsLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00077">77</a> of file <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html">BuiltinAttributeInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">mlir::emitError()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a2e2f4d4cb24fe5f60b359e5962ad5498" name="a2e2f4d4cb24fe5f60b359e5962ad5498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2f4d4cb24fe5f60b359e5962ad5498">&#9670;&#160;</a></span>verifyBranchSuccessorOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyBranchSuccessorOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>succNo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1SuccessorOperands.html">SuccessorOperands</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that the given operands match those of the given successor block. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00073">73</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="Block_8h_source.html#l00129">mlir::Block::getArgument()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getNumArguments()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00070">mlir::SuccessorOperands::getProducedOperandCount()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00708">mlir::Operation::getSuccessor()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00061">mlir::SuccessorOperands::size()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="ae5372df7a0d717fe3ad6238640425402" name="ae5372df7a0d717fe3ad6238640425402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5372df7a0d717fe3ad6238640425402">&#9670;&#160;</a></span>verifyBranchWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyBranchWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that the branch weights attached to an operation implementing WeightedBranchOpInterface are correct. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00134">134</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00706">mlir::Operation::getNumSuccessors()</a>, and <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00114">verifyWeights()</a>.</p>

</div>
</div>
<a id="aee3b9d7e0a9cd00a32827f48d4536850" name="aee3b9d7e0a9cd00a32827f48d4536850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3b9d7e0a9cd00a32827f48d4536850">&#9670;&#160;</a></span>verifyDataLayoutOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyDataLayoutOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that the operation implementing the data layout interface, or a module operation, is valid. </p>
<p>This calls the verifier of the spec attribute and checks if the layout is compatible with specs attached to the enclosing operations. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00443">443</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00383">collectParentLayouts()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00057">diag()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00414">getCombinedDataLayout()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00363">getSpec()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="af3a791a52efb3f0b9d61ca353b635e95" name="af3a791a52efb3f0b9d61ca353b635e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a791a52efb3f0b9d61ca353b635e95">&#9670;&#160;</a></span>verifyDataLayoutSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyDataLayoutSpec </td>
          <td>(</td>
          <td class="paramtype">DataLayoutSpecInterface</td>          <td class="paramname"><span class="paramname"><em>spec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that a data layout spec is valid. </p>
<p>This dispatches to individual entry verifiers, and then to the verifiers implemented by the relevant type and dialect interfaces for type and identifier keys respectively. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00797">797</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">mlir::emitError()</a>, <a class="el" href="IR_2Dialect_8h_source.html#l00054">mlir::Dialect::getNamespace()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="abc3a9033156fc6f0f4ee40b16eaa835c" name="abc3a9033156fc6f0f4ee40b16eaa835c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3a9033156fc6f0f4ee40b16eaa835c">&#9670;&#160;</a></span>verifyDestinationStyleOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyDestinationStyleOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that <span class="tt">op</span> conforms to the invariants of DestinationStyleOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="DestinationStyleOpInterface_8cpp_source.html#l00029">29</a> of file <a class="el" href="DestinationStyleOpInterface_8cpp_source.html">DestinationStyleOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00668">mlir::Operation::emitOpError()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="DestinationStyleOpInterface_8cpp_source.html#l00029">verifyDestinationStyleOpInterface()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DestinationStyleOpInterface_8cpp_source.html#l00029">verifyDestinationStyleOpInterface()</a>.</p>

</div>
</div>
<a id="a77ee29379e4568366034d669b060a034" name="a77ee29379e4568366034d669b060a034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ee29379e4568366034d669b060a034">&#9670;&#160;</a></span>verifyIndexingMapOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyIndexingMapOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that <span class="tt">op</span> conforms to the invariants of StructuredOpInterface. </p>

</div>
</div>
<a id="ad276c5acc7f5d475d0e1987a456a59e0" name="ad276c5acc7f5d475d0e1987a456a59e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad276c5acc7f5d475d0e1987a456a59e0">&#9670;&#160;</a></span>verifyInferredResultTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyInferredResultTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that the inferred result types match the actual result types for the op. </p>
<p>Precondition: op implements InferTypeOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00246">246</a> of file <a class="el" href="InferTypeOpInterface_8cpp_source.html">InferTypeOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00668">mlir::Operation::emitOpError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00900">mlir::Operation::getPropertiesStorage()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00509">mlir::Operation::getRawDictionaryAttrs()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00428">mlir::Operation::getResultTypes()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="af09e6bd26baceff7935df426cf406496" name="af09e6bd26baceff7935df426cf406496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09e6bd26baceff7935df426cf406496">&#9670;&#160;</a></span>verifyInParallelOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyInParallelOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ParallelCombiningOpInterface_8cpp_source.html#l00018">18</a> of file <a class="el" href="ParallelCombiningOpInterface_8cpp_source.html">ParallelCombiningOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00674">mlir::Operation::getNumRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00686">mlir::Operation::getRegion()</a>, <a class="el" href="IR_2Region_8h_source.html#l00068">mlir::Region::hasOneBlock()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a960f17c15fd15a72390d00da41a4e12f" name="a960f17c15fd15a72390d00da41a4e12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960f17c15fd15a72390d00da41a4e12f">&#9670;&#160;</a></span>verifyLoopLikeOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyLoopLikeOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify invariants of the LoopLikeOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="LoopLikeInterface_8cpp_source.html#l00055">55</a> of file <a class="el" href="LoopLikeInterface_8cpp_source.html">LoopLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00668">mlir::Operation::emitOpError()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="LoopLikeInterface_8cpp_source.html#l00055">verifyLoopLikeOpInterface()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopLikeInterface_8cpp_source.html#l00055">verifyLoopLikeOpInterface()</a>.</p>

</div>
</div>
<a id="ad771bcf841b38d5c2ccca4417102863e" name="ad771bcf841b38d5c2ccca4417102863e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad771bcf841b38d5c2ccca4417102863e">&#9670;&#160;</a></span>verifyMemorySpaceCastOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyMemorySpaceCastOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to verify the given memory space cast operation. </p>

<p class="definition">Definition at line <a class="el" href="MemOpInterfaces_8cpp_source.html#l00017">17</a> of file <a class="el" href="MemOpInterfaces_8cpp_source.html">MemOpInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8h_source.html#l00101">mlir::Type::getTypeID()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="afebb54d50bfcc329f59aee2490b27c07" name="afebb54d50bfcc329f59aee2490b27c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afebb54d50bfcc329f59aee2490b27c07">&#9670;&#160;</a></span>verifyOffsetSizeAndStrideOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyOffsetSizeAndStrideOp </td>
          <td>(</td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterface_8cpp_source.html#l00096">96</a> of file <a class="el" href="ViewLikeInterface_8cpp_source.html">ViewLikeInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="ViewLikeInterface_8cpp_source.html#l00020">mlir::verifyListOfOperandsOrIntegers()</a>.</p>

</div>
</div>
<a id="a25a3777b2ac1a4abcc61e74c35c7b997" name="a25a3777b2ac1a4abcc61e74c35c7b997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a3777b2ac1a4abcc61e74c35c7b997">&#9670;&#160;</a></span>verifyRegionBranchWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyRegionBranchWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that the region weights attached to an operation implementing WeightedRegiobBranchOpInterface are correct. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00145">145</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00674">mlir::Operation::getNumRegions()</a>, and <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00114">verifyWeights()</a>.</p>

</div>
</div>
<a id="a819d12bc01c2443cfc1b72c4824bfaba" name="a819d12bc01c2443cfc1b72c4824bfaba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819d12bc01c2443cfc1b72c4824bfaba">&#9670;&#160;</a></span>verifyShapedDimOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyShapedDimOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify invariants of ops that implement the ShapedDimOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="ShapedOpInterfaces_8cpp_source.html#l00017">17</a> of file <a class="el" href="ShapedOpInterfaces_8cpp_source.html">ShapedOpInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a0ebd9058172b2a090d824c6ab1841413" name="a0ebd9058172b2a090d824c6ab1841413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebd9058172b2a090d824c6ab1841413">&#9670;&#160;</a></span>verifySubsetExtractionOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifySubsetExtractionOpInterface </td>
          <td>(</td>
          <td class="paramtype">SubsetExtractionOpInterface</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify <span class="tt">SubsetExtractionOpInterface</span>. </p>

<p class="definition">Definition at line <a class="el" href="SubsetOpInterface_8cpp_source.html#l00102">102</a> of file <a class="el" href="SubsetOpInterface_8cpp_source.html">SubsetOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="SubsetOpInterface_8cpp_source.html#l00102">verifySubsetExtractionOpInterface()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SubsetOpInterface_8cpp_source.html#l00102">verifySubsetExtractionOpInterface()</a>.</p>

</div>
</div>
<a id="aba9dcc8813e435202abcbb438f66d90a" name="aba9dcc8813e435202abcbb438f66d90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9dcc8813e435202abcbb438f66d90a">&#9670;&#160;</a></span>verifySubsetOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifySubsetOpInterface </td>
          <td>(</td>
          <td class="paramtype">SubsetOpInterface</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify <span class="tt">SubsetOpInterface</span>. </p>

<p class="definition">Definition at line <a class="el" href="SubsetOpInterface_8cpp_source.html#l00092">92</a> of file <a class="el" href="SubsetOpInterface_8cpp_source.html">SubsetOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="SubsetOpInterface_8cpp_source.html#l00092">verifySubsetOpInterface()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SubsetOpInterface_8cpp_source.html#l00092">verifySubsetOpInterface()</a>.</p>

</div>
</div>
<a id="ae8e42f84b57ed10b489c12a7236bb356" name="ae8e42f84b57ed10b489c12a7236bb356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e42f84b57ed10b489c12a7236bb356">&#9670;&#160;</a></span>verifySymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifySymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolTable_8cpp_source.html#l00530">530</a> of file <a class="el" href="SymbolTable_8cpp_source.html">SymbolTable.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00668">mlir::Operation::emitOpError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00534">mlir::Operation::getAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>, <a class="el" href="SymbolTable_8h_source.html#l00076">mlir::SymbolTable::getSymbolAttrName()</a>, <a class="el" href="SymbolTable_8h_source.html#l00082">mlir::SymbolTable::getVisibilityAttrName()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="aea9f7283021fca39df8cf99bbd90cf4a" name="aea9f7283021fca39df8cf99bbd90cf4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9f7283021fca39df8cf99bbd90cf4a">&#9670;&#160;</a></span>verifySymbolTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifySymbolTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SymbolTable_8cpp_source.html#l00482">482</a> of file <a class="el" href="SymbolTable_8cpp_source.html">SymbolTable.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00230">mlir::Diagnostic::append()</a>, <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00342">mlir::InFlightDiagnostic::append()</a>, <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00354">mlir::InFlightDiagnostic::attachNote()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00668">mlir::Operation::emitOpError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00486">mlir::Operation::getDiscardableAttrs()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00674">mlir::Operation::getNumRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00686">mlir::Operation::getRegion()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>, <a class="el" href="SymbolTable_8h_source.html#l00076">mlir::SymbolTable::getSymbolAttrName()</a>, <a class="el" href="IR_2Region_8h_source.html#l00068">mlir::Region::hasOneBlock()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="SymbolTable_8cpp_source.html#l00080">walkSymbolTable()</a>.</p>

</div>
</div>
<a id="a474ca87dcf5fa084441e1a1275852fbb" name="a474ca87dcf5fa084441e1a1275852fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474ca87dcf5fa084441e1a1275852fbb">&#9670;&#160;</a></span>verifyTargetSystemSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyTargetSystemSpec </td>
          <td>(</td>
          <td class="paramtype">TargetSystemSpecInterface</td>          <td class="paramname"><span class="paramname"><em>spec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies that a target system desc spec is valid. </p>
<p>This dispatches to individual entry verifiers, and then to the verifiers implemented by the relevant dialect interfaces for identifier keys. </p>

<p class="definition">Definition at line <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00887">887</a> of file <a class="el" href="DataLayoutInterfaces_8cpp_source.html">DataLayoutInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">mlir::emitError()</a>, <a class="el" href="IR_2Dialect_8h_source.html#l00054">mlir::Dialect::getNamespace()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="ae4afbba3aecdff992f5fb31b086f9c12" name="ae4afbba3aecdff992f5fb31b086f9c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4afbba3aecdff992f5fb31b086f9c12">&#9670;&#160;</a></span>verifyTypesAlongControlFlowEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::detail::verifyTypesAlongControlFlowEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that types match along control flow edges described the given op. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00221">221</a> of file <a class="el" href="ControlFlowInterfaces_8cpp_source.html">ControlFlowInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>, <a class="el" href="ValueRange_8cpp_source.html#l00028">mlir::OperandRange::getTypes()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00241">mlir::RegionBranchPoint::parent()</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02099">TypeRange</a>, and <a class="el" href="ControlFlowInterfaces_8cpp_source.html#l00176">verifyTypesAlongAllEdges()</a>.</p>

</div>
</div>
<a id="a5b337bcade50e3cd7191efec879db837" name="a5b337bcade50e3cd7191efec879db837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b337bcade50e3cd7191efec879db837">&#9670;&#160;</a></span>walk() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Block.html">Block</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00119">119</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00028">mlir::PostOrder</a>, <a class="el" href="Visitors_8h_source.html#l00028">mlir::PreOrder</a>, and <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

</div>
</div>
<a id="a3adcd8424919a733a4cce559560e5dd9" name="a3adcd8424919a733a4cce559560e5dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adcd8424919a733a4cce559560e5dd9">&#9670;&#160;</a></span>walk() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00136">136</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00028">mlir::PostOrder</a>, <a class="el" href="Visitors_8h_source.html#l00028">mlir::PreOrder</a>, and <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

</div>
</div>
<a id="a7626abe27e64a0a166feedf7e829c968" name="a7626abe27e64a0a166feedf7e829c968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7626abe27e64a0a166feedf7e829c968">&#9670;&#160;</a></span>walk() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a> &amp;stage)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic walkers with stage aware callbacks. </p>
<p>Walk all the operations nested under (and including) the given operation, with the callback being invoked on each operation N+1 times, where N is the number of regions attached to the operation. The <span class="tt">stage</span> input to the callback indicates the current walk stage. This method is invoked for void returning callbacks. </p>

</div>
</div>
<a id="a152b851682ac1cad31c84dc1a6fc38cb" name="a152b851682ac1cad31c84dc1a6fc38cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152b851682ac1cad31c84dc1a6fc38cb">&#9670;&#160;</a></span>walk() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the regions, blocks, or operations nested under (and including) the given operation. </p>
<p>The order in which regions, blocks and operations at the same nesting level are visited (e.g., lexicographical or reverse lexicographical order) is determined by 'Iterator'. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'order'. These methods are invoked for void-returning callbacks. A callback on a block or operation is allowed to erase that block or operation only if the walk is in post-order. See non-void method for pre-order erasure. </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00102">102</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00028">mlir::PostOrder</a>, <a class="el" href="Visitors_8h_source.html#l00028">mlir::PreOrder</a>, and <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Block_8h_source.html#l00360">mlir::Block::walk()</a>, <a class="el" href="Visitors_8h_source.html#l00119">walk()</a>, <a class="el" href="Visitors_8h_source.html#l00136">walk()</a>, <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>, <a class="el" href="Visitors_8h_source.html#l00194">walk()</a>, <a class="el" href="Visitors_8h_source.html#l00222">walk()</a>, <a class="el" href="Visitors_8h_source.html#l00166">walk()</a>, <a class="el" href="Visitors_8h_source.html#l00277">walk()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00119">mlir::PatternApplicator::walkAllPatterns()</a>, and <a class="el" href="AttrTypeSubElements_8h_source.html#l00518">walkImmediateSubElementsImpl()</a>.</p>

</div>
</div>
<a id="ac791c882fa374a53b6a7ec0387586f59" name="ac791c882fa374a53b6a7ec0387586f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac791c882fa374a53b6a7ec0387586f59">&#9670;&#160;</a></span>walk() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Block.html">Block</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00194">194</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="Visitors_8h_source.html#l00028">mlir::PostOrder</a>, <a class="el" href="Visitors_8h_source.html#l00028">mlir::PreOrder</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

</div>
</div>
<a id="ab4e61da15ae81a346c6b060103d0ed54" name="ab4e61da15ae81a346c6b060103d0ed54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e61da15ae81a346c6b060103d0ed54">&#9670;&#160;</a></span>walk() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00222">222</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="Visitors_8h_source.html#l00028">mlir::PostOrder</a>, <a class="el" href="Visitors_8h_source.html#l00028">mlir::PreOrder</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

</div>
</div>
<a id="aa2adf6127282c5d8cd497d1eff1013c1" name="aa2adf6127282c5d8cd497d1eff1013c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2adf6127282c5d8cd497d1eff1013c1">&#9670;&#160;</a></span>walk() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, const <a class="el" href="classmlir_1_1WalkStage.html">WalkStage</a> &amp;stage)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all the operations nested under (and including) the given operation, with the callback being invoked on each operation N+1 times, where N is the number of regions attached to the operation. </p>
<p>The <span class="tt">stage</span> input to the callback indicates the current walk stage. This method is invoked for skippable or interruptible callbacks. </p>

</div>
</div>
<a id="a08eda9acbea0f5326d02db4b99814395" name="a08eda9acbea0f5326d02db4b99814395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08eda9acbea0f5326d02db4b99814395">&#9670;&#160;</a></span>walk() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a>(<a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a></td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the regions, blocks, or operations nested under (and including) the given operation. </p>
<p>The order in which regions, blocks and operations at the same nesting level are visited (e.g., lexicographical or reverse lexicographical order) is determined by 'Iterator'. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'order'. This method is invoked for skippable or interruptible callbacks. A callback on a block or operation is allowed to erase that block or operation if either:</p><ul>
<li>the walk is in post-order, or</li>
<li>the walk is in pre-order and the walk is skipped after the erasure. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00166">166</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="Visitors_8h_source.html#l00028">mlir::PostOrder</a>, <a class="el" href="Visitors_8h_source.html#l00028">mlir::PreOrder</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

</div>
</div>
<a id="ae7fb4b0d0a078cc3764b8e4a78205aba" name="ae7fb4b0d0a078cc3764b8e4a78205aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fb4b0d0a078cc3764b8e4a78205aba">&#9670;&#160;</a></span>walk() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> Order = WalkOrder::PostOrder, typename Iterator = ForwardIterator, typename FuncTy, typename ArgT = detail::first_argument&lt;FuncTy&gt;, typename RetT = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; llvm::is_one_of&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;::value, RetT &gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the regions, blocks, or operations nested under (and including) the given operation. </p>
<p>The order in which regions, blocks and operations at the same nesting level are visited (e.g., lexicographical or reverse lexicographical order) is determined by 'Iterator'. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'Order' (post-order by default). A callback on a block or operation is allowed to erase that block or operation if either:</p><ul>
<li>the walk is in post-order, or</li>
<li>the walk is in pre-order and the walk is skipped after the erasure. This method is selected for callbacks that operate on Region*, Block*, and Operation*.</li>
</ul>
<p>Example: op-&gt;walk([](<a class="el" href="classmlir_1_1Region.html" title="This class contains a list of basic blocks and a link to the parent operation it is attached to.">Region</a> *r) { ... }); op-&gt;walk([](<a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a> *b) { ... }); op-&gt;walk([](<a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> *op) { ... }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00277">277</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

</div>
</div>
<a id="a0bcb55459dcace8bc159f9cf642ec047" name="a0bcb55459dcace8bc159f9cf642ec047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcb55459dcace8bc159f9cf642ec047">&#9670;&#160;</a></span>walk() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> Order = WalkOrder::PostOrder, typename Iterator = ForwardIterator, typename FuncTy, typename ArgT = detail::first_argument&lt;FuncTy&gt;, typename RetT = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; !llvm::is_one_of&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;::value &amp;&amp;std::is_same&lt; RetT, <a class="el" href="classvoid.html">void</a> &gt;::value, RetT &gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations of type 'ArgT' nested under and including the given operation. </p>
<p>The order in which regions, blocks and operations at the same nesting are visited (e.g., lexicographical or reverse lexicographical order) is determined by 'Iterator'. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'order' (post-order by default). This method is selected for void-returning callbacks that operate on a specific derived operation type. A callback on an operation is allowed to erase that operation only if the walk is in post-order. See non-void method for pre-order erasure.</p>
<p>Example: op-&gt;walk([](ReturnOp op) { ... }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00301">301</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

</div>
</div>
<a id="a5f537fb0b2bd29ab4cf6e27ef6c7137a" name="a5f537fb0b2bd29ab4cf6e27ef6c7137a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f537fb0b2bd29ab4cf6e27ef6c7137a">&#9670;&#160;</a></span>walk() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> Order = WalkOrder::PostOrder, typename Iterator = ForwardIterator, typename FuncTy, typename ArgT = detail::first_argument&lt;FuncTy&gt;, typename RetT = decltype(std::declval&lt;FuncTy&gt;()(std::declval&lt;ArgT&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; !llvm::is_one_of&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Region.html">Region</a> *, <a class="el" href="classmlir_1_1Block.html">Block</a> * &gt;::value &amp;&amp;std::is_same&lt; RetT, <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> &gt;::value, RetT &gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations of type 'ArgT' nested under and including the given operation. </p>
<p>The order in which regions, blocks and operations at the same nesting are visited (e.g., lexicographical or reverse lexicographical order) is determined by 'Iterator'. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'Order' (post-order by default). This method is selected for WalkReturn returning skippable or interruptible callbacks that operate on a specific derived operation type. A callback on an operation is allowed to erase that operation if either:</p><ul>
<li>the walk is in post-order, or</li>
<li>the walk is in pre-order and the walk is skipped after the erasure.</li>
</ul>
<p>Example: op-&gt;walk([](ReturnOp op) { if (some_invariant) return <a class="el" href="classmlir_1_1WalkResult.html#a693d2ecca6f15d4d492c6ff2bea148d0">WalkResult::skip()</a>; if (another_invariant) return <a class="el" href="classmlir_1_1WalkResult.html#abab80dca5987e18f9abf08162cd3faaa">WalkResult::interrupt()</a>; return <a class="el" href="classmlir_1_1WalkResult.html#a97a7015a793bb5d2a97f08e358f42797">WalkResult::advance()</a>; }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00338">338</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, and <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

</div>
</div>
<a id="af31a4cf656e761cf8a04760f12de30f8" name="af31a4cf656e761cf8a04760f12de30f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31a4cf656e761cf8a04760f12de30f8">&#9670;&#160;</a></span>walk() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncTy, typename ArgT = detail::first_argument&lt;FuncTy&gt;, typename RetT = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value, RetT &gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations nested under and including the given operation. </p>
<p>This method is selected for stage-aware callbacks that operate on Operation*.</p>
<p>Example: op-&gt;walk([](<a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> *op, const <a class="el" href="classmlir_1_1WalkStage.html" title="A utility class to encode the current walk stage for &quot;generic&quot; walkers.">WalkStage</a> &amp;stage) { ... }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00377">377</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

</div>
</div>
<a id="a3285200671885c53b9a0897a36a36e89" name="a3285200671885c53b9a0897a36a36e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3285200671885c53b9a0897a36a36e89">&#9670;&#160;</a></span>walk() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncTy, typename ArgT = detail::first_argument&lt;FuncTy&gt;, typename RetT = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_same&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value &amp;&amp;std::is_same&lt; RetT, <a class="el" href="classvoid.html">void</a> &gt;::value, RetT &gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations of type 'ArgT' nested under and including the given operation. </p>
<p>This method is selected for void returning callbacks that operate on a specific derived operation type.</p>
<p>Example: op-&gt;walk([](ReturnOp op, const <a class="el" href="classmlir_1_1WalkStage.html" title="A utility class to encode the current walk stage for &quot;generic&quot; walkers.">WalkStage</a> &amp;stage) { ... }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00394">394</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

</div>
</div>
<a id="a5b2fed9675957963fd823d25c6a77ee0" name="a5b2fed9675957963fd823d25c6a77ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2fed9675957963fd823d25c6a77ee0">&#9670;&#160;</a></span>walk() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncTy, typename ArgT = detail::first_argument&lt;FuncTy&gt;, typename RetT = decltype(std::declval&lt;FuncTy&gt;()(              std::declval&lt;ArgT&gt;(), std::declval&lt;const WalkStage &amp;&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_same&lt; ArgT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value &amp;&amp;std::is_same&lt; RetT, <a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a> &gt;::value, RetT &gt; mlir::detail::walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncTy &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the operations of type 'ArgT' nested under and including the given operation. </p>
<p>This method is selected for WalkReturn returning interruptible callbacks that operate on a specific derived operation type.</p>
<p>Example: op-&gt;walk(op, [](ReturnOp op, const <a class="el" href="classmlir_1_1WalkStage.html" title="A utility class to encode the current walk stage for &quot;generic&quot; walkers.">WalkStage</a> &amp;stage) { if (some_invariant) return <a class="el" href="classmlir_1_1WalkResult.html#abab80dca5987e18f9abf08162cd3faaa">WalkResult::interrupt()</a>; return <a class="el" href="classmlir_1_1WalkResult.html#a97a7015a793bb5d2a97f08e358f42797">WalkResult::advance()</a>; }); </p>

<p class="definition">Definition at line <a class="el" href="Visitors_8h_source.html#l00419">419</a> of file <a class="el" href="Visitors_8h_source.html">Visitors.h</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, and <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

</div>
</div>
<a id="a9d0ecdf07e5bd3e5496db1048d6b0beb" name="a9d0ecdf07e5bd3e5496db1048d6b0beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0ecdf07e5bd3e5496db1048d6b0beb">&#9670;&#160;</a></span>walkImmediateSubElementsImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::detail::walkImmediateSubElementsImpl </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>derived</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>walkAttrsFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Type.html">Type</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>walkTypesFn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides the underlying implementation for the SubElementInterface walk method, using the key type of the derived attribute/type to interact with the individual parameters. </p>

<p class="definition">Definition at line <a class="el" href="AttrTypeSubElements_8h_source.html#l00518">518</a> of file <a class="el" href="AttrTypeSubElements_8h_source.html">AttrTypeSubElements.h</a>.</p>

<p class="reference">References <a class="el" href="AttrTypeSubElements_8h_source.html#l00417">mlir::has_sub_attr_or_type_v</a>, and <a class="el" href="Visitors_8h_source.html#l00102">walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StorageUniquerSupport_8h_source.html#l00132">mlir::detail::StorageUserBase&lt; ConcreteType, BaseType, StorageType, detail::AttributeUniquer, Traits... &gt;::getWalkImmediateSubElementsFn()</a>.</p>

</div>
</div>
<a id="a37f32721e9d15092545cf9ea586d6d7e" name="a37f32721e9d15092545cf9ea586d6d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f32721e9d15092545cf9ea586d6d7e">&#9670;&#160;</a></span>wrapIntegerMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::detail::wrapIntegerMemorySpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>memorySpace</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps deprecated integer memory space to the new <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> form. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00538">538</a> of file <a class="el" href="IR_2BuiltinTypes_8cpp_source.html">BuiltinTypes.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
