<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::transform::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="namespacemlir_1_1transform.html">transform</a></li><li class="navelem"><a href="namespacemlir_1_1transform_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mlir::transform::detail Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:TransformDialectDataBase" id="r_TransformDialectDataBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1transform_1_1detail_1_1TransformDialectDataBase.html">TransformDialectDataBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete base class for CRTP <a class="el" href="classmlir_1_1transform_1_1detail_1_1TransformDialectDataBase.html" title="Concrete base class for CRTP TransformDialectDataBase.">TransformDialectDataBase</a>.  <a href="classmlir_1_1transform_1_1detail_1_1TransformDialectDataBase.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab49efa35a55e8224a1ad36d69d6198c9" id="r_ab49efa35a55e8224a1ad36d69d6198c9"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab49efa35a55e8224a1ad36d69d6198c9">verifyStructuredOpPredicateOpTrait</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> structuredOpHandle)</td></tr>
<tr class="memitem:accfe7c2cf4c9692e48bfb28f0fb39b9b" id="r_accfe7c2cf4c9692e48bfb28f0fb39b9b"><td class="memTemplParams" colspan="2">template&lt;typename OpTy&gt; </td></tr>
<tr class="memitem:accfe7c2cf4c9692e48bfb28f0fb39b9b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accfe7c2cf4c9692e48bfb28f0fb39b9b">matchOptionalOperation</a> (OpTy op, <a class="el" href="classmlir_1_1transform_1_1TransformResults.html">TransformResults</a> &amp;results, <a class="el" href="classmlir_1_1transform_1_1TransformState.html">TransformState</a> &amp;state)</td></tr>
<tr class="memdesc:accfe7c2cf4c9692e48bfb28f0fb39b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch <span class="tt">matchOperation</span> based on Operation* or std::optional&lt;Operation*&gt; first operand.  <br /></td></tr>
<tr class="memitem:a97376b0a911f5a44f05410e33d7fe30e" id="r_a97376b0a911f5a44f05410e33d7fe30e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97376b0a911f5a44f05410e33d7fe30e">mapPossibleTopLevelTransformOpBlockArguments</a> (<a class="el" href="classmlir_1_1transform_1_1TransformState.html">TransformState</a> &amp;state, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a97376b0a911f5a44f05410e33d7fe30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the only block argument of the op with <a class="el" href="classmlir_1_1transform_1_1PossibleTopLevelTransformOpTrait.html" title="This trait is supposed to be attached to Transform dialect operations that can be standalone top-leve...">PossibleTopLevelTransformOpTrait</a> to either the list of operations associated with its operand or the root of the payload IR, depending on what is available in the context.  <br /></td></tr>
<tr class="memitem:af472e3604dc87e29966aba3b81c0a5fb" id="r_af472e3604dc87e29966aba3b81c0a5fb"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af472e3604dc87e29966aba3b81c0a5fb">verifyPossibleTopLevelTransformOpTrait</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:af472e3604dc87e29966aba3b81c0a5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verification hook for <a class="el" href="classmlir_1_1transform_1_1PossibleTopLevelTransformOpTrait.html" title="This trait is supposed to be attached to Transform dialect operations that can be standalone top-leve...">PossibleTopLevelTransformOpTrait</a>.  <br /></td></tr>
<tr class="memitem:afc8c491c51ccdf3437db9ee7486b083a" id="r_afc8c491c51ccdf3437db9ee7486b083a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc8c491c51ccdf3437db9ee7486b083a">getPotentialTopLevelEffects</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *operation, <a class="el" href="classmlir_1_1Value.html">Value</a> root, <a class="el" href="classmlir_1_1Block.html">Block</a> &amp;body, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="namespacemlir_1_1MemoryEffects.html#aba14da80da7a4a192a129fecdb0ac624">MemoryEffects::EffectInstance</a> &gt; &amp;effects)</td></tr>
<tr class="memdesc:afc8c491c51ccdf3437db9ee7486b083a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">effects</span> with side effects implied by <a class="el" href="classmlir_1_1transform_1_1PossibleTopLevelTransformOpTrait.html" title="This trait is supposed to be attached to Transform dialect operations that can be standalone top-leve...">PossibleTopLevelTransformOpTrait</a> for the given operation.  <br /></td></tr>
<tr class="memitem:a08d70b4f0eb6e462437d65f2d7567055" id="r_a08d70b4f0eb6e462437d65f2d7567055"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08d70b4f0eb6e462437d65f2d7567055">verifyTransformOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a08d70b4f0eb6e462437d65f2d7567055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verification hook for TransformOpInterface.  <br /></td></tr>
<tr class="memitem:a5e775963104a18977a3ae5a6f67a5a88" id="r_a5e775963104a18977a3ae5a6f67a5a88"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e775963104a18977a3ae5a6f67a5a88">appendValueMappings</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir_1_1transform.html#a5fb1ec52849c25d93b80118a5b02ffc8">transform::MappedValue</a> &gt; &gt; mappings, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values, const <a class="el" href="classmlir_1_1transform_1_1TransformState.html">transform::TransformState</a> &amp;state, <a class="el" href="classbool.html">bool</a> flatten=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:a5e775963104a18977a3ae5a6f67a5a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the entities associated with the given transform values in <span class="tt">state</span> to the pre-existing list of mappings.  <br /></td></tr>
<tr class="memitem:ab9fccd8f879c8e6b65fafbda237918eb" id="r_ab9fccd8f879c8e6b65fafbda237918eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9fccd8f879c8e6b65fafbda237918eb">prepareValueMappings</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir_1_1transform.html#a5fb1ec52849c25d93b80118a5b02ffc8">transform::MappedValue</a> &gt; &gt; &amp;mappings, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values, const <a class="el" href="classmlir_1_1transform_1_1TransformState.html">transform::TransformState</a> &amp;state)</td></tr>
<tr class="memdesc:ab9fccd8f879c8e6b65fafbda237918eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">mappings</span> with mapped values associated with the given transform IR values in the given <span class="tt">state</span>.  <br /></td></tr>
<tr class="memitem:a81d536d06d24d9780714574520f14e25" id="r_a81d536d06d24d9780714574520f14e25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81d536d06d24d9780714574520f14e25">forwardTerminatorOperands</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1transform_1_1TransformState.html">transform::TransformState</a> &amp;state, <a class="el" href="classmlir_1_1transform_1_1TransformResults.html">transform::TransformResults</a> &amp;results)</td></tr>
<tr class="memdesc:a81d536d06d24d9780714574520f14e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">results</span> with payload associations that match exactly those of the operands to <span class="tt">block</span>'s terminator.  <br /></td></tr>
<tr class="memitem:a9c029c6849c69a0f311170959ae70966" id="r_a9c029c6849c69a0f311170959ae70966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1transform_1_1TransformState.html">TransformState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c029c6849c69a0f311170959ae70966">makeTransformStateForTesting</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> *region, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *payloadRoot)</td></tr>
<tr class="memdesc:a9c029c6849c69a0f311170959ae70966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a dummy transform state for testing purposes.  <br /></td></tr>
<tr class="memitem:a0a3d6c26ca1ca817dad960606875fb3b" id="r_a0a3d6c26ca1ca817dad960606875fb3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a3d6c26ca1ca817dad960606875fb3b">getConsumedHandleOpOperands</a> (transform::TransformOpInterface transformOp)</td></tr>
<tr class="memdesc:a0a3d6c26ca1ca817dad960606875fb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all operands that are handles and being consumed by the given op.  <br /></td></tr>
<tr class="memitem:a8c4853c22618926e8e9f6505afcdff9d" id="r_a8c4853c22618926e8e9f6505afcdff9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c4853c22618926e8e9f6505afcdff9d">getParamProducerTransformOpTraitEffects</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="namespacemlir_1_1MemoryEffects.html#aba14da80da7a4a192a129fecdb0ac624">MemoryEffects::EffectInstance</a> &gt; &amp;effects)</td></tr>
<tr class="memdesc:a8c4853c22618926e8e9f6505afcdff9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-template implementation of <a class="el" href="classmlir_1_1transform_1_1ParamProducerTransformOpTrait.html#ad3321e39e0c4a2102e0ab54da46788c7" title="Populates effects with effect instances described in the trait documentation.">ParamProducerTransformOpTrait::getEffects()</a>.  <br /></td></tr>
<tr class="memitem:aad39ec48980e7ee4339642e7e286d304" id="r_aad39ec48980e7ee4339642e7e286d304"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad39ec48980e7ee4339642e7e286d304">verifyParamProducerTransformOpTrait</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:aad39ec48980e7ee4339642e7e286d304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-template implementation of ParamProducerTransformOpTrait::verify().  <br /></td></tr>
<tr class="memitem:aa8f9cf3218ac160aecacfbdee04aa56b" id="r_aa8f9cf3218ac160aecacfbdee04aa56b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8f9cf3218ac160aecacfbdee04aa56b">checkApplyToOne</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *transformOp, <a class="el" href="classmlir_1_1Location.html">Location</a> payloadOpLoc, const <a class="el" href="classmlir_1_1transform_1_1ApplyToEachResultList.html">ApplyToEachResultList</a> &amp;partialResult)</td></tr>
<tr class="memdesc:aa8f9cf3218ac160aecacfbdee04aa56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the contents of <span class="tt">partialResult</span> matches the number, kind (payload op or parameter) and nullity (either all or none) requirements of <span class="tt">transformOp</span>.  <br /></td></tr>
<tr class="memitem:a7b899140fcc90aabc5b221816337cc4d" id="r_a7b899140fcc90aabc5b221816337cc4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b899140fcc90aabc5b221816337cc4d">setApplyToOneResults</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *transformOp, <a class="el" href="classmlir_1_1transform_1_1TransformResults.html">TransformResults</a> &amp;transformResults, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1transform_1_1ApplyToEachResultList.html">ApplyToEachResultList</a> &gt; results)</td></tr>
<tr class="memdesc:a7b899140fcc90aabc5b221816337cc4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Transpose" the results produced by individual applications, arranging them per result value of the transform op, and populate <span class="tt">transformResults</span> with that.  <br /></td></tr>
<tr class="memitem:afb3bcac37879d4e8c9c4c178600aa017" id="r_afb3bcac37879d4e8c9c4c178600aa017"><td class="memTemplParams" colspan="2">template&lt;typename TransformOpTy, typename <a class="el" href="structmlir_1_1Range.html">Range</a>&gt; </td></tr>
<tr class="memitem:afb3bcac37879d4e8c9c4c178600aa017 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb3bcac37879d4e8c9c4c178600aa017">applyTransformToEach</a> (TransformOpTy transformOp, <a class="el" href="classmlir_1_1transform_1_1TransformRewriter.html">TransformRewriter</a> &amp;rewriter, <a class="el" href="structmlir_1_1Range.html">Range</a> &amp;&amp;targets, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1transform_1_1ApplyToEachResultList.html">ApplyToEachResultList</a> &gt; &amp;results, <a class="el" href="classmlir_1_1transform_1_1TransformState.html">TransformState</a> &amp;state)</td></tr>
<tr class="memdesc:afb3bcac37879d4e8c9c4c178600aa017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a one-to-one or a one-to-many transform to each of the given targets.  <br /></td></tr>
<tr class="memitem:a8ee541c7d80632f563472fe99ba8e684" id="r_a8ee541c7d80632f563472fe99ba8e684"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ee541c7d80632f563472fe99ba8e684">checkNestedConsumption</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; targets)</td></tr>
<tr class="memdesc:a8ee541c7d80632f563472fe99ba8e684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports an error and returns failure if <span class="tt">targets</span> contains an ancestor operation before its descendant (or a copy of itself).  <br /></td></tr>
<tr class="memitem:ac972c3c018134f06d3406b1237310cbb" id="r_ac972c3c018134f06d3406b1237310cbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac972c3c018134f06d3406b1237310cbb">checkImplementsTransformOpInterface</a> (StringRef name, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ac972c3c018134f06d3406b1237310cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that the operations provided as template arguments implement the TransformOpInterface and MemoryEffectsOpInterface.  <br /></td></tr>
<tr class="memitem:a66abffa78647df1f7e48d10ed3c5eeec" id="r_a66abffa78647df1f7e48d10ed3c5eeec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66abffa78647df1f7e48d10ed3c5eeec">checkImplementsTransformHandleTypeInterface</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> typeID, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a66abffa78647df1f7e48d10ed3c5eeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that the type provided as template argument implements the TransformHandleTypeInterface.  <br /></td></tr>
<tr class="memitem:a4b901961a14a54c8a5ce44fbc17e61e6" id="r_a4b901961a14a54c8a5ce44fbc17e61e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b901961a14a54c8a5ce44fbc17e61e6">mergeSymbolsInto</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>, <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; other)</td></tr>
<tr class="memdesc:a4b901961a14a54c8a5ce44fbc17e61e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge all symbols from <span class="tt">other</span> into <span class="tt">target</span>.  <br /></td></tr>
<tr class="memitem:a6312474ea1986d03c2788246b215e70e" id="r_a6312474ea1986d03c2788246b215e70e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6312474ea1986d03c2788246b215e70e">expandPathsToMLIRFiles</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; paths, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; std::string &gt; &amp;fileNames)</td></tr>
<tr class="memdesc:a6312474ea1986d03c2788246b215e70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands the given list of <span class="tt">paths</span> to a list of <span class="tt">.mlir</span> files.  <br /></td></tr>
<tr class="memitem:a1e51908acb17379cdee600e5d14eb504" id="r_a1e51908acb17379cdee600e5d14eb504"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e51908acb17379cdee600e5d14eb504">parseTransformModuleFromFile</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, llvm::StringRef transformFileName, <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt; &amp;transformModule)</td></tr>
<tr class="memdesc:a1e51908acb17379cdee600e5d14eb504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to parse and verify the content of a <span class="tt">transformFileName</span> MLIR file containing a transform dialect specification.  <br /></td></tr>
<tr class="memitem:a0ff3c0c4abf23c806d81a4897c638fa8" id="r_a0ff3c0c4abf23c806d81a4897c638fa8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ff3c0c4abf23c806d81a4897c638fa8">assembleTransformLibraryFromPaths</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; transformLibraryPaths, <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt; &amp;transformModule)</td></tr>
<tr class="memdesc:a0ff3c0c4abf23c806d81a4897c638fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to parse, verify, aggregate and link the content of all mlir files nested under <span class="tt">transformLibraryPaths</span> and containing transform dialect specifications.  <br /></td></tr>
<tr class="memitem:a2413cdd0547cc80c81350234f5b76e43" id="r_a2413cdd0547cc80c81350234f5b76e43"><td class="memItemLeft" align="right" valign="top">ModuleOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2413cdd0547cc80c81350234f5b76e43">getPreloadedTransformModule</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a2413cdd0547cc80c81350234f5b76e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to load a transform interpreter <span class="tt">module</span> from a module that has already been preloaded in the context.  <br /></td></tr>
<tr class="memitem:a8e95146317beb53f05b36c2d9d7a4267" id="r_a8e95146317beb53f05b36c2d9d7a4267"><td class="memItemLeft" align="right" valign="top">TransformOpInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e95146317beb53f05b36c2d9d7a4267">findTransformEntryPoint</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *root, ModuleOp module, StringRef entryPoint=TransformDialect::kTransformEntryPointSymbolName)</td></tr>
<tr class="memdesc:a8e95146317beb53f05b36c2d9d7a4267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first TransformOpInterface named <span class="tt">kTransformEntryPointSymbolName</span> that is either:  <br /></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a5e775963104a18977a3ae5a6f67a5a88" name="a5e775963104a18977a3ae5a6f67a5a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e775963104a18977a3ae5a6f67a5a88">&#9670;&#160;</a></span>appendValueMappings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::transform::detail::appendValueMappings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir_1_1transform.html#a5fb1ec52849c25d93b80118a5b02ffc8">transform::MappedValue</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>mappings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1transform_1_1TransformState.html">transform::TransformState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>flatten</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the entities associated with the given transform values in <span class="tt">state</span> to the pre-existing list of mappings. </p>
<p>The array of mappings must have as many elements as values. If <span class="tt">flatten</span> is set, multiple values may be associated with each transform value, and this always succeeds. Otherwise, checks that each value has exactly one mapping associated and return failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01533">1533</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="TransformInterfaces_8cpp_source.html#l00076">mlir::transform::TransformState::getParams()</a>, <a class="el" href="TransformInterfaces_8h_source.html#l00248">mlir::transform::TransformState::getPayloadOps()</a>, <a class="el" href="TransformInterfaces_8h_source.html#l00277">mlir::transform::TransformState::getPayloadValues()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterfaces_8cpp_source.html#l01556">prepareValueMappings()</a>.</p>

</div>
</div>
<a id="afb3bcac37879d4e8c9c4c178600aa017" name="afb3bcac37879d4e8c9c4c178600aa017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3bcac37879d4e8c9c4c178600aa017">&#9670;&#160;</a></span>applyTransformToEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TransformOpTy, typename <a class="el" href="structmlir_1_1Range.html">Range</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a> mlir::transform::detail::applyTransformToEach </td>
          <td>(</td>
          <td class="paramtype">TransformOpTy</td>          <td class="paramname"><span class="paramname"><em>transformOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1transform_1_1TransformRewriter.html">TransformRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Range.html">Range</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>targets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1transform_1_1ApplyToEachResultList.html">ApplyToEachResultList</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>results</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1transform_1_1TransformState.html">TransformState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a one-to-one or a one-to-many transform to each of the given targets. </p>
<p>Puts the results of transforms, if any, in <span class="tt">results</span> in the same order. Fails if any of the application fails. Individual transforms must be callable with the following signature:</p><ul>
<li>DiagnosedSilenceableFailure(OpTy,
      SmallVector&lt;Operation*&gt; &amp;results, state) where OpTy is either</li>
<li><a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> *, in which case the transform is always applied;</li>
<li>a concrete <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a> class, in which case a check is performed whether <span class="tt">targets</span> contains operations of the same class and a silenceable failure is reported if it does not. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8h_source.html#l01497">1497</a> of file <a class="el" href="TransformInterfaces_8h_source.html">TransformInterfaces.h</a>.</p>

<p class="reference">References <a class="el" href="TransformInterfaces_8cpp_source.html#l01444">checkApplyToOne()</a>, <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00054">mlir::DiagnosedSilenceableFailure::definiteFailure()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00057">diag()</a>, <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00044">mlir::Error</a>, <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00080">mlir::DiagnosedSilenceableFailure::isDefiniteFailure()</a>, <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00085">mlir::DiagnosedSilenceableFailure::isSilenceableFailure()</a>, <a class="el" href="TransformInterfaces_8h_source.html#l01447">mlir::transform::ApplyToEachResultList::reserve()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00061">mlir::DiagnosedSilenceableFailure::silenceableFailure()</a>, <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00048">mlir::DiagnosedSilenceableFailure::success()</a>, <a class="el" href="DiagnosedSilenceableFailure_8h_source.html#l00118">mlir::DiagnosedSilenceableFailure::takeDiagnostics()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterfaces_8h_source.html#l01557">mlir::transform::TransformEachOpTrait&lt; OpTy &gt;::apply()</a>.</p>

</div>
</div>
<a id="a0ff3c0c4abf23c806d81a4897c638fa8" name="a0ff3c0c4abf23c806d81a4897c638fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff3c0c4abf23c806d81a4897c638fa8">&#9670;&#160;</a></span>assembleTransformLibraryFromPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::transform::detail::assembleTransformLibraryFromPaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>transformLibraryPaths</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>transformModule</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to parse, verify, aggregate and link the content of all mlir files nested under <span class="tt">transformLibraryPaths</span> and containing transform dialect specifications. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00216">216</a> of file <a class="el" href="TransformInterpreterUtils_8cpp_source.html">TransformInterpreterUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00039">expandPathsToMLIRFiles()</a>, <a class="el" href="Location_8cpp_source.html#l00157">mlir::FileLineColLoc::get()</a>, <a class="el" href="OwningOpRef_8h_source.html#l00051">mlir::OwningOpRef&lt; OpTy &gt;::get()</a>, <a class="el" href="Dialect_2Transform_2IR_2Utils_8cpp_source.html#l00080">mergeSymbolsInto()</a>, <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00088">parseTransformModuleFromFile()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="aa8f9cf3218ac160aecacfbdee04aa56b" name="aa8f9cf3218ac160aecacfbdee04aa56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f9cf3218ac160aecacfbdee04aa56b">&#9670;&#160;</a></span>checkApplyToOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::transform::detail::checkApplyToOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>transformOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>payloadOpLoc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1transform_1_1ApplyToEachResultList.html">ApplyToEachResultList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>partialResult</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that the contents of <span class="tt">partialResult</span> matches the number, kind (payload op or parameter) and nullity (either all or none) requirements of <span class="tt">transformOp</span>. </p>
<p>Report errors and return failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01444">1444</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l00057">diag()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00310">emitDiag()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">mlir::emitError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="OperationSupport_8h_source.html#l00473">mlir::OperationName::getStringRef()</a>, <a class="el" href="TransformInterfaces_8h_source.html#l01456">mlir::transform::ApplyToEachResultList::size()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterfaces_8h_source.html#l01497">applyTransformToEach()</a>.</p>

</div>
</div>
<a id="a66abffa78647df1f7e48d10ed3c5eeec" name="a66abffa78647df1f7e48d10ed3c5eeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66abffa78647df1f7e48d10ed3c5eeec">&#9670;&#160;</a></span>checkImplementsTransformHandleTypeInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::transform::detail::checkImplementsTransformHandleTypeInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a></td>          <td class="paramname"><span class="paramname"><em>typeID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts that the type provided as template argument implements the TransformHandleTypeInterface. </p>
<p>This must be a dynamic assertion since interface implementations may be registered at runtime. </p>

<p class="definition">Definition at line <a class="el" href="TransformDialect_8cpp_source.html#l00052">52</a> of file <a class="el" href="TransformDialect_8cpp_source.html">TransformDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01011">mlir::AbstractType::lookup()</a>.</p>

</div>
</div>
<a id="ac972c3c018134f06d3406b1237310cbb" name="ac972c3c018134f06d3406b1237310cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac972c3c018134f06d3406b1237310cbb">&#9670;&#160;</a></span>checkImplementsTransformOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::transform::detail::checkImplementsTransformOpInterface </td>
          <td>(</td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts that the operations provided as template arguments implement the TransformOpInterface and MemoryEffectsOpInterface. </p>
<p>This must be a dynamic assertion since interface implementations may be registered at runtime. </p>

<p class="definition">Definition at line <a class="el" href="TransformDialect_8cpp_source.html#l00028">28</a> of file <a class="el" href="TransformDialect_8cpp_source.html">TransformDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00371">mlir::OperationName::hasInterface()</a>, <a class="el" href="OperationSupport_8h_source.html#l00277">mlir::OperationName::hasTrait()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l00953">mlir::RegisteredOperationName::lookup()</a>.</p>

</div>
</div>
<a id="a8ee541c7d80632f563472fe99ba8e684" name="a8ee541c7d80632f563472fe99ba8e684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee541c7d80632f563472fe99ba8e684">&#9670;&#160;</a></span>checkNestedConsumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::transform::detail::checkNestedConsumption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>targets</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports an error and returns failure if <span class="tt">targets</span> contains an ancestor operation before its descendant (or a copy of itself). </p>
<p>Implementation detail for expensive checks during <span class="tt"><a class="el" href="classmlir_1_1transform_1_1TransformEachOpTrait.html#af845e7db5cfedefa62d5ebe8531f6d3b" title="Calls applyToOne for every payload operation associated with the operand of this transform IR op,...">TransformEachOpTrait::apply</a></span>. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01422">1422</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l00057">diag()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">mlir::emitError()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterfaces_8h_source.html#l01557">mlir::transform::TransformEachOpTrait&lt; OpTy &gt;::apply()</a>.</p>

</div>
</div>
<a id="a6312474ea1986d03c2788246b215e70e" name="a6312474ea1986d03c2788246b215e70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6312474ea1986d03c2788246b215e70e">&#9670;&#160;</a></span>expandPathsToMLIRFiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::transform::detail::expandPathsToMLIRFiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>paths</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fileNames</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expands the given list of <span class="tt">paths</span> to a list of <span class="tt">.mlir</span> files. </p>
<p>Each entry in <span class="tt">paths</span> may either be a regular file, in which case it ends up in the result list, or a directory, in which case all (regular) <span class="tt">.mlir</span> files in that directory are added. Any other file types lead to a failure. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00039">39</a> of file <a class="el" href="TransformInterpreterUtils_8cpp_source.html">TransformInterpreterUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00032">DBGS</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">mlir::emitError()</a>, <a class="el" href="Location_8cpp_source.html#l00157">mlir::FileLineColLoc::get()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00216">assembleTransformLibraryFromPaths()</a>.</p>

</div>
</div>
<a id="a8e95146317beb53f05b36c2d9d7a4267" name="a8e95146317beb53f05b36c2d9d7a4267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e95146317beb53f05b36c2d9d7a4267">&#9670;&#160;</a></span>findTransformEntryPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">transform::TransformOpInterface mlir::transform::detail::findTransformEntryPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleOp</td>          <td class="paramname"><span class="paramname"><em>module</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>entryPoint</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TransformDialect::kTransformEntryPointSymbolName</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first TransformOpInterface named <span class="tt">kTransformEntryPointSymbolName</span> that is either: </p>
<ol type="1">
<li>nested under <span class="tt">root</span> (takes precedence).</li>
<li>nested under <span class="tt">module</span>, if not found in <span class="tt">root</span>. Reports errors and returns null if no such operation found. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00199">199</a> of file <a class="el" href="TransformInterpreterUtils_8cpp_source.html">TransformInterpreterUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l00057">diag()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, and <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00190">findTransformEntryPointInOp()</a>.</p>

</div>
</div>
<a id="a81d536d06d24d9780714574520f14e25" name="a81d536d06d24d9780714574520f14e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d536d06d24d9780714574520f14e25">&#9670;&#160;</a></span>forwardTerminatorOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::transform::detail::forwardTerminatorOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1transform_1_1TransformState.html">transform::TransformState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1transform_1_1TransformResults.html">transform::TransformResults</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>results</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">results</span> with payload associations that match exactly those of the operands to <span class="tt">block</span>'s terminator. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01566">1566</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00420">mlir::Operation::getOpResults()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00076">mlir::transform::TransformState::getParams()</a>, <a class="el" href="Block_8cpp_source.html#l00031">mlir::Block::getParentOp()</a>, <a class="el" href="TransformInterfaces_8h_source.html#l00248">mlir::transform::TransformState::getPayloadOps()</a>, <a class="el" href="TransformInterfaces_8h_source.html#l00277">mlir::transform::TransformState::getPayloadValues()</a>, <a class="el" href="Block_8cpp_source.html#l00244">mlir::Block::getTerminator()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, <a class="el" href="TransformInterfaces_8h_source.html#l00824">mlir::transform::TransformResults::set()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01079">mlir::transform::TransformResults::setParams()</a>, and <a class="el" href="TransformInterfaces_8h_source.html#l00856">mlir::transform::TransformResults::setValues()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformOps_8cpp_source.html#l02016">applySequenceBlock()</a>.</p>

</div>
</div>
<a id="a0a3d6c26ca1ca817dad960606875fb3b" name="a0a3d6c26ca1ca817dad960606875fb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3d6c26ca1ca817dad960606875fb3b">&#9670;&#160;</a></span>getConsumedHandleOpOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt; mlir::transform::detail::getConsumedHandleOpOperands </td>
          <td>(</td>
          <td class="paramtype">transform::TransformOpInterface</td>          <td class="paramname"><span class="paramname"><em>transformOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all operands that are handles and being consumed by the given op. </p>

</div>
</div>
<a id="a8c4853c22618926e8e9f6505afcdff9d" name="a8c4853c22618926e8e9f6505afcdff9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4853c22618926e8e9f6505afcdff9d">&#9670;&#160;</a></span>getParamProducerTransformOpTraitEffects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::transform::detail::getParamProducerTransformOpTraitEffects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="namespacemlir_1_1MemoryEffects.html#aba14da80da7a4a192a129fecdb0ac624">MemoryEffects::EffectInstance</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>effects</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-template implementation of <a class="el" href="classmlir_1_1transform_1_1ParamProducerTransformOpTrait.html#ad3321e39e0c4a2102e0ab54da46788c7" title="Populates effects with effect instances described in the trait documentation.">ParamProducerTransformOpTrait::getEffects()</a>. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01753">1753</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01843">mlir::transform::onlyReadsHandle()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01858">mlir::transform::onlyReadsPayload()</a>, and <a class="el" href="TransformInterfaces_8cpp_source.html#l01821">mlir::transform::producesHandle()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterfaces_8h_source.html#l01381">mlir::transform::ParamProducerTransformOpTrait&lt; OpTy &gt;::getEffects()</a>.</p>

</div>
</div>
<a id="afc8c491c51ccdf3437db9ee7486b083a" name="afc8c491c51ccdf3437db9ee7486b083a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8c491c51ccdf3437db9ee7486b083a">&#9670;&#160;</a></span>getPotentialTopLevelEffects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::transform::detail::getPotentialTopLevelEffects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>operation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="namespacemlir_1_1MemoryEffects.html#aba14da80da7a4a192a129fecdb0ac624">MemoryEffects::EffectInstance</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>effects</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">effects</span> with side effects implied by <a class="el" href="classmlir_1_1transform_1_1PossibleTopLevelTransformOpTrait.html" title="This trait is supposed to be attached to Transform dialect operations that can be standalone top-leve...">PossibleTopLevelTransformOpTrait</a> for the given operation. </p>
<p>The operation may have an optional <span class="tt">root</span> operand, indicating it is not in fact top-level. It is also expected to have a single-block body. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01629">1629</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00420">mlir::Operation::getOpResults()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01843">mlir::transform::onlyReadsHandle()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01821">mlir::transform::producesHandle()</a>, and <a class="el" href="TransformInterfaces_8cpp_source.html#l01611">remapArgumentEffects()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterfaces_8h_source.html#l01170">mlir::transform::PossibleTopLevelTransformOpTrait&lt; OpTy &gt;::getPotentialTopLevelEffects()</a>.</p>

</div>
</div>
<a id="a2413cdd0547cc80c81350234f5b76e43" name="a2413cdd0547cc80c81350234f5b76e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2413cdd0547cc80c81350234f5b76e43">&#9670;&#160;</a></span>getPreloadedTransformModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ModuleOp mlir::transform::detail::getPreloadedTransformModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to load a transform interpreter <span class="tt">module</span> from a module that has already been preloaded in the context. </p>
<p>This mode is useful in cases where explicit parsing of a transform library from file is expected to be prohibitively expensive. In such cases, the transform module is expected to be found in the preloaded library modules of the transform dialect. Returns null if the module is not found. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00119">119</a> of file <a class="el" href="TransformInterpreterUtils_8cpp_source.html">TransformInterpreterUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8h_source.html#l00100">mlir::MLIRContext::getOrLoadDialect()</a>.</p>

</div>
</div>
<a id="a9c029c6849c69a0f311170959ae70966" name="a9c029c6849c69a0f311170959ae70966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c029c6849c69a0f311170959ae70966">&#9670;&#160;</a></span>makeTransformStateForTesting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1transform_1_1TransformState.html">transform::TransformState</a> mlir::transform::detail::makeTransformStateForTesting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>payloadRoot</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a dummy transform state for testing purposes. </p>
<p>This MUST NOT be used outside of test cases. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01587">1587</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a97376b0a911f5a44f05410e33d7fe30e" name="a97376b0a911f5a44f05410e33d7fe30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97376b0a911f5a44f05410e33d7fe30e">&#9670;&#160;</a></span>mapPossibleTopLevelTransformOpBlockArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::transform::detail::mapPossibleTopLevelTransformOpBlockArguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1transform_1_1TransformState.html">TransformState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps the only block argument of the op with <a class="el" href="classmlir_1_1transform_1_1PossibleTopLevelTransformOpTrait.html" title="This trait is supposed to be attached to Transform dialect operations that can be standalone top-leve...">PossibleTopLevelTransformOpTrait</a> to either the list of operations associated with its operand or the root of the payload IR, depending on what is available in the context. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01651">1651</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">mlir::emitError()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="Block_8h_source.html#l00129">mlir::Block::getArgument()</a>, <a class="el" href="Block_8h_source.html#l00087">mlir::Block::getArguments()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getNumArguments()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00346">mlir::Operation::getNumOperands()</a>, <a class="el" href="TransformInterfaces_8h_source.html#l00237">mlir::transform::TransformState::getNumTopLevelMappings()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="TransformInterfaces_8h_source.html#l00248">mlir::transform::TransformState::getPayloadOps()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00064">mlir::transform::TransformState::getTopLevel()</a>, <a class="el" href="TransformInterfaces_8h_source.html#l00240">mlir::transform::TransformState::getTopLevelMapping()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l00189">mlir::transform::TransformState::mapBlockArgument()</a>, <a class="el" href="TransformInterfaces_8h_source.html#l00326">mlir::transform::TransformState::mapBlockArguments()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01556">prepareValueMappings()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterfaces_8h_source.html#l01180">mlir::transform::PossibleTopLevelTransformOpTrait&lt; OpTy &gt;::mapBlockArguments()</a>.</p>

</div>
</div>
<a id="accfe7c2cf4c9692e48bfb28f0fb39b9b" name="accfe7c2cf4c9692e48bfb28f0fb39b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfe7c2cf4c9692e48bfb28f0fb39b9b">&#9670;&#160;</a></span>matchOptionalOperation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a> mlir::transform::detail::matchOptionalOperation </td>
          <td>(</td>
          <td class="paramtype">OpTy</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1transform_1_1TransformResults.html">TransformResults</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>results</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1transform_1_1TransformState.html">TransformState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch <span class="tt">matchOperation</span> based on Operation* or std::optional&lt;Operation*&gt; first operand. </p>

<p class="definition">Definition at line <a class="el" href="MatchInterfaces_8h_source.html#l00027">27</a> of file <a class="el" href="MatchInterfaces_8h_source.html">MatchInterfaces.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="MatchInterfaces_8h_source.html#l00086">mlir::transform::AtMostOneOpMatcherOpTrait&lt; OpTy &gt;::apply()</a>.</p>

</div>
</div>
<a id="a4b901961a14a54c8a5ce44fbc17e61e6" name="a4b901961a14a54c8a5ce44fbc17e61e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b901961a14a54c8a5ce44fbc17e61e6">&#9670;&#160;</a></span>mergeSymbolsInto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::transform::detail::mergeSymbolsInto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge all symbols from <span class="tt">other</span> into <span class="tt">target</span>. </p>
<p>Both ops need to implement the <span class="tt"><a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a></span> trait. Operations are moved from <span class="tt">other</span>, i.e., <span class="tt">other</span> may be modified by this function and might not verify after the function returns. Upon merging, private symbols may be renamed in order to avoid collisions in the result. Public symbols may not collide, with the exception of instances of <span class="tt">SymbolOpInterface</span>, where collisions are allowed if at least one of the two is external, in which case the other op preserved (or any one of the two if both are external). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Transform_2IR_2Utils_8cpp_source.html#l00080">80</a> of file <a class="el" href="Dialect_2Transform_2IR_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Transform_2IR_2Utils_8cpp_source.html#l00025">canMergeInto()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00057">diag()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00686">mlir::Operation::getRegion()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00170">mlir::SymbolTable::insert()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00142">mlir::SymbolTable::lookup()</a>, <a class="el" href="Dialect_2Transform_2IR_2Utils_8cpp_source.html#l00032">mergeInto()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00149">mlir::SymbolTable::remove()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>, and <a class="el" href="Verifier_8cpp_source.html#l00423">mlir::verify()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00265">mlir::transform::applyTransformNamedSequence()</a>, <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00216">assembleTransformLibraryFromPaths()</a>, and <a class="el" href="CAPI_2Dialect_2TransformInterpreter_8cpp_source.html#l00076">mlirMergeSymbolsIntoFromClone()</a>.</p>

</div>
</div>
<a id="a1e51908acb17379cdee600e5d14eb504" name="a1e51908acb17379cdee600e5d14eb504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e51908acb17379cdee600e5d14eb504">&#9670;&#160;</a></span>parseTransformModuleFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::transform::detail::parseTransformModuleFromFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef</td>          <td class="paramname"><span class="paramname"><em>transformFileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>transformModule</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to parse and verify the content of a <span class="tt">transformFileName</span> MLIR file containing a transform dialect specification. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00088">88</a> of file <a class="el" href="TransformInterpreterUtils_8cpp_source.html">TransformInterpreterUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00032">DBGS</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">mlir::emitError()</a>, <a class="el" href="Location_8cpp_source.html#l00157">mlir::FileLineColLoc::get()</a>, <a class="el" href="namespacemlir.html#a5ca85238ce4c87b3f6c9c5dd1c0969f7">mlir::openInputFile()</a>, <a class="el" href="Tools_2PDLL_2Parser_2Parser_8cpp_source.html#l00038">mlir::parseSourceFile()</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="Verifier_8cpp_source.html#l00423">mlir::verify()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00216">assembleTransformLibraryFromPaths()</a>.</p>

</div>
</div>
<a id="ab9fccd8f879c8e6b65fafbda237918eb" name="ab9fccd8f879c8e6b65fafbda237918eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fccd8f879c8e6b65fafbda237918eb">&#9670;&#160;</a></span>prepareValueMappings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::transform::detail::prepareValueMappings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir_1_1transform.html#a5fb1ec52849c25d93b80118a5b02ffc8">transform::MappedValue</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mappings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1transform_1_1TransformState.html">transform::TransformState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">mappings</span> with mapped values associated with the given transform IR values in the given <span class="tt">state</span>. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01556">1556</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="TransformInterfaces_8cpp_source.html#l01533">appendValueMappings()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterfaces_8cpp_source.html#l01651">mapPossibleTopLevelTransformOpBlockArguments()</a>, and <a class="el" href="TransformOps_8cpp_source.html#l01086">matchBlock()</a>.</p>

</div>
</div>
<a id="a7b899140fcc90aabc5b221816337cc4d" name="a7b899140fcc90aabc5b221816337cc4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b899140fcc90aabc5b221816337cc4d">&#9670;&#160;</a></span>setApplyToOneResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::transform::detail::setApplyToOneResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>transformOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1transform_1_1TransformResults.html">TransformResults</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>transformResults</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1transform_1_1ApplyToEachResultList.html">ApplyToEachResultList</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>results</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Transpose" the results produced by individual applications, arranging them per result value of the transform op, and populate <span class="tt">transformResults</span> with that. </p>
<p>The number, kind and nullity of per-application results are assumed to have been verified. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01501">1501</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="TransformInterfaces_8cpp_source.html#l01497">castVector()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="TransformInterfaces_8h_source.html#l00824">mlir::transform::TransformResults::set()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01079">mlir::transform::TransformResults::setParams()</a>, and <a class="el" href="TransformInterfaces_8h_source.html#l00856">mlir::transform::TransformResults::setValues()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterfaces_8h_source.html#l01557">mlir::transform::TransformEachOpTrait&lt; OpTy &gt;::apply()</a>.</p>

</div>
</div>
<a id="aad39ec48980e7ee4339642e7e286d304" name="aad39ec48980e7ee4339642e7e286d304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad39ec48980e7ee4339642e7e286d304">&#9670;&#160;</a></span>verifyParamProducerTransformOpTrait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::transform::detail::verifyParamProducerTransformOpTrait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-template implementation of ParamProducerTransformOpTrait::verify(). </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01768">1768</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00668">mlir::Operation::emitOpError()</a>, <a class="el" href="OperationSupport_8h_source.html#l00344">mlir::OperationName::getInterface()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="OperationSupport_8h_source.html#l00473">mlir::OperationName::getStringRef()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterfaces_8h_source.html#l01389">mlir::transform::ParamProducerTransformOpTrait&lt; OpTy &gt;::verifyTrait()</a>.</p>

</div>
</div>
<a id="af472e3604dc87e29966aba3b81c0a5fb" name="af472e3604dc87e29966aba3b81c0a5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af472e3604dc87e29966aba3b81c0a5fb">&#9670;&#160;</a></span>verifyPossibleTopLevelTransformOpTrait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::transform::detail::verifyPossibleTopLevelTransformOpTrait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verification hook for <a class="el" href="classmlir_1_1transform_1_1PossibleTopLevelTransformOpTrait.html" title="This trait is supposed to be attached to Transform dialect operations that can be standalone top-leve...">PossibleTopLevelTransformOpTrait</a>. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01686">1686</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l00057">diag()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00668">mlir::Operation::emitOpError()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="Value_8h_source.html#l00321">mlir::BlockArgument::getArgNumber()</a>, <a class="el" href="Block_8h_source.html#l00129">mlir::Block::getArgument()</a>, <a class="el" href="Block_8h_source.html#l00087">mlir::Block::getArguments()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getNumArguments()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00346">mlir::Operation::getNumOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00674">mlir::Operation::getNumRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00248">mlir::Operation::getParentWithTrait()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00686">mlir::Operation::getRegion()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterfaces_8cpp_source.html#l01992">mlir::transform::applyTransforms()</a>, and <a class="el" href="TransformInterfaces_8h_source.html#l01160">mlir::transform::PossibleTopLevelTransformOpTrait&lt; OpTy &gt;::verifyTrait()</a>.</p>

</div>
</div>
<a id="ab49efa35a55e8224a1ad36d69d6198c9" name="ab49efa35a55e8224a1ad36d69d6198c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49efa35a55e8224a1ad36d69d6198c9">&#9670;&#160;</a></span>verifyStructuredOpPredicateOpTrait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::transform::detail::verifyStructuredOpPredicateOpTrait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>structuredOpHandle</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgMatchOps_8cpp_source.html#l00144">144</a> of file <a class="el" href="LinalgMatchOps_8cpp_source.html">LinalgMatchOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00668">mlir::Operation::emitOpError()</a>, <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="Block_8h_source.html#l00129">mlir::Block::getArgument()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getNumArguments()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00674">mlir::Operation::getNumRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00686">mlir::Operation::getRegion()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgMatchOps_8h_source.html#l00028">mlir::transform::StructuredOpPredicateOpTrait&lt; OpTy &gt;::verifyTrait()</a>.</p>

</div>
</div>
<a id="a08d70b4f0eb6e462437d65f2d7567055" name="a08d70b4f0eb6e462437d65f2d7567055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d70b4f0eb6e462437d65f2d7567055">&#9670;&#160;</a></span>verifyTransformOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::transform::detail::verifyTransformOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verification hook for TransformOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01925">1925</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l00057">diag()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="SideEffectInterfaces_8h_source.html#l00216">mlir::SideEffects::EffectInstance&lt; EffectT &gt;::getValue()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00217">mlir::hasEffect()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
