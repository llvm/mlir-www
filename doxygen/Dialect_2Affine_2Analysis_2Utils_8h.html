<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: include/mlir/Dialect/Affine/Analysis/Utils.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a href="dir_5654f77406fb9ceec87e68ef828ceea2.html">mlir</a></li><li class="navelem"><a href="dir_d07a6fac82475a065a3b2953573f00a0.html">Dialect</a></li><li class="navelem"><a href="dir_166398e1f0020b3d916a929c669bf538.html">Affine</a></li><li class="navelem"><a href="dir_740c1a08dd185e22adde3d54ecb6f2ad.html">Analysis</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Utils.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="AffineStructures_8h_source.html">mlir/Dialect/Affine/Analysis/AffineStructures.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
</div>
<p><a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:mlir_3A_3Aaffine_3A_3ALoopNestStateCollector" id="r_mlir_3A_3Aaffine_3A_3ALoopNestStateCollector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1LoopNestStateCollector.html">mlir::affine::LoopNestStateCollector</a></td></tr>
<tr class="memitem:mlir_3A_3Aaffine_3A_3AMemRefDependenceGraph" id="r_mlir_3A_3Aaffine_3A_3AMemRefDependenceGraph"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">mlir::affine::MemRefDependenceGraph</a></td></tr>
<tr class="memitem:mlir_3A_3Aaffine_3A_3AMemRefDependenceGraph_3A_3ANode" id="r_mlir_3A_3Aaffine_3A_3AMemRefDependenceGraph_3A_3ANode"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">mlir::affine::MemRefDependenceGraph::Node</a></td></tr>
<tr class="memitem:mlir_3A_3Aaffine_3A_3AMemRefDependenceGraph_3A_3AEdge" id="r_mlir_3A_3Aaffine_3A_3AMemRefDependenceGraph_3A_3AEdge"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html">mlir::affine::MemRefDependenceGraph::Edge</a></td></tr>
<tr class="memitem:mlir_3A_3Aaffine_3A_3ASliceComputationResult" id="r_mlir_3A_3Aaffine_3A_3ASliceComputationResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1SliceComputationResult.html">mlir::affine::SliceComputationResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates different result statuses of slice computation by <span class="tt">computeSliceUnion</span>  <a href="structmlir_1_1affine_1_1SliceComputationResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Aaffine_3A_3AComputationSliceState" id="r_mlir_3A_3Aaffine_3A_3AComputationSliceState"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">mlir::affine::ComputationSliceState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html" title="ComputationSliceState aggregates loop IVs, loop bound AffineMaps and their associated operands for a ...">ComputationSliceState</a> aggregates loop IVs, loop bound AffineMaps and their associated operands for a set of loops within a loop nest (typically the set of loops surrounding a store operation).  <a href="structmlir_1_1affine_1_1ComputationSliceState.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Aaffine_3A_3AMemRefRegion" id="r_mlir_3A_3Aaffine_3A_3AMemRefRegion"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">mlir::affine::MemRefRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A region of a memref's data space; this is typically constructed by analyzing load/store op's on this memref and the index space of loops surrounding such op's.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:mlir" id="r_mlir"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="memitem:mlir_3A_3Aaffine" id="r_mlir_3A_3Aaffine"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html">mlir::affine</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9085efe05b8bc0b7c3b4f643d70eb1e7" id="r_a9085efe05b8bc0b7c3b4f643d70eb1e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a9085efe05b8bc0b7c3b4f643d70eb1e7">mlir::affine::getAffineForIVs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *loops)</td></tr>
<tr class="memdesc:a9085efe05b8bc0b7c3b4f643d70eb1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'loops' with IVs of the affine.for ops surrounding 'op' ordered from the outermost 'affine.for' operation to the innermost one while not traversing outside of the surrounding affine scope.  <br /></td></tr>
<tr class="memitem:a50b5b72a6baee24bfab9faebd198fe9b" id="r_a50b5b72a6baee24bfab9faebd198fe9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a50b5b72a6baee24bfab9faebd198fe9b">mlir::affine::getAffineIVs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivs)</td></tr>
<tr class="memdesc:a50b5b72a6baee24bfab9faebd198fe9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'ivs' with IVs of the surrounding affine.for and affine.parallel ops ordered from the outermost one to the innermost while not traversing outside of the surrounding affine scope.  <br /></td></tr>
<tr class="memitem:a1f8e59ec9faff34b64ebb0411a383c3a" id="r_a1f8e59ec9faff34b64ebb0411a383c3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a1f8e59ec9faff34b64ebb0411a383c3a">mlir::affine::getEnclosingAffineOps</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *ops)</td></tr>
<tr class="memdesc:a1f8e59ec9faff34b64ebb0411a383c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'ops' with affine operations enclosing <span class="tt">op</span> ordered from outermost to innermost while stopping at the boundary of the affine scope.  <br /></td></tr>
<tr class="memitem:ac82ec61d5cae9ebb4489d2ab9ad6e8f8" id="r_ac82ec61d5cae9ebb4489d2ab9ad6e8f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ac82ec61d5cae9ebb4489d2ab9ad6e8f8">mlir::affine::getNestingDepth</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ac82ec61d5cae9ebb4489d2ab9ad6e8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nesting depth of this operation, i.e., the number of loops surrounding this operation.  <br /></td></tr>
<tr class="memitem:a34c1ca39d435d06366058d16b5fe4225" id="r_a34c1ca39d435d06366058d16b5fe4225"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a34c1ca39d435d06366058d16b5fe4225">mlir::affine::isLoopParallelAndContainsReduction</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a34c1ca39d435d06366058d16b5fe4225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a loop is a parallel loop and contains a reduction loop.  <br /></td></tr>
<tr class="memitem:a5ad383995f97dc30a0d6891e33fd499a" id="r_a5ad383995f97dc30a0d6891e33fd499a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a5ad383995f97dc30a0d6891e33fd499a">mlir::affine::getSequentialLoops</a> (AffineForOp forOp, llvm::SmallDenseSet&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; *sequentialLoops)</td></tr>
<tr class="memdesc:a5ad383995f97dc30a0d6891e33fd499a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'sequentialLoops' all sequential loops in loop nest rooted at 'forOp'.  <br /></td></tr>
<tr class="memitem:ab6cceed0c6debb9af0d3bd76c9ed52f4" id="r_ab6cceed0c6debb9af0d3bd76c9ed52f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ab6cceed0c6debb9af0d3bd76c9ed52f4">mlir::affine::getComputationSliceState</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *depSourceOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *depSinkOp, const <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;dependenceConstraints, <a class="el" href="classunsigned.html">unsigned</a> loopDepth, <a class="el" href="classbool.html">bool</a> isBackwardSlice, <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState)</td></tr>
<tr class="memdesc:ab6cceed0c6debb9af0d3bd76c9ed52f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the computation slice loop bounds for one loop nest as affine maps of the other loop nest's IVs and symbols, using 'dependenceConstraints' computed between 'depSourceAccess' and 'depSinkAccess'.  <br /></td></tr>
<tr class="memitem:acfb5cde2210f8126b02cd84843a0c43b" id="r_acfb5cde2210f8126b02cd84843a0c43b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#acfb5cde2210f8126b02cd84843a0c43b">mlir::affine::getSliceIterationCount</a> (const llvm::SmallDenseMap&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, uint64_t, 8 &gt; &amp;sliceTripCountMap)</td></tr>
<tr class="memdesc:acfb5cde2210f8126b02cd84843a0c43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of iterations for the <span class="tt">slicetripCountMap</span> provided.  <br /></td></tr>
<tr class="memitem:af1b7ee261b2662fe2f0c257c9e04f3b6" id="r_af1b7ee261b2662fe2f0c257c9e04f3b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#af1b7ee261b2662fe2f0c257c9e04f3b6">mlir::affine::buildSliceTripCountMap</a> (const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;slice, llvm::SmallDenseMap&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, uint64_t, 8 &gt; *tripCountMap)</td></tr>
<tr class="memdesc:af1b7ee261b2662fe2f0c257c9e04f3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a map 'tripCountMap' from AffineForOp to constant trip count for loop nest surrounding represented by slice loop bounds in 'slice'.  <br /></td></tr>
<tr class="memitem:a29213ed6d6cdad5cdd69bb66c6df863f" id="r_a29213ed6d6cdad5cdd69bb66c6df863f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1affine_1_1SliceComputationResult.html">SliceComputationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a29213ed6d6cdad5cdd69bb66c6df863f">mlir::affine::computeSliceUnion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; opsA, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; opsB, <a class="el" href="classunsigned.html">unsigned</a> loopDepth, <a class="el" href="classunsigned.html">unsigned</a> numCommonLoops, <a class="el" href="classbool.html">bool</a> isBackwardSlice, <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceUnion)</td></tr>
<tr class="memdesc:a29213ed6d6cdad5cdd69bb66c6df863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes in 'sliceUnion' the union of all slice bounds computed at 'loopDepth' between all dependent pairs of ops in 'opsA' and 'opsB', and then verifies if it is valid.  <br /></td></tr>
<tr class="memitem:af32168fb86ad493527c61d139acee48a" id="r_af32168fb86ad493527c61d139acee48a"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#af32168fb86ad493527c61d139acee48a">mlir::affine::insertBackwardComputationSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *srcOpInst, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *dstOpInst, <a class="el" href="classunsigned.html">unsigned</a> dstLoopDepth, <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState)</td></tr>
<tr class="memdesc:af32168fb86ad493527c61d139acee48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the computation contained in the loop nest surrounding 'srcOpInst', slices the iteration space of src loop based on slice bounds in 'sliceState', and inserts the computation slice at the beginning of the operation block of the loop at 'dstLoopDepth' in the loop nest surrounding 'dstOpInst'.  <br /></td></tr>
<tr class="memitem:ac5e109cfdab6f0859fbbc3e0bf08ebac" id="r_ac5e109cfdab6f0859fbbc3e0bf08ebac"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ac5e109cfdab6f0859fbbc3e0bf08ebac">mlir::affine::getIntOrFloatMemRefSizeInBytes</a> (MemRefType memRefType)</td></tr>
<tr class="memdesc:ac5e109cfdab6f0859fbbc3e0bf08ebac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of a memref with element type int or float in bytes if it's statically shaped, std::nullopt otherwise.  <br /></td></tr>
<tr class="memitem:addef193d35d8d7990addced6bcb731c1" id="r_addef193d35d8d7990addced6bcb731c1"><td class="memTemplParams" colspan="2">template&lt;typename LoadOrStoreOpPointer&gt; </td></tr>
<tr class="memitem:addef193d35d8d7990addced6bcb731c1 template"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#addef193d35d8d7990addced6bcb731c1">mlir::affine::boundCheckLoadOrStoreOp</a> (LoadOrStoreOpPointer loadOrStoreOp, <a class="el" href="classbool.html">bool</a> <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:addef193d35d8d7990addced6bcb731c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a load or store op for an out of bound access; returns failure if the access is out of bounds along any of the dimensions, success otherwise.  <br /></td></tr>
<tr class="memitem:a3a39bbf8628440572cdd76a10d58dc53" id="r_a3a39bbf8628440572cdd76a10d58dc53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a3a39bbf8628440572cdd76a10d58dc53">mlir::affine::getNumCommonSurroundingLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;a, <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>)</td></tr>
<tr class="memdesc:a3a39bbf8628440572cdd76a10d58dc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of surrounding loops common to both A and B.  <br /></td></tr>
<tr class="memitem:a93666d2fb7a3b0598ecf69542f1a5ab7" id="r_a93666d2fb7a3b0598ecf69542f1a5ab7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a93666d2fb7a3b0598ecf69542f1a5ab7">mlir::affine::getMemoryFootprintBytes</a> (AffineForOp forOp, int memorySpace=-1)</td></tr>
<tr class="memdesc:a93666d2fb7a3b0598ecf69542f1a5ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memory footprint of all data touched in the specified memory space in bytes; if the memory space is unspecified, considers all memory spaces.  <br /></td></tr>
<tr class="memitem:afd9e0f536b1471778961ba51c2227f07" id="r_afd9e0f536b1471778961ba51c2227f07"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#afd9e0f536b1471778961ba51c2227f07">mlir::affine::getMemRefIntOrFloatEltSizeInBytes</a> (MemRefType memRefType)</td></tr>
<tr class="memdesc:afd9e0f536b1471778961ba51c2227f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memref's element type's size in bytes where the elemental type is an int or float or a vector of such types.  <br /></td></tr>
<tr class="memitem:a1f2e85e904cf88ca63479dad00941e87" id="r_a1f2e85e904cf88ca63479dad00941e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a1f2e85e904cf88ca63479dad00941e87">mlir::affine::simplifyIntegerSet</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="memdesc:a1f2e85e904cf88ca63479dad00941e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the integer set by simplifying the underlying affine expressions by flattening and some simple inference.  <br /></td></tr>
<tr class="memitem:a9cc3df9a0cea6ad3bf48958ad2d54128" id="r_a9cc3df9a0cea6ad3bf48958ad2d54128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a9cc3df9a0cea6ad3bf48958ad2d54128">mlir::affine::getInnermostCommonLoopDepth</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *surroundingLoops=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a9cc3df9a0cea6ad3bf48958ad2d54128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the innermost common loop depth for the set of operations in 'ops'.  <br /></td></tr>
<tr class="memitem:af4c9fec2934b9a14a5883e9fabbe3f49" id="r_af4c9fec2934b9a14a5883e9fabbe3f49"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html">AffineValueMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#af4c9fec2934b9a14a5883e9fabbe3f49">mlir::affine::simplifyConstrainedMinMaxOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> constraints)</td></tr>
<tr class="memdesc:af4c9fec2934b9a14a5883e9fabbe3f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to simplify the given affine.min or affine.max op to an affine map with a single result and operands, taking into account the specified constraint set.  <br /></td></tr>
<tr class="memitem:ae33ee1431de2b7e6802c9270b1ff60d1" id="r_ae33ee1431de2b7e6802c9270b1ff60d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html">mlir::Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ae33ee1431de2b7e6802c9270b1ff60d1">mlir::affine::findInnermostCommonBlockInScope</a> (<a class="el" href="classmlir_1_1Operation.html">mlir::Operation</a> *a, <a class="el" href="classmlir_1_1Operation.html">mlir::Operation</a> *<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>)</td></tr>
<tr class="memdesc:ae33ee1431de2b7e6802c9270b1ff60d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the innermost common <span class="tt"><a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a></span> of <span class="tt">a</span> and <span class="tt">b</span> in the affine scope that <span class="tt">a</span> and <span class="tt">b</span> are part of.  <br /></td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
