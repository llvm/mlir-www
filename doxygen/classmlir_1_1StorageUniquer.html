<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::StorageUniquer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1StorageUniquer.html">StorageUniquer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlir_1_1StorageUniquer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::StorageUniquer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A utility class to get or create instances of "storage classes".  
 <a href="classmlir_1_1StorageUniquer.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="StorageUniquer_8h_source.html">mlir/Support/StorageUniquer.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mlir::StorageUniquer:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classmlir_1_1StorageUniquer__inherit__graph.svg" width="179" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer_1_1BaseStorage.html">BaseStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class acts as the base storage that all storage classes must derived from.  <a href="classmlir_1_1StorageUniquer_1_1BaseStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a utility allocator used to allocate memory for instances of derived types.  <a href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1f5e53b96192c7a25b6ab0523483c5b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#a1f5e53b96192c7a25b6ab0523483c5b3">StorageUniquer</a> ()</td></tr>
<tr class="separator:a1f5e53b96192c7a25b6ab0523483c5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4766e45fc3cd0a11f578e2adaa5f01f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#ac4766e45fc3cd0a11f578e2adaa5f01f">~StorageUniquer</a> ()</td></tr>
<tr class="separator:ac4766e45fc3cd0a11f578e2adaa5f01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3929c9fc0d5c77c3978f49ba88465f9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#a3929c9fc0d5c77c3978f49ba88465f9a">disableMultithreading</a> (bool disable=true)</td></tr>
<tr class="memdesc:a3929c9fc0d5c77c3978f49ba88465f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flag specifying if multi-threading is disabled within the uniquer.  <a href="classmlir_1_1StorageUniquer.html#a3929c9fc0d5c77c3978f49ba88465f9a">More...</a><br /></td></tr>
<tr class="separator:a3929c9fc0d5c77c3978f49ba88465f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47a419c58694e2fdcd1faf26af803e8"><td class="memTemplParams" colspan="2">template&lt;typename Storage &gt; </td></tr>
<tr class="memitem:af47a419c58694e2fdcd1faf26af803e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#af47a419c58694e2fdcd1faf26af803e8">registerParametricStorageType</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id)</td></tr>
<tr class="memdesc:af47a419c58694e2fdcd1faf26af803e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new parametric storage class, this is necessary to create instances of this class type.  <a href="classmlir_1_1StorageUniquer.html#af47a419c58694e2fdcd1faf26af803e8">More...</a><br /></td></tr>
<tr class="separator:af47a419c58694e2fdcd1faf26af803e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95af1c87864a2055a591af5694ab678f"><td class="memTemplParams" colspan="2">template&lt;typename Storage &gt; </td></tr>
<tr class="memitem:a95af1c87864a2055a591af5694ab678f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#a95af1c87864a2055a591af5694ab678f">registerParametricStorageType</a> ()</td></tr>
<tr class="memdesc:a95af1c87864a2055a591af5694ab678f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility override when the storage type represents the type id.  <a href="classmlir_1_1StorageUniquer.html#a95af1c87864a2055a591af5694ab678f">More...</a><br /></td></tr>
<tr class="separator:a95af1c87864a2055a591af5694ab678f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c76f657e631fa4f852ddb9318f245b3"><td class="memTemplParams" colspan="2">template&lt;typename Storage &gt; </td></tr>
<tr class="memitem:a6c76f657e631fa4f852ddb9318f245b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#a6c76f657e631fa4f852ddb9318f245b3">registerSingletonStorageType</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(Storage *)&gt; initFn)</td></tr>
<tr class="memdesc:a6c76f657e631fa4f852ddb9318f245b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new singleton storage class, this is necessary to get the singletone instance.  <a href="classmlir_1_1StorageUniquer.html#a6c76f657e631fa4f852ddb9318f245b3">More...</a><br /></td></tr>
<tr class="separator:a6c76f657e631fa4f852ddb9318f245b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3656e781b752de5865c644394ac0d5e"><td class="memTemplParams" colspan="2">template&lt;typename Storage &gt; </td></tr>
<tr class="memitem:af3656e781b752de5865c644394ac0d5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#af3656e781b752de5865c644394ac0d5e">registerSingletonStorageType</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id)</td></tr>
<tr class="separator:af3656e781b752de5865c644394ac0d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1886dc27e347fc25568eb9038f1db7"><td class="memTemplParams" colspan="2">template&lt;typename Storage &gt; </td></tr>
<tr class="memitem:ade1886dc27e347fc25568eb9038f1db7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#ade1886dc27e347fc25568eb9038f1db7">registerSingletonStorageType</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(Storage *)&gt; initFn={})</td></tr>
<tr class="memdesc:ade1886dc27e347fc25568eb9038f1db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility override when the storage type represents the type id.  <a href="classmlir_1_1StorageUniquer.html#ade1886dc27e347fc25568eb9038f1db7">More...</a><br /></td></tr>
<tr class="separator:ade1886dc27e347fc25568eb9038f1db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6f75da7ba66a4cf446744872c3c4e6"><td class="memTemplParams" colspan="2">template&lt;typename Storage , typename... Args&gt; </td></tr>
<tr class="memitem:abc6f75da7ba66a4cf446744872c3c4e6"><td class="memTemplItemLeft" align="right" valign="top">Storage *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#abc6f75da7ba66a4cf446744872c3c4e6">get</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(Storage *)&gt; initFn, <a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:abc6f75da7ba66a4cf446744872c3c4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a uniqued instance of 'Storage'.  <a href="classmlir_1_1StorageUniquer.html#abc6f75da7ba66a4cf446744872c3c4e6">More...</a><br /></td></tr>
<tr class="separator:abc6f75da7ba66a4cf446744872c3c4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c67910e6c361b0acc2a577defbbb7c"><td class="memTemplParams" colspan="2">template&lt;typename Storage , typename... Args&gt; </td></tr>
<tr class="memitem:a57c67910e6c361b0acc2a577defbbb7c"><td class="memTemplItemLeft" align="right" valign="top">Storage *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#a57c67910e6c361b0acc2a577defbbb7c">get</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(Storage *)&gt; initFn, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a57c67910e6c361b0acc2a577defbbb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility override when the storage type represents the type id.  <a href="classmlir_1_1StorageUniquer.html#a57c67910e6c361b0acc2a577defbbb7c">More...</a><br /></td></tr>
<tr class="separator:a57c67910e6c361b0acc2a577defbbb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae8c7d590f89991ae9ca84c59b98b32"><td class="memTemplParams" colspan="2">template&lt;typename Storage &gt; </td></tr>
<tr class="memitem:adae8c7d590f89991ae9ca84c59b98b32"><td class="memTemplItemLeft" align="right" valign="top">Storage *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#adae8c7d590f89991ae9ca84c59b98b32">get</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id)</td></tr>
<tr class="memdesc:adae8c7d590f89991ae9ca84c59b98b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a uniqued instance of 'Storage' which is a singleton storage type.  <a href="classmlir_1_1StorageUniquer.html#adae8c7d590f89991ae9ca84c59b98b32">More...</a><br /></td></tr>
<tr class="separator:adae8c7d590f89991ae9ca84c59b98b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaad7a9c79171fe22e9d745ec51f7f21"><td class="memTemplParams" colspan="2">template&lt;typename Storage &gt; </td></tr>
<tr class="memitem:adaad7a9c79171fe22e9d745ec51f7f21"><td class="memTemplItemLeft" align="right" valign="top">Storage *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#adaad7a9c79171fe22e9d745ec51f7f21">get</a> ()</td></tr>
<tr class="memdesc:adaad7a9c79171fe22e9d745ec51f7f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility override when the storage type represents the type id.  <a href="classmlir_1_1StorageUniquer.html#adaad7a9c79171fe22e9d745ec51f7f21">More...</a><br /></td></tr>
<tr class="separator:adaad7a9c79171fe22e9d745ec51f7f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903554c1946174ffb1f129ed303a7dc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#a903554c1946174ffb1f129ed303a7dc1">isSingletonStorageInitialized</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id)</td></tr>
<tr class="memdesc:a903554c1946174ffb1f129ed303a7dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if there is a singleton storage uniquer initialized for the provided <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a>.  <a href="classmlir_1_1StorageUniquer.html#a903554c1946174ffb1f129ed303a7dc1">More...</a><br /></td></tr>
<tr class="separator:a903554c1946174ffb1f129ed303a7dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36cae692d56d193d7d82f01e99bffdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#ad36cae692d56d193d7d82f01e99bffdd">isParametricStorageInitialized</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id)</td></tr>
<tr class="memdesc:ad36cae692d56d193d7d82f01e99bffdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if there is a parametric storage uniquer initialized for the provided <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a>.  <a href="classmlir_1_1StorageUniquer.html#ad36cae692d56d193d7d82f01e99bffdd">More...</a><br /></td></tr>
<tr class="separator:ad36cae692d56d193d7d82f01e99bffdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487ccdd7e1da2f3e808d63b82fb95d45"><td class="memTemplParams" colspan="2">template&lt;typename Storage , typename... Args&gt; </td></tr>
<tr class="memitem:a487ccdd7e1da2f3e808d63b82fb95d45"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#a487ccdd7e1da2f3e808d63b82fb95d45">mutate</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id, Storage *storage, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a487ccdd7e1da2f3e808d63b82fb95d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the mutable component of 'storage' by forwarding the trailing arguments to the 'mutate' function of the derived class.  <a href="classmlir_1_1StorageUniquer.html#a487ccdd7e1da2f3e808d63b82fb95d45">More...</a><br /></td></tr>
<tr class="separator:a487ccdd7e1da2f3e808d63b82fb95d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A utility class to get or create instances of "storage classes". </p>
<p>These storage classes must derive from '<a class="el" href="classmlir_1_1StorageUniquer_1_1BaseStorage.html" title="This class acts as the base storage that all storage classes must derived from.">StorageUniquer::BaseStorage</a>'.</p>
<p>For non-parametric storage classes, i.e. singleton classes, nothing else is needed. Instances of these classes can be created by calling <code>get</code> without trailing arguments.</p>
<p>Otherwise, the parametric storage classes may be created with <code>get</code>, and must respect the following:</p><ul>
<li>Define a type alias, KeyTy, to a type that uniquely identifies the instance of the storage class.<ul>
<li>The key type must be constructible from the values passed into the getComplex call.</li>
<li>If the KeyTy does not have an <a class="el" href="structllvm_1_1DenseMapInfo.html">llvm::DenseMapInfo</a> specialization, the storage class must define a hashing method: 'static unsigned hashKey(const KeyTy &amp;)'</li>
</ul>
</li>
<li>Provide a method, 'bool operator==(const KeyTy &amp;) const', to compare the storage instance against an instance of the key type.</li>
<li>Provide a static construction method: 'DerivedStorage *construct(<a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html" title="This is a utility allocator used to allocate memory for instances of derived types.">StorageAllocator</a> &amp;, const KeyTy &amp;key)' that builds a unique instance of the derived storage. The arguments to this function are an allocator to store any uniqued data and the key type for this storage.</li>
<li>Provide a cleanup method: 'void cleanup()' that is called when erasing a storage instance. This should cleanup any fields of the storage as necessary and not attempt to free the memory of the storage itself.</li>
</ul>
<p>Storage classes may have an optional mutable component, which must not take part in the unique immutable key. In this case, storage classes may be mutated with <code>mutate</code> and must additionally respect the following:</p><ul>
<li>Provide a mutation method: 'LogicalResult mutate(StorageAllocator &amp;, &lt;...&gt;)' that is called when mutating a storage instance. The first argument is an allocator to store any mutable data, and the remaining arguments are forwarded from the call site. The storage can be mutated at any time after creation. Care must be taken to avoid excessive mutation since the allocated storage can keep containing previous states. The return value of the function is used to indicate whether the mutation was successful, e.g., to limit the number of mutations or enable deferred one-time assignment of the mutable component.</li>
</ul>
<p>All storage classes must be registered with the uniquer via <code>registerParametricStorageType</code> or <code>registerSingletonStorageType</code> using an appropriate unique <code><a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a></code> for the storage class. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00082">82</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1f5e53b96192c7a25b6ab0523483c5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5e53b96192c7a25b6ab0523483c5b3">&#9670;&nbsp;</a></span>StorageUniquer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StorageUniquer::StorageUniquer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8cpp_source.html#l00361">361</a> of file <a class="el" href="StorageUniquer_8cpp_source.html">StorageUniquer.cpp</a>.</p>

</div>
</div>
<a id="ac4766e45fc3cd0a11f578e2adaa5f01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4766e45fc3cd0a11f578e2adaa5f01f">&#9670;&nbsp;</a></span>~StorageUniquer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StorageUniquer::~StorageUniquer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3929c9fc0d5c77c3978f49ba88465f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3929c9fc0d5c77c3978f49ba88465f9a">&#9670;&nbsp;</a></span>disableMultithreading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageUniquer::disableMultithreading </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disable</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the flag specifying if multi-threading is disabled within the uniquer. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8cpp_source.html#l00365">365</a> of file <a class="el" href="StorageUniquer_8cpp_source.html">StorageUniquer.cpp</a>.</p>

</div>
</div>
<a id="adaad7a9c79171fe22e9d745ec51f7f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaad7a9c79171fe22e9d745ec51f7f21">&#9670;&nbsp;</a></span>get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Storage* mlir::StorageUniquer::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility override when the storage type represents the type id. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00235">235</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="a57c67910e6c361b0acc2a577defbbb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c67910e6c361b0acc2a577defbbb7c">&#9670;&nbsp;</a></span>get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Storage* mlir::StorageUniquer::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(Storage *)&gt;&#160;</td>
          <td class="paramname"><em>initFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility override when the storage type represents the type id. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00222">222</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="abc6f75da7ba66a4cf446744872c3c4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6f75da7ba66a4cf446744872c3c4e6">&#9670;&nbsp;</a></span>get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Storage* mlir::StorageUniquer::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(Storage *)&gt;&#160;</td>
          <td class="paramname"><em>initFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a uniqued instance of 'Storage'. </p>
<p>'id' is the type id used when registering the storage instance. 'initFn' is an optional parameter that can be used to initialize a newly inserted storage instance. This function is used for derived types that have complex storage or uniquing constraints. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00195">195</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01009">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00962">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00057">mlir::pdll::ast::AttributeType::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00065">mlir::pdll::ast::ConstraintType::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00136">mlir::pdll::ast::RewriteType::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00167">mlir::pdll::ast::TypeType::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00175">mlir::pdll::ast::ValueType::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00144">mlir::pdll::ast::TupleType::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00073">mlir::pdll::ast::OperationType::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00095">mlir::pdll::ast::RangeType::get()</a>, <a class="el" href="lib_2Conversion_2PDLToPDLInterp_2Predicate_8h_source.html#l00125">mlir::pdl_to_pdl_interp::PredicateBase&lt; ConcreteT, BaseT, void, Kind &gt;::get()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00218">mlir::GenericLatticeAnchorBase&lt; ConcreteT, Value &gt;::get()</a>, <a class="el" href="lib_2Conversion_2PDLToPDLInterp_2Predicate_8h_source.html#l00095">mlir::pdl_to_pdl_interp::PredicateBase&lt; ConcreteT, BaseT, Key, Kind &gt;::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00643">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00608">getAffineDimOrSymbol()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00409">mlir::DataFlowSolver::getProgramPointAfter()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00395">mlir::DataFlowSolver::getProgramPointBefore()</a>, <a class="el" href="AttributeSupport_8h_source.html#l00230">mlir::detail::AttributeUniquer::getWithTypeID()</a>, <a class="el" href="TypeSupport_8h_source.html#l00224">mlir::detail::TypeUniquer::getWithTypeID()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01067">mlir::AffineExpr::operator%()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00891">mlir::AffineExpr::operator*()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00824">mlir::AffineExpr::operator+()</a>.</p>

</div>
</div>
<a id="adae8c7d590f89991ae9ca84c59b98b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae8c7d590f89991ae9ca84c59b98b32">&#9670;&nbsp;</a></span>get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Storage* mlir::StorageUniquer::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a uniqued instance of 'Storage' which is a singleton storage type. </p>
<p>'id' is the type id used when registering the storage instance. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00230">230</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="ad36cae692d56d193d7d82f01e99bffdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36cae692d56d193d7d82f01e99bffdd">&#9670;&nbsp;</a></span>isParametricStorageInitialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageUniquer::isParametricStorageInitialized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if there is a parametric storage uniquer initialized for the provided <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a>. </p>
<p>Test is the parametric storage is initialized.</p>
<p>This is only useful for debugging/diagnostic purpose: the uniquer is initialized when a dialect is loaded. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8cpp_source.html#l00398">398</a> of file <a class="el" href="StorageUniquer_8cpp_source.html">StorageUniquer.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeSupport_8h_source.html#l00230">mlir::detail::AttributeUniquer::getWithTypeID()</a>, and <a class="el" href="TypeSupport_8h_source.html#l00224">mlir::detail::TypeUniquer::getWithTypeID()</a>.</p>

</div>
</div>
<a id="a903554c1946174ffb1f129ed303a7dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903554c1946174ffb1f129ed303a7dc1">&#9670;&nbsp;</a></span>isSingletonStorageInitialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageUniquer::isSingletonStorageInitialized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if there is a singleton storage uniquer initialized for the provided <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a>. </p>
<p>Test is the storage singleton is initialized.</p>
<p>This is only useful for debugging/diagnostic purpose: the uniquer is initialized when a dialect is loaded. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8cpp_source.html#l00393">393</a> of file <a class="el" href="StorageUniquer_8cpp_source.html">StorageUniquer.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeSupport_8h_source.html#l00255">mlir::detail::AttributeUniquer::getWithTypeID()</a>, and <a class="el" href="TypeSupport_8h_source.html#l00245">mlir::detail::TypeUniquer::getWithTypeID()</a>.</p>

</div>
</div>
<a id="a487ccdd7e1da2f3e808d63b82fb95d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487ccdd7e1da2f3e808d63b82fb95d45">&#9670;&nbsp;</a></span>mutate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::StorageUniquer::mutate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Storage *&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the mutable component of 'storage' by forwarding the trailing arguments to the 'mutate' function of the derived class. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00252">252</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeSupport_8h_source.html#l00268">mlir::detail::AttributeUniquer::mutate()</a>, and <a class="el" href="TypeSupport_8h_source.html#l00260">mlir::detail::TypeUniquer::mutate()</a>.</p>

</div>
</div>
<a id="a95af1c87864a2055a591af5694ab678f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95af1c87864a2055a591af5694ab678f">&#9670;&nbsp;</a></span>registerParametricStorageType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::StorageUniquer::registerParametricStorageType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility override when the storage type represents the type id. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00160">160</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="af47a419c58694e2fdcd1faf26af803e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47a419c58694e2fdcd1faf26af803e8">&#9670;&nbsp;</a></span>registerParametricStorageType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::StorageUniquer::registerParametricStorageType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a new parametric storage class, this is necessary to create instances of this class type. </p>
<p><code>id</code> is the type identifier that will be used to identify this type when creating instances of it via 'get'. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00149">149</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AST_2Context_8cpp_source.html#l00015">mlir::pdll::ast::Context::Context()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00327">mlir::DataFlowSolver::DataFlowSolver()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00637">mlir::DataFlowAnalysis::registerAnchorKind()</a>, <a class="el" href="AttributeSupport_8h_source.html#l00287">mlir::detail::AttributeUniquer::registerAttribute()</a>, and <a class="el" href="TypeSupport_8h_source.html#l00279">mlir::detail::TypeUniquer::registerType()</a>.</p>

</div>
</div>
<a id="ade1886dc27e347fc25568eb9038f1db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1886dc27e347fc25568eb9038f1db7">&#9670;&nbsp;</a></span>registerSingletonStorageType() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::StorageUniquer::registerSingletonStorageType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(Storage *)&gt;&#160;</td>
          <td class="paramname"><em>initFn</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility override when the storage type represents the type id. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00185">185</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="af3656e781b752de5865c644394ac0d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3656e781b752de5865c644394ac0d5e">&#9670;&nbsp;</a></span>registerSingletonStorageType() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::StorageUniquer::registerSingletonStorageType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00180">180</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="a6c76f657e631fa4f852ddb9318f245b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c76f657e631fa4f852ddb9318f245b3">&#9670;&nbsp;</a></span>registerSingletonStorageType() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::StorageUniquer::registerSingletonStorageType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(Storage *)&gt;&#160;</td>
          <td class="paramname"><em>initFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a new singleton storage class, this is necessary to get the singletone instance. </p>
<p><code>id</code> is the type identifier that will be used to access the singleton instance via 'get'. An optional initialization function may also be provided to initialize the newly created storage instance, and used when the singleton instance is created. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00169">169</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AST_2Context_8cpp_source.html#l00015">mlir::pdll::ast::Context::Context()</a>, <a class="el" href="AttributeSupport_8h_source.html#l00297">mlir::detail::AttributeUniquer::registerAttribute()</a>, and <a class="el" href="TypeSupport_8h_source.html#l00289">mlir::detail::TypeUniquer::registerType()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Support/<a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a></li>
<li>lib/Support/<a class="el" href="StorageUniquer_8cpp_source.html">StorageUniquer.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:30 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
