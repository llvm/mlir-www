<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::StorageUniquer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="classmlir_1_1StorageUniquer.html">StorageUniquer</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlir_1_1StorageUniquer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mlir::StorageUniquer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A utility class to get or create instances of "storage classes".  
 <a href="#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="StorageUniquer_8h_source.html">mlir/Support/StorageUniquer.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Inheritance diagram for mlir::StorageUniquer:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="classmlir_1_1StorageUniquer__inherit__graph.svg" width="179" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:BaseStorage" id="r_BaseStorage"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer_1_1BaseStorage.html">BaseStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class acts as the base storage that all storage classes must derived from.  <a href="classmlir_1_1StorageUniquer_1_1BaseStorage.html#details">More...</a><br /></td></tr>
<tr class="memitem:StorageAllocator" id="r_StorageAllocator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a utility allocator used to allocate memory for instances of derived types.  <a href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1f5e53b96192c7a25b6ab0523483c5b3" id="r_a1f5e53b96192c7a25b6ab0523483c5b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f5e53b96192c7a25b6ab0523483c5b3">StorageUniquer</a> ()</td></tr>
<tr class="memitem:ac4766e45fc3cd0a11f578e2adaa5f01f" id="r_ac4766e45fc3cd0a11f578e2adaa5f01f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4766e45fc3cd0a11f578e2adaa5f01f">~StorageUniquer</a> ()</td></tr>
<tr class="memitem:a3929c9fc0d5c77c3978f49ba88465f9a" id="r_a3929c9fc0d5c77c3978f49ba88465f9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3929c9fc0d5c77c3978f49ba88465f9a">disableMultithreading</a> (<a class="el" href="classbool.html">bool</a> disable=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:a3929c9fc0d5c77c3978f49ba88465f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flag specifying if multi-threading is disabled within the uniquer.  <br /></td></tr>
<tr class="memitem:af47a419c58694e2fdcd1faf26af803e8" id="r_af47a419c58694e2fdcd1faf26af803e8"><td class="memTemplParams" colspan="2">template&lt;typename Storage&gt; </td></tr>
<tr class="memitem:af47a419c58694e2fdcd1faf26af803e8 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af47a419c58694e2fdcd1faf26af803e8">registerParametricStorageType</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id)</td></tr>
<tr class="memdesc:af47a419c58694e2fdcd1faf26af803e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new parametric storage class, this is necessary to create instances of this class type.  <br /></td></tr>
<tr class="memitem:a95af1c87864a2055a591af5694ab678f" id="r_a95af1c87864a2055a591af5694ab678f"><td class="memTemplParams" colspan="2">template&lt;typename Storage&gt; </td></tr>
<tr class="memitem:a95af1c87864a2055a591af5694ab678f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95af1c87864a2055a591af5694ab678f">registerParametricStorageType</a> ()</td></tr>
<tr class="memdesc:a95af1c87864a2055a591af5694ab678f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility override when the storage type represents the type id.  <br /></td></tr>
<tr class="memitem:a6c76f657e631fa4f852ddb9318f245b3" id="r_a6c76f657e631fa4f852ddb9318f245b3"><td class="memTemplParams" colspan="2">template&lt;typename Storage&gt; </td></tr>
<tr class="memitem:a6c76f657e631fa4f852ddb9318f245b3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c76f657e631fa4f852ddb9318f245b3">registerSingletonStorageType</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(Storage *)&gt; initFn)</td></tr>
<tr class="memdesc:a6c76f657e631fa4f852ddb9318f245b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new singleton storage class, this is necessary to get the singletone instance.  <br /></td></tr>
<tr class="memitem:af3656e781b752de5865c644394ac0d5e" id="r_af3656e781b752de5865c644394ac0d5e"><td class="memTemplParams" colspan="2">template&lt;typename Storage&gt; </td></tr>
<tr class="memitem:af3656e781b752de5865c644394ac0d5e template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3656e781b752de5865c644394ac0d5e">registerSingletonStorageType</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id)</td></tr>
<tr class="memitem:ade1886dc27e347fc25568eb9038f1db7" id="r_ade1886dc27e347fc25568eb9038f1db7"><td class="memTemplParams" colspan="2">template&lt;typename Storage&gt; </td></tr>
<tr class="memitem:ade1886dc27e347fc25568eb9038f1db7 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade1886dc27e347fc25568eb9038f1db7">registerSingletonStorageType</a> (<a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(Storage *)&gt; initFn={})</td></tr>
<tr class="memdesc:ade1886dc27e347fc25568eb9038f1db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility override when the storage type represents the type id.  <br /></td></tr>
<tr class="memitem:a7ad5c03093e0f3a4b5028939a3cd2fd7" id="r_a7ad5c03093e0f3a4b5028939a3cd2fd7"><td class="memTemplParams" colspan="2">template&lt;typename Storage, typename... Args&gt; </td></tr>
<tr class="memitem:a7ad5c03093e0f3a4b5028939a3cd2fd7 template"><td class="memItemLeft" align="right" valign="top">Storage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ad5c03093e0f3a4b5028939a3cd2fd7">get</a> (<a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(Storage *)&gt; initFn, <a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a7ad5c03093e0f3a4b5028939a3cd2fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a uniqued instance of 'Storage'.  <br /></td></tr>
<tr class="memitem:a6f414cb258f6de25644932b61c3dc79a" id="r_a6f414cb258f6de25644932b61c3dc79a"><td class="memTemplParams" colspan="2">template&lt;typename Storage, typename... Args&gt; </td></tr>
<tr class="memitem:a6f414cb258f6de25644932b61c3dc79a template"><td class="memItemLeft" align="right" valign="top">Storage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f414cb258f6de25644932b61c3dc79a">get</a> (<a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(Storage *)&gt; initFn, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a6f414cb258f6de25644932b61c3dc79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility override when the storage type represents the type id.  <br /></td></tr>
<tr class="memitem:a3150d31a67656854b0fc4d46a55eac62" id="r_a3150d31a67656854b0fc4d46a55eac62"><td class="memTemplParams" colspan="2">template&lt;typename Storage&gt; </td></tr>
<tr class="memitem:a3150d31a67656854b0fc4d46a55eac62 template"><td class="memItemLeft" align="right" valign="top">Storage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3150d31a67656854b0fc4d46a55eac62">get</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id)</td></tr>
<tr class="memdesc:a3150d31a67656854b0fc4d46a55eac62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a uniqued instance of 'Storage' which is a singleton storage type.  <br /></td></tr>
<tr class="memitem:a832c06979681f76901aede2de7406cdb" id="r_a832c06979681f76901aede2de7406cdb"><td class="memTemplParams" colspan="2">template&lt;typename Storage&gt; </td></tr>
<tr class="memitem:a832c06979681f76901aede2de7406cdb template"><td class="memItemLeft" align="right" valign="top">Storage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a832c06979681f76901aede2de7406cdb">get</a> ()</td></tr>
<tr class="memdesc:a832c06979681f76901aede2de7406cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility override when the storage type represents the type id.  <br /></td></tr>
<tr class="memitem:a903554c1946174ffb1f129ed303a7dc1" id="r_a903554c1946174ffb1f129ed303a7dc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a903554c1946174ffb1f129ed303a7dc1">isSingletonStorageInitialized</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id)</td></tr>
<tr class="memdesc:a903554c1946174ffb1f129ed303a7dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if there is a singleton storage uniquer initialized for the provided <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a>.  <br /></td></tr>
<tr class="memitem:ad36cae692d56d193d7d82f01e99bffdd" id="r_ad36cae692d56d193d7d82f01e99bffdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad36cae692d56d193d7d82f01e99bffdd">isParametricStorageInitialized</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id)</td></tr>
<tr class="memdesc:ad36cae692d56d193d7d82f01e99bffdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if there is a parametric storage uniquer initialized for the provided <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a>.  <br /></td></tr>
<tr class="memitem:a487ccdd7e1da2f3e808d63b82fb95d45" id="r_a487ccdd7e1da2f3e808d63b82fb95d45"><td class="memTemplParams" colspan="2">template&lt;typename Storage, typename... Args&gt; </td></tr>
<tr class="memitem:a487ccdd7e1da2f3e808d63b82fb95d45 template"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a487ccdd7e1da2f3e808d63b82fb95d45">mutate</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id, Storage *storage, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a487ccdd7e1da2f3e808d63b82fb95d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the mutable component of 'storage' by forwarding the trailing arguments to the 'mutate' function of the derived class.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A utility class to get or create instances of "storage classes". </p>
<p>These storage classes must derive from '<a class="el" href="classmlir_1_1StorageUniquer_1_1BaseStorage.html" title="This class acts as the base storage that all storage classes must derived from.">StorageUniquer::BaseStorage</a>'.</p>
<p>For non-parametric storage classes, i.e. singleton classes, nothing else is needed. Instances of these classes can be created by calling <span class="tt">get</span> without trailing arguments.</p>
<p>Otherwise, the parametric storage classes may be created with <span class="tt">get</span>, and must respect the following:</p><ul>
<li>Define a type alias, KeyTy, to a type that uniquely identifies the instance of the storage class.<ul>
<li>The key type must be constructible from the values passed into the getComplex call.</li>
<li>If the KeyTy does not have an <a class="el" href="structllvm_1_1DenseMapInfo.html">llvm::DenseMapInfo</a> specialization, the storage class must define a hashing method: 'static unsigned hashKey(const KeyTy &amp;)'</li>
</ul>
</li>
<li>Provide a method, 'bool operator==(const KeyTy &amp;) const', to compare the storage instance against an instance of the key type.</li>
<li>Provide a static construction method: 'DerivedStorage *construct(<a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html" title="This is a utility allocator used to allocate memory for instances of derived types.">StorageAllocator</a> &amp;, const KeyTy &amp;key)' that builds a unique instance of the derived storage. The arguments to this function are an allocator to store any uniqued data and the key type for this storage.</li>
<li>Provide a cleanup method: 'void cleanup()' that is called when erasing a storage instance. This should cleanup any fields of the storage as necessary and not attempt to free the memory of the storage itself.</li>
</ul>
<p>Storage classes may have an optional mutable component, which must not take part in the unique immutable key. In this case, storage classes may be mutated with <span class="tt">mutate</span> and must additionally respect the following:</p><ul>
<li>Provide a mutation method: 'LogicalResult mutate(StorageAllocator &amp;, &lt;...&gt;)' that is called when mutating a storage instance. The first argument is an allocator to store any mutable data, and the remaining arguments are forwarded from the call site. The storage can be mutated at any time after creation. Care must be taken to avoid excessive mutation since the allocated storage can keep containing previous states. The return value of the function is used to indicate whether the mutation was successful, e.g., to limit the number of mutations or enable deferred one-time assignment of the mutable component.</li>
</ul>
<p>All storage classes must be registered with the uniquer via <span class="tt">registerParametricStorageType</span> or <span class="tt">registerSingletonStorageType</span> using an appropriate unique <span class="tt"><a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a></span> for the storage class. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00082">82</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1f5e53b96192c7a25b6ab0523483c5b3" name="a1f5e53b96192c7a25b6ab0523483c5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5e53b96192c7a25b6ab0523483c5b3">&#9670;&#160;</a></span>StorageUniquer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StorageUniquer::StorageUniquer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8cpp_source.html#l00361">361</a> of file <a class="el" href="StorageUniquer_8cpp_source.html">StorageUniquer.cpp</a>.</p>

</div>
</div>
<a id="ac4766e45fc3cd0a11f578e2adaa5f01f" name="ac4766e45fc3cd0a11f578e2adaa5f01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4766e45fc3cd0a11f578e2adaa5f01f">&#9670;&#160;</a></span>~StorageUniquer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StorageUniquer::~StorageUniquer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a3929c9fc0d5c77c3978f49ba88465f9a" name="a3929c9fc0d5c77c3978f49ba88465f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3929c9fc0d5c77c3978f49ba88465f9a">&#9670;&#160;</a></span>disableMultithreading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> StorageUniquer::disableMultithreading </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>disable</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the flag specifying if multi-threading is disabled within the uniquer. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8cpp_source.html#l00365">365</a> of file <a class="el" href="StorageUniquer_8cpp_source.html">StorageUniquer.cpp</a>.</p>

</div>
</div>
<a id="a832c06979681f76901aede2de7406cdb" name="a832c06979681f76901aede2de7406cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832c06979681f76901aede2de7406cdb">&#9670;&#160;</a></span>get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Storage * mlir::StorageUniquer::get </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility override when the storage type represents the type id. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00235">235</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

<p class="reference">References <a class="el" href="StorageUniquer_8h_source.html#l00235">get()</a>, and <a class="el" href="TypeID_8h_source.html#l00245">mlir::TypeID::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StorageUniquer_8h_source.html#l00235">get()</a>, and <a class="el" href="StorageUniquer_8h_source.html#l00222">get()</a>.</p>

</div>
</div>
<a id="a6f414cb258f6de25644932b61c3dc79a" name="a6f414cb258f6de25644932b61c3dc79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f414cb258f6de25644932b61c3dc79a">&#9670;&#160;</a></span>get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Storage * mlir::StorageUniquer::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(Storage *)&gt;</td>          <td class="paramname"><span class="paramname"><em>initFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility override when the storage type represents the type id. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00222">222</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

<p class="reference">References <a class="el" href="StorageUniquer_8h_source.html#l00235">get()</a>, and <a class="el" href="TypeID_8h_source.html#l00245">mlir::TypeID::get()</a>.</p>

</div>
</div>
<a id="a7ad5c03093e0f3a4b5028939a3cd2fd7" name="a7ad5c03093e0f3a4b5028939a3cd2fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad5c03093e0f3a4b5028939a3cd2fd7">&#9670;&#160;</a></span>get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Storage * mlir::StorageUniquer::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(Storage *)&gt;</td>          <td class="paramname"><span class="paramname"><em>initFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a uniqued instance of 'Storage'. </p>
<p>'id' is the type id used when registering the storage instance. 'initFn' is an optional parameter that can be used to initialize a newly inserted storage instance. This function is used for derived types that have complex storage or uniquing constraints. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00195">195</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01009">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00962">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00218">mlir::GenericLatticeAnchorBase&lt; ConcreteT, Value &gt;::get()</a>, <a class="el" href="lib_2Conversion_2PDLToPDLInterp_2Predicate_8h_source.html#l00095">mlir::pdl_to_pdl_interp::PredicateBase&lt; ConcreteT, BaseT, Key, Kind &gt;::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00056">mlir::pdll::ast::AttributeType::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00064">mlir::pdll::ast::ConstraintType::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00072">mlir::pdll::ast::OperationType::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00094">mlir::pdll::ast::RangeType::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00135">mlir::pdll::ast::RewriteType::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00143">mlir::pdll::ast::TupleType::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00166">mlir::pdll::ast::TypeType::get()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8cpp_source.html#l00174">mlir::pdll::ast::ValueType::get()</a>, <a class="el" href="AttributeSupport_8h_source.html#l00255">mlir::detail::AttributeUniquer::getWithTypeID()</a>, <a class="el" href="AttributeSupport_8h_source.html#l00230">mlir::detail::AttributeUniquer::getWithTypeID()</a>, <a class="el" href="TypeSupport_8h_source.html#l00245">mlir::detail::TypeUniquer::getWithTypeID()</a>, <a class="el" href="TypeSupport_8h_source.html#l00224">mlir::detail::TypeUniquer::getWithTypeID()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01067">mlir::AffineExpr::operator%()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00891">mlir::AffineExpr::operator*()</a>.</p>

</div>
</div>
<a id="a3150d31a67656854b0fc4d46a55eac62" name="a3150d31a67656854b0fc4d46a55eac62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3150d31a67656854b0fc4d46a55eac62">&#9670;&#160;</a></span>get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Storage * mlir::StorageUniquer::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a uniqued instance of 'Storage' which is a singleton storage type. </p>
<p>'id' is the type id used when registering the storage instance. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00230">230</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="ad36cae692d56d193d7d82f01e99bffdd" name="ad36cae692d56d193d7d82f01e99bffdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36cae692d56d193d7d82f01e99bffdd">&#9670;&#160;</a></span>isParametricStorageInitialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> StorageUniquer::isParametricStorageInitialized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if there is a parametric storage uniquer initialized for the provided <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a>. </p>
<p>Test is the parametric storage is initialized.</p>
<p>This is only useful for debugging/diagnostic purpose: the uniquer is initialized when a dialect is loaded. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8cpp_source.html#l00398">398</a> of file <a class="el" href="StorageUniquer_8cpp_source.html">StorageUniquer.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeSupport_8h_source.html#l00230">mlir::detail::AttributeUniquer::getWithTypeID()</a>, and <a class="el" href="TypeSupport_8h_source.html#l00224">mlir::detail::TypeUniquer::getWithTypeID()</a>.</p>

</div>
</div>
<a id="a903554c1946174ffb1f129ed303a7dc1" name="a903554c1946174ffb1f129ed303a7dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903554c1946174ffb1f129ed303a7dc1">&#9670;&#160;</a></span>isSingletonStorageInitialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> StorageUniquer::isSingletonStorageInitialized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if there is a singleton storage uniquer initialized for the provided <a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type.">TypeID</a>. </p>
<p>Test is the storage singleton is initialized.</p>
<p>This is only useful for debugging/diagnostic purpose: the uniquer is initialized when a dialect is loaded. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8cpp_source.html#l00393">393</a> of file <a class="el" href="StorageUniquer_8cpp_source.html">StorageUniquer.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeSupport_8h_source.html#l00255">mlir::detail::AttributeUniquer::getWithTypeID()</a>, and <a class="el" href="TypeSupport_8h_source.html#l00245">mlir::detail::TypeUniquer::getWithTypeID()</a>.</p>

</div>
</div>
<a id="a487ccdd7e1da2f3e808d63b82fb95d45" name="a487ccdd7e1da2f3e808d63b82fb95d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487ccdd7e1da2f3e808d63b82fb95d45">&#9670;&#160;</a></span>mutate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::StorageUniquer::mutate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Storage *</td>          <td class="paramname"><span class="paramname"><em>storage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the mutable component of 'storage' by forwarding the trailing arguments to the 'mutate' function of the derived class. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00252">252</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeSupport_8h_source.html#l00268">mlir::detail::AttributeUniquer::mutate()</a>, and <a class="el" href="TypeSupport_8h_source.html#l00260">mlir::detail::TypeUniquer::mutate()</a>.</p>

</div>
</div>
<a id="a95af1c87864a2055a591af5694ab678f" name="a95af1c87864a2055a591af5694ab678f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95af1c87864a2055a591af5694ab678f">&#9670;&#160;</a></span>registerParametricStorageType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::StorageUniquer::registerParametricStorageType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility override when the storage type represents the type id. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00160">160</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

<p class="reference">References <a class="el" href="TypeID_8h_source.html#l00245">mlir::TypeID::get()</a>, and <a class="el" href="StorageUniquer_8h_source.html#l00160">registerParametricStorageType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Conversion_2PDLToPDLInterp_2Predicate_8h_source.html#l00568">mlir::pdl_to_pdl_interp::PredicateUniquer::PredicateUniquer()</a>, and <a class="el" href="StorageUniquer_8h_source.html#l00160">registerParametricStorageType()</a>.</p>

</div>
</div>
<a id="af47a419c58694e2fdcd1faf26af803e8" name="af47a419c58694e2fdcd1faf26af803e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47a419c58694e2fdcd1faf26af803e8">&#9670;&#160;</a></span>registerParametricStorageType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::StorageUniquer::registerParametricStorageType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a new parametric storage class, this is necessary to create instances of this class type. </p>
<p><span class="tt">id</span> is the type identifier that will be used to identify this type when creating instances of it via 'get'. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00149">149</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeSupport_8h_source.html#l00287">mlir::detail::AttributeUniquer::registerAttribute()</a>, and <a class="el" href="TypeSupport_8h_source.html#l00279">mlir::detail::TypeUniquer::registerType()</a>.</p>

</div>
</div>
<a id="ade1886dc27e347fc25568eb9038f1db7" name="ade1886dc27e347fc25568eb9038f1db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1886dc27e347fc25568eb9038f1db7">&#9670;&#160;</a></span>registerSingletonStorageType() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::StorageUniquer::registerSingletonStorageType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(Storage *)&gt;</td>          <td class="paramname"><span class="paramname"><em>initFn</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility override when the storage type represents the type id. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00185">185</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="af3656e781b752de5865c644394ac0d5e" name="af3656e781b752de5865c644394ac0d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3656e781b752de5865c644394ac0d5e">&#9670;&#160;</a></span>registerSingletonStorageType() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::StorageUniquer::registerSingletonStorageType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00180">180</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

<p class="reference">References <a class="el" href="StorageUniquer_8h_source.html#l00169">registerSingletonStorageType()</a>.</p>

</div>
</div>
<a id="a6c76f657e631fa4f852ddb9318f245b3" name="a6c76f657e631fa4f852ddb9318f245b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c76f657e631fa4f852ddb9318f245b3">&#9670;&#160;</a></span>registerSingletonStorageType() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::StorageUniquer::registerSingletonStorageType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(Storage *)&gt;</td>          <td class="paramname"><span class="paramname"><em>initFn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a new singleton storage class, this is necessary to get the singletone instance. </p>
<p><span class="tt">id</span> is the type identifier that will be used to access the singleton instance via 'get'. An optional initialization function may also be provided to initialize the newly created storage instance, and used when the singleton instance is created. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00169">169</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Conversion_2PDLToPDLInterp_2Predicate_8h_source.html#l00568">mlir::pdl_to_pdl_interp::PredicateUniquer::PredicateUniquer()</a>, <a class="el" href="AttributeSupport_8h_source.html#l00297">mlir::detail::AttributeUniquer::registerAttribute()</a>, <a class="el" href="StorageUniquer_8h_source.html#l00180">registerSingletonStorageType()</a>, and <a class="el" href="TypeSupport_8h_source.html#l00289">mlir::detail::TypeUniquer::registerType()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Support/<a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a></li>
<li>lib/Support/<a class="el" href="StorageUniquer_8cpp_source.html">StorageUniquer.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
