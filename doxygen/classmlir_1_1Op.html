<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::Op&lt; ConcreteType, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1Op.html">Op</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmlir_1_1Op-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::Op&lt; ConcreteType, Traits &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This provides public APIs that all operations should have.  
 <a href="classmlir_1_1Op.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="OpDefinition_8h_source.html">mlir/IR/OpDefinition.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mlir::Op&lt; ConcreteType, Traits &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classmlir_1_1Op__inherit__graph.svg" width="1615" height="342"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a63c65a9810b37ce3fa35ca27acdce394"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a63c65a9810b37ce3fa35ca27acdce394">ConcreteOpType</a> = ConcreteType</td></tr>
<tr class="memdesc:a63c65a9810b37ce3fa35ca27acdce394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expose the type we are instantiated on to template machinery that may want to introspect traits on this operation.  <a href="classmlir_1_1Op.html#a63c65a9810b37ce3fa35ca27acdce394">More...</a><br /></td></tr>
<tr class="separator:a63c65a9810b37ce3fa35ca27acdce394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb22cbbff9dc8dab72c638ea384ecd2a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb22cbbff9dc8dab72c638ea384ecd2a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#aeb22cbbff9dc8dab72c638ea384ecd2a">InferredProperties</a> = typename <a class="el" href="structmlir_1_1PropertiesSelector.html">PropertiesSelector</a>&lt; T &gt;::type</td></tr>
<tr class="separator:aeb22cbbff9dc8dab72c638ea384ecd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a78d7e2ead4d30cbc9c32d8ecfa1d1fbb"><td class="memItemLeft" align="right" valign="top">ConcreteType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a78d7e2ead4d30cbc9c32d8ecfa1d1fbb">clone</a> ()</td></tr>
<tr class="memdesc:a78d7e2ead4d30cbc9c32d8ecfa1d1fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a deep copy of this operation.  <a href="classmlir_1_1Op.html#a78d7e2ead4d30cbc9c32d8ecfa1d1fbb">More...</a><br /></td></tr>
<tr class="separator:a78d7e2ead4d30cbc9c32d8ecfa1d1fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcbe19488b3c38705a819fb09e0be5d"><td class="memItemLeft" align="right" valign="top">ConcreteType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#aebcbe19488b3c38705a819fb09e0be5d">cloneWithoutRegions</a> ()</td></tr>
<tr class="memdesc:aebcbe19488b3c38705a819fb09e0be5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a partial copy of this operation without traversing into attached regions.  <a href="classmlir_1_1Op.html#aebcbe19488b3c38705a819fb09e0be5d">More...</a><br /></td></tr>
<tr class="separator:aebcbe19488b3c38705a819fb09e0be5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9f320696122f31b6b22509d137d33d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#abe9f320696122f31b6b22509d137d33d">Op</a> ()</td></tr>
<tr class="memdesc:abe9f320696122f31b6b22509d137d33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a public constructor. Any op can be initialized to null.  <a href="classmlir_1_1Op.html#abe9f320696122f31b6b22509d137d33d">More...</a><br /></td></tr>
<tr class="separator:abe9f320696122f31b6b22509d137d33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b3a86209028ced4a8405877fb51b5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a25b3a86209028ced4a8405877fb51b5b">Op</a> (std::nullptr_t)</td></tr>
<tr class="separator:a25b3a86209028ced4a8405877fb51b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5905d939c92414ac6cce2c7d54f8f05e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a5905d939c92414ac6cce2c7d54f8f05e">Op</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *state)</td></tr>
<tr class="memdesc:a5905d939c92414ac6cce2c7d54f8f05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a public constructor to enable access via the llvm::cast family of methods.  <a href="classmlir_1_1Op.html#a5905d939c92414ac6cce2c7d54f8f05e">More...</a><br /></td></tr>
<tr class="separator:a5905d939c92414ac6cce2c7d54f8f05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab748974126586683a89d2355aeccc2f9"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#ab748974126586683a89d2355aeccc2f9">getAsOpaquePointer</a> () const</td></tr>
<tr class="memdesc:ab748974126586683a89d2355aeccc2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for supporting PointerLikeTypeTraits.  <a href="classmlir_1_1Op.html#ab748974126586683a89d2355aeccc2f9">More...</a><br /></td></tr>
<tr class="separator:ab748974126586683a89d2355aeccc2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc93f31894a0fa90004999ceea8dbe36"><td class="memTemplParams" colspan="2">template&lt;typename T  = ConcreteType&gt; </td></tr>
<tr class="memitem:abc93f31894a0fa90004999ceea8dbe36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Op.html#aeb22cbbff9dc8dab72c638ea384ecd2a">InferredProperties</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#abc93f31894a0fa90004999ceea8dbe36">getProperties</a> ()</td></tr>
<tr class="separator:abc93f31894a0fa90004999ceea8dbe36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0de86e7f83e0d3c90eb5ac7b36d5b3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#ab0de86e7f83e0d3c90eb5ac7b36d5b3b">getOperation</a> ()</td></tr>
<tr class="memdesc:ab0de86e7f83e0d3c90eb5ac7b36d5b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherit getOperation from <code><a class="el" href="classmlir_1_1OpState.html" title="This is the concrete base class that holds the operation pointer and has non-generic methods that onl...">OpState</a></code>.  <a href="classmlir_1_1Op.html#ab0de86e7f83e0d3c90eb5ac7b36d5b3b">More...</a><br /></td></tr>
<tr class="separator:ab0de86e7f83e0d3c90eb5ac7b36d5b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353c0e5088dbb6624b01221f62262f78"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a353c0e5088dbb6624b01221f62262f78">verify</a> ()</td></tr>
<tr class="memdesc:a353c0e5088dbb6624b01221f62262f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the concrete type didn't implement a custom verifier hook, just fall back to this one which accepts everything.  <a href="classmlir_1_1Op.html#a353c0e5088dbb6624b01221f62262f78">More...</a><br /></td></tr>
<tr class="separator:a353c0e5088dbb6624b01221f62262f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707e0acf20eca83644d64ca1718a6c4a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a707e0acf20eca83644d64ca1718a6c4a">verifyRegions</a> ()</td></tr>
<tr class="separator:a707e0acf20eca83644d64ca1718a6c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:a4a630754c7bac8e1c33ced0f4f25e3ba inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a4a630754c7bac8e1c33ced0f4f25e3ba">operator bool</a> ()</td></tr>
<tr class="memdesc:a4a630754c7bac8e1c33ced0f4f25e3ba inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ops are pointer-like, so we allow conversion to bool.  <a href="classmlir_1_1OpState.html#a4a630754c7bac8e1c33ced0f4f25e3ba">More...</a><br /></td></tr>
<tr class="separator:a4a630754c7bac8e1c33ced0f4f25e3ba inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53baa7db4eecd983c7387027ebf0f44 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ac53baa7db4eecd983c7387027ebf0f44">operator Operation *</a> () const</td></tr>
<tr class="memdesc:ac53baa7db4eecd983c7387027ebf0f44 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implicitly converts to Operation*.  <a href="classmlir_1_1OpState.html#ac53baa7db4eecd983c7387027ebf0f44">More...</a><br /></td></tr>
<tr class="separator:ac53baa7db4eecd983c7387027ebf0f44 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4123d8ee9f66429dadb11acbfefc0b inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#afd4123d8ee9f66429dadb11acbfefc0b">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:afd4123d8ee9f66429dadb11acbfefc0b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut of <code>-&gt;</code> to access a member of <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="classmlir_1_1OpState.html#afd4123d8ee9f66429dadb11acbfefc0b">More...</a><br /></td></tr>
<tr class="separator:afd4123d8ee9f66429dadb11acbfefc0b inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0de86e7f83e0d3c90eb5ac7b36d5b3b inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ab0de86e7f83e0d3c90eb5ac7b36d5b3b">getOperation</a> ()</td></tr>
<tr class="memdesc:ab0de86e7f83e0d3c90eb5ac7b36d5b3b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the operation that this refers to.  <a href="classmlir_1_1OpState.html#ab0de86e7f83e0d3c90eb5ac7b36d5b3b">More...</a><br /></td></tr>
<tr class="separator:ab0de86e7f83e0d3c90eb5ac7b36d5b3b inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15857fa62a3a6e8423b3d1511acfc040 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a15857fa62a3a6e8423b3d1511acfc040">getContext</a> ()</td></tr>
<tr class="memdesc:a15857fa62a3a6e8423b3d1511acfc040 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the context this operation belongs to.  <a href="classmlir_1_1OpState.html#a15857fa62a3a6e8423b3d1511acfc040">More...</a><br /></td></tr>
<tr class="separator:a15857fa62a3a6e8423b3d1511acfc040 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a472af9de9610021657c2874e6b1191 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a5a472af9de9610021657c2874e6b1191">print</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags={})</td></tr>
<tr class="memdesc:a5a472af9de9610021657c2874e6b1191 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the operation to the given stream.  <a href="classmlir_1_1OpState.html#a5a472af9de9610021657c2874e6b1191">More...</a><br /></td></tr>
<tr class="separator:a5a472af9de9610021657c2874e6b1191 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae2204ca73ef2a338a1f980d3662f80 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a5ae2204ca73ef2a338a1f980d3662f80">print</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AsmState.html">AsmState</a> &amp;asmState)</td></tr>
<tr class="separator:a5ae2204ca73ef2a338a1f980d3662f80 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023cde86e8d01c23ae2f7c07d084d21a inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a023cde86e8d01c23ae2f7c07d084d21a">dump</a> ()</td></tr>
<tr class="memdesc:a023cde86e8d01c23ae2f7c07d084d21a inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump this operation.  <a href="classmlir_1_1OpState.html#a023cde86e8d01c23ae2f7c07d084d21a">More...</a><br /></td></tr>
<tr class="separator:a023cde86e8d01c23ae2f7c07d084d21a inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad824acf76e230e3cd64a02d66a82a0cb inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ad824acf76e230e3cd64a02d66a82a0cb">getLoc</a> ()</td></tr>
<tr class="memdesc:ad824acf76e230e3cd64a02d66a82a0cb inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">The source location the operation was defined or derived from.  <a href="classmlir_1_1OpState.html#ad824acf76e230e3cd64a02d66a82a0cb">More...</a><br /></td></tr>
<tr class="separator:ad824acf76e230e3cd64a02d66a82a0cb inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3159f7aa51ff5db54cbab48867d00365 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a3159f7aa51ff5db54cbab48867d00365">use_empty</a> ()</td></tr>
<tr class="memdesc:a3159f7aa51ff5db54cbab48867d00365 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are no users of any results of this operation.  <a href="classmlir_1_1OpState.html#a3159f7aa51ff5db54cbab48867d00365">More...</a><br /></td></tr>
<tr class="separator:a3159f7aa51ff5db54cbab48867d00365 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202c02a251ca0fce2c2a9df84b9ea32f inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a202c02a251ca0fce2c2a9df84b9ea32f">erase</a> ()</td></tr>
<tr class="memdesc:a202c02a251ca0fce2c2a9df84b9ea32f inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove this operation from its parent block and delete it.  <a href="classmlir_1_1OpState.html#a202c02a251ca0fce2c2a9df84b9ea32f">More...</a><br /></td></tr>
<tr class="separator:a202c02a251ca0fce2c2a9df84b9ea32f inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a602baeafc892ba94fd30bfeb0624b inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a96a602baeafc892ba94fd30bfeb0624b">emitOpError</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:a96a602baeafc892ba94fd30bfeb0624b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an error with the op name prefixed, like "'dim' op " which is convenient for verifiers.  <a href="classmlir_1_1OpState.html#a96a602baeafc892ba94fd30bfeb0624b">More...</a><br /></td></tr>
<tr class="separator:a96a602baeafc892ba94fd30bfeb0624b inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ab2e156408bc77bb5d5629068bda60 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a78ab2e156408bc77bb5d5629068bda60">emitError</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:a78ab2e156408bc77bb5d5629068bda60 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an error about fatal conditions with this operation, reporting up to any diagnostic handlers that may be listening.  <a href="classmlir_1_1OpState.html#a78ab2e156408bc77bb5d5629068bda60">More...</a><br /></td></tr>
<tr class="separator:a78ab2e156408bc77bb5d5629068bda60 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94173f14645d198ba9e07f763acfe4b inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#aa94173f14645d198ba9e07f763acfe4b">emitWarning</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:aa94173f14645d198ba9e07f763acfe4b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a warning about this operation, reporting up to any diagnostic handlers that may be listening.  <a href="classmlir_1_1OpState.html#aa94173f14645d198ba9e07f763acfe4b">More...</a><br /></td></tr>
<tr class="separator:aa94173f14645d198ba9e07f763acfe4b inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac456e15c3588fd348490eb8e423617ea inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ac456e15c3588fd348490eb8e423617ea">emitRemark</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:ac456e15c3588fd348490eb8e423617ea inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a remark about this operation, reporting up to any diagnostic handlers that may be listening.  <a href="classmlir_1_1OpState.html#ac456e15c3588fd348490eb8e423617ea">More...</a><br /></td></tr>
<tr class="separator:ac456e15c3588fd348490eb8e423617ea inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3992b78b5c039f6f48ab9ab53b999480 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplParams" colspan="2">template&lt;WalkOrder Order = WalkOrder::PostOrder, typename Iterator  = ForwardIterator, typename FnT , typename RetT  = detail::walkResultType&lt;FnT&gt;&gt; </td></tr>
<tr class="memitem:a3992b78b5c039f6f48ab9ab53b999480 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::function_traits&lt; std::decay_t&lt; FnT &gt; &gt;::num_args==1, RetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a3992b78b5c039f6f48ab9ab53b999480">walk</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a3992b78b5c039f6f48ab9ab53b999480 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk the operation by calling the callback for each nested operation (including this one), block or region, depending on the callback provided.  <a href="classmlir_1_1OpState.html#a3992b78b5c039f6f48ab9ab53b999480">More...</a><br /></td></tr>
<tr class="separator:a3992b78b5c039f6f48ab9ab53b999480 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d45fa93789d2ba8003734baef9f9454 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename RetT  = detail::walkResultType&lt;FnT&gt;&gt; </td></tr>
<tr class="memitem:a0d45fa93789d2ba8003734baef9f9454 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::function_traits&lt; std::decay_t&lt; FnT &gt; &gt;::num_args==2, RetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a0d45fa93789d2ba8003734baef9f9454">walk</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a0d45fa93789d2ba8003734baef9f9454 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic walker with a stage aware callback.  <a href="classmlir_1_1OpState.html#a0d45fa93789d2ba8003734baef9f9454">More...</a><br /></td></tr>
<tr class="separator:a0d45fa93789d2ba8003734baef9f9454 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab0f28a9a8ea472061179fd53883ea589"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T &gt; class Trait&gt; </td></tr>
<tr class="memitem:ab0f28a9a8ea472061179fd53883ea589"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#ab0f28a9a8ea472061179fd53883ea589">hasTrait</a> ()</td></tr>
<tr class="memdesc:ab0f28a9a8ea472061179fd53883ea589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if this operation contains the provided trait.  <a href="classmlir_1_1Op.html#ab0f28a9a8ea472061179fd53883ea589">More...</a><br /></td></tr>
<tr class="separator:ab0f28a9a8ea472061179fd53883ea589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1240be31ea922d33b1b2392e723a3b4e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a1240be31ea922d33b1b2392e723a3b4e">classof</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a1240be31ea922d33b1b2392e723a3b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this "op class" can match against the specified operation.  <a href="classmlir_1_1Op.html#a1240be31ea922d33b1b2392e723a3b4e">More...</a><br /></td></tr>
<tr class="separator:a1240be31ea922d33b1b2392e723a3b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c101993f4bb1de5e348350e13578094"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c101993f4bb1de5e348350e13578094"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1OpState.html">OpState</a>, T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a9c101993f4bb1de5e348350e13578094">classof</a> (const T *op)</td></tr>
<tr class="memdesc:a9c101993f4bb1de5e348350e13578094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <code>classof</code> support for other OpBase derived classes, such as Interfaces.  <a href="classmlir_1_1Op.html#a9c101993f4bb1de5e348350e13578094">More...</a><br /></td></tr>
<tr class="separator:a9c101993f4bb1de5e348350e13578094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2c41a61d1531398c6bfc2f2ed1e4e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Op.html#a63c65a9810b37ce3fa35ca27acdce394">ConcreteOpType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a2c2c41a61d1531398c6bfc2f2ed1e4e8">getFromOpaquePointer</a> (const void *pointer)</td></tr>
<tr class="separator:a2c2c41a61d1531398c6bfc2f2ed1e4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad859b0a042439ebb5182e4493ff7b853"><td class="memTemplParams" colspan="2">template&lt;typename... Models&gt; </td></tr>
<tr class="memitem:ad859b0a042439ebb5182e4493ff7b853"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#ad859b0a042439ebb5182e4493ff7b853">attachInterface</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:ad859b0a042439ebb5182e4493ff7b853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach the given models as implementations of the corresponding interfaces for the concrete operation.  <a href="classmlir_1_1Op.html#ad859b0a042439ebb5182e4493ff7b853">More...</a><br /></td></tr>
<tr class="separator:ad859b0a042439ebb5182e4493ff7b853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbadb7faf098d7d2e7a276b594a966d"><td class="memTemplParams" colspan="2">template&lt;typename PropertiesTy &gt; </td></tr>
<tr class="memitem:a1bbadb7faf098d7d2e7a276b594a966d"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a1bbadb7faf098d7d2e7a276b594a966d">setPropertiesFromAttr</a> (PropertiesTy &amp;prop, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="classmlir_1_1OpState.html#a78ab2e156408bc77bb5d5629068bda60">emitError</a>)</td></tr>
<tr class="memdesc:a1bbadb7faf098d7d2e7a276b594a966d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided attribute to a property and assigned it to the provided properties.  <a href="classmlir_1_1Op.html#a1bbadb7faf098d7d2e7a276b594a966d">More...</a><br /></td></tr>
<tr class="separator:a1bbadb7faf098d7d2e7a276b594a966d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65160d5d9f4234c81d7db4be013aad40"><td class="memTemplParams" colspan="2">template&lt;typename PropertiesTy &gt; </td></tr>
<tr class="memitem:a65160d5d9f4234c81d7db4be013aad40"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a65160d5d9f4234c81d7db4be013aad40">getPropertiesAsAttr</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, const PropertiesTy &amp;prop)</td></tr>
<tr class="memdesc:a65160d5d9f4234c81d7db4be013aad40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided properties to an attribute.  <a href="classmlir_1_1Op.html#a65160d5d9f4234c81d7db4be013aad40">More...</a><br /></td></tr>
<tr class="separator:a65160d5d9f4234c81d7db4be013aad40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e2d0393e4914199370400b54baa4a8"><td class="memTemplParams" colspan="2">template&lt;typename PropertiesTy &gt; </td></tr>
<tr class="memitem:ab4e2d0393e4914199370400b54baa4a8"><td class="memTemplItemLeft" align="right" valign="top">static llvm::hash_code&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#ab4e2d0393e4914199370400b54baa4a8">computePropertiesHash</a> (const PropertiesTy &amp;prop)</td></tr>
<tr class="memdesc:ab4e2d0393e4914199370400b54baa4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash the provided properties.  <a href="classmlir_1_1Op.html#ab4e2d0393e4914199370400b54baa4a8">More...</a><br /></td></tr>
<tr class="separator:ab4e2d0393e4914199370400b54baa4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab836044f7d5dc6bd251ec324e6a59d20"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#ab836044f7d5dc6bd251ec324e6a59d20">hasProperties</a> ()</td></tr>
<tr class="memdesc:ab836044f7d5dc6bd251ec324e6a59d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this operation defines a <code>Properties</code> inner type.  <a href="classmlir_1_1Op.html#ab836044f7d5dc6bd251ec324e6a59d20">More...</a><br /></td></tr>
<tr class="separator:ab836044f7d5dc6bd251ec324e6a59d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb1f4a3688ae37231e943a74f5a9079"><td class="memTemplParams" colspan="2">template&lt;typename T  = ConcreteType&gt; </td></tr>
<tr class="memitem:afbb1f4a3688ae37231e943a74f5a9079"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#afbb1f4a3688ae37231e943a74f5a9079">populateDefaultProperties</a> (<a class="el" href="classmlir_1_1OperationName.html">OperationName</a> opName, <a class="el" href="classmlir_1_1Op.html#aeb22cbbff9dc8dab72c638ea384ecd2a">InferredProperties</a>&lt; T &gt; &amp;properties)</td></tr>
<tr class="memdesc:afbb1f4a3688ae37231e943a74f5a9079"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook populates any unset default attrs when mapped to properties.  <a href="classmlir_1_1Op.html#afbb1f4a3688ae37231e943a74f5a9079">More...</a><br /></td></tr>
<tr class="separator:afbb1f4a3688ae37231e943a74f5a9079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78566efdfb9083f28e2a290758be204e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a78566efdfb9083f28e2a290758be204e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a78566efdfb9083f28e2a290758be204e">printProperties</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, const T &amp;properties, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; elidedProps={})</td></tr>
<tr class="memdesc:a78566efdfb9083f28e2a290758be204e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the operation properties with names not included within 'elidedProps'.  <a href="classmlir_1_1Op.html#a78566efdfb9083f28e2a290758be204e">More...</a><br /></td></tr>
<tr class="separator:a78566efdfb9083f28e2a290758be204e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaebd0595f35c45f8ddb7c3bb0d7911b"><td class="memTemplParams" colspan="2">template&lt;typename T  = ConcreteType&gt; </td></tr>
<tr class="memitem:acaebd0595f35c45f8ddb7c3bb0d7911b"><td class="memTemplItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#acaebd0595f35c45f8ddb7c3bb0d7911b">parseProperties</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result)</td></tr>
<tr class="memdesc:acaebd0595f35c45f8ddb7c3bb0d7911b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses 'prop-dict' for the operation.  <a href="classmlir_1_1Op.html#acaebd0595f35c45f8ddb7c3bb0d7911b">More...</a><br /></td></tr>
<tr class="separator:acaebd0595f35c45f8ddb7c3bb0d7911b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:ab697ae7a73f65229a4c63fc72dc5655d inherit pub_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ab697ae7a73f65229a4c63fc72dc5655d">getCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;results, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ab697ae7a73f65229a4c63fc72dc5655d inherit pub_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook returns any canonicalization pattern rewrites that the operation supports, for use by the canonicalization pass.  <a href="classmlir_1_1OpState.html#ab697ae7a73f65229a4c63fc72dc5655d">More...</a><br /></td></tr>
<tr class="separator:ab697ae7a73f65229a4c63fc72dc5655d inherit pub_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86c745166da5745b6043c84025780f0 inherit pub_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ad86c745166da5745b6043c84025780f0">populateDefaultAttrs</a> (const <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> &amp;, <a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;)</td></tr>
<tr class="memdesc:ad86c745166da5745b6043c84025780f0 inherit pub_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook populates any unset default attrs.  <a href="classmlir_1_1OpState.html#ad86c745166da5745b6043c84025780f0">More...</a><br /></td></tr>
<tr class="separator:ad86c745166da5745b6043c84025780f0 inherit pub_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:a353c0e5088dbb6624b01221f62262f78 inherit pro_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a353c0e5088dbb6624b01221f62262f78">verify</a> ()</td></tr>
<tr class="memdesc:a353c0e5088dbb6624b01221f62262f78 inherit pro_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the concrete type didn't implement a custom verifier hook, just fall back to this one which accepts everything.  <a href="classmlir_1_1OpState.html#a353c0e5088dbb6624b01221f62262f78">More...</a><br /></td></tr>
<tr class="separator:a353c0e5088dbb6624b01221f62262f78 inherit pro_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707e0acf20eca83644d64ca1718a6c4a inherit pro_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a707e0acf20eca83644d64ca1718a6c4a">verifyRegions</a> ()</td></tr>
<tr class="separator:a707e0acf20eca83644d64ca1718a6c4a inherit pro_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cb0c062a04c9797e443d2ee1a4d9e7 inherit pro_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ad2cb0c062a04c9797e443d2ee1a4d9e7">OpState</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *state)</td></tr>
<tr class="memdesc:ad2cb0c062a04c9797e443d2ee1a4d9e7 inherit pro_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutability management is handled by the OpWrapper/OpConstWrapper classes, so we can cast it away here.  <a href="classmlir_1_1OpState.html#ad2cb0c062a04c9797e443d2ee1a4d9e7">More...</a><br /></td></tr>
<tr class="separator:ad2cb0c062a04c9797e443d2ee1a4d9e7 inherit pro_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:abcfdfbc4f6158e19c5993549247132fb inherit pro_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#abcfdfbc4f6158e19c5993549247132fb">parse</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result)</td></tr>
<tr class="memdesc:abcfdfbc4f6158e19c5993549247132fb inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the custom form of an operation.  <a href="classmlir_1_1OpState.html#abcfdfbc4f6158e19c5993549247132fb">More...</a><br /></td></tr>
<tr class="separator:abcfdfbc4f6158e19c5993549247132fb inherit pro_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d2761129af0c55404133f9b47f21b6 inherit pro_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#aa1d2761129af0c55404133f9b47f21b6">print</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, StringRef defaultDialect)</td></tr>
<tr class="memdesc:aa1d2761129af0c55404133f9b47f21b6 inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the operation.  <a href="classmlir_1_1OpState.html#aa1d2761129af0c55404133f9b47f21b6">More...</a><br /></td></tr>
<tr class="separator:aa1d2761129af0c55404133f9b47f21b6 inherit pro_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e0ae9c848fe4e633e46a3ce0863bab inherit pro_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ab8e0ae9c848fe4e633e46a3ce0863bab">genericParseProperties</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;result)</td></tr>
<tr class="memdesc:ab8e0ae9c848fe4e633e46a3ce0863bab inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse properties as a <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <a href="classmlir_1_1OpState.html#ab8e0ae9c848fe4e633e46a3ce0863bab">More...</a><br /></td></tr>
<tr class="separator:ab8e0ae9c848fe4e633e46a3ce0863bab inherit pro_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07588469ccab75d875094f095c4f2d1b inherit pro_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a07588469ccab75d875094f095c4f2d1b">genericPrintProperties</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> properties, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; elidedProps={})</td></tr>
<tr class="memdesc:a07588469ccab75d875094f095c4f2d1b inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the properties as a <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> with names not included within 'elidedProps'.  <a href="classmlir_1_1OpState.html#a07588469ccab75d875094f095c4f2d1b">More...</a><br /></td></tr>
<tr class="separator:a07588469ccab75d875094f095c4f2d1b inherit pro_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624f18cf4e9a772ab1187fd997ccf2b8 inherit pro_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a624f18cf4e9a772ab1187fd997ccf2b8">printOpName</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, StringRef defaultDialect)</td></tr>
<tr class="memdesc:a624f18cf4e9a772ab1187fd997ccf2b8 inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an operation name, eliding the dialect prefix if necessary.  <a href="classmlir_1_1OpState.html#a624f18cf4e9a772ab1187fd997ccf2b8">More...</a><br /></td></tr>
<tr class="separator:a624f18cf4e9a772ab1187fd997ccf2b8 inherit pro_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9229a9829135abc357f1da5086695d inherit pro_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1EmptyProperties.html">EmptyProperties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a5e9229a9829135abc357f1da5086695d">getEmptyProperties</a> ()</td></tr>
<tr class="memdesc:a5e9229a9829135abc357f1da5086695d inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">For all op which don't have properties, we keep a single instance of <code><a class="el" href="structmlir_1_1EmptyProperties.html" title="Structure used by default as a &quot;marker&quot; when no &quot;Properties&quot; are set on an Operation.">EmptyProperties</a></code> to be used where a reference to a properties is needed: this allow to bind a pointer to the reference without triggering UB.  <a href="classmlir_1_1OpState.html#a5e9229a9829135abc357f1da5086695d">More...</a><br /></td></tr>
<tr class="separator:a5e9229a9829135abc357f1da5086695d inherit pro_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt;<br />
class mlir::Op&lt; ConcreteType, Traits &gt;</h3>

<p>This provides public APIs that all operations should have. </p>
<p>The template argument 'ConcreteType' should be the concrete type by CRTP and the others are base classes by the policy pattern. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01673">1673</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a63c65a9810b37ce3fa35ca27acdce394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c65a9810b37ce3fa35ca27acdce394">&#9670;&nbsp;</a></span>ConcreteOpType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::<a class="el" href="classmlir_1_1Op.html#a63c65a9810b37ce3fa35ca27acdce394">ConcreteOpType</a> =  ConcreteType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expose the type we are instantiated on to template machinery that may want to introspect traits on this operation. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01718">1718</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="aeb22cbbff9dc8dab72c638ea384ecd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb22cbbff9dc8dab72c638ea384ecd2a">&#9670;&nbsp;</a></span>InferredProperties</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::<a class="el" href="classmlir_1_1Op.html#aeb22cbbff9dc8dab72c638ea384ecd2a">InferredProperties</a> =  typename <a class="el" href="structmlir_1_1PropertiesSelector.html">PropertiesSelector</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01975">1975</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abe9f320696122f31b6b22509d137d33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9f320696122f31b6b22509d137d33d">&#9670;&nbsp;</a></span>Op() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::<a class="el" href="classmlir_1_1Op.html">Op</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a public constructor. Any op can be initialized to null. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01721">1721</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a25b3a86209028ced4a8405877fb51b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b3a86209028ced4a8405877fb51b5b">&#9670;&nbsp;</a></span>Op() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::<a class="el" href="classmlir_1_1Op.html">Op</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01722">1722</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a5905d939c92414ac6cce2c7d54f8f05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5905d939c92414ac6cce2c7d54f8f05e">&#9670;&nbsp;</a></span>Op() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::<a class="el" href="classmlir_1_1Op.html">Op</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a public constructor to enable access via the llvm::cast family of methods. </p>
<p>This should not be used directly. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01726">1726</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad859b0a042439ebb5182e4493ff7b853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad859b0a042439ebb5182e4493ff7b853">&#9670;&nbsp;</a></span>attachInterface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename... Models&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::attachInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach the given models as implementations of the corresponding interfaces for the concrete operation. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01740">1740</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00931">mlir::RegisteredOperationName::lookup()</a>.</p>

</div>
</div>
<a id="a9c101993f4bb1de5e348350e13578094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c101993f4bb1de5e348350e13578094">&#9670;&nbsp;</a></span>classof() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1OpState.html">OpState</a>, T&gt;::value, bool&gt; <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::classof </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide <code>classof</code> support for other OpBase derived classes, such as Interfaces. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01712">1712</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l01697">mlir::Op&lt; ConcreteType, Traits &gt;::classof()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00112">mlir::Op&lt; ConcreteType, Traits &gt;::getOperation()</a>.</p>

</div>
</div>
<a id="a1240be31ea922d33b1b2392e723a3b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1240be31ea922d33b1b2392e723a3b4e">&#9670;&nbsp;</a></span>classof() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::classof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this "op class" can match against the specified operation. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01697">1697</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00123">mlir::Operation::getRegisteredInfo()</a>, and <a class="el" href="OperationSupport_8h_source.html#l00473">mlir::OperationName::getStringRef()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpDefinition_8h_source.html#l01712">mlir::Op&lt; ConcreteType, Traits &gt;::classof()</a>.</p>

</div>
</div>
<a id="a78d7e2ead4d30cbc9c32d8ecfa1d1fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d7e2ead4d30cbc9c32d8ecfa1d1fbb">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConcreteType <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a deep copy of this operation. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01687">1687</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l01687">mlir::Op&lt; ConcreteType, Traits &gt;::clone()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00112">mlir::Op&lt; ConcreteType, Traits &gt;::getOperation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpDefinition_8h_source.html#l01687">mlir::Op&lt; ConcreteType, Traits &gt;::clone()</a>.</p>

</div>
</div>
<a id="aebcbe19488b3c38705a819fb09e0be5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcbe19488b3c38705a819fb09e0be5d">&#9670;&nbsp;</a></span>cloneWithoutRegions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConcreteType <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::cloneWithoutRegions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a partial copy of this operation without traversing into attached regions. </p>
<p>The new operation will have the same number of regions as the original one, but they will be left empty. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01692">1692</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00112">mlir::Op&lt; ConcreteType, Traits &gt;::getOperation()</a>.</p>

</div>
</div>
<a id="ab4e2d0393e4914199370400b54baa4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e2d0393e4914199370400b54baa4a8">&#9670;&nbsp;</a></span>computePropertiesHash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename PropertiesTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::hash_code <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::computePropertiesHash </td>
          <td>(</td>
          <td class="paramtype">const PropertiesTy &amp;&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash the provided properties. </p>
<p>This default implementation forwards to a free function <code>computeHash</code> that can be looked up with ADL in the namespace where the properties are defined. It can also be overridden in the derived ConcreteOp. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01775">1775</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="ModuleCombiner_8cpp_source.html#l00072">computeHash()</a>.</p>

</div>
</div>
<a id="ab748974126586683a89d2355aeccc2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab748974126586683a89d2355aeccc2f9">&#9670;&nbsp;</a></span>getAsOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::getAsOpaquePointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for supporting PointerLikeTypeTraits. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01729">1729</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a2c2c41a61d1531398c6bfc2f2ed1e4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2c41a61d1531398c6bfc2f2ed1e4e8">&#9670;&nbsp;</a></span>getFromOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Op.html#a63c65a9810b37ce3fa35ca27acdce394">ConcreteOpType</a> <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::getFromOpaquePointer </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01732">1732</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="ab0de86e7f83e0d3c90eb5ac7b36d5b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0de86e7f83e0d3c90eb5ac7b36d5b3b">&#9670;&nbsp;</a></span>getOperation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a>* mlir::OpState::getOperation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inherit getOperation from <code><a class="el" href="classmlir_1_1OpState.html" title="This is the concrete base class that holds the operation pointer and has non-generic methods that onl...">OpState</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00112">112</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpDefinition_8h_source.html#l01712">mlir::Op&lt; ConcreteType, Traits &gt;::classof()</a>, <a class="el" href="OpDefinition_8h_source.html#l01687">mlir::Op&lt; ConcreteType, Traits &gt;::clone()</a>, <a class="el" href="OpDefinition_8h_source.html#l01692">mlir::Op&lt; ConcreteType, Traits &gt;::cloneWithoutRegions()</a>, <a class="el" href="ShardOps_8h_source.html#l00130">mlir::shard::getGrid()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00200">getGridAndVerifyAxes()</a>, and <a class="el" href="OpDefinition_8h_source.html#l01977">mlir::Op&lt; ConcreteType, Traits &gt;::getProperties()</a>.</p>

</div>
</div>
<a id="abc93f31894a0fa90004999ceea8dbe36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc93f31894a0fa90004999ceea8dbe36">&#9670;&nbsp;</a></span>getProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename T  = ConcreteType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Op.html#aeb22cbbff9dc8dab72c638ea384ecd2a">InferredProperties</a>&lt;T&gt;&amp; <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::getProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01977">1977</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00249">mlir::OpState::getEmptyProperties()</a>, <a class="el" href="OpDefinition_8h_source.html#l00112">mlir::Op&lt; ConcreteType, Traits &gt;::getOperation()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00913">mlir::Operation::getPropertiesStorageUnsafe()</a>, and <a class="el" href="OpDefinition_8h_source.html#l01843">mlir::Op&lt; ConcreteType, Traits &gt;::hasProperties()</a>.</p>

</div>
</div>
<a id="a65160d5d9f4234c81d7db4be013aad40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65160d5d9f4234c81d7db4be013aad40">&#9670;&nbsp;</a></span>getPropertiesAsAttr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename PropertiesTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::getPropertiesAsAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PropertiesTy &amp;&#160;</td>
          <td class="paramname"><em>prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the provided properties to an attribute. </p>
<p>This default implementation forwards to a free function <code>getPropertiesAsAttribute</code> that can be looked up with ADL in the namespace where the properties are defined. It can also be overridden in the derived ConcreteOp. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01766">1766</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="ab836044f7d5dc6bd251ec324e6a59d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab836044f7d5dc6bd251ec324e6a59d20">&#9670;&nbsp;</a></span>hasProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::hasProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this operation defines a <code>Properties</code> inner type. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01843">1843</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpDefinition_8h_source.html#l01977">mlir::Op&lt; ConcreteType, Traits &gt;::getProperties()</a>.</p>

</div>
</div>
<a id="ab0f28a9a8ea472061179fd53883ea589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f28a9a8ea472061179fd53883ea589">&#9670;&nbsp;</a></span>hasTrait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename T &gt; class Trait&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::hasTrait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return if this operation contains the provided trait. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01682">1682</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="acaebd0595f35c45f8ddb7c3bb0d7911b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaebd0595f35c45f8ddb7c3bb0d7911b">&#9670;&nbsp;</a></span>parseProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename T  = ConcreteType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ParseResult <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::parseProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses 'prop-dict' for the operation. </p>
<p>Unless overridden, the method will parse the properties using the generic property dictionary using the '&lt;{ ... }&gt;' syntax. The resulting properties are stored within the property structure of 'result', accessible via 'getOrAddProperties'. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l02009">2009</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00830">mlir::OpState::emitError()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00792">mlir::OpState::genericParseProperties()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="OperationSupport_8h_source.html#l01114">mlir::OperationState::getContext()</a>, <a class="el" href="OperationSupport_8h_source.html#l00997">mlir::OperationState::getOrAddProperties()</a>, <a class="el" href="OperationSupport_8h_source.html#l00473">mlir::OperationName::getStringRef()</a>, <a class="el" href="OperationSupport_8h_source.html#l00949">mlir::OperationState::location</a>, and <a class="el" href="OperationSupport_8h_source.html#l00950">mlir::OperationState::name</a>.</p>

</div>
</div>
<a id="afbb1f4a3688ae37231e943a74f5a9079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb1f4a3688ae37231e943a74f5a9079">&#9670;&nbsp;</a></span>populateDefaultProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename T  = ConcreteType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::populateDefaultProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>opName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Op.html#aeb22cbbff9dc8dab72c638ea384ecd2a">InferredProperties</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This hook populates any unset default attrs when mapped to properties. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01987">1987</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a78566efdfb9083f28e2a290758be204e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78566efdfb9083f28e2a290758be204e">&#9670;&nbsp;</a></span>printProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::printProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt;&#160;</td>
          <td class="paramname"><em>elidedProps</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the operation properties with names not included within 'elidedProps'. </p>
<p>Unless overridden, this method will try to dispatch to a <code>printProperties</code> free-function if it exists, and otherwise by converting the properties to an <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01995">1995</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a1bbadb7faf098d7d2e7a276b594a966d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbadb7faf098d7d2e7a276b594a966d">&#9670;&nbsp;</a></span>setPropertiesFromAttr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename PropertiesTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::setPropertiesFromAttr </td>
          <td>(</td>
          <td class="paramtype">PropertiesTy &amp;&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the provided attribute to a property and assigned it to the provided properties. </p>
<p>This default implementation forwards to a free function <code>setPropertiesFromAttribute</code> that can be looked up with ADL in the namespace where the properties are defined. It can also be overridden in the derived ConcreteOp. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01757">1757</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00830">mlir::OpState::emitError()</a>.</p>

</div>
</div>
<a id="a353c0e5088dbb6624b01221f62262f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353c0e5088dbb6624b01221f62262f78">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::OpState::verify</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the concrete type didn't implement a custom verifier hook, just fall back to this one which accepts everything. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00214">214</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a707e0acf20eca83644d64ca1718a6c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707e0acf20eca83644d64ca1718a6c4a">&#9670;&nbsp;</a></span>verifyRegions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::OpState::verifyRegions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00215">215</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/mlir/IR/<a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:30 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
