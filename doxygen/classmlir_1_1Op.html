<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::Op&lt; ConcreteType, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="classmlir_1_1Op.html">Op</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmlir_1_1Op-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mlir::Op&lt; ConcreteType, Traits &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This provides public APIs that all operations should have.  
 <a href="#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="OpDefinition_8h_source.html">mlir/IR/OpDefinition.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Inheritance diagram for mlir::Op&lt; ConcreteType, Traits &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="classmlir_1_1Op__inherit__graph.svg" width="2206" height="508"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a63c65a9810b37ce3fa35ca27acdce394" id="r_a63c65a9810b37ce3fa35ca27acdce394"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63c65a9810b37ce3fa35ca27acdce394">ConcreteOpType</a> = ConcreteType</td></tr>
<tr class="memdesc:a63c65a9810b37ce3fa35ca27acdce394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expose the type we are instantiated on to template machinery that may want to introspect traits on this operation.  <br /></td></tr>
<tr class="memitem:aeb22cbbff9dc8dab72c638ea384ecd2a" id="r_aeb22cbbff9dc8dab72c638ea384ecd2a"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aeb22cbbff9dc8dab72c638ea384ecd2a template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb22cbbff9dc8dab72c638ea384ecd2a">InferredProperties</a> = typename <a class="el" href="structmlir_1_1PropertiesSelector.html">PropertiesSelector</a>&lt;T&gt;::type</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a78d7e2ead4d30cbc9c32d8ecfa1d1fbb" id="r_a78d7e2ead4d30cbc9c32d8ecfa1d1fbb"><td class="memItemLeft" align="right" valign="top">ConcreteType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78d7e2ead4d30cbc9c32d8ecfa1d1fbb">clone</a> ()</td></tr>
<tr class="memdesc:a78d7e2ead4d30cbc9c32d8ecfa1d1fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a deep copy of this operation.  <br /></td></tr>
<tr class="memitem:aebcbe19488b3c38705a819fb09e0be5d" id="r_aebcbe19488b3c38705a819fb09e0be5d"><td class="memItemLeft" align="right" valign="top">ConcreteType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebcbe19488b3c38705a819fb09e0be5d">cloneWithoutRegions</a> ()</td></tr>
<tr class="memdesc:aebcbe19488b3c38705a819fb09e0be5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a partial copy of this operation without traversing into attached regions.  <br /></td></tr>
<tr class="memitem:abe9f320696122f31b6b22509d137d33d" id="r_abe9f320696122f31b6b22509d137d33d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe9f320696122f31b6b22509d137d33d">Op</a> ()</td></tr>
<tr class="memdesc:abe9f320696122f31b6b22509d137d33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a public constructor. Any op can be initialized to null.  <br /></td></tr>
<tr class="memitem:a25b3a86209028ced4a8405877fb51b5b" id="r_a25b3a86209028ced4a8405877fb51b5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25b3a86209028ced4a8405877fb51b5b">Op</a> (std::nullptr_t)</td></tr>
<tr class="memitem:a5905d939c92414ac6cce2c7d54f8f05e" id="r_a5905d939c92414ac6cce2c7d54f8f05e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5905d939c92414ac6cce2c7d54f8f05e">Op</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *state)</td></tr>
<tr class="memdesc:a5905d939c92414ac6cce2c7d54f8f05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a public constructor to enable access via the llvm::cast family of methods.  <br /></td></tr>
<tr class="memitem:a9cb4f01a9acd6af950335514bdd62fb8" id="r_a9cb4f01a9acd6af950335514bdd62fb8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvoid.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cb4f01a9acd6af950335514bdd62fb8">getAsOpaquePointer</a> () const</td></tr>
<tr class="memdesc:a9cb4f01a9acd6af950335514bdd62fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for supporting PointerLikeTypeTraits.  <br /></td></tr>
<tr class="memitem:a52bb5c8dcf6ff3eaa958325a191463c0" id="r_a52bb5c8dcf6ff3eaa958325a191463c0"><td class="memTemplParams" colspan="2">template&lt;typename T = ConcreteType&gt; </td></tr>
<tr class="memitem:a52bb5c8dcf6ff3eaa958325a191463c0 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aeb22cbbff9dc8dab72c638ea384ecd2a">InferredProperties</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52bb5c8dcf6ff3eaa958325a191463c0">getProperties</a> ()</td></tr>
<tr class="memitem:a07498e3dedc536a76cf17a1641ceda39" id="r_a07498e3dedc536a76cf17a1641ceda39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07498e3dedc536a76cf17a1641ceda39">getOperation</a> ()</td></tr>
<tr class="memdesc:a07498e3dedc536a76cf17a1641ceda39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherit getOperation from <span class="tt"><a class="el" href="classmlir_1_1OpState.html" title="This is the concrete base class that holds the operation pointer and has non-generic methods that onl...">OpState</a></span>.  <br /></td></tr>
<tr class="memitem:a353c0e5088dbb6624b01221f62262f78" id="r_a353c0e5088dbb6624b01221f62262f78"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a353c0e5088dbb6624b01221f62262f78">verify</a> ()</td></tr>
<tr class="memdesc:a353c0e5088dbb6624b01221f62262f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the concrete type didn't implement a custom verifier hook, just fall back to this one which accepts everything.  <br /></td></tr>
<tr class="memitem:a707e0acf20eca83644d64ca1718a6c4a" id="r_a707e0acf20eca83644d64ca1718a6c4a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a707e0acf20eca83644d64ca1718a6c4a">verifyRegions</a> ()</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classmlir_1_1OpState')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:a4a630754c7bac8e1c33ced0f4f25e3ba inherit pub_methods_classmlir_1_1OpState" id="r_a4a630754c7bac8e1c33ced0f4f25e3ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a4a630754c7bac8e1c33ced0f4f25e3ba">operator bool</a> ()</td></tr>
<tr class="memdesc:a4a630754c7bac8e1c33ced0f4f25e3ba inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ops are pointer-like, so we allow conversion to bool.  <br /></td></tr>
<tr class="memitem:ac53baa7db4eecd983c7387027ebf0f44 inherit pub_methods_classmlir_1_1OpState" id="r_ac53baa7db4eecd983c7387027ebf0f44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ac53baa7db4eecd983c7387027ebf0f44">operator Operation *</a> () const</td></tr>
<tr class="memdesc:ac53baa7db4eecd983c7387027ebf0f44 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implicitly converts to Operation*.  <br /></td></tr>
<tr class="memitem:a03ca82f3b7fa6b65533860e3818c1b8a inherit pub_methods_classmlir_1_1OpState" id="r_a03ca82f3b7fa6b65533860e3818c1b8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a03ca82f3b7fa6b65533860e3818c1b8a">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:a03ca82f3b7fa6b65533860e3818c1b8a inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut of <span class="tt">-&gt;</span> to access a member of <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <br /></td></tr>
<tr class="memitem:a07498e3dedc536a76cf17a1641ceda39 inherit pub_methods_classmlir_1_1OpState" id="r_a07498e3dedc536a76cf17a1641ceda39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a07498e3dedc536a76cf17a1641ceda39">getOperation</a> ()</td></tr>
<tr class="memdesc:a07498e3dedc536a76cf17a1641ceda39 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the operation that this refers to.  <br /></td></tr>
<tr class="memitem:a87756cd2be7f772c2f6b129188fe4865 inherit pub_methods_classmlir_1_1OpState" id="r_a87756cd2be7f772c2f6b129188fe4865"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a87756cd2be7f772c2f6b129188fe4865">getContext</a> ()</td></tr>
<tr class="memdesc:a87756cd2be7f772c2f6b129188fe4865 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the context this operation belongs to.  <br /></td></tr>
<tr class="memitem:a5a472af9de9610021657c2874e6b1191 inherit pub_methods_classmlir_1_1OpState" id="r_a5a472af9de9610021657c2874e6b1191"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a5a472af9de9610021657c2874e6b1191">print</a> (<a class="el" href="classmlir_1_1raw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags={})</td></tr>
<tr class="memdesc:a5a472af9de9610021657c2874e6b1191 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the operation to the given stream.  <br /></td></tr>
<tr class="memitem:a5ae2204ca73ef2a338a1f980d3662f80 inherit pub_methods_classmlir_1_1OpState" id="r_a5ae2204ca73ef2a338a1f980d3662f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a5ae2204ca73ef2a338a1f980d3662f80">print</a> (<a class="el" href="classmlir_1_1raw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1AsmState.html">AsmState</a> &amp;asmState)</td></tr>
<tr class="memitem:a023cde86e8d01c23ae2f7c07d084d21a inherit pub_methods_classmlir_1_1OpState" id="r_a023cde86e8d01c23ae2f7c07d084d21a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a023cde86e8d01c23ae2f7c07d084d21a">dump</a> ()</td></tr>
<tr class="memdesc:a023cde86e8d01c23ae2f7c07d084d21a inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump this operation.  <br /></td></tr>
<tr class="memitem:ad824acf76e230e3cd64a02d66a82a0cb inherit pub_methods_classmlir_1_1OpState" id="r_ad824acf76e230e3cd64a02d66a82a0cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ad824acf76e230e3cd64a02d66a82a0cb">getLoc</a> ()</td></tr>
<tr class="memdesc:ad824acf76e230e3cd64a02d66a82a0cb inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">The source location the operation was defined or derived from.  <br /></td></tr>
<tr class="memitem:a3159f7aa51ff5db54cbab48867d00365 inherit pub_methods_classmlir_1_1OpState" id="r_a3159f7aa51ff5db54cbab48867d00365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a3159f7aa51ff5db54cbab48867d00365">use_empty</a> ()</td></tr>
<tr class="memdesc:a3159f7aa51ff5db54cbab48867d00365 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are no users of any results of this operation.  <br /></td></tr>
<tr class="memitem:a202c02a251ca0fce2c2a9df84b9ea32f inherit pub_methods_classmlir_1_1OpState" id="r_a202c02a251ca0fce2c2a9df84b9ea32f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a202c02a251ca0fce2c2a9df84b9ea32f">erase</a> ()</td></tr>
<tr class="memdesc:a202c02a251ca0fce2c2a9df84b9ea32f inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove this operation from its parent block and delete it.  <br /></td></tr>
<tr class="memitem:a96a602baeafc892ba94fd30bfeb0624b inherit pub_methods_classmlir_1_1OpState" id="r_a96a602baeafc892ba94fd30bfeb0624b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a96a602baeafc892ba94fd30bfeb0624b">emitOpError</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:a96a602baeafc892ba94fd30bfeb0624b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an error with the op name prefixed, like "'dim' op " which is convenient for verifiers.  <br /></td></tr>
<tr class="memitem:a78ab2e156408bc77bb5d5629068bda60 inherit pub_methods_classmlir_1_1OpState" id="r_a78ab2e156408bc77bb5d5629068bda60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a78ab2e156408bc77bb5d5629068bda60">emitError</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:a78ab2e156408bc77bb5d5629068bda60 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an error about fatal conditions with this operation, reporting up to any diagnostic handlers that may be listening.  <br /></td></tr>
<tr class="memitem:aa94173f14645d198ba9e07f763acfe4b inherit pub_methods_classmlir_1_1OpState" id="r_aa94173f14645d198ba9e07f763acfe4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#aa94173f14645d198ba9e07f763acfe4b">emitWarning</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:aa94173f14645d198ba9e07f763acfe4b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a warning about this operation, reporting up to any diagnostic handlers that may be listening.  <br /></td></tr>
<tr class="memitem:ac456e15c3588fd348490eb8e423617ea inherit pub_methods_classmlir_1_1OpState" id="r_ac456e15c3588fd348490eb8e423617ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ac456e15c3588fd348490eb8e423617ea">emitRemark</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:ac456e15c3588fd348490eb8e423617ea inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a remark about this operation, reporting up to any diagnostic handlers that may be listening.  <br /></td></tr>
<tr class="memitem:adba39290e636f2a3c0373e225b2e132f inherit pub_methods_classmlir_1_1OpState" id="r_adba39290e636f2a3c0373e225b2e132f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> Order = WalkOrder::PostOrder, typename Iterator = ForwardIterator, typename FnT, typename RetT = detail::walkResultType&lt;FnT&gt;&gt; </td></tr>
<tr class="memitem:adba39290e636f2a3c0373e225b2e132f inherit pub_methods_classmlir_1_1OpState template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::function_traits&lt; std::decay_t&lt; FnT &gt; &gt;::num_args==1, RetT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#adba39290e636f2a3c0373e225b2e132f">walk</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:adba39290e636f2a3c0373e225b2e132f inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk the operation by calling the callback for each nested operation (including this one), block or region, depending on the callback provided.  <br /></td></tr>
<tr class="memitem:a1965cbcb6a548fb66991c7d7dfd5105b inherit pub_methods_classmlir_1_1OpState" id="r_a1965cbcb6a548fb66991c7d7dfd5105b"><td class="memTemplParams" colspan="2">template&lt;typename FnT, typename RetT = detail::walkResultType&lt;FnT&gt;&gt; </td></tr>
<tr class="memitem:a1965cbcb6a548fb66991c7d7dfd5105b inherit pub_methods_classmlir_1_1OpState template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::function_traits&lt; std::decay_t&lt; FnT &gt; &gt;::num_args==2, RetT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a1965cbcb6a548fb66991c7d7dfd5105b">walk</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a1965cbcb6a548fb66991c7d7dfd5105b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic walker with a stage aware callback.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab0f28a9a8ea472061179fd53883ea589" id="r_ab0f28a9a8ea472061179fd53883ea589"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T &gt; class Trait&gt; </td></tr>
<tr class="memitem:ab0f28a9a8ea472061179fd53883ea589 template"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0f28a9a8ea472061179fd53883ea589">hasTrait</a> ()</td></tr>
<tr class="memdesc:ab0f28a9a8ea472061179fd53883ea589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if this operation contains the provided trait.  <br /></td></tr>
<tr class="memitem:a1240be31ea922d33b1b2392e723a3b4e" id="r_a1240be31ea922d33b1b2392e723a3b4e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1240be31ea922d33b1b2392e723a3b4e">classof</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a1240be31ea922d33b1b2392e723a3b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this "op class" can match against the specified operation.  <br /></td></tr>
<tr class="memitem:ae9813259fa981d1887d5d79e50bbcc5a" id="r_ae9813259fa981d1887d5d79e50bbcc5a"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ae9813259fa981d1887d5d79e50bbcc5a template"><td class="memItemLeft" align="right" valign="top">static std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1OpState.html">OpState</a>, T &gt;::value, <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9813259fa981d1887d5d79e50bbcc5a">classof</a> (const T *op)</td></tr>
<tr class="memdesc:ae9813259fa981d1887d5d79e50bbcc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <span class="tt">classof</span> support for other OpBase derived classes, such as Interfaces.  <br /></td></tr>
<tr class="memitem:a2c2c41a61d1531398c6bfc2f2ed1e4e8" id="r_a2c2c41a61d1531398c6bfc2f2ed1e4e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a63c65a9810b37ce3fa35ca27acdce394">ConcreteOpType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c2c41a61d1531398c6bfc2f2ed1e4e8">getFromOpaquePointer</a> (const <a class="el" href="classvoid.html">void</a> *pointer)</td></tr>
<tr class="memitem:ad859b0a042439ebb5182e4493ff7b853" id="r_ad859b0a042439ebb5182e4493ff7b853"><td class="memTemplParams" colspan="2">template&lt;typename... Models&gt; </td></tr>
<tr class="memitem:ad859b0a042439ebb5182e4493ff7b853 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad859b0a042439ebb5182e4493ff7b853">attachInterface</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:ad859b0a042439ebb5182e4493ff7b853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach the given models as implementations of the corresponding interfaces for the concrete operation.  <br /></td></tr>
<tr class="memitem:a1bbadb7faf098d7d2e7a276b594a966d" id="r_a1bbadb7faf098d7d2e7a276b594a966d"><td class="memTemplParams" colspan="2">template&lt;typename PropertiesTy&gt; </td></tr>
<tr class="memitem:a1bbadb7faf098d7d2e7a276b594a966d template"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bbadb7faf098d7d2e7a276b594a966d">setPropertiesFromAttr</a> (PropertiesTy &amp;prop, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="classmlir_1_1OpState.html#a78ab2e156408bc77bb5d5629068bda60">emitError</a>)</td></tr>
<tr class="memdesc:a1bbadb7faf098d7d2e7a276b594a966d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided attribute to a property and assigned it to the provided properties.  <br /></td></tr>
<tr class="memitem:a65160d5d9f4234c81d7db4be013aad40" id="r_a65160d5d9f4234c81d7db4be013aad40"><td class="memTemplParams" colspan="2">template&lt;typename PropertiesTy&gt; </td></tr>
<tr class="memitem:a65160d5d9f4234c81d7db4be013aad40 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65160d5d9f4234c81d7db4be013aad40">getPropertiesAsAttr</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, const PropertiesTy &amp;prop)</td></tr>
<tr class="memdesc:a65160d5d9f4234c81d7db4be013aad40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided properties to an attribute.  <br /></td></tr>
<tr class="memitem:ab4e2d0393e4914199370400b54baa4a8" id="r_ab4e2d0393e4914199370400b54baa4a8"><td class="memTemplParams" colspan="2">template&lt;typename PropertiesTy&gt; </td></tr>
<tr class="memitem:ab4e2d0393e4914199370400b54baa4a8 template"><td class="memItemLeft" align="right" valign="top">static llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4e2d0393e4914199370400b54baa4a8">computePropertiesHash</a> (const PropertiesTy &amp;prop)</td></tr>
<tr class="memdesc:ab4e2d0393e4914199370400b54baa4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash the provided properties.  <br /></td></tr>
<tr class="memitem:ab836044f7d5dc6bd251ec324e6a59d20" id="r_ab836044f7d5dc6bd251ec324e6a59d20"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab836044f7d5dc6bd251ec324e6a59d20">hasProperties</a> ()</td></tr>
<tr class="memdesc:ab836044f7d5dc6bd251ec324e6a59d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this operation defines a <span class="tt">Properties</span> inner type.  <br /></td></tr>
<tr class="memitem:afbb1f4a3688ae37231e943a74f5a9079" id="r_afbb1f4a3688ae37231e943a74f5a9079"><td class="memTemplParams" colspan="2">template&lt;typename T = ConcreteType&gt; </td></tr>
<tr class="memitem:afbb1f4a3688ae37231e943a74f5a9079 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbb1f4a3688ae37231e943a74f5a9079">populateDefaultProperties</a> (<a class="el" href="classmlir_1_1OperationName.html">OperationName</a> opName, <a class="el" href="#aeb22cbbff9dc8dab72c638ea384ecd2a">InferredProperties</a>&lt; T &gt; &amp;properties)</td></tr>
<tr class="memdesc:afbb1f4a3688ae37231e943a74f5a9079"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook populates any unset default attrs when mapped to properties.  <br /></td></tr>
<tr class="memitem:a78566efdfb9083f28e2a290758be204e" id="r_a78566efdfb9083f28e2a290758be204e"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a78566efdfb9083f28e2a290758be204e template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78566efdfb9083f28e2a290758be204e">printProperties</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, const T &amp;properties, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; elidedProps={})</td></tr>
<tr class="memdesc:a78566efdfb9083f28e2a290758be204e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the operation properties with names not included within 'elidedProps'.  <br /></td></tr>
<tr class="memitem:acaebd0595f35c45f8ddb7c3bb0d7911b" id="r_acaebd0595f35c45f8ddb7c3bb0d7911b"><td class="memTemplParams" colspan="2">template&lt;typename T = ConcreteType&gt; </td></tr>
<tr class="memitem:acaebd0595f35c45f8ddb7c3bb0d7911b template"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acaebd0595f35c45f8ddb7c3bb0d7911b">parseProperties</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memdesc:acaebd0595f35c45f8ddb7c3bb0d7911b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses 'prop-dict' for the operation.  <br /></td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classmlir_1_1OpState')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Static Public Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:ab697ae7a73f65229a4c63fc72dc5655d inherit pub_static_methods_classmlir_1_1OpState" id="r_ab697ae7a73f65229a4c63fc72dc5655d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ab697ae7a73f65229a4c63fc72dc5655d">getCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;results, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ab697ae7a73f65229a4c63fc72dc5655d inherit pub_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook returns any canonicalization pattern rewrites that the operation supports, for use by the canonicalization pass.  <br /></td></tr>
<tr class="memitem:ad86c745166da5745b6043c84025780f0 inherit pub_static_methods_classmlir_1_1OpState" id="r_ad86c745166da5745b6043c84025780f0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ad86c745166da5745b6043c84025780f0">populateDefaultAttrs</a> (const <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> &amp;, <a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;)</td></tr>
<tr class="memdesc:ad86c745166da5745b6043c84025780f0 inherit pub_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook populates any unset default attrs.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-inherited" class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classmlir_1_1OpState')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:a353c0e5088dbb6624b01221f62262f78 inherit pro_methods_classmlir_1_1OpState" id="r_a353c0e5088dbb6624b01221f62262f78"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a353c0e5088dbb6624b01221f62262f78">verify</a> ()</td></tr>
<tr class="memdesc:a353c0e5088dbb6624b01221f62262f78 inherit pro_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the concrete type didn't implement a custom verifier hook, just fall back to this one which accepts everything.  <br /></td></tr>
<tr class="memitem:a707e0acf20eca83644d64ca1718a6c4a inherit pro_methods_classmlir_1_1OpState" id="r_a707e0acf20eca83644d64ca1718a6c4a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a707e0acf20eca83644d64ca1718a6c4a">verifyRegions</a> ()</td></tr>
<tr class="memitem:ad2cb0c062a04c9797e443d2ee1a4d9e7 inherit pro_methods_classmlir_1_1OpState" id="r_ad2cb0c062a04c9797e443d2ee1a4d9e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ad2cb0c062a04c9797e443d2ee1a4d9e7">OpState</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *state)</td></tr>
<tr class="memdesc:ad2cb0c062a04c9797e443d2ee1a4d9e7 inherit pro_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutability management is handled by the OpWrapper/OpConstWrapper classes, so we can cast it away here.  <br /></td></tr>
<tr class="inherit_header pro_static_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_static_methods_classmlir_1_1OpState')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Static Protected Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:abcfdfbc4f6158e19c5993549247132fb inherit pro_static_methods_classmlir_1_1OpState" id="r_abcfdfbc4f6158e19c5993549247132fb"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#abcfdfbc4f6158e19c5993549247132fb">parse</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memdesc:abcfdfbc4f6158e19c5993549247132fb inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the custom form of an operation.  <br /></td></tr>
<tr class="memitem:aa1d2761129af0c55404133f9b47f21b6 inherit pro_static_methods_classmlir_1_1OpState" id="r_aa1d2761129af0c55404133f9b47f21b6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#aa1d2761129af0c55404133f9b47f21b6">print</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, StringRef defaultDialect)</td></tr>
<tr class="memdesc:aa1d2761129af0c55404133f9b47f21b6 inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the operation.  <br /></td></tr>
<tr class="memitem:ab8e0ae9c848fe4e633e46a3ce0863bab inherit pro_static_methods_classmlir_1_1OpState" id="r_ab8e0ae9c848fe4e633e46a3ce0863bab"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ab8e0ae9c848fe4e633e46a3ce0863bab">genericParseProperties</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memdesc:ab8e0ae9c848fe4e633e46a3ce0863bab inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse properties as a <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <br /></td></tr>
<tr class="memitem:a07588469ccab75d875094f095c4f2d1b inherit pro_static_methods_classmlir_1_1OpState" id="r_a07588469ccab75d875094f095c4f2d1b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a07588469ccab75d875094f095c4f2d1b">genericPrintProperties</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> properties, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; elidedProps={})</td></tr>
<tr class="memdesc:a07588469ccab75d875094f095c4f2d1b inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the properties as a <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> with names not included within 'elidedProps'.  <br /></td></tr>
<tr class="memitem:a624f18cf4e9a772ab1187fd997ccf2b8 inherit pro_static_methods_classmlir_1_1OpState" id="r_a624f18cf4e9a772ab1187fd997ccf2b8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a624f18cf4e9a772ab1187fd997ccf2b8">printOpName</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, StringRef defaultDialect)</td></tr>
<tr class="memdesc:a624f18cf4e9a772ab1187fd997ccf2b8 inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an operation name, eliding the dialect prefix if necessary.  <br /></td></tr>
<tr class="memitem:a1ca17fc28ef080321a0bebb3001d492a inherit pro_static_methods_classmlir_1_1OpState" id="r_a1ca17fc28ef080321a0bebb3001d492a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1EmptyProperties.html">EmptyProperties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a1ca17fc28ef080321a0bebb3001d492a">getEmptyProperties</a> ()</td></tr>
<tr class="memdesc:a1ca17fc28ef080321a0bebb3001d492a inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">For all op which don't have properties, we keep a single instance of <span class="tt"><a class="el" href="structmlir_1_1EmptyProperties.html" title="Structure used by default as a &quot;marker&quot; when no &quot;Properties&quot; are set on an Operation.">EmptyProperties</a></span> to be used where a reference to a properties is needed: this allow to bind a pointer to the reference without triggering UB.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt;<br />
class mlir::Op&lt; ConcreteType, Traits &gt;</div><p>This provides public APIs that all operations should have. </p>
<p>The template argument 'ConcreteType' should be the concrete type by CRTP and the others are base classes by the policy pattern. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01673">1673</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a63c65a9810b37ce3fa35ca27acdce394" name="a63c65a9810b37ce3fa35ca27acdce394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c65a9810b37ce3fa35ca27acdce394">&#9670;&#160;</a></span>ConcreteOpType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::ConcreteOpType = ConcreteType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expose the type we are instantiated on to template machinery that may want to introspect traits on this operation. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01718">1718</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="aeb22cbbff9dc8dab72c638ea384ecd2a" name="aeb22cbbff9dc8dab72c638ea384ecd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb22cbbff9dc8dab72c638ea384ecd2a">&#9670;&#160;</a></span>InferredProperties</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::InferredProperties = typename <a class="el" href="structmlir_1_1PropertiesSelector.html">PropertiesSelector</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01975">1975</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abe9f320696122f31b6b22509d137d33d" name="abe9f320696122f31b6b22509d137d33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9f320696122f31b6b22509d137d33d">&#9670;&#160;</a></span>Op() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::Op </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a public constructor. Any op can be initialized to null. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01721">1721</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01379">nullptr</a>, and <a class="el" href="OpDefinition_8h_source.html#l00244">mlir::OpState::OpState()</a>.</p>

</div>
</div>
<a id="a25b3a86209028ced4a8405877fb51b5b" name="a25b3a86209028ced4a8405877fb51b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b3a86209028ced4a8405877fb51b5b">&#9670;&#160;</a></span>Op() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::Op </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01722">1722</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l01379">nullptr</a>, and <a class="el" href="OpDefinition_8h_source.html#l00244">mlir::OpState::OpState()</a>.</p>

</div>
</div>
<a id="a5905d939c92414ac6cce2c7d54f8f05e" name="a5905d939c92414ac6cce2c7d54f8f05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5905d939c92414ac6cce2c7d54f8f05e">&#9670;&#160;</a></span>Op() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::Op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a public constructor to enable access via the llvm::cast family of methods. </p>
<p>This should not be used directly. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01726">1726</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00244">mlir::OpState::OpState()</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ad859b0a042439ebb5182e4493ff7b853" name="ad859b0a042439ebb5182e4493ff7b853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad859b0a042439ebb5182e4493ff7b853">&#9670;&#160;</a></span>attachInterface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename... Models&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::attachInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach the given models as implementations of the corresponding interfaces for the concrete operation. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01740">1740</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="TypeID_8h_source.html#l00245">mlir::TypeID::get()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l00953">mlir::RegisteredOperationName::lookup()</a>.</p>

</div>
</div>
<a id="ae9813259fa981d1887d5d79e50bbcc5a" name="ae9813259fa981d1887d5d79e50bbcc5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9813259fa981d1887d5d79e50bbcc5a">&#9670;&#160;</a></span>classof() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1OpState.html">OpState</a>, T &gt;::value, <a class="el" href="classbool.html">bool</a> &gt; <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::classof </td>
          <td>(</td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide <span class="tt">classof</span> support for other OpBase derived classes, such as Interfaces. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01712">1712</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l01697">classof()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00112">getOperation()</a>.</p>

</div>
</div>
<a id="a1240be31ea922d33b1b2392e723a3b4e" name="a1240be31ea922d33b1b2392e723a3b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1240be31ea922d33b1b2392e723a3b4e">&#9670;&#160;</a></span>classof() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::classof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this "op class" can match against the specified operation. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01697">1697</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="TypeID_8h_source.html#l00245">mlir::TypeID::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00123">mlir::Operation::getRegisteredInfo()</a>, and <a class="el" href="OperationSupport_8h_source.html#l00473">mlir::OperationName::getStringRef()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpDefinition_8h_source.html#l01712">classof()</a>.</p>

</div>
</div>
<a id="a78d7e2ead4d30cbc9c32d8ecfa1d1fbb" name="a78d7e2ead4d30cbc9c32d8ecfa1d1fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d7e2ead4d30cbc9c32d8ecfa1d1fbb">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConcreteType <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a deep copy of this operation. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01687">1687</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l01687">clone()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00112">getOperation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpDefinition_8h_source.html#l01687">clone()</a>.</p>

</div>
</div>
<a id="aebcbe19488b3c38705a819fb09e0be5d" name="aebcbe19488b3c38705a819fb09e0be5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcbe19488b3c38705a819fb09e0be5d">&#9670;&#160;</a></span>cloneWithoutRegions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConcreteType <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::cloneWithoutRegions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a partial copy of this operation without traversing into attached regions. </p>
<p>The new operation will have the same number of regions as the original one, but they will be left empty. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01692">1692</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l01692">cloneWithoutRegions()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00112">getOperation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpDefinition_8h_source.html#l01692">cloneWithoutRegions()</a>.</p>

</div>
</div>
<a id="ab4e2d0393e4914199370400b54baa4a8" name="ab4e2d0393e4914199370400b54baa4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e2d0393e4914199370400b54baa4a8">&#9670;&#160;</a></span>computePropertiesHash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename PropertiesTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::hash_code <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::computePropertiesHash </td>
          <td>(</td>
          <td class="paramtype">const PropertiesTy &amp;</td>          <td class="paramname"><span class="paramname"><em>prop</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash the provided properties. </p>
<p>This default implementation forwards to a free function <span class="tt">computeHash</span> that can be looked up with ADL in the namespace where the properties are defined. It can also be overridden in the derived ConcreteOp. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01775">1775</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="ModuleCombiner_8cpp_source.html#l00072">computeHash()</a>.</p>

</div>
</div>
<a id="a9cb4f01a9acd6af950335514bdd62fb8" name="a9cb4f01a9acd6af950335514bdd62fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb4f01a9acd6af950335514bdd62fb8">&#9670;&#160;</a></span>getAsOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvoid.html">void</a> * <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::getAsOpaquePointer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for supporting PointerLikeTypeTraits. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01729">1729</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a2c2c41a61d1531398c6bfc2f2ed1e4e8" name="a2c2c41a61d1531398c6bfc2f2ed1e4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2c41a61d1531398c6bfc2f2ed1e4e8">&#9670;&#160;</a></span>getFromOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a63c65a9810b37ce3fa35ca27acdce394">ConcreteOpType</a> <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::getFromOpaquePointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoid.html">void</a> *</td>          <td class="paramname"><span class="paramname"><em>pointer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01732">1732</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a07498e3dedc536a76cf17a1641ceda39" name="a07498e3dedc536a76cf17a1641ceda39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07498e3dedc536a76cf17a1641ceda39">&#9670;&#160;</a></span>getOperation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::OpState::getOperation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inherit getOperation from <span class="tt"><a class="el" href="classmlir_1_1OpState.html" title="This is the concrete base class that holds the operation pointer and has non-generic methods that onl...">OpState</a></span>. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00112">112</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpDefinition_8h_source.html#l01712">classof()</a>, <a class="el" href="OpDefinition_8h_source.html#l01687">clone()</a>, <a class="el" href="OpDefinition_8h_source.html#l01692">cloneWithoutRegions()</a>, <a class="el" href="ShardOps_8h_source.html#l00130">mlir::shard::getGrid()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00200">getGridAndVerifyAxes()</a>, and <a class="el" href="OpDefinition_8h_source.html#l01977">getProperties()</a>.</p>

</div>
</div>
<a id="a52bb5c8dcf6ff3eaa958325a191463c0" name="a52bb5c8dcf6ff3eaa958325a191463c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bb5c8dcf6ff3eaa958325a191463c0">&#9670;&#160;</a></span>getProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename T = ConcreteType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aeb22cbbff9dc8dab72c638ea384ecd2a">InferredProperties</a>&lt; T &gt; &amp; <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::getProperties </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01977">1977</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00249">mlir::OpState::getEmptyProperties()</a>, <a class="el" href="OpDefinition_8h_source.html#l00112">getOperation()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00913">mlir::Operation::getPropertiesStorageUnsafe()</a>, and <a class="el" href="OpDefinition_8h_source.html#l01843">hasProperties()</a>.</p>

</div>
</div>
<a id="a65160d5d9f4234c81d7db4be013aad40" name="a65160d5d9f4234c81d7db4be013aad40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65160d5d9f4234c81d7db4be013aad40">&#9670;&#160;</a></span>getPropertiesAsAttr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename PropertiesTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::getPropertiesAsAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PropertiesTy &amp;</td>          <td class="paramname"><span class="paramname"><em>prop</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the provided properties to an attribute. </p>
<p>This default implementation forwards to a free function <span class="tt">getPropertiesAsAttribute</span> that can be looked up with ADL in the namespace where the properties are defined. It can also be overridden in the derived ConcreteOp. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01766">1766</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="ab836044f7d5dc6bd251ec324e6a59d20" name="ab836044f7d5dc6bd251ec324e6a59d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab836044f7d5dc6bd251ec324e6a59d20">&#9670;&#160;</a></span>hasProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbool.html">bool</a> <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::hasProperties </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this operation defines a <span class="tt">Properties</span> inner type. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01843">1843</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpDefinition_8h_source.html#l01977">getProperties()</a>.</p>

</div>
</div>
<a id="ab0f28a9a8ea472061179fd53883ea589" name="ab0f28a9a8ea472061179fd53883ea589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f28a9a8ea472061179fd53883ea589">&#9670;&#160;</a></span>hasTrait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename T &gt; class Trait&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbool.html">bool</a> <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::hasTrait </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return if this operation contains the provided trait. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01682">1682</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="acaebd0595f35c45f8ddb7c3bb0d7911b" name="acaebd0595f35c45f8ddb7c3bb0d7911b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaebd0595f35c45f8ddb7c3bb0d7911b">&#9670;&#160;</a></span>parseProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename T = ConcreteType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::parseProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses 'prop-dict' for the operation. </p>
<p>Unless overridden, the method will parse the properties using the generic property dictionary using the '&lt;{ ... }&gt;' syntax. The resulting properties are stored within the property structure of 'result', accessible via 'getOrAddProperties'. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l02009">2009</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">mlir::emitError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00826">mlir::OpState::emitError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00788">mlir::OpState::genericParseProperties()</a>, <a class="el" href="OpDefinition_8h_source.html#l02009">parseProperties()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpDefinition_8h_source.html#l02009">parseProperties()</a>.</p>

</div>
</div>
<a id="afbb1f4a3688ae37231e943a74f5a9079" name="afbb1f4a3688ae37231e943a74f5a9079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb1f4a3688ae37231e943a74f5a9079">&#9670;&#160;</a></span>populateDefaultProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename T = ConcreteType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::populateDefaultProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a></td>          <td class="paramname"><span class="paramname"><em>opName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aeb22cbbff9dc8dab72c638ea384ecd2a">InferredProperties</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>properties</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This hook populates any unset default attrs when mapped to properties. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01987">1987</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a78566efdfb9083f28e2a290758be204e" name="a78566efdfb9083f28e2a290758be204e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78566efdfb9083f28e2a290758be204e">&#9670;&#160;</a></span>printProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::printProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>properties</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt;</td>          <td class="paramname"><span class="paramname"><em>elidedProps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the operation properties with names not included within 'elidedProps'. </p>
<p>Unless overridden, this method will try to dispatch to a <span class="tt">printProperties</span> free-function if it exists, and otherwise by converting the properties to an <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01995">1995</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a1bbadb7faf098d7d2e7a276b594a966d" name="a1bbadb7faf098d7d2e7a276b594a966d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbadb7faf098d7d2e7a276b594a966d">&#9670;&#160;</a></span>setPropertiesFromAttr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<div class="memtemplate">
template&lt;typename PropertiesTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult <a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::setPropertiesFromAttr </td>
          <td>(</td>
          <td class="paramtype">PropertiesTy &amp;</td>          <td class="paramname"><span class="paramname"><em>prop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;</td>          <td class="paramname"><span class="paramname"><em>emitError</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the provided attribute to a property and assigned it to the provided properties. </p>
<p>This default implementation forwards to a free function <span class="tt">setPropertiesFromAttribute</span> that can be looked up with ADL in the namespace where the properties are defined. It can also be overridden in the derived ConcreteOp. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01757">1757</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00826">mlir::OpState::emitError()</a>.</p>

</div>
</div>
<a id="a353c0e5088dbb6624b01221f62262f78" name="a353c0e5088dbb6624b01221f62262f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353c0e5088dbb6624b01221f62262f78">&#9670;&#160;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::OpState::verify </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the concrete type didn't implement a custom verifier hook, just fall back to this one which accepts everything. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00214">214</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a707e0acf20eca83644d64ca1718a6c4a" name="a707e0acf20eca83644d64ca1718a6c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707e0acf20eca83644d64ca1718a6c4a">&#9670;&#160;</a></span>verifyRegions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, template&lt; typename T &gt; class... Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::OpState::verifyRegions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00215">215</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/mlir/IR/<a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
