<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::OpState Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="classmlir_1_1OpState.html">OpState</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classmlir_1_1OpState-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mlir::OpState Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This is the concrete base class that holds the operation pointer and has non-generic methods that only depend on State (to avoid having them instantiated on template types that don't affect them.  
 <a href="#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="OpDefinition_8h_source.html">mlir/IR/OpDefinition.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Inheritance diagram for mlir::OpState:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="classmlir_1_1OpState__inherit__graph.svg" width="2139" height="578"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a630754c7bac8e1c33ced0f4f25e3ba" id="r_a4a630754c7bac8e1c33ced0f4f25e3ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a630754c7bac8e1c33ced0f4f25e3ba">operator bool</a> ()</td></tr>
<tr class="memdesc:a4a630754c7bac8e1c33ced0f4f25e3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ops are pointer-like, so we allow conversion to bool.  <br /></td></tr>
<tr class="memitem:ac53baa7db4eecd983c7387027ebf0f44" id="r_ac53baa7db4eecd983c7387027ebf0f44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac53baa7db4eecd983c7387027ebf0f44">operator Operation *</a> () const</td></tr>
<tr class="memdesc:ac53baa7db4eecd983c7387027ebf0f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implicitly converts to Operation*.  <br /></td></tr>
<tr class="memitem:a03ca82f3b7fa6b65533860e3818c1b8a" id="r_a03ca82f3b7fa6b65533860e3818c1b8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03ca82f3b7fa6b65533860e3818c1b8a">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:a03ca82f3b7fa6b65533860e3818c1b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut of <span class="tt">-&gt;</span> to access a member of <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <br /></td></tr>
<tr class="memitem:a07498e3dedc536a76cf17a1641ceda39" id="r_a07498e3dedc536a76cf17a1641ceda39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07498e3dedc536a76cf17a1641ceda39">getOperation</a> ()</td></tr>
<tr class="memdesc:a07498e3dedc536a76cf17a1641ceda39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the operation that this refers to.  <br /></td></tr>
<tr class="memitem:a87756cd2be7f772c2f6b129188fe4865" id="r_a87756cd2be7f772c2f6b129188fe4865"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87756cd2be7f772c2f6b129188fe4865">getContext</a> ()</td></tr>
<tr class="memdesc:a87756cd2be7f772c2f6b129188fe4865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the context this operation belongs to.  <br /></td></tr>
<tr class="memitem:a5a472af9de9610021657c2874e6b1191" id="r_a5a472af9de9610021657c2874e6b1191"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a472af9de9610021657c2874e6b1191">print</a> (<a class="el" href="classmlir_1_1raw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags={})</td></tr>
<tr class="memdesc:a5a472af9de9610021657c2874e6b1191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the operation to the given stream.  <br /></td></tr>
<tr class="memitem:a5ae2204ca73ef2a338a1f980d3662f80" id="r_a5ae2204ca73ef2a338a1f980d3662f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ae2204ca73ef2a338a1f980d3662f80">print</a> (<a class="el" href="classmlir_1_1raw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1AsmState.html">AsmState</a> &amp;asmState)</td></tr>
<tr class="memitem:a023cde86e8d01c23ae2f7c07d084d21a" id="r_a023cde86e8d01c23ae2f7c07d084d21a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a023cde86e8d01c23ae2f7c07d084d21a">dump</a> ()</td></tr>
<tr class="memdesc:a023cde86e8d01c23ae2f7c07d084d21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump this operation.  <br /></td></tr>
<tr class="memitem:ad824acf76e230e3cd64a02d66a82a0cb" id="r_ad824acf76e230e3cd64a02d66a82a0cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad824acf76e230e3cd64a02d66a82a0cb">getLoc</a> ()</td></tr>
<tr class="memdesc:ad824acf76e230e3cd64a02d66a82a0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The source location the operation was defined or derived from.  <br /></td></tr>
<tr class="memitem:a3159f7aa51ff5db54cbab48867d00365" id="r_a3159f7aa51ff5db54cbab48867d00365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3159f7aa51ff5db54cbab48867d00365">use_empty</a> ()</td></tr>
<tr class="memdesc:a3159f7aa51ff5db54cbab48867d00365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are no users of any results of this operation.  <br /></td></tr>
<tr class="memitem:a202c02a251ca0fce2c2a9df84b9ea32f" id="r_a202c02a251ca0fce2c2a9df84b9ea32f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a202c02a251ca0fce2c2a9df84b9ea32f">erase</a> ()</td></tr>
<tr class="memdesc:a202c02a251ca0fce2c2a9df84b9ea32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove this operation from its parent block and delete it.  <br /></td></tr>
<tr class="memitem:a96a602baeafc892ba94fd30bfeb0624b" id="r_a96a602baeafc892ba94fd30bfeb0624b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96a602baeafc892ba94fd30bfeb0624b">emitOpError</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:a96a602baeafc892ba94fd30bfeb0624b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an error with the op name prefixed, like "'dim' op " which is convenient for verifiers.  <br /></td></tr>
<tr class="memitem:a78ab2e156408bc77bb5d5629068bda60" id="r_a78ab2e156408bc77bb5d5629068bda60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78ab2e156408bc77bb5d5629068bda60">emitError</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:a78ab2e156408bc77bb5d5629068bda60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an error about fatal conditions with this operation, reporting up to any diagnostic handlers that may be listening.  <br /></td></tr>
<tr class="memitem:aa94173f14645d198ba9e07f763acfe4b" id="r_aa94173f14645d198ba9e07f763acfe4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa94173f14645d198ba9e07f763acfe4b">emitWarning</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:aa94173f14645d198ba9e07f763acfe4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a warning about this operation, reporting up to any diagnostic handlers that may be listening.  <br /></td></tr>
<tr class="memitem:ac456e15c3588fd348490eb8e423617ea" id="r_ac456e15c3588fd348490eb8e423617ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac456e15c3588fd348490eb8e423617ea">emitRemark</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:ac456e15c3588fd348490eb8e423617ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a remark about this operation, reporting up to any diagnostic handlers that may be listening.  <br /></td></tr>
<tr class="memitem:adba39290e636f2a3c0373e225b2e132f" id="r_adba39290e636f2a3c0373e225b2e132f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> Order = WalkOrder::PostOrder, typename Iterator = ForwardIterator, typename FnT, typename RetT = detail::walkResultType&lt;FnT&gt;&gt; </td></tr>
<tr class="memitem:adba39290e636f2a3c0373e225b2e132f template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::function_traits&lt; std::decay_t&lt; FnT &gt; &gt;::num_args==1, RetT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adba39290e636f2a3c0373e225b2e132f">walk</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:adba39290e636f2a3c0373e225b2e132f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk the operation by calling the callback for each nested operation (including this one), block or region, depending on the callback provided.  <br /></td></tr>
<tr class="memitem:a1965cbcb6a548fb66991c7d7dfd5105b" id="r_a1965cbcb6a548fb66991c7d7dfd5105b"><td class="memTemplParams" colspan="2">template&lt;typename FnT, typename RetT = detail::walkResultType&lt;FnT&gt;&gt; </td></tr>
<tr class="memitem:a1965cbcb6a548fb66991c7d7dfd5105b template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::function_traits&lt; std::decay_t&lt; FnT &gt; &gt;::num_args==2, RetT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1965cbcb6a548fb66991c7d7dfd5105b">walk</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a1965cbcb6a548fb66991c7d7dfd5105b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic walker with a stage aware callback.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab697ae7a73f65229a4c63fc72dc5655d" id="r_ab697ae7a73f65229a4c63fc72dc5655d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab697ae7a73f65229a4c63fc72dc5655d">getCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;results, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ab697ae7a73f65229a4c63fc72dc5655d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook returns any canonicalization pattern rewrites that the operation supports, for use by the canonicalization pass.  <br /></td></tr>
<tr class="memitem:ad86c745166da5745b6043c84025780f0" id="r_ad86c745166da5745b6043c84025780f0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad86c745166da5745b6043c84025780f0">populateDefaultAttrs</a> (const <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> &amp;, <a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;)</td></tr>
<tr class="memdesc:ad86c745166da5745b6043c84025780f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook populates any unset default attrs.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a353c0e5088dbb6624b01221f62262f78" id="r_a353c0e5088dbb6624b01221f62262f78"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a353c0e5088dbb6624b01221f62262f78">verify</a> ()</td></tr>
<tr class="memdesc:a353c0e5088dbb6624b01221f62262f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the concrete type didn't implement a custom verifier hook, just fall back to this one which accepts everything.  <br /></td></tr>
<tr class="memitem:a707e0acf20eca83644d64ca1718a6c4a" id="r_a707e0acf20eca83644d64ca1718a6c4a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a707e0acf20eca83644d64ca1718a6c4a">verifyRegions</a> ()</td></tr>
<tr class="memitem:ad2cb0c062a04c9797e443d2ee1a4d9e7" id="r_ad2cb0c062a04c9797e443d2ee1a4d9e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2cb0c062a04c9797e443d2ee1a4d9e7">OpState</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *state)</td></tr>
<tr class="memdesc:ad2cb0c062a04c9797e443d2ee1a4d9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutability management is handled by the OpWrapper/OpConstWrapper classes, so we can cast it away here.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-static-methods" class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:abcfdfbc4f6158e19c5993549247132fb" id="r_abcfdfbc4f6158e19c5993549247132fb"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcfdfbc4f6158e19c5993549247132fb">parse</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memdesc:abcfdfbc4f6158e19c5993549247132fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the custom form of an operation.  <br /></td></tr>
<tr class="memitem:aa1d2761129af0c55404133f9b47f21b6" id="r_aa1d2761129af0c55404133f9b47f21b6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1d2761129af0c55404133f9b47f21b6">print</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, StringRef defaultDialect)</td></tr>
<tr class="memdesc:aa1d2761129af0c55404133f9b47f21b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the operation.  <br /></td></tr>
<tr class="memitem:ab8e0ae9c848fe4e633e46a3ce0863bab" id="r_ab8e0ae9c848fe4e633e46a3ce0863bab"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8e0ae9c848fe4e633e46a3ce0863bab">genericParseProperties</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memdesc:ab8e0ae9c848fe4e633e46a3ce0863bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse properties as a <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <br /></td></tr>
<tr class="memitem:a07588469ccab75d875094f095c4f2d1b" id="r_a07588469ccab75d875094f095c4f2d1b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07588469ccab75d875094f095c4f2d1b">genericPrintProperties</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> properties, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; elidedProps={})</td></tr>
<tr class="memdesc:a07588469ccab75d875094f095c4f2d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the properties as a <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> with names not included within 'elidedProps'.  <br /></td></tr>
<tr class="memitem:a624f18cf4e9a772ab1187fd997ccf2b8" id="r_a624f18cf4e9a772ab1187fd997ccf2b8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a624f18cf4e9a772ab1187fd997ccf2b8">printOpName</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, StringRef defaultDialect)</td></tr>
<tr class="memdesc:a624f18cf4e9a772ab1187fd997ccf2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an operation name, eliding the dialect prefix if necessary.  <br /></td></tr>
<tr class="memitem:a1ca17fc28ef080321a0bebb3001d492a" id="r_a1ca17fc28ef080321a0bebb3001d492a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1EmptyProperties.html">EmptyProperties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ca17fc28ef080321a0bebb3001d492a">getEmptyProperties</a> ()</td></tr>
<tr class="memdesc:a1ca17fc28ef080321a0bebb3001d492a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For all op which don't have properties, we keep a single instance of <span class="tt"><a class="el" href="structmlir_1_1EmptyProperties.html" title="Structure used by default as a &quot;marker&quot; when no &quot;Properties&quot; are set on an Operation.">EmptyProperties</a></span> to be used where a reference to a properties is needed: this allow to bind a pointer to the reference without triggering UB.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the concrete base class that holds the operation pointer and has non-generic methods that only depend on State (to avoid having them instantiated on template types that don't affect them. </p>
<p>This also has the fallback implementations of customization hooks for when they aren't customized. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00100">100</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad2cb0c062a04c9797e443d2ee1a4d9e7" name="ad2cb0c062a04c9797e443d2ee1a4d9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2cb0c062a04c9797e443d2ee1a4d9e7">&#9670;&#160;</a></span>OpState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::OpState::OpState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutability management is handled by the OpWrapper/OpConstWrapper classes, so we can cast it away here. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00244">244</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpDefinition_8h_source.html#l01721">mlir::Op&lt; ConcreteType, Traits &gt;::Op()</a>, <a class="el" href="OpDefinition_8h_source.html#l01726">mlir::Op&lt; ConcreteType, Traits &gt;::Op()</a>, and <a class="el" href="OpDefinition_8h_source.html#l01722">mlir::Op&lt; ConcreteType, Traits &gt;::Op()</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a023cde86e8d01c23ae2f7c07d084d21a" name="a023cde86e8d01c23ae2f7c07d084d21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023cde86e8d01c23ae2f7c07d084d21a">&#9670;&#160;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::OpState::dump </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump this operation. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00126">126</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Conversion_2SPIRVCommon_2Pattern_8h_source.html#l00027">mlir::spirv::ElementwiseOpPattern&lt; Op, SPIRVOp &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a78ab2e156408bc77bb5d5629068bda60" name="a78ab2e156408bc77bb5d5629068bda60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ab2e156408bc77bb5d5629068bda60">&#9670;&#160;</a></span>emitError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> OpState::emitError </td>
          <td>(</td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>message</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit an error about fatal conditions with this operation, reporting up to any diagnostic handlers that may be listening. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8cpp_source.html#l00826">826</a> of file <a class="el" href="IR_2Operation_8cpp_source.html">Operation.cpp</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00112">getOperation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpenACC_8cpp_source.html#l01645">checkDataOperands()</a>, <a class="el" href="OpenACC_8cpp_source.html#l04083">checkDeclareOperands()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00593">checkNoModifier()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00601">checkValidModifier()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00585">checkVarAndAccVar()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00567">checkVarAndVarType()</a>, <a class="el" href="OpenACC_8cpp_source.html#l00545">checkWaitAndAsyncConflict()</a>, <a class="el" href="lib_2Conversion_2SPIRVCommon_2Pattern_8h_source.html#l00027">mlir::spirv::ElementwiseOpPattern&lt; Op, SPIRVOp &gt;::matchAndRewrite()</a>, <a class="el" href="OpDefinition_8h_source.html#l02009">mlir::Op&lt; ConcreteType, Traits &gt;::parseProperties()</a>, <a class="el" href="OpDefinition_8h_source.html#l01757">mlir::Op&lt; ConcreteType, Traits &gt;::setPropertiesFromAttr()</a>, <a class="el" href="ArithOps_8cpp_source.html#l01398">verifyExtOp()</a>, and <a class="el" href="ArithOps_8cpp_source.html#l01412">verifyTruncateOp()</a>.</p>

</div>
</div>
<a id="a96a602baeafc892ba94fd30bfeb0624b" name="a96a602baeafc892ba94fd30bfeb0624b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a602baeafc892ba94fd30bfeb0624b">&#9670;&#160;</a></span>emitOpError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> OpState::emitOpError </td>
          <td>(</td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>message</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit an error with the op name prefixed, like "'dim' op " which is convenient for verifiers. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8cpp_source.html#l00832">832</a> of file <a class="el" href="IR_2Operation_8cpp_source.html">Operation.cpp</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00112">getOperation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemoryOps_8cpp_source.html#l00330">mlir::spirv::verifyAccessChain()</a>, <a class="el" href="OpenACC_8cpp_source.html#l01700">verifyDeviceTypeAndSegmentCountMatch()</a>, <a class="el" href="OpenACC_8cpp_source.html#l01690">verifyDeviceTypeCountMatch()</a>, <a class="el" href="GroupOps_8cpp_source.html#l00335">mlir::spirv::verifyGroupOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02012">mlir::affine::AffineDmaStartOp::verifyInvariantsImpl()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02148">mlir::affine::AffineDmaWaitOp::verifyInvariantsImpl()</a>.</p>

</div>
</div>
<a id="ac456e15c3588fd348490eb8e423617ea" name="ac456e15c3588fd348490eb8e423617ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac456e15c3588fd348490eb8e423617ea">&#9670;&#160;</a></span>emitRemark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> OpState::emitRemark </td>
          <td>(</td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>message</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a remark about this operation, reporting up to any diagnostic handlers that may be listening. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8cpp_source.html#l00844">844</a> of file <a class="el" href="IR_2Operation_8cpp_source.html">Operation.cpp</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00112">getOperation()</a>.</p>

</div>
</div>
<a id="aa94173f14645d198ba9e07f763acfe4b" name="aa94173f14645d198ba9e07f763acfe4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94173f14645d198ba9e07f763acfe4b">&#9670;&#160;</a></span>emitWarning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> OpState::emitWarning </td>
          <td>(</td>
          <td class="paramtype">const Twine &amp;</td>          <td class="paramname"><span class="paramname"><em>message</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a warning about this operation, reporting up to any diagnostic handlers that may be listening. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8cpp_source.html#l00838">838</a> of file <a class="el" href="IR_2Operation_8cpp_source.html">Operation.cpp</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00112">getOperation()</a>.</p>

</div>
</div>
<a id="a202c02a251ca0fce2c2a9df84b9ea32f" name="a202c02a251ca0fce2c2a9df84b9ea32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202c02a251ca0fce2c2a9df84b9ea32f">&#9670;&#160;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::OpState::erase </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove this operation from its parent block and delete it. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00135">135</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="ab8e0ae9c848fe4e633e46a3ce0863bab" name="ab8e0ae9c848fe4e633e46a3ce0863bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e0ae9c848fe4e633e46a3ce0863bab">&#9670;&#160;</a></span>genericParseProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult OpState::genericParseProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse properties as a <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8cpp_source.html#l00788">788</a> of file <a class="el" href="IR_2Operation_8cpp_source.html">Operation.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="classmlir_1_1AsmParser.html#ab0c07420f37ac78e5376cccc48e6e0d4">mlir::AsmParser::parseGreater()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a94976a6ddf09e6edb7cfe006b0c31faa">mlir::AsmParser::parseOptionalLess()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpDefinition_8h_source.html#l02009">mlir::Op&lt; ConcreteType, Traits &gt;::parseProperties()</a>.</p>

</div>
</div>
<a id="a07588469ccab75d875094f095c4f2d1b" name="a07588469ccab75d875094f095c4f2d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07588469ccab75d875094f095c4f2d1b">&#9670;&#160;</a></span>genericPrintProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> OpState::genericPrintProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>properties</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt;</td>          <td class="paramname"><span class="paramname"><em>elidedProps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the properties as a <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> with names not included within 'elidedProps'. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8cpp_source.html#l00799">799</a> of file <a class="el" href="IR_2Operation_8cpp_source.html">Operation.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8cpp_source.html#l00055">mlir::NamedAttribute::getName()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l02993">mlir::AsmPrinter::printNamedAttribute()</a>.</p>

</div>
</div>
<a id="ab697ae7a73f65229a4c63fc72dc5655d" name="ab697ae7a73f65229a4c63fc72dc5655d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab697ae7a73f65229a4c63fc72dc5655d">&#9670;&#160;</a></span>getCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::OpState::getCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>results</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This hook returns any canonicalization pattern rewrites that the operation supports, for use by the canonicalization pass. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00205">205</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a87756cd2be7f772c2f6b129188fe4865" name="a87756cd2be7f772c2f6b129188fe4865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87756cd2be7f772c2f6b129188fe4865">&#9670;&#160;</a></span>getContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> * mlir::OpState::getContext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the context this operation belongs to. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00115">115</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00112">getOperation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00245">mlir::affine::AffineDmaStartOp::getAffineMapAttrForMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00373">mlir::affine::AffineDmaWaitOp::getAffineMapAttrForMemRef()</a>, and <a class="el" href="IndexIntrinsicsOpLowering_8h_source.html#l00055">mlir::gpu::index_lowering::OpLowering&lt; Op, XOp, YOp, ZOp &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a1ca17fc28ef080321a0bebb3001d492a" name="a1ca17fc28ef080321a0bebb3001d492a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca17fc28ef080321a0bebb3001d492a">&#9670;&#160;</a></span>getEmptyProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1EmptyProperties.html">EmptyProperties</a> &amp; mlir::OpState::getEmptyProperties </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For all op which don't have properties, we keep a single instance of <span class="tt"><a class="el" href="structmlir_1_1EmptyProperties.html" title="Structure used by default as a &quot;marker&quot; when no &quot;Properties&quot; are set on an Operation.">EmptyProperties</a></span> to be used where a reference to a properties is needed: this allow to bind a pointer to the reference without triggering UB. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00249">249</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpDefinition_8h_source.html#l01977">mlir::Op&lt; ConcreteType, Traits &gt;::getProperties()</a>.</p>

</div>
</div>
<a id="ad824acf76e230e3cd64a02d66a82a0cb" name="ad824acf76e230e3cd64a02d66a82a0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad824acf76e230e3cd64a02d66a82a0cb">&#9670;&#160;</a></span>getLoc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Location.html">Location</a> mlir::OpState::getLoc </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The source location the operation was defined or derived from. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00129">129</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpenACC_8cpp_source.html#l04083">checkDeclareOperands()</a>, <a class="el" href="ConversionUtils_8h_source.html#l00051">mlir::tosa::checkHasDynamicBatchDims()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00200">getGridAndVerifyAxes()</a>, <a class="el" href="IndexIntrinsicsOpLowering_8h_source.html#l00055">mlir::gpu::index_lowering::OpLowering&lt; Op, XOp, YOp, ZOp &gt;::matchAndRewrite()</a>, <a class="el" href="lib_2Conversion_2SPIRVCommon_2Pattern_8h_source.html#l00027">mlir::spirv::ElementwiseOpPattern&lt; Op, SPIRVOp &gt;::matchAndRewrite()</a>, and <a class="el" href="MemoryOps_8cpp_source.html#l00330">mlir::spirv::verifyAccessChain()</a>.</p>

</div>
</div>
<a id="a07498e3dedc536a76cf17a1641ceda39" name="a07498e3dedc536a76cf17a1641ceda39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07498e3dedc536a76cf17a1641ceda39">&#9670;&#160;</a></span>getOperation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::OpState::getOperation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the operation that this refers to. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00112">112</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Operation_8cpp_source.html#l00826">emitError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00832">emitOpError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00844">emitRemark()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00838">emitWarning()</a>, <a class="el" href="OpDefinition_8h_source.html#l00115">getContext()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00103">operator bool()</a>.</p>

</div>
</div>
<a id="a4a630754c7bac8e1c33ced0f4f25e3ba" name="a4a630754c7bac8e1c33ced0f4f25e3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a630754c7bac8e1c33ced0f4f25e3ba">&#9670;&#160;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::OpState::operator <a class="el" href="classbool.html">bool</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ops are pointer-like, so we allow conversion to bool. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00103">103</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00112">getOperation()</a>.</p>

</div>
</div>
<a id="ac53baa7db4eecd983c7387027ebf0f44" name="ac53baa7db4eecd983c7387027ebf0f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53baa7db4eecd983c7387027ebf0f44">&#9670;&#160;</a></span>operator Operation *()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::OpState::operator <a class="el" href="classmlir_1_1Operation.html">Operation</a> * </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This implicitly converts to Operation*. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00106">106</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a03ca82f3b7fa6b65533860e3818c1b8a" name="a03ca82f3b7fa6b65533860e3818c1b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ca82f3b7fa6b65533860e3818c1b8a">&#9670;&#160;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::OpState::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shortcut of <span class="tt">-&gt;</span> to access a member of <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00109">109</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="abcfdfbc4f6158e19c5993549247132fb" name="abcfdfbc4f6158e19c5993549247132fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfdfbc4f6158e19c5993549247132fb">&#9670;&#160;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult OpState::parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the custom form of an operation. </p>
<p>Unless overridden, this method will first try to get an operation parser from the op's dialect. Otherwise the custom assembly form of an op is always rejected. <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a> implementations should implement this to return failure. On success, they should fill in result with the fields to use. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8cpp_source.html#l00759">759</a> of file <a class="el" href="IR_2Operation_8cpp_source.html">Operation.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="ad86c745166da5745b6043c84025780f0" name="ad86c745166da5745b6043c84025780f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86c745166da5745b6043c84025780f0">&#9670;&#160;</a></span>populateDefaultAttrs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::OpState::populateDefaultAttrs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This hook populates any unset default attrs. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00209">209</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="aa1d2761129af0c55404133f9b47f21b6" name="aa1d2761129af0c55404133f9b47f21b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d2761129af0c55404133f9b47f21b6">&#9670;&#160;</a></span>print() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> OpState::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>defaultDialect</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the operation. </p>
<p>Unless overridden, this method will first try to get an operation printer from the dialect. Otherwise, it prints the operation in generic form. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8cpp_source.html#l00768">768</a> of file <a class="el" href="IR_2Operation_8cpp_source.html">Operation.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00220">mlir::Operation::getDialect()</a>, <a class="el" href="IR_2Dialect_8cpp_source.html#l00087">mlir::Dialect::getOperationPrinter()</a>, <a class="el" href="classmlir_1_1OpAsmPrinter.html#ab322ff0b02c607374d3237d08d2f2b7f">mlir::OpAsmPrinter::printGenericOp()</a>, and <a class="el" href="IR_2Operation_8cpp_source.html#l00779">printOpName()</a>.</p>

</div>
</div>
<a id="a5ae2204ca73ef2a338a1f980d3662f80" name="a5ae2204ca73ef2a338a1f980d3662f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae2204ca73ef2a338a1f980d3662f80">&#9670;&#160;</a></span>print() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::OpState::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1raw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmState.html">AsmState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>asmState</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00121">121</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a5a472af9de9610021657c2874e6b1191" name="a5a472af9de9610021657c2874e6b1191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a472af9de9610021657c2874e6b1191">&#9670;&#160;</a></span>print() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::OpState::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1raw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the operation to the given stream. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00118">118</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpDefinition_8h_source.html#l00315">mlir::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="a624f18cf4e9a772ab1187fd997ccf2b8" name="a624f18cf4e9a772ab1187fd997ccf2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624f18cf4e9a772ab1187fd997ccf2b8">&#9670;&#160;</a></span>printOpName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> OpState::printOpName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>defaultDialect</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an operation name, eliding the dialect prefix if necessary. </p>
<p>Print an operation name, eliding the dialect prefix if necessary and doesn't lead to ambiguities. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8cpp_source.html#l00779">779</a> of file <a class="el" href="IR_2Operation_8cpp_source.html">Operation.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l02956">mlir::AsmPrinter::getStream()</a>, and <a class="el" href="OperationSupport_8h_source.html#l00473">mlir::OperationName::getStringRef()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Operation_8cpp_source.html#l00768">print()</a>.</p>

</div>
</div>
<a id="a3159f7aa51ff5db54cbab48867d00365" name="a3159f7aa51ff5db54cbab48867d00365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3159f7aa51ff5db54cbab48867d00365">&#9670;&#160;</a></span>use_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::OpState::use_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if there are no users of any results of this operation. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00132">132</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a353c0e5088dbb6624b01221f62262f78" name="a353c0e5088dbb6624b01221f62262f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353c0e5088dbb6624b01221f62262f78">&#9670;&#160;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::OpState::verify </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the concrete type didn't implement a custom verifier hook, just fall back to this one which accepts everything. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00214">214</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a707e0acf20eca83644d64ca1718a6c4a" name="a707e0acf20eca83644d64ca1718a6c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707e0acf20eca83644d64ca1718a6c4a">&#9670;&#160;</a></span>verifyRegions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::OpState::verifyRegions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00215">215</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="adba39290e636f2a3c0373e225b2e132f" name="adba39290e636f2a3c0373e225b2e132f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba39290e636f2a3c0373e225b2e132f">&#9670;&#160;</a></span>walk() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> Order = WalkOrder::PostOrder, typename Iterator = ForwardIterator, typename FnT, typename RetT = detail::walkResultType&lt;FnT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; llvm::function_traits&lt; std::decay_t&lt; FnT &gt; &gt;::num_args==1, RetT &gt; mlir::OpState::walk </td>
          <td>(</td>
          <td class="paramtype">FnT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walk the operation by calling the callback for each nested operation (including this one), block or region, depending on the callback provided. </p>
<p>The order in which regions, blocks and operations the same nesting level are visited (e.g., lexicographical or reverse lexicographical order) is determined by 'Iterator'. The walk order for enclosing regions, blocks and operations with respect to their nested ones is specified by 'Order' (post-order by default). A callback on a block or operation is allowed to erase that block or operation if either:</p><ul>
<li>the walk is in post-order, or</li>
<li>the walk is in pre-order and the walk is skipped after the erasure. See <a class="el" href="classmlir_1_1Operation.html#ad1a108a9ec4ea0859f442ae6f22f19a8" title="Walk the operation by calling the callback for each nested operation (including this one),...">Operation::walk</a> for more details. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00169">169</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a1965cbcb6a548fb66991c7d7dfd5105b" name="a1965cbcb6a548fb66991c7d7dfd5105b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1965cbcb6a548fb66991c7d7dfd5105b">&#9670;&#160;</a></span>walk() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FnT, typename RetT = detail::walkResultType&lt;FnT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; llvm::function_traits&lt; std::decay_t&lt; FnT &gt; &gt;::num_args==2, RetT &gt; mlir::OpState::walk </td>
          <td>(</td>
          <td class="paramtype">FnT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic walker with a stage aware callback. </p>
<p>Walk the operation by calling the callback for each nested operation (including this one) N+1 times, where N is the number of regions attached to that operation.</p>
<p>The callback method can take any of the following forms: void(Operation &lt;em&gt;, const WalkStage &amp;) : Walk all operation opaquely</p><ul>
<li>op.walk([](<a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> *nestedOp, const <a class="el" href="classmlir_1_1WalkStage.html" title="A utility class to encode the current walk stage for &quot;generic&quot; walkers.">WalkStage</a> &amp;stage) { ...}); void(OpT, const WalkStage &amp;) : Walk all operations of the given derived type.</li>
<li>op.walk([](ReturnOp returnOp, const <a class="el" href="classmlir_1_1WalkStage.html" title="A utility class to encode the current walk stage for &quot;generic&quot; walkers.">WalkStage</a> &amp;stage) { ...}); <a class="el" href="classmlir_1_1WalkResult.html" title="A utility result that is used to signal how to proceed with an ongoing walk:">WalkResult</a>(<a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a></li>
</ul>
<p>|OpT, const <a class="el" href="classmlir_1_1WalkStage.html" title="A utility class to encode the current walk stage for &quot;generic&quot; walkers.">WalkStage</a> &amp;stage) : Walk operations, but allow for interruption/skipping.</p><ul>
<li>op.walk([](... op, const <a class="el" href="classmlir_1_1WalkStage.html" title="A utility class to encode the current walk stage for &quot;generic&quot; walkers.">WalkStage</a> &amp;stage) { // Skip the walk of this op based on some invariant. if (some_invariant) return <a class="el" href="classmlir_1_1WalkResult.html#a693d2ecca6f15d4d492c6ff2bea148d0">WalkResult::skip()</a>; // Interrupt, i.e cancel, the walk based on some invariant. if (another_invariant) return <a class="el" href="classmlir_1_1WalkResult.html#abab80dca5987e18f9abf08162cd3faaa">WalkResult::interrupt()</a>; return <a class="el" href="classmlir_1_1WalkResult.html#a97a7015a793bb5d2a97f08e358f42797">WalkResult::advance()</a>; }); </li>
</ul>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00197">197</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/IR/<a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a></li>
<li>lib/IR/<a class="el" href="IR_2Operation_8cpp_source.html">Operation.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
