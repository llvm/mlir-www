<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::affine::MemRefRegion Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1affine.html">affine</a></li><li class="navelem"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structmlir_1_1affine_1_1MemRefRegion-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::affine::MemRefRegion Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A region of a memref's data space; this is typically constructed by analyzing load/store op's on this memref and the index space of loops surrounding such op's.  
 <a href="structmlir_1_1affine_1_1MemRefRegion.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">mlir/Dialect/Affine/Analysis/Utils.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac6d5022fc3e167d5e4f2c9e9c116ae39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#ac6d5022fc3e167d5e4f2c9e9c116ae39">MemRefRegion</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">loc</a>)</td></tr>
<tr class="separator:ac6d5022fc3e167d5e4f2c9e9c116ae39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e67b614605337ccb83b83bdaace70c"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#a60e67b614605337ccb83b83bdaace70c">compute</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, unsigned loopDepth, const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState=nullptr, bool addMemRefDimBounds=true, bool dropLocalVars=true, bool dropOuterIVs=true)</td></tr>
<tr class="memdesc:a60e67b614605337ccb83b83bdaace70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the memory region accessed by this memref with the region represented as constraints symbolic/parametric in 'loopDepth' loops surrounding opInst.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#a60e67b614605337ccb83b83bdaace70c">More...</a><br /></td></tr>
<tr class="separator:a60e67b614605337ccb83b83bdaace70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183baa082e4b25b1204cc5f9fa712d5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#a183baa082e4b25b1204cc5f9fa712d5b">getConstraints</a> ()</td></tr>
<tr class="separator:a183baa082e4b25b1204cc5f9fa712d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb1611afca2ff34d88c1c89a08c3497"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#aafb1611afca2ff34d88c1c89a08c3497">getConstraints</a> () const</td></tr>
<tr class="separator:aafb1611afca2ff34d88c1c89a08c3497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4255fd434f5d6dc27bebe8ffe3198dc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#a4255fd434f5d6dc27bebe8ffe3198dc7">isWrite</a> () const</td></tr>
<tr class="separator:a4255fd434f5d6dc27bebe8ffe3198dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0382cfe83a9301c5cc63f73a1a1e8d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#ab0382cfe83a9301c5cc63f73a1a1e8d3">setWrite</a> (bool flag)</td></tr>
<tr class="separator:ab0382cfe83a9301c5cc63f73a1a1e8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e6b8cc86992af6bcd29f0357072ca6"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#a02e6b8cc86992af6bcd29f0357072ca6">getConstantBoundingSizeAndShape</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *shape=nullptr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *lbs=nullptr) const</td></tr>
<tr class="memdesc:a02e6b8cc86992af6bcd29f0357072ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant upper bound on the number of elements in this region if bounded by a known constant (always possible for static shapes), std::nullopt otherwise.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#a02e6b8cc86992af6bcd29f0357072ca6">More...</a><br /></td></tr>
<tr class="separator:a02e6b8cc86992af6bcd29f0357072ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772a10d9c01365d3d3a697f8679e1afc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#a772a10d9c01365d3d3a697f8679e1afc">getLowerAndUpperBound</a> (unsigned pos, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;lbMap, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;ubMap) const</td></tr>
<tr class="memdesc:a772a10d9c01365d3d3a697f8679e1afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lower and upper bound map for the dimensional variable at <code>pos</code>.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#a772a10d9c01365d3d3a697f8679e1afc">More...</a><br /></td></tr>
<tr class="separator:a772a10d9c01365d3d3a697f8679e1afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb53fa6d699f6834738fa2f220ac783"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#a8fb53fa6d699f6834738fa2f220ac783">getRegionSize</a> ()</td></tr>
<tr class="memdesc:a8fb53fa6d699f6834738fa2f220ac783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of this <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html" title="A region of a memref&#39;s data space; this is typically constructed by analyzing load/store op&#39;s on this...">MemRefRegion</a> in bytes.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#a8fb53fa6d699f6834738fa2f220ac783">More...</a><br /></td></tr>
<tr class="separator:a8fb53fa6d699f6834738fa2f220ac783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2761578967822bb7853e072a1a29bac"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#aa2761578967822bb7853e072a1a29bac">unionBoundingBox</a> (const <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> &amp;other)</td></tr>
<tr class="separator:aa2761578967822bb7853e072a1a29bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22317444c57ececdfd0b3f5497d1971c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#a22317444c57ececdfd0b3f5497d1971c">getRank</a> () const</td></tr>
<tr class="memdesc:a22317444c57ececdfd0b3f5497d1971c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank of the memref that this region corresponds to.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#a22317444c57ececdfd0b3f5497d1971c">More...</a><br /></td></tr>
<tr class="separator:a22317444c57ececdfd0b3f5497d1971c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac097fcae970f4cd44eb14f9484deaf43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#ac097fcae970f4cd44eb14f9484deaf43">memref</a></td></tr>
<tr class="memdesc:ac097fcae970f4cd44eb14f9484deaf43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memref that this region corresponds to.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#ac097fcae970f4cd44eb14f9484deaf43">More...</a><br /></td></tr>
<tr class="separator:ac097fcae970f4cd44eb14f9484deaf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0de038280a27f97e36f354690dbe15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#aaa0de038280a27f97e36f354690dbe15">write</a> = false</td></tr>
<tr class="memdesc:aaa0de038280a27f97e36f354690dbe15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read or write.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#aaa0de038280a27f97e36f354690dbe15">More...</a><br /></td></tr>
<tr class="separator:aaa0de038280a27f97e36f354690dbe15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8b1c63008105dbed4b81d798babf92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">loc</a></td></tr>
<tr class="memdesc:aff8b1c63008105dbed4b81d798babf92"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there is more than one load/store op associated with the region, the location information would correspond to one of those op's.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">More...</a><br /></td></tr>
<tr class="separator:aff8b1c63008105dbed4b81d798babf92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0ae2cb9072efe63434e12545d10486"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html#a3d0ae2cb9072efe63434e12545d10486">cst</a></td></tr>
<tr class="memdesc:a3d0ae2cb9072efe63434e12545d10486"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Region.html" title="This class contains a list of basic blocks and a link to the parent operation it is attached to.">Region</a> (data space) of the memref accessed.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#a3d0ae2cb9072efe63434e12545d10486">More...</a><br /></td></tr>
<tr class="separator:a3d0ae2cb9072efe63434e12545d10486"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A region of a memref's data space; this is typically constructed by analyzing load/store op's on this memref and the index space of loops surrounding such op's. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00489">489</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac6d5022fc3e167d5e4f2c9e9c116ae39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d5022fc3e167d5e4f2c9e9c116ae39">&#9670;&nbsp;</a></span>MemRefRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::affine::MemRefRegion::MemRefRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00490">490</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a60e67b614605337ccb83b83bdaace70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e67b614605337ccb83b83bdaace70c">&#9670;&nbsp;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult MemRefRegion::compute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>sliceState</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addMemRefDimBounds</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dropLocalVars</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dropOuterIVs</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the memory region accessed by this memref with the region represented as constraints symbolic/parametric in 'loopDepth' loops surrounding opInst. </p>
<p>Computes the memory region accessed by this memref with the region represented as constraints symbolic/parametric in 'loopDepth' loops surrounding opInst and any additional Function symbols.</p>
<p>The computed region's 'cst' field has exactly as many dimensional variables as the rank of the memref, and <em>potentially</em> additional symbolic variables which could include any of the loop IVs surrounding opInst up until 'loopDepth' and another additional Function symbols involved with the access (for eg., those appear in affine.apply's, loop bounds, etc.). If 'sliceState' is non-null, operands from 'sliceState' are added as symbols, and the following constraints are added to the system: *) Inequality constraints which represent loop bounds for 'sliceState' operands which are loop IVS (these represent the destination loop IVs of the slice, and are added as symbols to <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html" title="A region of a memref&#39;s data space; this is typically constructed by analyzing load/store op&#39;s on this...">MemRefRegion</a>'s constraint system). *) Inequality constraints for the slice bounds in 'sliceState', which represent the bounds on the loop IVs in this constraint system w.r.t to slice operands (which correspond to symbols). If 'addMemRefDimBounds' is true, constant upper/lower bounds [0, memref.getDimSize(i)) are added for each MemRef dimension 'i'. If <code>dropLocalVars</code> is true, all local variables in <code>cst</code> are projected out.</p>
<p>For example, the memref region for this operation at loopDepth = 1 will be:</p>
<p>affine.for i = 0 to 32 { affine.for ii = i to (d0) -&gt; (d0 + 8) (i) { load A[ii] } }</p>
<p>{memref = A, write = false, {i &lt;= m0 &lt;= i + 7} } The last field is a 2-d <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html" title="FlatAffineValueConstraints is an extension of FlatLinearValueConstraints with helper functions for Af...">FlatAffineValueConstraints</a> symbolic in i.</p>
<p>If <code>dropOuterIVs</code> is true, project out any IVs other than those among <code>loopDepth</code> surrounding IVs, which would be symbols. If <code>dropOuterIVs</code> is false, the IVs would be turned into local variables instead of being projected out. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">1257</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00267">mlir::Operation::emitError()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00507">mlir::affine::MemRefAccess::getAccessMap()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02091">mlir::affine::getAffineIVs()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00110">mlir::affine::AffineValueMap::getAffineMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02812">mlir::affine::getAffineParallelInductionVarOwner()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02801">mlir::affine::getForInductionVarOwner()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00074">mlir::affine::AffineValueMap::getNumOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00102">mlir::affine::AffineValueMap::getOperand()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02053">mlir::affine::MemRefAccess::getRank()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02797">mlir::affine::isAffineInductionVar()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02057">mlir::affine::MemRefAccess::isStore()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00321">mlir::affine::ComputationSliceState::ivs</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00327">mlir::affine::ComputationSliceState::lbOperands</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00323">mlir::affine::ComputationSliceState::lbs</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00083">mlir::affine::MemRefAccess::memref</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00325">mlir::affine::ComputationSliceState::ubs</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00333">createPrivateMemRef()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l00500">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a02e6b8cc86992af6bcd29f0357072ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e6b8cc86992af6bcd29f0357072ca6">&#9670;&nbsp;</a></span>getConstantBoundingSizeAndShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int64_t &gt; MemRefRegion::getConstantBoundingSizeAndShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>shape</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *&#160;</td>
          <td class="paramname"><em>lbs</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant upper bound on the number of elements in this region if bounded by a known constant (always possible for static shapes), std::nullopt otherwise. </p>
<p>Note that the symbols of the region are treated specially, i.e., the returned bounding constant holds for <em>any given</em> value of the symbol variables. The 'shape' vector is set to the corresponding dimension-wise bounds major to minor. The number of elements and all the dimension-wise bounds are guaranteed to be non-negative. We use int64_t instead of uint64_t since index types can be at most int64_t. <code>lbs</code> are set to the lower bound maps for each of the rank dimensions where each of these maps is purely symbolic in the constraints set's symbols. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01160">1160</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01444">mlir::FlatLinearValueConstraints::addBound()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01221">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00643">mlir::getAffineConstantExpr()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00947">mlir::FlatLinearConstraints::getConstantBoundOnDimSize()</a>, and <a class="el" href="IntegerRelation_8h_source.html#l00214">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00333">createPrivateMemRef()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01942">generateCopy()</a>.</p>

</div>
</div>
<a id="a183baa082e4b25b1204cc5f9fa712d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183baa082e4b25b1204cc5f9fa712d5b">&#9670;&nbsp;</a></span>getConstraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a>* mlir::affine::MemRefRegion::getConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00535">535</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00586">cst</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00333">createPrivateMemRef()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01758">findHighestBlockForPlacement()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01942">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02258">getFullMemRefAsRegion()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01235">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="aafb1611afca2ff34d88c1c89a08c3497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb1611afca2ff34d88c1c89a08c3497">&#9670;&nbsp;</a></span>getConstraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a>* mlir::affine::MemRefRegion::getConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00536">536</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00586">cst</a>.</p>

</div>
</div>
<a id="a772a10d9c01365d3d3a697f8679e1afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772a10d9c01365d3d3a697f8679e1afc">&#9670;&nbsp;</a></span>getLowerAndUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemRefRegion::getLowerAndUpperBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>lbMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>ubMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the lower and upper bound map for the dimensional variable at <code>pos</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01216">1216</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01942">generateCopy()</a>.</p>

</div>
</div>
<a id="a22317444c57ececdfd0b3f5497d1971c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22317444c57ececdfd0b3f5497d1971c">&#9670;&nbsp;</a></span>getRank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MemRefRegion::getRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rank of the memref that this region corresponds to. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01156">1156</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="a8fb53fa6d699f6834738fa2f220ac783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb53fa6d699f6834738fa2f220ac783">&#9670;&nbsp;</a></span>getRegionSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int64_t &gt; MemRefRegion::getRegionSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of this <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html" title="A region of a memref&#39;s data space; this is typically constructed by analyzing load/store op&#39;s on this...">MemRefRegion</a> in bytes. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01438">1438</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01419">mlir::affine::getMemRefIntOrFloatEltSizeInBytes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00500">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a4255fd434f5d6dc27bebe8ffe3198dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4255fd434f5d6dc27bebe8ffe3198dc7">&#9670;&nbsp;</a></span>isWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::MemRefRegion::isWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00537">537</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00573">write</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01942">generateCopy()</a>.</p>

</div>
</div>
<a id="ab0382cfe83a9301c5cc63f73a1a1e8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0382cfe83a9301c5cc63f73a1a1e8d3">&#9670;&nbsp;</a></span>setWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::MemRefRegion::setWrite </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00538">538</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00573">write</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02258">getFullMemRefAsRegion()</a>.</p>

</div>
</div>
<a id="aa2761578967822bb7853e072a1a29bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2761578967822bb7853e072a1a29bac">&#9670;&nbsp;</a></span>unionBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult MemRefRegion::unionBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01235">1235</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00535">getConstraints()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00570">memref</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3d0ae2cb9072efe63434e12545d10486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0ae2cb9072efe63434e12545d10486">&#9670;&nbsp;</a></span>cst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> mlir::affine::MemRefRegion::cst</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Region.html" title="This class contains a list of basic blocks and a link to the parent operation it is attached to.">Region</a> (data space) of the memref accessed. </p>
<p>This set will thus have at least as many dimensional variables as the shape dimensionality of the memref, and these are the leading dimensions of the set appearing in that order (major to minor / outermost to innermost). There may be additional variables since getMemRefRegion() is called with a specific loop depth, and thus the region is symbolic in the outer surrounding loops at that depth. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00586">586</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00535">getConstraints()</a>.</p>

</div>
</div>
<a id="aff8b1c63008105dbed4b81d798babf92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8b1c63008105dbed4b81d798babf92">&#9670;&nbsp;</a></span>loc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Location.html">Location</a> mlir::affine::MemRefRegion::loc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If there is more than one load/store op associated with the region, the location information would correspond to one of those op's. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00577">577</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01942">generateCopy()</a>.</p>

</div>
</div>
<a id="ac097fcae970f4cd44eb14f9484deaf43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac097fcae970f4cd44eb14f9484deaf43">&#9670;&nbsp;</a></span>memref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::affine::MemRefRegion::memref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memref that this region corresponds to. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00570">570</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01758">findHighestBlockForPlacement()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01942">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02501">mlir::affine::generateCopyForMemRegion()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02258">getFullMemRefAsRegion()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01814">getMultiLevelStrides()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01235">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="aaa0de038280a27f97e36f354690dbe15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0de038280a27f97e36f354690dbe15">&#9670;&nbsp;</a></span>write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::MemRefRegion::write = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read or write. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00573">573</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00537">isWrite()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00538">setWrite()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/mlir/Dialect/Affine/Analysis/<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a></li>
<li>lib/Dialect/Affine/Analysis/<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 27 2025 16:33:11 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
