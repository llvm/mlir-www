<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Affine/Utils/LoopUtils.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a href="dir_30022079959872f4a1874dfcab7bb1fc.html">Affine</a></li><li class="navelem"><a href="dir_36ccfdf0d236a67fd57e73c4a5bad479.html">Utils</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">LoopUtils.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="LoopUtils_8h_source.html">mlir/Dialect/Affine/LoopUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SliceAnalysis_8h_source.html">mlir/Analysis/SliceAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopAnalysis_8h_source.html">mlir/Dialect/Affine/Analysis/LoopAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">mlir/Dialect/Affine/Analysis/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineValueMap_8h_source.html">mlir/Dialect/Affine/IR/AffineValueMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Affine_2Utils_8h_source.html">mlir/Dialect/Affine/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="FuncOps_8h_source.html">mlir/Dialect/Func/IR/FuncOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2MemRef_2IR_2MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html">mlir/Dialect/SCF/IR/SCF.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IRMapping_8h_source.html">mlir/IR/IRMapping.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2IntegerSet_8h_source.html">mlir/IR/IntegerSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OperationSupport_8h_source.html">mlir/IR/OperationSupport.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GreedyPatternRewriteDriver_8h_source.html">mlir/Transforms/GreedyPatternRewriteDriver.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/MapVector.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
<code>#include &quot;llvm/Support/DebugLog.h&quot;</code><br />
<code>#include &quot;llvm/Support/raw_ostream.h&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
</div>
<p><a href="LoopUtils_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:StrideInfo" id="r_StrideInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structStrideInfo.html">StrideInfo</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d" id="r_ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;loop-utils&quot;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae9f5fd0b12aa6c54ccac5e3b989058e1" id="r_ae9f5fd0b12aa6c54ccac5e3b989058e1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9f5fd0b12aa6c54ccac5e3b989058e1">getCleanupLoopLowerBound</a> (AffineForOp forOp, <a class="el" href="classunsigned.html">unsigned</a> unrollFactor, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;cleanupLbMap, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;cleanupLbOperands)</td></tr>
<tr class="memdesc:ae9f5fd0b12aa6c54ccac5e3b989058e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cleanup loop lower bound of the loop being unrolled with the specified unroll factor; this bound will also be upper bound of the main part of the unrolled loop.  <br /></td></tr>
<tr class="memitem:afec6a79e25848be5701c5726d5c58c45" id="r_afec6a79e25848be5701c5726d5c58c45"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afec6a79e25848be5701c5726d5c58c45">replaceIterArgsAndYieldResults</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:afec6a79e25848be5701c5726d5c58c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to replace uses of loop carried values (iter_args) and loop yield values while promoting single iteration affine.for ops.  <br /></td></tr>
<tr class="memitem:a7daa0cf47d38f4f64e5fb7a5aa8499b6" id="r_a7daa0cf47d38f4f64e5fb7a5aa8499b6"><td class="memItemLeft" align="right" valign="top">static AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7daa0cf47d38f4f64e5fb7a5aa8499b6">generateShiftedLoop</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> lbMap, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> ubMap, const std::vector&lt; std::pair&lt; uint64_t, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt; &gt; &amp;opGroupQueue, <a class="el" href="classunsigned.html">unsigned</a> offset, AffineForOp srcForOp, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> <a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>)</td></tr>
<tr class="memdesc:a7daa0cf47d38f4f64e5fb7a5aa8499b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an affine.for op with the specified lower and upper bounds while generating the right IV remappings to realize shifts for operations in its body.  <br /></td></tr>
<tr class="memitem:a44093d02d8de995e099d42473ce4aa76" id="r_a44093d02d8de995e099d42473ce4aa76"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44093d02d8de995e099d42473ce4aa76">checkIfHyperRectangular</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; input)</td></tr>
<tr class="memdesc:a44093d02d8de995e099d42473ce4aa76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a loop nest is hyper-rectangular or not.  <br /></td></tr>
<tr class="memitem:a0f327fc3b9847b709c76fd332b23ef08" id="r_a0f327fc3b9847b709c76fd332b23ef08"><td class="memTemplParams" colspan="2">template&lt;typename t&gt; </td></tr>
<tr class="memitem:a0f327fc3b9847b709c76fd332b23ef08 template"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f327fc3b9847b709c76fd332b23ef08">performPreTilingChecks</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; input, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; t &gt; tileSizes)</td></tr>
<tr class="memdesc:a0f327fc3b9847b709c76fd332b23ef08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the input nest is supported for tiling and whether tiling would be legal or not.  <br /></td></tr>
<tr class="memitem:a5924e91f0fcb574f01a0ef718fd0d38e" id="r_a5924e91f0fcb574f01a0ef718fd0d38e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5924e91f0fcb574f01a0ef718fd0d38e">moveLoopBodyImpl</a> (AffineForOp src, AffineForOp dest, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> loc)</td></tr>
<tr class="memdesc:a5924e91f0fcb574f01a0ef718fd0d38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the loop body of AffineForOp 'src' from 'src' into the specified location in destination's body, ignoring the terminator.  <br /></td></tr>
<tr class="memitem:aae5f970248a3cca1c62cb4419bb98d79" id="r_aae5f970248a3cca1c62cb4419bb98d79"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae5f970248a3cca1c62cb4419bb98d79">moveLoopBody</a> (AffineForOp src, AffineForOp dest)</td></tr>
<tr class="memdesc:aae5f970248a3cca1c62cb4419bb98d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the loop body of AffineForOp 'src' from 'src' to the start of dest body.  <br /></td></tr>
<tr class="memitem:a27b83fb46075059780be0d1454804ab6" id="r_a27b83fb46075059780be0d1454804ab6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27b83fb46075059780be0d1454804ab6">constructTiledLoopNest</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; origLoops, AffineForOp rootAffineForOp, <a class="el" href="classunsigned.html">unsigned</a> width, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; tiledLoops)</td></tr>
<tr class="memdesc:a27b83fb46075059780be0d1454804ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs tiled loop nest, without setting the loop bounds and move the body of the original loop nest to the tiled loop nest.  <br /></td></tr>
<tr class="memitem:a63fecf5961f8da1b944c27825666cdf6" id="r_a63fecf5961f8da1b944c27825666cdf6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63fecf5961f8da1b944c27825666cdf6">setIntraTileBoundsParametric</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, AffineForOp origLoop, AffineForOp newInterTileLoop, AffineForOp newIntraTileLoop, <a class="el" href="classmlir_1_1Value.html">Value</a> tileSize)</td></tr>
<tr class="memdesc:a63fecf5961f8da1b944c27825666cdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set lower and upper bounds of intra-tile loops for parametric tiling.  <br /></td></tr>
<tr class="memitem:a61d47dd5a912dd47b30a64a582d8ddb7" id="r_a61d47dd5a912dd47b30a64a582d8ddb7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61d47dd5a912dd47b30a64a582d8ddb7">setInterTileBoundsParametric</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, AffineForOp origLoop, AffineForOp newLoop, <a class="el" href="classmlir_1_1Value.html">Value</a> tileSize)</td></tr>
<tr class="memdesc:a61d47dd5a912dd47b30a64a582d8ddb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set lower and upper bounds of inter-tile loops for parametric tiling.  <br /></td></tr>
<tr class="memitem:a109bbddfb77b05a4f3e45beffe019a16" id="r_a109bbddfb77b05a4f3e45beffe019a16"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a109bbddfb77b05a4f3e45beffe019a16">constructParametricallyTiledIndexSetHyperRect</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; origLoops, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; newLoops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; tileSizes)</td></tr>
<tr class="memdesc:a109bbddfb77b05a4f3e45beffe019a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and sets new loop bounds after tiling for the case of hyper-rectangular index sets, where the bounds of one dimension do not depend on other dimensions and tiling parameters are captured from SSA values.  <br /></td></tr>
<tr class="memitem:a97f9e7796076ef4cea1254a2e0ba5041" id="r_a97f9e7796076ef4cea1254a2e0ba5041"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97f9e7796076ef4cea1254a2e0ba5041">constructTiledIndexSetHyperRect</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; origLoops, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; newLoops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; tileSizes)</td></tr>
<tr class="memdesc:a97f9e7796076ef4cea1254a2e0ba5041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and sets new loop bounds after tiling for the case of hyper-rectangular index sets, where the bounds of one dimension do not depend on other dimensions.  <br /></td></tr>
<tr class="memitem:a6a3d5bafce05406f1c3de35328216d3f" id="r_a6a3d5bafce05406f1c3de35328216d3f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a3d5bafce05406f1c3de35328216d3f">generateUnrolledLoop</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *loopBodyBlock, <a class="el" href="classmlir_1_1Value.html">Value</a> forOpIV, uint64_t unrollFactor, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt; ivRemapFn, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt; annotateFn, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> iterArgs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> yieldedValues)</td></tr>
<tr class="memdesc:a6a3d5bafce05406f1c3de35328216d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates unrolled copies of AffineForOp 'loopBodyBlock', with associated 'forOpIV' by 'unrollFactor', calling 'ivRemapFn' to remap 'forOpIV' for each unrolled body.  <br /></td></tr>
<tr class="memitem:aa38533a9233645094cbc0d835899e16b" id="r_aa38533a9233645094cbc0d835899e16b"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa38533a9233645094cbc0d835899e16b">generateCleanupLoopForUnroll</a> (AffineForOp forOp, uint64_t unrollFactor)</td></tr>
<tr class="memdesc:aa38533a9233645094cbc0d835899e16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to generate cleanup loop for unroll or unroll-and-jam when the trip count is not a multiple of <span class="tt">unrollFactor</span>.  <br /></td></tr>
<tr class="memitem:aa8682a13fef12f391f3d7ec0314776f2" id="r_aa8682a13fef12f391f3d7ec0314776f2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8682a13fef12f391f3d7ec0314776f2">areInnerBoundsInvariant</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:aa8682a13fef12f391f3d7ec0314776f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all control operands of all loops are defined outside of <span class="tt">forOp</span> and return false if not.  <br /></td></tr>
<tr class="memitem:a42ac875abb0563bdb3ea255ae048eafc" id="r_a42ac875abb0563bdb3ea255ae048eafc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42ac875abb0563bdb3ea255ae048eafc">checkLoopInterchangeDependences</a> (const std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1affine_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt; &gt; &amp;depCompsVec, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; loopPermMap)</td></tr>
<tr class="memitem:af1da35f76711087c102d41952e7be187" id="r_af1da35f76711087c102d41952e7be187"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1da35f76711087c102d41952e7be187">augmentMapAndBounds</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> iv, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; *operands, <a class="el" href="classint64__t.html">int64_t</a> offset=0)</td></tr>
<tr class="memitem:afd502bddb6a553eb2aa32603adbdce3d" id="r_afd502bddb6a553eb2aa32603adbdce3d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd502bddb6a553eb2aa32603adbdce3d">stripmineSink</a> (AffineForOp forOp, uint64_t factor, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; targets)</td></tr>
<tr class="memitem:adda437963a9fbf87b5b4ec7660ab18de" id="r_adda437963a9fbf87b5b4ec7660ab18de"><td class="memTemplParams" colspan="2">template&lt;typename SizeType&gt; </td></tr>
<tr class="memitem:adda437963a9fbf87b5b4ec7660ab18de template"><td class="memItemLeft" align="right" valign="top">static AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adda437963a9fbf87b5b4ec7660ab18de">stripmineSink</a> (AffineForOp forOp, SizeType factor, AffineForOp <a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>)</td></tr>
<tr class="memitem:a4a0a140f24e42583fb80603e04bb3984" id="r_a4a0a140f24e42583fb80603e04bb3984"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a0a140f24e42583fb80603e04bb3984">findHighestBlockForPlacement</a> (const <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> &amp;region, <a class="el" href="classmlir_1_1Block.html">Block</a> &amp;block, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> &amp;begin, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> &amp;end, <a class="el" href="classmlir_1_1Block.html">Block</a> **copyPlacementBlock, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> *copyInPlacementStart, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> *copyOutPlacementStart)</td></tr>
<tr class="memdesc:a4a0a140f24e42583fb80603e04bb3984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a memref region, determine the lowest depth at which transfers can be placed for it, and return the corresponding block, start and end positions in the block for placing incoming (read) and outgoing (write) copies respectively.  <br /></td></tr>
<tr class="memitem:a809d332a4034932b525aab736987d9ff" id="r_a809d332a4034932b525aab736987d9ff"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a809d332a4034932b525aab736987d9ff">getMultiLevelStrides</a> (const <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> &amp;region, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; bufferShape, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structStrideInfo.html">StrideInfo</a> &gt; *strideInfos)</td></tr>
<tr class="memdesc:a809d332a4034932b525aab736987d9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns striding information for a copy/transfer of this region with potentially multiple striding levels from outermost to innermost.  <br /></td></tr>
<tr class="memitem:a420db562c84b0a026e92385cb33aaf6f" id="r_a420db562c84b0a026e92385cb33aaf6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a420db562c84b0a026e92385cb33aaf6f">getContext</a> ())</td></tr>
<tr class="memitem:a21afe25f740b26159558c302bd046e69" id="r_a21afe25f740b26159558c302bd046e69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21afe25f740b26159558c302bd046e69">for</a> (auto applyOp :mayBeDeadApplys) <a class="el" href="#a38d8eb4db64049cbfcc770fdb9f2e522">if</a>(applyOp.use_empty()) applyOp.erase()</td></tr>
<tr class="memitem:a38d8eb4db64049cbfcc770fdb9f2e522" id="r_a38d8eb4db64049cbfcc770fdb9f2e522"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38d8eb4db64049cbfcc770fdb9f2e522">if</a> (!isCopyOut)</td></tr>
<tr class="memitem:a16585588bafd6d8730c830ca72e4e229" id="r_a16585588bafd6d8730c830ca72e4e229"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16585588bafd6d8730c830ca72e4e229">emitRemarkForBlock</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> &amp;block)</td></tr>
<tr class="memitem:ad077dc835cc07a8b6e9fd23f222b4ac6" id="r_ad077dc835cc07a8b6e9fd23f222b4ac6"><td class="memItemLeft" align="right" valign="top">*<a class="el" href="#a38d8eb4db64049cbfcc770fdb9f2e522">if</a> <a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> could not be generated due to yet unimplemented cases *copyInPlacementStart and copyOutPlacementStart in copyPlacementBlock *specify the insertion points where the incoming <a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> and outgoing should be&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad077dc835cc07a8b6e9fd23f222b4ac6">inserted</a> (the insertion happens right before the *insertion point). Since `begin` can itself be invalidated due to the memref *rewriting done from this method</td></tr>
<tr class="memitem:af34d730a7920f1ae277f8c166146132d" id="r_af34d730a7920f1ae277f8c166146132d"><td class="memItemLeft" align="right" valign="top">*<a class="el" href="#a38d8eb4db64049cbfcc770fdb9f2e522">if</a> <a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> could not be generated due to yet unimplemented cases *copyInPlacementStart and copyOutPlacementStart in copyPlacementBlock *specify the insertion points where the incoming <a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> and outgoing should be the output argument nBegin is set to its *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af34d730a7920f1ae277f8c166146132d">replacement</a> (set to `begin` <a class="el" href="#a38d8eb4db64049cbfcc770fdb9f2e522">if</a> no invalidation happens). Since outgoing *<a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> could have been <a class="el" href="#ad077dc835cc07a8b6e9fd23f222b4ac6">inserted</a> at `end`</td></tr>
<tr class="memitem:a0e71f888deac2564882ac59e028b8e90" id="r_a0e71f888deac2564882ac59e028b8e90"><td class="memItemLeft" align="right" valign="top">*<a class="el" href="#a38d8eb4db64049cbfcc770fdb9f2e522">if</a> <a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> could not be generated due to yet unimplemented cases *copyInPlacementStart and copyOutPlacementStart in copyPlacementBlock *specify the insertion points where the incoming <a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> and outgoing should be the output argument nBegin is set to its the output argument nEnd is set *to the new end sizeInBytes is set to the size of the fast buffer *allocated *static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e71f888deac2564882ac59e028b8e90">generateCopy</a> (const <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> &amp;region, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> begin, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> end, <a class="el" href="classmlir_1_1Block.html">Block</a> *copyPlacementBlock, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> copyInPlacementStart, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> copyOutPlacementStart, const <a class="el" href="structmlir_1_1affine_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;copyOptions, <a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;fastBufferMap, <a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;copyNests, uint64_t *sizeInBytes, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> *nBegin, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> *nEnd)</td></tr>
<tr class="memitem:a3841de62eb5a230cd65788335217c99c" id="r_a3841de62eb5a230cd65788335217c99c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3841de62eb5a230cd65788335217c99c">getFullMemRefAsRegion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numParamLoopIVs, <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> *region)</td></tr>
<tr class="memdesc:a3841de62eb5a230cd65788335217c99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the memref region to just include the entire memref.  <br /></td></tr>
<tr class="memitem:ae9917950d0e2bf69ccfd4f4396226f7c" id="r_ae9917950d0e2bf69ccfd4f4396226f7c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9917950d0e2bf69ccfd4f4396226f7c">gatherLoopsInBlock</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classunsigned.html">unsigned</a> currLoopDepth, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt; &gt; &amp;depthToLoops)</td></tr>
<tr class="memdesc:ae9917950d0e2bf69ccfd4f4396226f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers all AffineForOps in 'block' at 'currLoopDepth' in 'depthToLoops'.  <br /></td></tr>
<tr class="memitem:ab281427ba40a98c3049b992b9ede579e" id="r_ab281427ba40a98c3049b992b9ede579e"><td class="memItemLeft" align="right" valign="top">static AffineIfOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab281427ba40a98c3049b992b9ede579e">createSeparationCondition</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; loops, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> <a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>)</td></tr>
<tr class="memdesc:ab281427ba40a98c3049b992b9ede579e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an AffineIfOp that encodes the conditional to choose between the constant trip count version and an unknown trip count version of this nest of loops.  <br /></td></tr>
<tr class="memitem:a7251ea142ec1d74f6258afa49a410ce1" id="r_a7251ea142ec1d74f6258afa49a410ce1"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7251ea142ec1d74f6258afa49a410ce1">createFullTiles</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; inputNest, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; &amp;fullTileLoops, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> <a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>)</td></tr>
<tr class="memdesc:a7251ea142ec1d74f6258afa49a410ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the full tile loop nest (along with its body).  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afede4e8e79beed3bccedb6dde3a866b8" id="r_afede4e8e79beed3bccedb6dde3a866b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afede4e8e79beed3bccedb6dde3a866b8">fastBufExprs</a></td></tr>
<tr class="memitem:a10daa62245f5f90b8d68a7eebd5371c4" id="r_a10daa62245f5f90b8d68a7eebd5371c4"><td class="memItemLeft" align="right" valign="top">fullyComposeAffineMapAndOperands &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10daa62245f5f90b8d68a7eebd5371c4">fastBufMap</a> = simplifyAffineMap(fastBufMap)</td></tr>
<tr class="memitem:ab3c0736f545f4a75f723449c452395b3" id="r_ab3c0736f545f4a75f723449c452395b3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3c0736f545f4a75f723449c452395b3">load</a></td></tr>
<tr class="memitem:adae31dc2552ddc12092a83df1b1de2dc" id="r_adae31dc2552ddc12092a83df1b1de2dc"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adae31dc2552ddc12092a83df1b1de2dc">copyNestRoot</a></td></tr>
<tr class="memitem:ab10e1ab563e9544b86390dde94e70835" id="r_ab10e1ab563e9544b86390dde94e70835"><td class="memItemLeft" align="right" valign="top">*<a class="el" href="#a38d8eb4db64049cbfcc770fdb9f2e522">if</a> copies could not be generated due to yet unimplemented cases *copyInPlacementStart and copyOutPlacementStart in copyPlacementBlock *specify the insertion points where the incoming copies and outgoing&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a></td></tr>
<tr class="memdesc:ab10e1ab563e9544b86390dde94e70835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a buffer in the faster memory space for the specified memref region (memref has to be non-zero ranked); generates a copy from the lower memory space to this one, and replaces all loads/stores in the block range [&lsquo;begin&rsquo;, &lsquo;end&rsquo;) of &lsquo;block&rsquo; to load/store from that buffer. Returns failure.  <br /></td></tr>
<tr class="memitem:addee311e44ade07d151d91df4f71cfbd" id="r_addee311e44ade07d151d91df4f71cfbd"><td class="memItemLeft" align="right" valign="top">*<a class="el" href="#a38d8eb4db64049cbfcc770fdb9f2e522">if</a> <a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> could not be generated due to yet unimplemented cases *copyInPlacementStart and copyOutPlacementStart in copyPlacementBlock *specify the insertion points where the incoming <a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> and outgoing *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addee311e44ade07d151d91df4f71cfbd">respectively</a></td></tr>
</table>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&#160;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;loop-utils&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00032">32</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="aa8682a13fef12f391f3d7ec0314776f2" name="aa8682a13fef12f391f3d7ec0314776f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8682a13fef12f391f3d7ec0314776f2">&#9670;&#160;</a></span>areInnerBoundsInvariant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> areInnerBoundsInvariant </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if all control operands of all loops are defined outside of <span class="tt">forOp</span> and return false if not. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01072">1072</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, and <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01084">mlir::affine::loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="af1da35f76711087c102d41952e7be187" name="af1da35f76711087c102d41952e7be187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1da35f76711087c102d41952e7be187">&#9670;&#160;</a></span>augmentMapAndBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> augmentMapAndBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>iv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; *</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01509">1509</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="AffineOps_8cpp_source.html#l01759">mlir::affine::canonicalizeMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01529">stripmineSink()</a>.</p>

</div>
</div>
<a id="a44093d02d8de995e099d42473ce4aa76" name="a44093d02d8de995e099d42473ce4aa76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44093d02d8de995e099d42473ce4aa76">&#9670;&#160;</a></span>checkIfHyperRectangular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult checkIfHyperRectangular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a loop nest is hyper-rectangular or not. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00363">363</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1affine.html#a320102486b693e875ebb36f63c3bfc51">mlir::affine::getIndexSet()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01885">mlir::presburger::IntegerRelation::isHyperRectangular()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00383">performPreTilingChecks()</a>.</p>

</div>
</div>
<a id="a42ac875abb0563bdb3ea255ae048eafc" name="a42ac875abb0563bdb3ea255ae048eafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ac875abb0563bdb3ea255ae048eafc">&#9670;&#160;</a></span>checkLoopInterchangeDependences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> checkLoopInterchangeDependences </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1affine_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>depCompsVec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>loopPermMap</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01302">1302</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01336">mlir::affine::isValidLoopInterchangePermutation()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01453">mlir::affine::sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="a109bbddfb77b05a4f3e45beffe019a16" name="a109bbddfb77b05a4f3e45beffe019a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109bbddfb77b05a4f3e45beffe019a16">&#9670;&#160;</a></span>constructParametricallyTiledIndexSetHyperRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> constructParametricallyTiledIndexSetHyperRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>origLoops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>newLoops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tileSizes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs and sets new loop bounds after tiling for the case of hyper-rectangular index sets, where the bounds of one dimension do not depend on other dimensions and tiling parameters are captured from SSA values. </p>
<p>Bounds of each dimension can thus be treated independently, and deriving the new bounds is much simpler and faster than for the case of tiling arbitrary polyhedral shapes. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00660">660</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00559">setInterTileBoundsParametric()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00464">setIntraTileBoundsParametric()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00814">mlir::affine::tilePerfectlyNestedParametric()</a>.</p>

</div>
</div>
<a id="a97f9e7796076ef4cea1254a2e0ba5041" name="a97f9e7796076ef4cea1254a2e0ba5041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f9e7796076ef4cea1254a2e0ba5041">&#9670;&#160;</a></span>constructTiledIndexSetHyperRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> constructTiledIndexSetHyperRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>origLoops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>newLoops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tileSizes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs and sets new loop bounds after tiling for the case of hyper-rectangular index sets, where the bounds of one dimension do not depend on other dimensions. </p>
<p>Bounds of each dimension can thus be treated independently, and deriving the new bounds is much simpler and faster than for the case of tiling arbitrary polyhedral shapes. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00688">688</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00216">mlir::affine::getConstantTripCount()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00243">mlir::affine::getLargestDivisorOfTripCount()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00772">mlir::affine::tilePerfectlyNested()</a>.</p>

</div>
</div>
<a id="a27b83fb46075059780be0d1454804ab6" name="a27b83fb46075059780be0d1454804ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b83fb46075059780be0d1454804ab6">&#9670;&#160;</a></span>constructTiledLoopNest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> constructTiledLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>origLoops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>rootAffineForOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>tiledLoops</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs tiled loop nest, without setting the loop bounds and move the body of the original loop nest to the tiled loop nest. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00423">423</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00417">moveLoopBody()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00772">mlir::affine::tilePerfectlyNested()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00814">mlir::affine::tilePerfectlyNestedParametric()</a>.</p>

</div>
</div>
<a id="a7251ea142ec1d74f6258afa49a410ce1" name="a7251ea142ec1d74f6258afa49a410ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7251ea142ec1d74f6258afa49a410ce1">&#9670;&#160;</a></span>createFullTiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult createFullTiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>inputNest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fullTileLoops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the full tile loop nest (along with its body). </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02665">2665</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00252">mlir::OpBuilder::atBlockTerminator()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00110">mlir::affine::AffineValueMap::getAffineMap()</a>, <a class="el" href="namespacemlir_1_1affine.html#a320102486b693e875ebb36f63c3bfc51">mlir::affine::getIndexSet()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00232">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00106">mlir::affine::AffineValueMap::getOperands()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00725">mlir::presburger::IntegerRelation::setDimSymbolSeparation()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="ab281427ba40a98c3049b992b9ede579e" name="ab281427ba40a98c3049b992b9ede579e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab281427ba40a98c3049b992b9ede579e">&#9670;&#160;</a></span>createSeparationCondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AffineIfOp createSeparationCondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an AffineIfOp that encodes the conditional to choose between the constant trip count version and an unknown trip count version of this nest of loops. </p>
<p>This is used to separate partial and full tiles if <span class="tt">loops</span> has the intra-tile loops. The affine.if op is inserted at the builder insertion point of <span class="tt">b</span>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02584">2584</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8h_source.html#l00196">mlir::presburger::IntegerRelation::atIneq()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="AffineOps_8cpp_source.html#l01764">mlir::affine::canonicalizeSetAndOperands()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01087">mlir::FlatLinearConstraints::getAsIntegerSet()</a>, <a class="el" href="namespacemlir_1_1affine.html#a320102486b693e875ebb36f63c3bfc51">mlir::affine::getIndexSet()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00257">mlir::presburger::IntegerRelation::getInequality()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00491">mlir::presburger::IntegerRelation::getLowerAndUpperBoundIndices()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00238">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00232">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00364">mlir::FlatLinearValueConstraints::getValues()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02412">mlir::presburger::IntegerRelation::removeIndependentConstraints()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01915">mlir::presburger::IntegerRelation::removeTrivialRedundancy()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00378">mlir::presburger::IntegerRelation::removeVar()</a>, and <a class="el" href="IntegerRelation_8h_source.html#l00725">mlir::presburger::IntegerRelation::setDimSymbolSeparation()</a>.</p>

</div>
</div>
<a id="a16585588bafd6d8730c830ca72e4e229" name="a16585588bafd6d8730c830ca72e4e229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16585588bafd6d8730c830ca72e4e229">&#9670;&#160;</a></span>emitRemarkForBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> emitRemarkForBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01929">1929</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00289">mlir::Operation::emitRemark()</a>, and <a class="el" href="Block_8cpp_source.html#l00031">mlir::Block::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01947">generateCopy()</a>.</p>

</div>
</div>
<a id="a4a0a140f24e42583fb80603e04bb3984" name="a4a0a140f24e42583fb80603e04bb3984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0a140f24e42583fb80603e04bb3984">&#9670;&#160;</a></span>findHighestBlockForPlacement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> findHighestBlockForPlacement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> **</td>          <td class="paramname"><span class="paramname"><em>copyPlacementBlock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> *</td>          <td class="paramname"><span class="paramname"><em>copyInPlacementStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> *</td>          <td class="paramname"><span class="paramname"><em>copyOutPlacementStart</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a memref region, determine the lowest depth at which transfers can be placed for it, and return the corresponding block, start and end positions in the block for placing incoming (read) and outgoing (write) copies respectively. </p>
<p>The lowest depth depends on whether the region being accessed is hoistable with respect to one or more immediately surrounding loops. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01764">1764</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00143">mlir::Block::begin()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00535">mlir::affine::MemRefRegion::getConstraints()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00865">mlir::affine::getEnclosingAffineOps()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00570">mlir::affine::MemRefRegion::memref</a>.</p>

</div>
</div>
<a id="a21afe25f740b26159558c302bd046e69" name="a21afe25f740b26159558c302bd046e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21afe25f740b26159558c302bd046e69">&#9670;&#160;</a></span>for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">for </td>
          <td>(</td>
          <td class="paramtype">auto applyOp :mayBeDeadApplys</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9917950d0e2bf69ccfd4f4396226f7c" name="ae9917950d0e2bf69ccfd4f4396226f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9917950d0e2bf69ccfd4f4396226f7c">&#9670;&#160;</a></span>gatherLoopsInBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> gatherLoopsInBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>currLoopDepth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>depthToLoops</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gathers all AffineForOps in 'block' at 'currLoopDepth' in 'depthToLoops'. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02534">2534</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l02534">gatherLoopsInBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02534">gatherLoopsInBlock()</a>.</p>

</div>
</div>
<a id="aa38533a9233645094cbc0d835899e16b" name="aa38533a9233645094cbc0d835899e16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38533a9233645094cbc0d835899e16b">&#9670;&#160;</a></span>generateCleanupLoopForUnroll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult generateCleanupLoopForUnroll </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unrollFactor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to generate cleanup loop for unroll or unroll-and-jam when the trip count is not a multiple of <span class="tt">unrollFactor</span>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00960">960</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00562">mlir::OpBuilder::clone()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00045">getCleanupLoopLowerBound()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00119">mlir::affine::promoteIfSingleIteration()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00995">mlir::affine::loopUnrollByFactor()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01084">mlir::affine::loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="a0e71f888deac2564882ac59e028b8e90" name="a0e71f888deac2564882ac59e028b8e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e71f888deac2564882ac59e028b8e90">&#9670;&#160;</a></span>generateCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">*<a class="el" href="#a38d8eb4db64049cbfcc770fdb9f2e522">if</a> <a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> could not be generated due to yet unimplemented cases *copyInPlacementStart and copyOutPlacementStart in copyPlacementBlock *specify the insertion points where the incoming <a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> and outgoing should be the output argument nBegin is set to its the output argument nEnd is set *to the new end sizeInBytes is set to the size of the fast buffer *allocated *static LogicalResult generateCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>copyPlacementBlock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a></td>          <td class="paramname"><span class="paramname"><em>copyInPlacementStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a></td>          <td class="paramname"><span class="paramname"><em>copyOutPlacementStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>copyOptions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fastBufferMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>copyNests</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *</td>          <td class="paramname"><span class="paramname"><em>sizeInBytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> *</td>          <td class="paramname"><span class="paramname"><em>nBegin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> *</td>          <td class="paramname"><span class="paramname"><em>nEnd</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01947">1947</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Block_8h_source.html#l00143">mlir::Block::begin()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01888">mlir::affine::AffineDmaStartOp::create()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02084">mlir::affine::AffineDmaWaitOp::create()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01929">emitRemarkForBlock()</a>, <a class="el" href="LoopUtils_8h_source.html#l00165">mlir::affine::AffineCopyOptions::fastMemorySpace</a>, <a class="el" href="Block_8cpp_source.html#l00074">mlir::Block::findAncestorOpInBlock()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01400">mlir::affine::fullyComposeAffineMapAndOperands()</a>, <a class="el" href="LoopUtils_8h_source.html#l00161">mlir::affine::AffineCopyOptions::generateDma</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01160">mlir::affine::MemRefRegion::getConstantBoundingSizeAndShape()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00535">mlir::affine::MemRefRegion::getConstraints()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01463">mlir::affine::getIntOrFloatMemRefSizeInBytes()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01216">mlir::affine::MemRefRegion::getLowerAndUpperBound()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01820">getMultiLevelStrides()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00238">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00235">mlir::presburger::IntegerRelation::getNumVars()</a>, <a class="el" href="Block_8cpp_source.html#l00027">mlir::Block::getParent()</a>, <a class="el" href="IR_2Region_8h_source.html#l00205">mlir::Region::getParentOfType()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00364">mlir::FlatLinearValueConstraints::getValues()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00383">mlir::Operation::isBeforeInBlock()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00537">mlir::affine::MemRefRegion::isWrite()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00577">mlir::affine::MemRefRegion::loc</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00570">mlir::affine::MemRefRegion::memref</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="LoopUtils_8h_source.html#l00167">mlir::affine::AffineCopyOptions::tagMemorySpace</a>.</p>

</div>
</div>
<a id="a7daa0cf47d38f4f64e5fb7a5aa8499b6" name="a7daa0cf47d38f4f64e5fb7a5aa8499b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7daa0cf47d38f4f64e5fb7a5aa8499b6">&#9670;&#160;</a></span>generateShiftedLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp generateShiftedLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>lbMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>ubMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; uint64_t, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>opGroupQueue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>srcForOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates an affine.for op with the specified lower and upper bounds while generating the right IV remappings to realize shifts for operations in its body. </p>
<p>The operations that go into the loop body are specified in opGroupQueue starting from the specified offset, and in that order. The first element of the pair specifies the shift applied to that group of operations; the shift is multiplied by the loop step before being applied. Returns nullptr if the generated loop simplifies to a single iteration one. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00175">175</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00252">mlir::OpBuilder::atBlockTerminator()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00119">mlir::affine::promoteIfSingleIteration()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00230">mlir::affine::affineForOpBodySkew()</a>.</p>

</div>
</div>
<a id="a6a3d5bafce05406f1c3de35328216d3f" name="a6a3d5bafce05406f1c3de35328216d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3d5bafce05406f1c3de35328216d3f">&#9670;&#160;</a></span>generateUnrolledLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> generateUnrolledLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>loopBodyBlock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>forOpIV</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unrollFactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>ivRemapFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>annotateFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>iterArgs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>yieldedValues</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates unrolled copies of AffineForOp 'loopBodyBlock', with associated 'forOpIV' by 'unrollFactor', calling 'ivRemapFn' to remap 'forOpIV' for each unrolled body. </p>
<p>If specified, annotates the Ops in each unrolled iteration using annotateFn. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00899">899</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00252">mlir::OpBuilder::atBlockTerminator()</a>, <a class="el" href="Block_8h_source.html#l00143">mlir::Block::begin()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00714">mlir::Operation::clone()</a>, <a class="el" href="Block_8h_source.html#l00144">mlir::Block::end()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="Block_8cpp_source.html#l00244">mlir::Block::getTerminator()</a>, <a class="el" href="IRMapping_8h_source.html#l00072">mlir::IRMapping::lookup()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00237">mlir::Operation::setOperands()</a>, and <a class="el" href="Value_8h_source.html#l00208">mlir::Value::use_empty()</a>.</p>

</div>
</div>
<a id="ae9f5fd0b12aa6c54ccac5e3b989058e1" name="ae9f5fd0b12aa6c54ccac5e3b989058e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f5fd0b12aa6c54ccac5e3b989058e1">&#9670;&#160;</a></span>getCleanupLoopLowerBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> getCleanupLoopLowerBound </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>unrollFactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cleanupLbMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cleanupLbOperands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cleanup loop lower bound of the loop being unrolled with the specified unroll factor; this bound will also be upper bound of the main part of the unrolled loop. </p>
<p>Computes the bound as an <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> with its operands or a null map when the trip count can't be expressed as an affine expression. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00045">45</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="AffineOps_8cpp_source.html#l01759">mlir::affine::canonicalizeMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01400">mlir::affine::fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00166">mlir::affine::getTripCountMapAndOperands()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00766">mlir::simplifyAffineMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00960">generateCleanupLoopForUnroll()</a>.</p>

</div>
</div>
<a id="a420db562c84b0a026e92385cb33aaf6f" name="a420db562c84b0a026e92385cb33aaf6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420db562c84b0a026e92385cb33aaf6f">&#9670;&#160;</a></span>getContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a> getContext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="AsmPrinter_8cpp_source.html#l01946">mlir::detail::AsmStateImpl::AsmStateImpl()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00193">mlir::impl::LowerSparseOpsToForeachBase&lt; DerivedT &gt;::classof()</a>, <a class="el" href="ExpandRealloc_8cpp_source.html#l00148">mlir::memref::impl::ExpandReallocPassBase&lt; DerivedT &gt;::clonePass()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00286">mlir::computeLinearIndex()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">mlir::affine::computeSliceUnion()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00096">constifyIndexValues()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00885">mlir::detail::ConversionPatternRewriterImpl::ConversionPatternRewriterImpl()</a>, <a class="el" href="include_2mlir_2Conversion_2LLVMCommon_2Pattern_8h_source.html#l00278">mlir::ConvertOpInterfaceToLLVMPattern&lt; SourceOp &gt;::ConvertOpInterfaceToLLVMPattern()</a>, <a class="el" href="include_2mlir_2Conversion_2LLVMCommon_2Pattern_8h_source.html#l00222">mlir::OneToNOpAdaptor&lt; SelectOp &gt;::ConvertOpToLLVMPattern()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00536">mlir::linalg::ConvMatcherBuilder::ConvMatcherBuilder()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00219">mlir::ConvertToLLVMPattern::copyUnrankedDescriptor()</a>, <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html#l00088">mlir::memref::createExpandOpsPass()</a>, <a class="el" href="DebugTranslation_8cpp_source.html#l00028">mlir::LLVM::detail::DebugTranslation::DebugTranslation()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00472">mlir::PassManager::enableCrashReproducerGeneration()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00389">mlir::spirv::ImageType::get()</a>, <a class="el" href="BubbleDownMemorySpaceCasts_8cpp_source.html#l00057">mlir::impl::BubbleDownMemorySpaceCastsBase&lt; DerivedT &gt;::getArgumentName()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01008">mlir::sparse_tensor::SparseTensorType::getCOOType()</a>, <a class="el" href="OpenMPOffloadPrivatizationPrepare_8cpp_source.html#l00061">mlir::omp::impl::PrepareForOMPOffloadPrivatizationPassBase&lt; DerivedT &gt;::getDependentDialects()</a>, <a class="el" href="NormalizeQuantTypes_8cpp_source.html#l00142">mlir::quant::impl::NormalizeQuantTypesBase&lt; DerivedT &gt;::getDependentDialects()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01607">mlir::SPIRVTypeConverter::getIndexType()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00040">mlir::ConvertToLLVMPattern::getIntPtrType()</a>, <a class="el" href="DeadCodeAnalysis_8cpp_source.html#l00117">mlir::dataflow::CFGEdge::getLoc()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00122">mlir::impl::LowerSparseIterationToSCFBase&lt; DerivedT &gt;::getName()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00334">mlir::impl::SparseAssemblerBase&lt; DerivedT &gt;::getName()</a>, <a class="el" href="Dialect_2SparseTensor_2Transforms_2SparseTensorPasses_8cpp_source.html#l00055">mlir::impl::LowerForeachToSCFBase&lt; DerivedT &gt;::getPassName()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00049">mlir::ConvertToLLVMPattern::getPtrType()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00447">mlir::getSymbolLessAffineMaps()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00045">mlir::ConvertToLLVMPattern::getVoidType()</a>, <a class="el" href="LevelZeroRuntimeWrappers_8cpp_source.html#l00152">L0RTContextWrapper::L0RTContextWrapper()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00020">mlirAffineExprGetContext()</a>, <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00021">mlirAffineMapGetContext()</a>, <a class="el" href="IR_8cpp_source.html#l01280">mlirAttributeGetContext()</a>, <a class="el" href="IR_8cpp_source.html#l00129">mlirDialectGetContext()</a>, <a class="el" href="IR_8cpp_source.html#l01324">mlirIdentifierGetContext()</a>, <a class="el" href="CAPI_2IR_2IntegerSet_8cpp_source.html#l00019">mlirIntegerSetGetContext()</a>, <a class="el" href="IR_8cpp_source.html#l00411">mlirLocationGetContext()</a>, <a class="el" href="IR_8cpp_source.html#l00446">mlirModuleGetContext()</a>, <a class="el" href="IR_8cpp_source.html#l00651">mlirOperationGetContext()</a>, <a class="el" href="IR_8cpp_source.html#l00758">mlirOperationSetInherentAttributeByName()</a>, <a class="el" href="CAPI_2Transforms_2Rewrite_8cpp_source.html#l00028">mlirRewriterBaseGetContext()</a>, <a class="el" href="IR_8cpp_source.html#l01249">mlirTypeGetContext()</a>, <a class="el" href="IR_8cpp_source.html#l01206">mlirValueGetContext()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00166">mlir::LLVM::ModuleImport::ModuleImport()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00218">mlir::detail::StorageUserBase&lt; ConcreteType, BaseType, StorageType, detail::AttributeUniquer, Traits... &gt;::mutate()</a>, <a class="el" href="ParserState_8h_source.html#l00052">mlir::detail::ParserState::ParserState()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l04013">mlir::AffineExpr::print()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l04027">mlir::AffineMap::print()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l03933">mlir::Attribute::print()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l04036">mlir::IntegerSet::print()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l03985">mlir::Type::print()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l03975">mlir::Attribute::printStripped()</a>, <a class="el" href="BytecodeReader_8cpp_source.html#l01854">mlir::BytecodeReader::Impl::read()</a>, <a class="el" href="PassCrashRecovery_8cpp_source.html#l00091">mlir::detail::RecoveryReproducerContext::RecoveryReproducerContext()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00252">mlir::SymbolTable::rename()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00247">mlir::SymbolTable::rename()</a>, <a class="el" href="MathToROCDL_8cpp_source.html#l00178">ConvertMathToROCDLPass::runOnOperation()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00847">mlir::detail::OpToOpPassAdaptor::runOnOperation()</a>, <a class="el" href="Serializer_8cpp_source.html#l00120">mlir::spirv::Serializer::Serializer()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00108">mlir::StructuredGenerator&lt; StructuredOpInterface, IteratorTypeT &gt;::StructuredGenerator()</a>.</p>

</div>
</div>
<a id="a3841de62eb5a230cd65788335217c99c" name="a3841de62eb5a230cd65788335217c99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3841de62eb5a230cd65788335217c99c">&#9670;&#160;</a></span>getFullMemRefAsRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> getFullMemRefAsRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numParamLoopIVs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> *</td>          <td class="paramname"><span class="paramname"><em>region</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the memref region to just include the entire memref. </p>
<p>Returns false dynamic shaped memref's for now. <span class="tt">numParamLoopIVs</span> is the number of enclosing loop IVs of <span class="tt">op</span> (starting from the outermost) that the region is parametric on. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02263">2263</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02962">mlir::affine::extractForInductionVars()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00851">mlir::affine::getAffineForIVs()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00535">mlir::affine::MemRefRegion::getConstraints()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00570">mlir::affine::MemRefRegion::memref</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00538">mlir::affine::MemRefRegion::setWrite()</a>.</p>

</div>
</div>
<a id="a809d332a4034932b525aab736987d9ff" name="a809d332a4034932b525aab736987d9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809d332a4034932b525aab736987d9ff">&#9670;&#160;</a></span>getMultiLevelStrides()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> getMultiLevelStrides </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>bufferShape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structStrideInfo.html">StrideInfo</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>strideInfos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns striding information for a copy/transfer of this region with potentially multiple striding levels from outermost to innermost. </p>
<p>For an n-dimensional region, there can be at most n-1 levels of striding successively nested. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01820">1820</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00570">mlir::affine::MemRefRegion::memref</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01947">generateCopy()</a>.</p>

</div>
</div>
<a id="a38d8eb4db64049cbfcc770fdb9f2e522" name="a38d8eb4db64049cbfcc770fdb9f2e522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d8eb4db64049cbfcc770fdb9f2e522">&#9670;&#160;</a></span>if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">if </td>
          <td>(</td>
          <td class="paramtype">!</td>          <td class="paramname"><span class="paramname"><em>isCopyOut</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01914">1914</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01926">copyNestRoot</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01905">fastBufMap</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01923">load</a>.</p>

<p class="reference">Referenced by <a class="el" href="TableGen_2Constraint_8cpp_source.html#l00019">mlir::tblgen::Constraint::Constraint()</a>, <a class="el" href="FrozenRewritePatternSet_8cpp_source.html#l00062">mlir::FrozenRewritePatternSet::FrozenRewritePatternSet()</a>, <a class="el" href="Partition_8cpp_source.html#l00609">mlir::shard::getResultShardings()</a>, <a class="el" href="OpImplementation_8h_source.html#l00863">mlir::AsmParser::KeywordSwitch&lt; ResultT &gt;::KeywordSwitch()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00217">mlir::OpPrintingFlags::OpPrintingFlags()</a>, <a class="el" href="OpenACC_8cpp_source.html#l04176">parseBindName()</a>, <a class="el" href="Remarks_8cpp_source.html#l00312">mlir::remark::detail::RemarkEngine::RemarkEngine()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l04209">sortMapIndices()</a>, and <a class="el" href="Block_8cpp_source.html#l00350">mlir::SuccessorRange::SuccessorRange()</a>.</p>

</div>
</div>
<a id="ad077dc835cc07a8b6e9fd23f222b4ac6" name="ad077dc835cc07a8b6e9fd23f222b4ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad077dc835cc07a8b6e9fd23f222b4ac6">&#9670;&#160;</a></span>inserted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">*<a class="el" href="#a38d8eb4db64049cbfcc770fdb9f2e522">if</a> <a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> could not be generated due to yet unimplemented cases *copyInPlacementStart and copyOutPlacementStart in copyPlacementBlock *specify the insertion points where the incoming <a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> and outgoing should be inserted </td>
          <td>(</td>
          <td class="paramtype">the insertion happens right before the *insertion</td>          <td class="paramname"><span class="paramname"><em>point</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="AsmParserState_8cpp_source.html#l00319">mlir::AsmParserState::addAttrAliasDefinition()</a>, <a class="el" href="AsmParserState_8cpp_source.html#l00293">mlir::AsmParserState::addDefinition()</a>, <a class="el" href="DataFlowFramework_8cpp_source.html#l00042">mlir::AnalysisState::addDependency()</a>, <a class="el" href="AsmParserState_8cpp_source.html#l00334">mlir::AsmParserState::addTypeAliasDefinition()</a>, <a class="el" href="AsmParserState_8cpp_source.html#l00383">mlir::AsmParserState::addUses()</a>, <a class="el" href="TableGen_2Pattern_8cpp_source.html#l00551">mlir::tblgen::SymbolInfoMap::bindAttr()</a>, <a class="el" href="TableGen_2Pattern_8cpp_source.html#l00544">mlir::tblgen::SymbolInfoMap::bindMultipleValues()</a>, <a class="el" href="TableGen_2Pattern_8cpp_source.html#l00525">mlir::tblgen::SymbolInfoMap::bindOpResult()</a>, <a class="el" href="TableGen_2Pattern_8cpp_source.html#l00556">mlir::tblgen::SymbolInfoMap::bindProp()</a>, <a class="el" href="TableGen_2Pattern_8cpp_source.html#l00539">mlir::tblgen::SymbolInfoMap::bindValue()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00545">buildPackingLoopNestImpl()</a>, <a class="el" href="IRDLLoading_8cpp_source.html#l00555">checkCorrectAnyOf()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00717">createIndex()</a>, <a class="el" href="Split_8cpp_source.html#l00032">createSplitPart()</a>, <a class="el" href="LoopAnnotationTranslation_8cpp_source.html#l00281">mlir::LLVM::detail::LoopAnnotationTranslation::getAccessGroup()</a>, <a class="el" href="OutlineShapeComputation_8cpp_source.html#l00042">mlir::impl::OutlineShapeComputationPassBase&lt; DerivedT &gt;::getArgument()</a>, <a class="el" href="OutlineShapeComputation_8cpp_source.html#l00039">mlir::impl::OutlineShapeComputationPassBase&lt; DerivedT &gt;::getArgumentName()</a>, <a class="el" href="CheckUses_8cpp_source.html#l00040">mlir::transform::impl::CheckUsesPassBase&lt; DerivedT &gt;::getArgumentName()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00261">getConstraintPredicates()</a>, <a class="el" href="TableGen_2Pattern_8cpp_source.html#l00169">mlir::tblgen::DagNode::getDialectOp()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02124">getMemoryFootprintBytes()</a>, <a class="el" href="Mem2Reg_8cpp_source.html#l00528">getOrCreateBlockIndices()</a>, <a class="el" href="IR_2Dialect_8cpp_source.html#l00217">mlir::DialectRegistry::insert()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02047">mlir::linalg::insertSlicesBack()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01126">mlir::sparse_tensor::isBlockSparsity()</a>, <a class="el" href="CyclicReplacerCache_8h_source.html#l00153">mlir::CyclicReplacerCache&lt; InT, OutT &gt;::lookupOrInit()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00078">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="Namespace_8h_source.html#l00086">mlir::Namespace::newName()</a>, <a class="el" href="Namespace_8h_source.html#l00120">mlir::Namespace::newName()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00055">remapInlinedLocations()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01594">mlir::linalg::DownscaleConv2DOp::returningMatchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01526">mlir::linalg::DownscaleDepthwiseConv2DNhwcHwcOp::returningMatchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01406">mlir::linalg::DownscaleSizeOneWindowed2DConvolution&lt; Conv2DOp, Conv1DOp &gt;::returningMatchAndRewrite()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00117">mlir::SymbolTable::SymbolTable()</a>, <a class="el" href="CFGToSCF_8cpp_source.html#l01273">mlir::transformCFGToSCF()</a>, <a class="el" href="CFGToSCF_8cpp_source.html#l00655">transformToReduceLoop()</a>, and <a class="el" href="PredicateTree_8cpp_source.html#l00541">visitUpward()</a>.</p>

</div>
</div>
<a id="aae5f970248a3cca1c62cb4419bb98d79" name="aae5f970248a3cca1c62cb4419bb98d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5f970248a3cca1c62cb4419bb98d79">&#9670;&#160;</a></span>moveLoopBody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> moveLoopBody </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move the loop body of AffineForOp 'src' from 'src' to the start of dest body. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00417">417</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00408">moveLoopBodyImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00423">constructTiledLoopNest()</a>.</p>

</div>
</div>
<a id="a5924e91f0fcb574f01a0ef718fd0d38e" name="a5924e91f0fcb574f01a0ef718fd0d38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5924e91f0fcb574f01a0ef718fd0d38e">&#9670;&#160;</a></span>moveLoopBodyImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> moveLoopBodyImpl </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move the loop body of AffineForOp 'src' from 'src' into the specified location in destination's body, ignoring the terminator. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00408">408</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00417">moveLoopBody()</a>.</p>

</div>
</div>
<a id="a0f327fc3b9847b709c76fd332b23ef08" name="a0f327fc3b9847b709c76fd332b23ef08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f327fc3b9847b709c76fd332b23ef08">&#9670;&#160;</a></span>performPreTilingChecks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult performPreTilingChecks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; t &gt;</td>          <td class="paramname"><span class="paramname"><em>tileSizes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the input nest is supported for tiling and whether tiling would be legal or not. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00383">383</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00363">checkIfHyperRectangular()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01361">mlir::affine::isPerfectlyNested()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00772">mlir::affine::tilePerfectlyNested()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00814">mlir::affine::tilePerfectlyNestedParametric()</a>.</p>

</div>
</div>
<a id="afec6a79e25848be5701c5726d5c58c45" name="afec6a79e25848be5701c5726d5c58c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec6a79e25848be5701c5726d5c58c45">&#9670;&#160;</a></span>replaceIterArgsAndYieldResults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> replaceIterArgsAndYieldResults </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to replace uses of loop carried values (iter_args) and loop yield values while promoting single iteration affine.for ops. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00103">103</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00119">mlir::affine::promoteIfSingleIteration()</a>.</p>

</div>
</div>
<a id="af34d730a7920f1ae277f8c166146132d" name="af34d730a7920f1ae277f8c166146132d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34d730a7920f1ae277f8c166146132d">&#9670;&#160;</a></span>replacement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">*<a class="el" href="#a38d8eb4db64049cbfcc770fdb9f2e522">if</a> <a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> could not be generated due to yet unimplemented cases *copyInPlacementStart and copyOutPlacementStart in copyPlacementBlock *specify the insertion points where the incoming <a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> and outgoing should be the output argument nBegin is set to its * replacement </td>
          <td>(</td>
          <td class="paramtype">set to `begin` <a class="el" href="#a38d8eb4db64049cbfcc770fdb9f2e522">if</a> no invalidation</td>          <td class="paramname"><span class="paramname"><em>happens</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01517">mlir::alignAffineMapWithValues()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00665">applyTilingToAll()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00255">mlir::bufferization::func_ext::CallOpInterface::bufferize()</a>, <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00096">mlir::bufferization::buildSubsetExtraction()</a>, <a class="el" href="LLVMMemorySlot_8cpp_source.html#l00215">castSameSizedTypes()</a>, <a class="el" href="PassDetail_8cpp_source.html#l00020">mlir::async::cloneConstantsIntoTheRegion()</a>, <a class="el" href="LLVMMemorySlot_8cpp_source.html#l00244">createExtractAndCast()</a>, <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00123">mlir::bufferization::eliminateEmptyTensors()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00085">mlir::bufferization::foldToBufferToTensorPair()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00218">generateFusedElementwiseOpRegion()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l02006">mlir::LLVM::ModuleTranslation::getOrCreateAliasScope()</a>, <a class="el" href="CyclicReplacerCache_8h_source.html#l00153">mlir::CyclicReplacerCache&lt; void *, const void * &gt;::lookupOrInit()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02110">DropUnitDimsFromScfForOp::matchAndRewrite()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05741">mlir::linalg::FoldTensorCastPackOp::matchAndRewrite()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l06064">mlir::linalg::FoldTensorCastUnPackOp::matchAndRewrite()</a>, <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00141">mlirAffineMapReplace()</a>, <a class="el" href="PatternMatch_8h_source.html#l00458">mlir::RewriterBase::ForwardingListener::notifyOperationReplaced()</a>, <a class="el" href="PatternMatch_8h_source.html#l00387">mlir::RewriterBase::Listener::notifyOperationReplaced()</a>, <a class="el" href="PatternMatch_8h_source.html#l00396">mlir::RewriterBase::Listener::notifyOperationReplaced()</a>, <a class="el" href="PatternLoggingListener_8cpp_source.html#l00029">mlir::RewriterBase::PatternLoggingListener::notifyOperationReplaced()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01412">mlir::transform::TransformRewriter::notifyPayloadOperationReplaced()</a>, <a class="el" href="TensorOps_8cpp_source.html#l02713">SliceCanonicalizer::operator()()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00715">pruneRedundantArguments()</a>, <a class="el" href="TemplatingUtils_8h_source.html#l00053">mlir::irdl::detail::Template::render()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00179">mlir::AffineExpr::replace()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00511">mlir::AffineMap::replace()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00035">mlir::replaceAllUsesInRegionWith()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00927">mlir::scf::replaceAndCastForOpIterArg()</a>, <a class="el" href="AttrTypeSubElements_8cpp_source.html#l00086">mlir::detail::AttrTypeReplacerBase&lt; Concrete &gt;::replaceElementsIn()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01026">mlir::transform::TransformState::Extension::replacePayloadOp()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01034">mlir::transform::TransformState::Extension::replacePayloadValue()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00455">replaceUnitMappingIdsHelper()</a>, <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00166">mlir::memref::replaceWithIndependentOp()</a>, <a class="el" href="DIExpressionRewriter_8cpp_source.html#l00027">mlir::LLVM::DIExpressionRewriter::simplify()</a>, and <a class="el" href="TransformInterfaces_8h_source.html#l01110">mlir::transform::TransformRewriter::TransformState</a>.</p>

</div>
</div>
<a id="a61d47dd5a912dd47b30a64a582d8ddb7" name="a61d47dd5a912dd47b30a64a582d8ddb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d47dd5a912dd47b30a64a582d8ddb7">&#9670;&#160;</a></span>setInterTileBoundsParametric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> setInterTileBoundsParametric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>origLoop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>newLoop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>tileSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set lower and upper bounds of inter-tile loops for parametric tiling. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00559">559</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00660">constructParametricallyTiledIndexSetHyperRect()</a>.</p>

</div>
</div>
<a id="a63fecf5961f8da1b944c27825666cdf6" name="a63fecf5961f8da1b944c27825666cdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fecf5961f8da1b944c27825666cdf6">&#9670;&#160;</a></span>setIntraTileBoundsParametric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> setIntraTileBoundsParametric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>origLoop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>newInterTileLoop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>newIntraTileLoop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>tileSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set lower and upper bounds of intra-tile loops for parametric tiling. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00464">464</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="AffineOps_8h_source.html#l00553">mlir::affine::AffineBound::getMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineOps_8h_source.html#l00555">mlir::affine::AffineBound::getNumOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineOps_8h_source.html#l00556">mlir::affine::AffineBound::getOperand()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00660">constructParametricallyTiledIndexSetHyperRect()</a>.</p>

</div>
</div>
<a id="adda437963a9fbf87b5b4ec7660ab18de" name="adda437963a9fbf87b5b4ec7660ab18de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda437963a9fbf87b5b4ec7660ab18de">&#9670;&#160;</a></span>stripmineSink() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp stripmineSink </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeType</td>          <td class="paramname"><span class="paramname"><em>factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01572">1572</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01529">stripmineSink()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="afd502bddb6a553eb2aa32603adbdce3d" name="afd502bddb6a553eb2aa32603adbdce3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd502bddb6a553eb2aa32603adbdce3d">&#9670;&#160;</a></span>stripmineSink() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt; stripmineSink </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>factor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>targets</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01529">1529</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00252">mlir::OpBuilder::atBlockTerminator()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01509">augmentMapAndBounds()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00035">mlir::replaceAllUsesInRegionWith()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01572">stripmineSink()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01584">mlir::affine::tile()</a>.</p>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="ab10e1ab563e9544b86390dde94e70835" name="ab10e1ab563e9544b86390dde94e70835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10e1ab563e9544b86390dde94e70835">&#9670;&#160;</a></span>copies</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* <a class="el" href="#a38d8eb4db64049cbfcc770fdb9f2e522">if</a> copies could not be generated due to yet unimplemented cases* copyInPlacementStart and copyOutPlacementStart in copyPlacementBlock* specify the insertion points where the incoming copies and outgoing copies</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a buffer in the faster memory space for the specified memref region (memref has to be non-zero ranked); generates a copy from the lower memory space to this one, and replaces all loads/stores in the block range [&lsquo;begin&rsquo;, &lsquo;end&rsquo;) of &lsquo;block&rsquo; to load/store from that buffer. Returns failure. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01939">1939</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

</div>
</div>
<a id="adae31dc2552ddc12092a83df1b1de2dc" name="adae31dc2552ddc12092a83df1b1de2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae31dc2552ddc12092a83df1b1de2dc">&#9670;&#160;</a></span>copyNestRoot</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return copyNestRoot</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01926">1926</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01914">if()</a>.</p>

</div>
</div>
<a id="afede4e8e79beed3bccedb6dde3a866b8" name="afede4e8e79beed3bccedb6dde3a866b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afede4e8e79beed3bccedb6dde3a866b8">&#9670;&#160;</a></span>fastBufExprs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fastBufExprs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01904">1904</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

</div>
</div>
<a id="a10daa62245f5f90b8d68a7eebd5371c4" name="a10daa62245f5f90b8d68a7eebd5371c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10daa62245f5f90b8d68a7eebd5371c4">&#9670;&#160;</a></span>fastBufMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">canonicalizeMapAndOperands &amp; fastBufMap = simplifyAffineMap(fastBufMap)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01905">1905</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01914">if()</a>.</p>

</div>
</div>
<a id="ab3c0736f545f4a75f723449c452395b3" name="ab3c0736f545f4a75f723449c452395b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c0736f545f4a75f723449c452395b3">&#9670;&#160;</a></span>load</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto load</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      AffineLoadOp::create(<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, loc, fastMemRef, <a class="code hl_variable" href="#a10daa62245f5f90b8d68a7eebd5371c4">fastBufMap</a>, fastBufMapOperands)</div>
<div class="ttc" id="aLinalgTransformOps_8cpp_html_a21ad0bd836b90d08f4cf640b4c298e7c"><div class="ttname"><a href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a></div><div class="ttdeci">b</div><div class="ttdoc">Return true if permutation is a valid permutation of the outer_dims_perm (case OuterOrInnerPerm::Oute...</div><div class="ttdef"><b>Definition</b> <a href="LinalgTransformOps_8cpp_source.html#l02097">LinalgTransformOps.cpp:2097</a></div></div>
<div class="ttc" id="aLoopUtils_8cpp_html_a10daa62245f5f90b8d68a7eebd5371c4"><div class="ttname"><a href="#a10daa62245f5f90b8d68a7eebd5371c4">fastBufMap</a></div><div class="ttdeci">fullyComposeAffineMapAndOperands &amp; fastBufMap</div><div class="ttdef"><b>Definition</b> <a href="LoopUtils_8cpp_source.html#l01905">LoopUtils.cpp:1905</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01923">1923</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00248">mlir::affine::canFuseLoops()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00541">convertTransferReadOp()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00530">mlir::createConvertAMDGPUToROCDLPass()</a>, <a class="el" href="MaskedloadToLoad_8cpp_source.html#l00052">createVectorLoadForMaskedLoad()</a>, <a class="el" href="XeGPUPropagateLayout_8cpp_source.html#l00341">mlir::xegpu::createXeGPUPropagateLayout()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00174">mlir::sparse_tensor::genIndexLoad()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00499">mlir::impl::ConvertAMDGPUToROCDLPassBase&lt; DerivedT &gt;::getDependentDialects()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00134">getProducerCandidates()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00161">getValueLoadedFromGlobal()</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00061">haveNoReadsAfterWriteExceptSameIndex()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01914">if()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00447">mlir::affine::isVectorizableLoopBody()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00380">isVectorizableLoopBodyWithOpCond()</a>, <a class="el" href="ExecutionEngine_2ExecutionEngine_8cpp_source.html#l00144">packFunctionArguments()</a>, and <a class="el" href="LowerVectorContract_8cpp_source.html#l00076">reshapeLoad()</a>.</p>

</div>
</div>
<a id="addee311e44ade07d151d91df4f71cfbd" name="addee311e44ade07d151d91df4f71cfbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addee311e44ade07d151d91df4f71cfbd">&#9670;&#160;</a></span>respectively</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* <a class="el" href="#a38d8eb4db64049cbfcc770fdb9f2e522">if</a> <a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> could not be generated due to yet unimplemented cases* copyInPlacementStart and copyOutPlacementStart in copyPlacementBlock* specify the insertion points where the incoming <a class="el" href="#ab10e1ab563e9544b86390dde94e70835">copies</a> and outgoing * respectively</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01940">1940</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
