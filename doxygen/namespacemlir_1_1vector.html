<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::vector Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="namespacemlir_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mlir::vector Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:detail" id="r_detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector_1_1detail.html">detail</a></td></tr>
<tr class="memitem:impl" id="r_impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector_1_1impl.html">impl</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:LowerVectorMultiReductionOptions" id="r_LowerVectorMultiReductionOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1LowerVectorMultiReductionOptions.html">LowerVectorMultiReductionOptions</a></td></tr>
<tr class="memitem:LowerVectorsOptions" id="r_LowerVectorsOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1LowerVectorsOptions.html">LowerVectorsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper structure used to hold the different options of LowerVectorsOp.  <a href="structmlir_1_1vector_1_1LowerVectorsOptions.html#details">More...</a><br /></td></tr>
<tr class="memitem:MaskableOpRewritePattern" id="r_MaskableOpRewritePattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1MaskableOpRewritePattern.html">MaskableOpRewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern for ops that implement <span class="tt">MaskableOpInterface</span> and that <em>might</em> be masked (i.e.  <a href="structmlir_1_1vector_1_1MaskableOpRewritePattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:ScalableValueBoundsConstraintSet" id="r_ScalableValueBoundsConstraintSet"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1ScalableValueBoundsConstraintSet.html">ScalableValueBoundsConstraintSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of <span class="tt"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html" title="A helper class to be used with ValueBoundsOpInterface.">ValueBoundsConstraintSet</a></span> that can solve for scalable bounds.  <a href="structmlir_1_1vector_1_1ScalableValueBoundsConstraintSet.html#details">More...</a><br /></td></tr>
<tr class="memitem:UnrollVectorOptions" id="r_UnrollVectorOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1UnrollVectorOptions.html">UnrollVectorOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options that control the vector unrolling.  <a href="structmlir_1_1vector_1_1UnrollVectorOptions.html#details">More...</a><br /></td></tr>
<tr class="memitem:VectorDim" id="r_VectorDim"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1VectorDim.html">VectorDim</a></td></tr>
<tr class="memitem:VectorTransformsOptions" id="r_VectorTransformsOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to control the behavior of vector transform patterns.  <a href="structmlir_1_1vector_1_1VectorTransformsOptions.html#details">More...</a><br /></td></tr>
<tr class="memitem:WarpExecuteOnLane0LoweringOptions" id="r_WarpExecuteOnLane0LoweringOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1WarpExecuteOnLane0LoweringOptions.html">WarpExecuteOnLane0LoweringOptions</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a00065bcfa1929cd9d44cd73d2fecd6fb" id="r_a00065bcfa1929cd9d44cd73d2fecd6fb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00065bcfa1929cd9d44cd73d2fecd6fb">ConstantOrScalableBound</a></td></tr>
<tr class="memitem:a4a5b92769df4fb85a67c4d06977e736f" id="r_a4a5b92769df4fb85a67c4d06977e736f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a5b92769df4fb85a67c4d06977e736f">DistributionMapFn</a> = std::function&lt;<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td></tr>
<tr class="memitem:ad578b5a1c96b2e80475b10afd0866e7b" id="r_ad578b5a1c96b2e80475b10afd0866e7b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad578b5a1c96b2e80475b10afd0866e7b">UnrollVectorOpFn</a></td></tr>
<tr class="memdesc:ad578b5a1c96b2e80475b10afd0866e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic utility for unrolling n-D vector operations to (n-1)-D operations.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4ba6d4a825dbd36205be5322733056ef" id="r_a4ba6d4a825dbd36205be5322733056ef"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ba6d4a825dbd36205be5322733056ef">ConstantMaskKind</a> { <a class="el" href="#a4ba6d4a825dbd36205be5322733056efa5a26d218c82b9e4168d67628ecb0a0d1">AllFalse</a> = 0
, <a class="el" href="#a4ba6d4a825dbd36205be5322733056efa822b19813c2556c566eec6864da1319f">AllTrue</a>
 }</td></tr>
<tr class="memdesc:a4ba6d4a825dbd36205be5322733056ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined constant_mask kinds.  <a href="#a4ba6d4a825dbd36205be5322733056ef">More...</a><br /></td></tr>
<tr class="memitem:acfee45e655b185bd625e2f7994dc2c50" id="r_acfee45e655b185bd625e2f7994dc2c50"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfee45e655b185bd625e2f7994dc2c50">BroadcastableToResult</a> { <a class="el" href="#acfee45e655b185bd625e2f7994dc2c50a505a83f220c02df2f85c3810cd9ceb38">Success</a> = 0
, <a class="el" href="#acfee45e655b185bd625e2f7994dc2c50ac76fd47e5afe8e699733f0b655854c5a">SourceRankHigher</a> = 1
, <a class="el" href="#acfee45e655b185bd625e2f7994dc2c50a2664c241558d7674e8ed4d5f63d2e463">DimensionMismatch</a> = 2
, <a class="el" href="#acfee45e655b185bd625e2f7994dc2c50a578636e914af1c61d9d43b36a2076248">SourceTypeNotAVector</a> = 3
 }</td></tr>
<tr class="memdesc:acfee45e655b185bd625e2f7994dc2c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether <span class="tt">srcType</span> can be broadcast to <span class="tt">dstVectorType</span> under the semantics of the <span class="tt">vector.broadcast</span> op.  <a href="#acfee45e655b185bd625e2f7994dc2c50">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a79b88f639bdf96c6e729d686a3c250f6" id="r_a79b88f639bdf96c6e729d686a3c250f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79b88f639bdf96c6e729d686a3c250f6">registerConvertVectorToLLVMInterface</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:aa5d301133c3ac8bc64957d0a9eb7006a" id="r_aa5d301133c3ac8bc64957d0a9eb7006a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5d301133c3ac8bc64957d0a9eb7006a">registerValueBoundsOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a2683abb4897d8bda306d12702ee2ca04" id="r_a2683abb4897d8bda306d12702ee2ca04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2683abb4897d8bda306d12702ee2ca04">buildTerminatedBody</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a2683abb4897d8bda306d12702ee2ca04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callback to build a region with a 'vector.yield' terminator with no arguments.  <br /></td></tr>
<tr class="memitem:a5150a3f7aa4857a1863bd10fb551442a" id="r_a5150a3f7aa4857a1863bd10fb551442a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acfee45e655b185bd625e2f7994dc2c50">BroadcastableToResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5150a3f7aa4857a1863bd10fb551442a">isBroadcastableTo</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> srcType, VectorType dstVectorType, std::pair&lt; <a class="el" href="structmlir_1_1vector_1_1VectorDim.html">VectorDim</a>, <a class="el" href="structmlir_1_1vector_1_1VectorDim.html">VectorDim</a> &gt; *mismatchingDims=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memitem:a901dfffd46bc2f80e977fdea83adc180" id="r_a901dfffd46bc2f80e977fdea83adc180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a901dfffd46bc2f80e977fdea83adc180">populateVectorToVectorCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a901dfffd46bc2f80e977fdea83adc180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of vector-to-vector canonicalization patterns.  <br /></td></tr>
<tr class="memitem:a7ec9916655c82acca22bdeb882303f0f" id="r_a7ec9916655c82acca22bdeb882303f0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ec9916655c82acca22bdeb882303f0f">populateFoldArithExtensionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a7ec9916655c82acca22bdeb882303f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns that fold arithmetic extension on floating point into vector contract for the backends with native support.  <br /></td></tr>
<tr class="memitem:a2bc60b182ad08ffab9aa924a74e78129" id="r_a2bc60b182ad08ffab9aa924a74e78129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bc60b182ad08ffab9aa924a74e78129">populateElementwiseToVectorOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a2bc60b182ad08ffab9aa924a74e78129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns that fold elementwise op on vectors to the vector dialect.  <br /></td></tr>
<tr class="memitem:ae3cb3b0a7edef27b564ca0603fedec4a" id="r_ae3cb3b0a7edef27b564ca0603fedec4a"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3cb3b0a7edef27b564ca0603fedec4a">getVectorSubscriptType</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder)</td></tr>
<tr class="memdesc:ae3cb3b0a7edef27b564ca0603fedec4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integer type required for subscripts in the vector dialect.  <br /></td></tr>
<tr class="memitem:a0499bcd00b867b4665ddf0c939543cfb" id="r_a0499bcd00b867b4665ddf0c939543cfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0499bcd00b867b4665ddf0c939543cfb">getVectorSubscriptAttr</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; values)</td></tr>
<tr class="memdesc:a0499bcd00b867b4665ddf0c939543cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an integer array attribute containing the given values using the integer type required for subscripts in the vector dialect.  <br /></td></tr>
<tr class="memitem:abf88d2bf2999298f815f0bc9ba05f2a4" id="r_abf88d2bf2999298f815f0bc9ba05f2a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf88d2bf2999298f815f0bc9ba05f2a4">getVectorReductionOp</a> (arith::AtomicRMWKind op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> vector)</td></tr>
<tr class="memdesc:abf88d2bf2999298f815f0bc9ba05f2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value obtained by reducing the vector into a scalar using the operation kind associated with a binary AtomicRMWKind op.  <br /></td></tr>
<tr class="memitem:a3221aacef9029612ded6c1d7bef1791c" id="r_a3221aacef9029612ded6c1d7bef1791c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3221aacef9029612ded6c1d7bef1791c">getTransferMinorIdentityMap</a> (ShapedType shapedType, VectorType vectorType)</td></tr>
<tr class="memdesc:a3221aacef9029612ded6c1d7bef1791c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the default minor identity map suitable for a vector transfer.  <br /></td></tr>
<tr class="memitem:a3db9bda1f50ffdff9759b51bf49ddb86" id="r_a3db9bda1f50ffdff9759b51bf49ddb86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3db9bda1f50ffdff9759b51bf49ddb86">checkSameValueRAW</a> (TransferWriteOp defWrite, TransferReadOp read)</td></tr>
<tr class="memdesc:a3db9bda1f50ffdff9759b51bf49ddb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the transfer_write fully writes the data accessed by the transfer_read.  <br /></td></tr>
<tr class="memitem:a6f1125a16d0ba1e024d9b99d5b439a0a" id="r_a6f1125a16d0ba1e024d9b99d5b439a0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f1125a16d0ba1e024d9b99d5b439a0a">checkSameValueWAW</a> (TransferWriteOp write, TransferWriteOp priorWrite)</td></tr>
<tr class="memdesc:a6f1125a16d0ba1e024d9b99d5b439a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the write op fully over-write the priorWrite transfer_write op.  <br /></td></tr>
<tr class="memitem:a5fd4b030a7ece80ee86e9b6c41895b82" id="r_a5fd4b030a7ece80ee86e9b6c41895b82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fd4b030a7ece80ee86e9b6c41895b82">isDisjointTransferIndices</a> (VectorTransferOpInterface transferA, VectorTransferOpInterface transferB, <a class="el" href="classbool.html">bool</a> testDynamicValueUsingBounds=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a5fd4b030a7ece80ee86e9b6c41895b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if we can prove that the transfer operations access disjoint memory, without requring the accessed tensor/memref to be the same.  <br /></td></tr>
<tr class="memitem:a629666d1e621e7ad850d28cecd82a263" id="r_a629666d1e621e7ad850d28cecd82a263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a629666d1e621e7ad850d28cecd82a263">isDisjointTransferSet</a> (VectorTransferOpInterface transferA, VectorTransferOpInterface transferB, <a class="el" href="classbool.html">bool</a> testDynamicValueUsingBounds=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a629666d1e621e7ad850d28cecd82a263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if we can prove that the transfer operations access disjoint memory, requiring the operations to access the same tensor/memref.  <br /></td></tr>
<tr class="memitem:a015472323cadf1a87aa5281a682eb0b9" id="r_a015472323cadf1a87aa5281a682eb0b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a015472323cadf1a87aa5281a682eb0b9">makeArithReduction</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, CombiningKind kind, <a class="el" href="classmlir_1_1Value.html">Value</a> v1, <a class="el" href="classmlir_1_1Value.html">Value</a> acc, arith::FastMathFlagsAttr fastmath=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> mask=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a015472323cadf1a87aa5281a682eb0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result value of reducing two scalar/vector values with the corresponding arith operation.  <br /></td></tr>
<tr class="memitem:a75d40ea32eb46ab63ab75c1b568ce4ef" id="r_a75d40ea32eb46ab63ab75c1b568ce4ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75d40ea32eb46ab63ab75c1b568ce4ef">isParallelIterator</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a75d40ea32eb46ab63ab75c1b568ce4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <span class="tt">attr</span> has "parallel" iterator type semantics.  <br /></td></tr>
<tr class="memitem:a2393c85f5a124d20d5299d422b29a140" id="r_a2393c85f5a124d20d5299d422b29a140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2393c85f5a124d20d5299d422b29a140">isReductionIterator</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a2393c85f5a124d20d5299d422b29a140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <span class="tt">attr</span> has "reduction" iterator type semantics.  <br /></td></tr>
<tr class="memitem:a817b87f0647b2d105ddb4ee8331c6e74" id="r_a817b87f0647b2d105ddb4ee8331c6e74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a817b87f0647b2d105ddb4ee8331c6e74">getAsIntegers</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; values)</td></tr>
<tr class="memdesc:a817b87f0647b2d105ddb4ee8331c6e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integer numbers in <span class="tt">values</span>.  <br /></td></tr>
<tr class="memitem:af32acdf7a602e7b76f6784237c2f2fa2" id="r_af32acdf7a602e7b76f6784237c2f2fa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af32acdf7a602e7b76f6784237c2f2fa2">getAsIntegers</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; foldResults)</td></tr>
<tr class="memdesc:af32acdf7a602e7b76f6784237c2f2fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integer numbers in <span class="tt">foldResults</span>.  <br /></td></tr>
<tr class="memitem:ab5c8f18ea2cde21d5f5585fe430d0494" id="r_ab5c8f18ea2cde21d5f5585fe430d0494"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5c8f18ea2cde21d5f5585fe430d0494">getAsValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; foldResults)</td></tr>
<tr class="memdesc:ab5c8f18ea2cde21d5f5585fe430d0494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <span class="tt">foldResults</span> into Values.  <br /></td></tr>
<tr class="memitem:a30a2f31604d067d92eed03a981b27cc5" id="r_a30a2f31604d067d92eed03a981b27cc5"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30a2f31604d067d92eed03a981b27cc5">getConstantVscaleMultiplier</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a30a2f31604d067d92eed03a981b27cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <span class="tt">value</span> is a constant multiple of <span class="tt">vector.vscale</span> (e.g.  <br /></td></tr>
<tr class="memitem:a561e2afa7c375df7a7dffe273c38b8de" id="r_a561e2afa7c375df7a7dffe273c38b8de"><td class="memItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a561e2afa7c375df7a7dffe273c38b8de">inferTransferOpMaskType</a> (VectorType vecType, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> permMap)</td></tr>
<tr class="memdesc:a561e2afa7c375df7a7dffe273c38b8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infers the mask type for a transfer op given its vector type and permutation map.  <br /></td></tr>
<tr class="memitem:aa7388851d413b45a98d71682285ce817" id="r_aa7388851d413b45a98d71682285ce817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7388851d413b45a98d71682285ce817">createMaskOpRegion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *maskableOp)</td></tr>
<tr class="memdesc:aa7388851d413b45a98d71682285ce817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the vector.yield-ended region of a vector.mask op with <span class="tt">maskableOp</span> as masked operation.  <br /></td></tr>
<tr class="memitem:a21bfcee9196fe1a2cfa548b7df8193a9" id="r_a21bfcee9196fe1a2cfa548b7df8193a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21bfcee9196fe1a2cfa548b7df8193a9">maskOperation</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *maskableOp, <a class="el" href="classmlir_1_1Value.html">Value</a> mask, <a class="el" href="classmlir_1_1Value.html">Value</a> passthru=<a class="el" href="classmlir_1_1Value.html">Value</a>())</td></tr>
<tr class="memdesc:a21bfcee9196fe1a2cfa548b7df8193a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector.mask operation around a maskable operation.  <br /></td></tr>
<tr class="memitem:a5af92ace2e0cbd151cca52cf528a500a" id="r_a5af92ace2e0cbd151cca52cf528a500a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af92ace2e0cbd151cca52cf528a500a">selectPassthru</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Value.html">Value</a> mask, <a class="el" href="classmlir_1_1Value.html">Value</a> newValue, <a class="el" href="classmlir_1_1Value.html">Value</a> passthru)</td></tr>
<tr class="memdesc:a5af92ace2e0cbd151cca52cf528a500a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector select operation that picks values from <span class="tt">newValue</span> or <span class="tt">passthru</span> for each result vector lane based on <span class="tt">mask</span>.  <br /></td></tr>
<tr class="memitem:a6867327b882d46f26e5f318a023508b9" id="r_a6867327b882d46f26e5f318a023508b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6867327b882d46f26e5f318a023508b9">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a8c3d017bb3f90cb64c531e7b6a4b0606" id="r_a8c3d017bb3f90cb64c531e7b6a4b0606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c3d017bb3f90cb64c531e7b6a4b0606">registerBufferizableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:ad9cfbb0f14dc6257ab43a4638ed9ef7d" id="r_ad9cfbb0f14dc6257ab43a4638ed9ef7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9cfbb0f14dc6257ab43a4638ed9ef7d">populateVectorContractLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, VectorContractLowering vectorContractLoweringOption, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1, <a class="el" href="classbool.html">bool</a> disableOuterProductLowering=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:ad9cfbb0f14dc6257ab43a4638ed9ef7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <br /></td></tr>
<tr class="memitem:a991e613d3d19627fd75f7c874a8e0fad" id="r_a991e613d3d19627fd75f7c874a8e0fad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a991e613d3d19627fd75f7c874a8e0fad">populateVectorOuterProductLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a991e613d3d19627fd75f7c874a8e0fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <br /></td></tr>
<tr class="memitem:aa136544741125dce255ad55a91f2067a" id="r_aa136544741125dce255ad55a91f2067a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa136544741125dce255ad55a91f2067a">populateVectorMultiReductionLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, VectorMultiReductionLowering <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:aa136544741125dce255ad55a91f2067a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert vector.multi_reduction op into a sequence of vector.reduction ops.  <br /></td></tr>
<tr class="memitem:a88033aae0cb3a6e60cbca725c347676f" id="r_a88033aae0cb3a6e60cbca725c347676f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88033aae0cb3a6e60cbca725c347676f">populateVectorBroadcastLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a88033aae0cb3a6e60cbca725c347676f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <br /></td></tr>
<tr class="memitem:a9ec71309405318dd0ed6b2b31ded892c" id="r_a9ec71309405318dd0ed6b2b31ded892c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ec71309405318dd0ed6b2b31ded892c">populateVectorMaskOpLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a9ec71309405318dd0ed6b2b31ded892c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <br /></td></tr>
<tr class="memitem:aa279bf22c17b61f1bf71e434dce3f158" id="r_aa279bf22c17b61f1bf71e434dce3f158"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa279bf22c17b61f1bf71e434dce3f158">populateScalarVectorTransferLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit, <a class="el" href="classbool.html">bool</a> allowMultipleUses)</td></tr>
<tr class="memdesc:aa279bf22c17b61f1bf71e434dce3f158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects patterns that lower scalar vector transfer ops to memref loads and stores when beneficial.  <br /></td></tr>
<tr class="memitem:a43189fd7073752a0dc3e3ac6274a1513" id="r_a43189fd7073752a0dc3e3ac6274a1513"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43189fd7073752a0dc3e3ac6274a1513">populateVectorShapeCastLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a43189fd7073752a0dc3e3ac6274a1513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <br /></td></tr>
<tr class="memitem:a6c0272615817f617a90ce4f9ff241562" id="r_a6c0272615817f617a90ce4f9ff241562"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c0272615817f617a90ce4f9ff241562">populateVectorTransposeLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, VectorTransposeLowering vectorTransposeLowering, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a6c0272615817f617a90ce4f9ff241562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <br /></td></tr>
<tr class="memitem:a4c2dd6fac5a93d9d6808bf8737db1cbb" id="r_a4c2dd6fac5a93d9d6808bf8737db1cbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c2dd6fac5a93d9d6808bf8737db1cbb">populateVectorTransferLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; maxTransferRank=std::nullopt, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a4c2dd6fac5a93d9d6808bf8737db1cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <br /></td></tr>
<tr class="memitem:a13c619a126f79a49fafb2f76bbc67606" id="r_a13c619a126f79a49fafb2f76bbc67606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13c619a126f79a49fafb2f76bbc67606">populateVectorTransferPermutationMapLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a13c619a126f79a49fafb2f76bbc67606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of transfer read/write lowering patterns that simplify the permutation map (e.g., converting it to a minor identity map) by inserting broadcasts and transposes.  <br /></td></tr>
<tr class="memitem:afbc33a6788e2401e592cce83b6c68c42" id="r_afbc33a6788e2401e592cce83b6c68c42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbc33a6788e2401e592cce83b6c68c42">populateVectorScanLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:afbc33a6788e2401e592cce83b6c68c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <br /></td></tr>
<tr class="memitem:a497578d7dbc818d7fc96548403f76542" id="r_a497578d7dbc818d7fc96548403f76542"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a497578d7dbc818d7fc96548403f76542">populateVectorStepLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a497578d7dbc818d7fc96548403f76542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <br /></td></tr>
<tr class="memitem:a439f87d998fc217be9e760851e5c7a63" id="r_a439f87d998fc217be9e760851e5c7a63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a439f87d998fc217be9e760851e5c7a63">populateVectorGatherLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a439f87d998fc217be9e760851e5c7a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <br /></td></tr>
<tr class="memitem:af2838611f578daf6c4d441da9c20dded" id="r_af2838611f578daf6c4d441da9c20dded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2838611f578daf6c4d441da9c20dded">populateVectorGatherToConditionalLoadPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:af2838611f578daf6c4d441da9c20dded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <br /></td></tr>
<tr class="memitem:ad2010f10ca9e7f5df4aed9571180e3c5" id="r_ad2010f10ca9e7f5df4aed9571180e3c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2010f10ca9e7f5df4aed9571180e3c5">populateVectorMaskLoweringPatternsForSideEffectingOps</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ad2010f10ca9e7f5df4aed9571180e3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates instances of <span class="tt">MaskOpRewritePattern</span> to lower masked operations with <span class="tt">vector.mask</span>.  <br /></td></tr>
<tr class="memitem:a6d67a015516dec992613685a6bb1a20b" id="r_a6d67a015516dec992613685a6bb1a20b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d67a015516dec992613685a6bb1a20b">populateVectorMaskedLoadStoreEmulationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a6d67a015516dec992613685a6bb1a20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <br /></td></tr>
<tr class="memitem:ad3c07e592cdd88b811669bd163b93378" id="r_ad3c07e592cdd88b811669bd163b93378"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3c07e592cdd88b811669bd163b93378">populateVectorInterleaveLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classint64__t.html">int64_t</a> targetRank=1, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:ad3c07e592cdd88b811669bd163b93378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <br /></td></tr>
<tr class="memitem:a33e5072e435d0da63d65e437f724e246" id="r_a33e5072e435d0da63d65e437f724e246"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33e5072e435d0da63d65e437f724e246">populateVectorInterleaveToShufflePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memitem:a8cad1ef496d64e01a0d7aaa62432e1d9" id="r_a8cad1ef496d64e01a0d7aaa62432e1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cad1ef496d64e01a0d7aaa62432e1d9">populateVectorBitCastLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classint64__t.html">int64_t</a> targetRank=1, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a8cad1ef496d64e01a0d7aaa62432e1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the pattern set with the following patterns:  <br /></td></tr>
<tr class="memitem:a12356bde7fa3274d54af5c6a88b6cd70" id="r_a12356bde7fa3274d54af5c6a88b6cd70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12356bde7fa3274d54af5c6a88b6cd70">populateVectorShuffleLoweringPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memitem:a42d94532ec0a3cacf8cdd83e46d21a12" id="r_a42d94532ec0a3cacf8cdd83e46d21a12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42d94532ec0a3cacf8cdd83e46d21a12">populateVectorRankReducingFMAPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a42d94532ec0a3cacf8cdd83e46d21a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates a pattern that rank-reduces n-D FMAs into (n-1)-D FMAs where n &gt; 1.  <br /></td></tr>
<tr class="memitem:a5ba5aa7f7dff77008128f92410137dfe" id="r_a5ba5aa7f7dff77008128f92410137dfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ba5aa7f7dff77008128f92410137dfe">populateVectorToFromElementsToShuffleTreePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a5ba5aa7f7dff77008128f92410137dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns to rewrite sequences of <span class="tt">vector.to_elements</span> + <span class="tt">vector.from_elements</span> operations into a tree of <span class="tt">vector.shuffle</span> operations.  <br /></td></tr>
<tr class="memitem:a30b3fc1228086cc143e4a10253983e6f" id="r_a30b3fc1228086cc143e4a10253983e6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30b3fc1228086cc143e4a10253983e6f">populateVectorContractToMatrixMultiply</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=100)</td></tr>
<tr class="memdesc:a30b3fc1228086cc143e4a10253983e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <br /></td></tr>
<tr class="memitem:ab0f29d74a98439c7b729ddf7ab80e0cc" id="r_ab0f29d74a98439c7b729ddf7ab80e0cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0f29d74a98439c7b729ddf7ab80e0cc">populateVectorTransposeToFlatTranspose</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=100)</td></tr>
<tr class="memdesc:ab0f29d74a98439c7b729ddf7ab80e0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with the following patterns:  <br /></td></tr>
<tr class="memitem:a4abad62f4d03b479cc3a2e598be744ad" id="r_a4abad62f4d03b479cc3a2e598be744ad"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4abad62f4d03b479cc3a2e598be744ad">createLowerVectorToFromElementsToShuffleTree</a> ()</td></tr>
<tr class="memitem:a555cfa7abe7f1b002abcfff16083f064" id="r_a555cfa7abe7f1b002abcfff16083f064"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a555cfa7abe7f1b002abcfff16083f064">createLowerVectorMaskPass</a> ()</td></tr>
<tr class="memdesc:a555cfa7abe7f1b002abcfff16083f064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the <span class="tt">vector.mask</span> lowering pass.  <br /></td></tr>
<tr class="memitem:a5379063f08515cc5aa200ed01a41ea95" id="r_a5379063f08515cc5aa200ed01a41ea95"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5379063f08515cc5aa200ed01a41ea95">createLowerVectorMultiReductionPass</a> (VectorMultiReductionLowering option=VectorMultiReductionLowering::InnerParallel)</td></tr>
<tr class="memdesc:a5379063f08515cc5aa200ed01a41ea95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the <span class="tt">vector.multi_reduction</span> lowering pass.  <br /></td></tr>
<tr class="memitem:a68d0d59b96d753e959c25829370fbac6" id="r_a68d0d59b96d753e959c25829370fbac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68d0d59b96d753e959c25829370fbac6">registerLowerVectorMaskPass</a> ()</td></tr>
<tr class="memitem:ad69211351808a6034694b97a318ee5bf" id="r_ad69211351808a6034694b97a318ee5bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad69211351808a6034694b97a318ee5bf">registerLowerVectorMaskPassPass</a> ()</td></tr>
<tr class="memitem:af58efebfc0ab2f8aeba0995520ad3848" id="r_af58efebfc0ab2f8aeba0995520ad3848"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af58efebfc0ab2f8aeba0995520ad3848">registerLowerVectorMultiReduction</a> ()</td></tr>
<tr class="memitem:ac11e4ba933d135e38891936729671d84" id="r_ac11e4ba933d135e38891936729671d84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac11e4ba933d135e38891936729671d84">registerLowerVectorMultiReductionPass</a> ()</td></tr>
<tr class="memitem:a02803c804875d166658b06881153cfef" id="r_a02803c804875d166658b06881153cfef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02803c804875d166658b06881153cfef">registerLowerVectorToFromElementsToShuffleTree</a> ()</td></tr>
<tr class="memitem:a83ab373b8dbbc7ce2ca3129bb3d24923" id="r_a83ab373b8dbbc7ce2ca3129bb3d24923"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83ab373b8dbbc7ce2ca3129bb3d24923">registerLowerVectorToFromElementsToShuffleTreePass</a> ()</td></tr>
<tr class="memitem:a69d670386627a2a6ed18395d5e5e44b0" id="r_a69d670386627a2a6ed18395d5e5e44b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69d670386627a2a6ed18395d5e5e44b0">registerVectorPasses</a> ()</td></tr>
<tr class="memitem:a5e106dc1b48251f4b3e11566df14078a" id="r_a5e106dc1b48251f4b3e11566df14078a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e106dc1b48251f4b3e11566df14078a">registerSubsetOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a6c711eddaf2b505fc007762dc805ecf0" id="r_a6c711eddaf2b505fc007762dc805ecf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c711eddaf2b505fc007762dc805ecf0">populateWarpExecuteOnLane0OpToScfForPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="structmlir_1_1vector_1_1WarpExecuteOnLane0LoweringOptions.html">WarpExecuteOnLane0LoweringOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memitem:a8461b000c4283d776959689802a7dea7" id="r_a8461b000c4283d776959689802a7dea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8461b000c4283d776959689802a7dea7">populateVectorContractCanonicalizeMatmulToMMT</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, std::function&lt; LogicalResult(vector::ContractionOp)&gt; constraint=[](vector::ContractionOp) { return <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success</a>();}, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>=1)</td></tr>
<tr class="memdesc:a8461b000c4283d776959689802a7dea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalization of a <span class="tt">vector.contraction a, b, c</span> with row-major matmul semantics to a contraction with MMT semantics (matrix matrix multiplication with the RHS transposed).  <br /></td></tr>
<tr class="memitem:aa2c39668001ee9e2ba767b172123f1d8" id="r_aa2c39668001ee9e2ba767b172123f1d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2c39668001ee9e2ba767b172123f1d8">populateVectorReductionToContractPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:aa2c39668001ee9e2ba767b172123f1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect patterns to convert reduction op to vector.contract and fold transpose/broadcast ops into the contract.  <br /></td></tr>
<tr class="memitem:ac789257ecc17a3ca9c07a9178fb530a3" id="r_ac789257ecc17a3ca9c07a9178fb530a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac789257ecc17a3ca9c07a9178fb530a3">populateVectorTransferFullPartialPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:ac789257ecc17a3ca9c07a9178fb530a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate <span class="tt">patterns</span> with the following patterns.  <br /></td></tr>
<tr class="memitem:a5f9beecd0d699bde9c3912943c0f3b13" id="r_a5f9beecd0d699bde9c3912943c0f3b13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f9beecd0d699bde9c3912943c0f3b13">populateDropInnerMostUnitDimsXferOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a5f9beecd0d699bde9c3912943c0f3b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to collapse the most inner unit dims in xfer Ops.  <br /></td></tr>
<tr class="memitem:a848e82989f2072855d837185e7e7694a" id="r_a848e82989f2072855d837185e7e7694a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a848e82989f2072855d837185e7e7694a">populateSinkVectorOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a848e82989f2072855d837185e7e7694a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns that remove redundant <a class="el" href="structVector.html">Vector</a> Ops by re-ordering them with e.g.  <br /></td></tr>
<tr class="memitem:ad09a4c24cd4f1765fa613e5f4d3cbeee" id="r_ad09a4c24cd4f1765fa613e5f4d3cbeee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad09a4c24cd4f1765fa613e5f4d3cbeee">eliminateVectorMasks</a> (<a class="el" href="classmlir_1_1IRRewriter.html">IRRewriter</a> &amp;rewriter, FunctionOpInterface function, std::optional&lt; VscaleRange &gt; vscaleRange={})</td></tr>
<tr class="memdesc:ad09a4c24cd4f1765fa613e5f4d3cbeee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a vector.transfer operation into an in-bounds (i.e., no out-of-bounds masking) fastpath and a slowpath.  <br /></td></tr>
<tr class="memitem:ab0bd96ceaaff937da9c8067138e02591" id="r_ab0bd96ceaaff937da9c8067138e02591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0bd96ceaaff937da9c8067138e02591">createOrFoldDimOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> source, <a class="el" href="classint64__t.html">int64_t</a> dim)</td></tr>
<tr class="memdesc:ab0bd96ceaaff937da9c8067138e02591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that creates a memref::DimOp or tensor::DimOp depending on the type of <span class="tt">source</span>.  <br /></td></tr>
<tr class="memitem:a87dd4973a2bd2cac230734188a21c995" id="r_a87dd4973a2bd2cac230734188a21c995"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87dd4973a2bd2cac230734188a21c995">isTranspose2DSlice</a> (vector::TransposeOp op)</td></tr>
<tr class="memdesc:a87dd4973a2bd2cac230734188a21c995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns two dims that are greater than one if the transposition is applied on a 2D slice.  <br /></td></tr>
<tr class="memitem:a2098102a54883ea02ee203ebabb4012e" id="r_a2098102a54883ea02ee203ebabb4012e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2098102a54883ea02ee203ebabb4012e">isContiguousSlice</a> (MemRefType memrefType, VectorType vectorType)</td></tr>
<tr class="memdesc:a2098102a54883ea02ee203ebabb4012e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <span class="tt">vectorType</span> is a contiguous slice of <span class="tt">memrefType</span>, in the sense that it can be read/written from/to a contiguous area of the memref.  <br /></td></tr>
<tr class="memitem:aabf889b1d187dae58df0a17542b919ad" id="r_aabf889b1d187dae58df0a17542b919ad"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1StaticTileOffsetRange.html">StaticTileOffsetRange</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabf889b1d187dae58df0a17542b919ad">createUnrollIterator</a> (VectorType vType, <a class="el" href="classint64__t.html">int64_t</a> targetRank=1)</td></tr>
<tr class="memdesc:aabf889b1d187dae58df0a17542b919ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator for all positions in the leading dimensions of <span class="tt">vType</span> up to the <span class="tt">targetRank</span>.  <br /></td></tr>
<tr class="memitem:ad0a5584142f33c4a2887d2e3131f7565" id="r_ad0a5584142f33c4a2887d2e3131f7565"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0a5584142f33c4a2887d2e3131f7565">makeVscaleConstantBuilder</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:ad0a5584142f33c4a2887d2e3131f7565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a functor (<a class="el" href="classint64__t.html">int64_t</a> -&gt; <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>) which returns a constant vscale multiple.  <br /></td></tr>
<tr class="memitem:a2a96bb3f0e3f37f46743b34436f7b14d" id="r_a2a96bb3f0e3f37f46743b34436f7b14d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a96bb3f0e3f37f46743b34436f7b14d">getDims</a> (VectorType vType)</td></tr>
<tr class="memdesc:a2a96bb3f0e3f37f46743b34436f7b14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range over the dims (size and scalability) of a VectorType.  <br /></td></tr>
<tr class="memitem:ad910c130857e946d9d30b58ffb708f3a" id="r_ad910c130857e946d9d30b58ffb708f3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad910c130857e946d9d30b58ffb708f3a">getMixedSizesXfer</a> (<a class="el" href="classbool.html">bool</a> hasTensorSemantics, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *xfer, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter)</td></tr>
<tr class="memdesc:ad910c130857e946d9d30b58ffb708f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for getMixedSizes for vector.transfer_read and vector.transfer_write Ops (for source and destination, respectively).  <br /></td></tr>
<tr class="memitem:abdf9a8c7b9a914162f597bc6d1aa0633" id="r_abdf9a8c7b9a914162f597bc6d1aa0633"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdf9a8c7b9a914162f597bc6d1aa0633">isLinearizableVector</a> (VectorType type)</td></tr>
<tr class="memdesc:abdf9a8c7b9a914162f597bc6d1aa0633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the input <a class="el" href="structVector.html">Vector</a> type can be linearized.  <br /></td></tr>
<tr class="memitem:ac1f704d81959566caaf92245061960fb" id="r_ac1f704d81959566caaf92245061960fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1f704d81959566caaf92245061960fb">createReadOrMaskedRead</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> source, const VectorType &amp;vecToReadTy, std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; padValue=std::nullopt, <a class="el" href="classbool.html">bool</a> useInBoundsInsteadOfMasking=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:ac1f704d81959566caaf92245061960fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a TransferReadOp from <span class="tt">source</span>.  <br /></td></tr>
<tr class="memitem:afad10ba2c08d9f9ffc2fbdd2bc562b36" id="r_afad10ba2c08d9f9ffc2fbdd2bc562b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afad10ba2c08d9f9ffc2fbdd2bc562b36">createReadOrMaskedRead</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> source, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; inputVectorSizes, std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; padValue=std::nullopt, <a class="el" href="classbool.html">bool</a> useInBoundsInsteadOfMasking=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; inputScalableVecDims={})</td></tr>
<tr class="memitem:a341516a4c95139534df7b424b2de2598" id="r_a341516a4c95139534df7b424b2de2598"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a341516a4c95139534df7b424b2de2598">isValidMaskedInputVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; shape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; inputVectorSizes)</td></tr>
<tr class="memdesc:a341516a4c95139534df7b424b2de2598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if <span class="tt">inputVectorSizes</span> is a valid masking configuraion for given <span class="tt">shape</span>, i.e., it meets:  <br /></td></tr>
<tr class="memitem:af60d532cb151ded3380cd20c91c455e5" id="r_af60d532cb151ded3380cd20c91c455e5"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af60d532cb151ded3380cd20c91c455e5">unrollVectorOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, <a class="el" href="#ad578b5a1c96b2e80475b10afd0866e7b">UnrollVectorOpFn</a> unrollFn)</td></tr>
<tr class="memitem:a99ff81229d9b99dfd500fa7168382a6e" id="r_a99ff81229d9b99dfd500fa7168382a6e"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99ff81229d9b99dfd500fa7168382a6e">unrollVectorValue</a> (<a class="el" href="namespacemlir.html#a864cb5eb1fea4a548c28cda535ba7213">TypedValue</a>&lt; VectorType &gt;, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;)</td></tr>
<tr class="memdesc:a99ff81229d9b99dfd500fa7168382a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic utility for unrolling values of type <a class="el" href="namespacemlir_1_1vector.html">vector&lt;NxAxBx...&gt;</a> to N values of type <a class="el" href="namespacemlir_1_1vector.html">vector&lt;AxBx...&gt;</a> using vector.extract.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a00065bcfa1929cd9d44cd73d2fecd6fb" name="a00065bcfa1929cd9d44cd73d2fecd6fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00065bcfa1929cd9d44cd73d2fecd6fb">&#9670;&#160;</a></span>ConstantOrScalableBound</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a00065bcfa1929cd9d44cd73d2fecd6fb">mlir::vector::ConstantOrScalableBound</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structmlir_1_1vector_1_1ScalableValueBoundsConstraintSet_1_1ConstantOrScalableBound.html">ScalableValueBoundsConstraintSet::ConstantOrScalableBound</a></div>
<div class="ttc" id="astructmlir_1_1vector_1_1ScalableValueBoundsConstraintSet_1_1ConstantOrScalableBound_html"><div class="ttname"><a href="structmlir_1_1vector_1_1ScalableValueBoundsConstraintSet_1_1ConstantOrScalableBound.html">mlir::vector::ScalableValueBoundsConstraintSet::ConstantOrScalableBound</a></div><div class="ttdoc">A thin wrapper over an AffineMap which can represent a constant bound, or a scalable bound (in terms ...</div><div class="ttdef"><b>Definition</b> <a href="ScalableValueBoundsConstraintSet_8h_source.html#l00047">ScalableValueBoundsConstraintSet.h:47</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="ScalableValueBoundsConstraintSet_8h_source.html#l00103">103</a> of file <a class="el" href="ScalableValueBoundsConstraintSet_8h_source.html">ScalableValueBoundsConstraintSet.h</a>.</p>

</div>
</div>
<a id="a4a5b92769df4fb85a67c4d06977e736f" name="a4a5b92769df4fb85a67c4d06977e736f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5b92769df4fb85a67c4d06977e736f">&#9670;&#160;</a></span>DistributionMapFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4a5b92769df4fb85a67c4d06977e736f">mlir::vector::DistributionMapFn</a> = std::function&lt;<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorDistribution_8h_source.html#l00044">44</a> of file <a class="el" href="VectorDistribution_8h_source.html">VectorDistribution.h</a>.</p>

</div>
</div>
<a id="ad578b5a1c96b2e80475b10afd0866e7b" name="ad578b5a1c96b2e80475b10afd0866e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad578b5a1c96b2e80475b10afd0866e7b">&#9670;&#160;</a></span>UnrollVectorOpFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad578b5a1c96b2e80475b10afd0866e7b">mlir::vector::UnrollVectorOpFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt;<a class="code hl_class" href="classmlir_1_1Value.html">Value</a>(<a class="code hl_class" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;, <a class="code hl_class" href="classmlir_1_1Location.html">Location</a>, VectorType, <a class="code hl_class" href="classint64__t.html">int64_t</a>)&gt;</div>
<div class="ttc" id="aclassint64__t_html"><div class="ttname"><a href="classint64__t.html">int64_t</a></div></div>
<div class="ttc" id="aclassmlir_1_1Location_html"><div class="ttname"><a href="classmlir_1_1Location.html">mlir::Location</a></div><div class="ttdoc">This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...</div><div class="ttdef"><b>Definition</b> <a href="Location_8h_source.html#l00076">Location.h:76</a></div></div>
<div class="ttc" id="aclassmlir_1_1PatternRewriter_html"><div class="ttname"><a href="classmlir_1_1PatternRewriter.html">mlir::PatternRewriter</a></div><div class="ttdoc">A special type of RewriterBase that coordinates the application of a rewrite pattern on the current I...</div><div class="ttdef"><b>Definition</b> <a href="PatternMatch_8h_source.html#l00793">PatternMatch.h:793</a></div></div>
<div class="ttc" id="aclassmlir_1_1Value_html"><div class="ttname"><a href="classmlir_1_1Value.html">mlir::Value</a></div><div class="ttdoc">This class represents an instance of an SSA value in the MLIR system, representing a computable value...</div><div class="ttdef"><b>Definition</b> <a href="Value_8h_source.html#l00096">Value.h:96</a></div></div>
<div class="ttc" id="anamespacemlir_html_aeb139bbbd94ce3525f61d508772f5d69"><div class="ttname"><a href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">mlir::function_ref</a></div><div class="ttdeci">llvm::function_ref&lt; Fn &gt; function_ref</div><div class="ttdef"><b>Definition</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00152">LLVM.h:152</a></div></div>
</div><!-- fragment -->
<p>Generic utility for unrolling n-D vector operations to (n-1)-D operations. </p>
<p>This handles the common pattern of:</p><ol type="1">
<li>Check if already 1-D. If so, return failure.</li>
<li>Check for scalable dimensions. If so, return failure.</li>
<li>Create poison initialized result.</li>
<li>Loop through the outermost dimension, execute the <a class="el" href="#ad578b5a1c96b2e80475b10afd0866e7b" title="Generic utility for unrolling n-D vector operations to (n-1)-D operations.">UnrollVectorOpFn</a> to create sub vectors.</li>
<li>Insert the sub vectors back into the final vector.</li>
<li>Replace the original op with the new result. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8h_source.html#l00257">257</a> of file <a class="el" href="VectorUtils_8h_source.html">VectorUtils.h</a>.</p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="acfee45e655b185bd625e2f7994dc2c50" name="acfee45e655b185bd625e2f7994dc2c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfee45e655b185bd625e2f7994dc2c50">&#9670;&#160;</a></span>BroadcastableToResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#acfee45e655b185bd625e2f7994dc2c50">mlir::vector::BroadcastableToResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether <span class="tt">srcType</span> can be broadcast to <span class="tt">dstVectorType</span> under the semantics of the <span class="tt">vector.broadcast</span> op. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acfee45e655b185bd625e2f7994dc2c50a505a83f220c02df2f85c3810cd9ceb38" name="acfee45e655b185bd625e2f7994dc2c50a505a83f220c02df2f85c3810cd9ceb38"></a>Success&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acfee45e655b185bd625e2f7994dc2c50ac76fd47e5afe8e699733f0b655854c5a" name="acfee45e655b185bd625e2f7994dc2c50ac76fd47e5afe8e699733f0b655854c5a"></a>SourceRankHigher&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acfee45e655b185bd625e2f7994dc2c50a2664c241558d7674e8ed4d5f63d2e463" name="acfee45e655b185bd625e2f7994dc2c50a2664c241558d7674e8ed4d5f63d2e463"></a>DimensionMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acfee45e655b185bd625e2f7994dc2c50a578636e914af1c61d9d43b36a2076248" name="acfee45e655b185bd625e2f7994dc2c50a578636e914af1c61d9d43b36a2076248"></a>SourceTypeNotAVector&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="VectorOps_8h_source.html#l00072">72</a> of file <a class="el" href="VectorOps_8h_source.html">VectorOps.h</a>.</p>

</div>
</div>
<a id="a4ba6d4a825dbd36205be5322733056ef" name="a4ba6d4a825dbd36205be5322733056ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba6d4a825dbd36205be5322733056ef">&#9670;&#160;</a></span>ConstantMaskKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a4ba6d4a825dbd36205be5322733056ef">mlir::vector::ConstantMaskKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predefined constant_mask kinds. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4ba6d4a825dbd36205be5322733056efa5a26d218c82b9e4168d67628ecb0a0d1" name="a4ba6d4a825dbd36205be5322733056efa5a26d218c82b9e4168d67628ecb0a0d1"></a>AllFalse&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4ba6d4a825dbd36205be5322733056efa822b19813c2556c566eec6864da1319f" name="a4ba6d4a825dbd36205be5322733056efa822b19813c2556c566eec6864da1319f"></a>AllTrue&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="VectorOps_8h_source.html#l00064">64</a> of file <a class="el" href="VectorOps_8h_source.html">VectorOps.h</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a2683abb4897d8bda306d12702ee2ca04" name="a2683abb4897d8bda306d12702ee2ca04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2683abb4897d8bda306d12702ee2ca04">&#9670;&#160;</a></span>buildTerminatedBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::buildTerminatedBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default callback to build a region with a 'vector.yield' terminator with no arguments. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00127">127</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

</div>
</div>
<a id="a3db9bda1f50ffdff9759b51bf49ddb86" name="a3db9bda1f50ffdff9759b51bf49ddb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db9bda1f50ffdff9759b51bf49ddb86">&#9670;&#160;</a></span>checkSameValueRAW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::vector::checkSameValueRAW </td>
          <td>(</td>
          <td class="paramtype">TransferWriteOp</td>          <td class="paramname"><span class="paramname"><em>defWrite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransferReadOp</td>          <td class="paramname"><span class="paramname"><em>read</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the transfer_write fully writes the data accessed by the transfer_read. </p>

</div>
</div>
<a id="a6f1125a16d0ba1e024d9b99d5b439a0a" name="a6f1125a16d0ba1e024d9b99d5b439a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1125a16d0ba1e024d9b99d5b439a0a">&#9670;&#160;</a></span>checkSameValueWAW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::vector::checkSameValueWAW </td>
          <td>(</td>
          <td class="paramtype">TransferWriteOp</td>          <td class="paramname"><span class="paramname"><em>write</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransferWriteOp</td>          <td class="paramname"><span class="paramname"><em>priorWrite</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the write op fully over-write the priorWrite transfer_write op. </p>

</div>
</div>
<a id="a555cfa7abe7f1b002abcfff16083f064" name="a555cfa7abe7f1b002abcfff16083f064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555cfa7abe7f1b002abcfff16083f064">&#9670;&#160;</a></span>createLowerVectorMaskPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::vector::createLowerVectorMaskPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the <span class="tt">vector.mask</span> lowering pass. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorMask_8cpp_source.html#l00310">310</a> of file <a class="el" href="LowerVectorMask_8cpp_source.html">LowerVectorMask.cpp</a>.</p>

</div>
</div>
<a id="a5379063f08515cc5aa200ed01a41ea95" name="a5379063f08515cc5aa200ed01a41ea95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5379063f08515cc5aa200ed01a41ea95">&#9670;&#160;</a></span>createLowerVectorMultiReductionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::vector::createLowerVectorMultiReductionPass </td>
          <td>(</td>
          <td class="paramtype">VectorMultiReductionLowering</td>          <td class="paramname"><span class="paramname"><em>option</em></span><span class="paramdefsep"> = </span><span class="paramdefval">VectorMultiReductionLowering::InnerParallel</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the <span class="tt">vector.multi_reduction</span> lowering pass. </p>

</div>
</div>
<a id="a4abad62f4d03b479cc3a2e598be744ad" name="a4abad62f4d03b479cc3a2e598be744ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4abad62f4d03b479cc3a2e598be744ad">&#9670;&#160;</a></span>createLowerVectorToFromElementsToShuffleTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::vector::createLowerVectorToFromElementsToShuffleTree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorToFromElementsToShuffleTree_8cpp_source.html#l00219">219</a> of file <a class="el" href="LowerVectorToFromElementsToShuffleTree_8cpp_source.html">LowerVectorToFromElementsToShuffleTree.cpp</a>.</p>

</div>
</div>
<a id="aa7388851d413b45a98d71682285ce817" name="aa7388851d413b45a98d71682285ce817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7388851d413b45a98d71682285ce817">&#9670;&#160;</a></span>createMaskOpRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::createMaskOpRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>maskableOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the vector.yield-ended region of a vector.mask op with <span class="tt">maskableOp</span> as masked operation. </p>

</div>
</div>
<a id="ab0bd96ceaaff937da9c8067138e02591" name="ab0bd96ceaaff937da9c8067138e02591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bd96ceaaff937da9c8067138e02591">&#9670;&#160;</a></span>createOrFoldDimOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::vector::createOrFoldDimOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function that creates a memref::DimOp or tensor::DimOp depending on the type of <span class="tt">source</span>. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00039">39</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="afad10ba2c08d9f9ffc2fbdd2bc562b36" name="afad10ba2c08d9f9ffc2fbdd2bc562b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad10ba2c08d9f9ffc2fbdd2bc562b36">&#9670;&#160;</a></span>createReadOrMaskedRead() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::vector::createReadOrMaskedRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inputVectorSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>padValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useInBoundsInsteadOfMasking</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classbool.html">bool</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inputScalableVecDims</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00319">319</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorUtils_8cpp_source.html#l00333">createReadOrMaskedRead()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="ac1f704d81959566caaf92245061960fb" name="ac1f704d81959566caaf92245061960fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f704d81959566caaf92245061960fb">&#9670;&#160;</a></span>createReadOrMaskedRead() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::vector::createReadOrMaskedRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;</td>          <td class="paramname"><span class="paramname"><em>vecToReadTy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>padValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useInBoundsInsteadOfMasking</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a TransferReadOp from <span class="tt">source</span>. </p>
<p>If the shape of vector to read differs from the shape of the value being read, masking is used to avoid out-of-bounds accesses. Set <span class="tt">useInBoundsInsteadOfMasking</span> to <span class="tt">true</span> to use the "in_bounds" attribute instead of explicit masks.</p>
<p>Note: all read offsets are set to 0. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00333">333</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="Builders_8cpp_source.html#l00053">mlir::Builder::getI1Type()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00077">mlir::memref::getMixedSizes()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00066">mlir::tensor::getMixedSizes()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="#a21bfcee9196fe1a2cfa548b7df8193a9">maskOperation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorUtils_8cpp_source.html#l00319">createReadOrMaskedRead()</a>.</p>

</div>
</div>
<a id="aabf889b1d187dae58df0a17542b919ad" name="aabf889b1d187dae58df0a17542b919ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf889b1d187dae58df0a17542b919ad">&#9670;&#160;</a></span>createUnrollIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1StaticTileOffsetRange.html">StaticTileOffsetRange</a> &gt; mlir::vector::createUnrollIterator </td>
          <td>(</td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>vType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>targetRank</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator for all positions in the leading dimensions of <span class="tt">vType</span> up to the <span class="tt">targetRank</span>. </p>
<p>If any leading dimension before the <span class="tt">targetRank</span> is scalable (so cannot be unrolled), it will return an iterator for positions up to the first scalable dimension.</p>
<p>If no leading dimensions can be unrolled an empty optional will be returned.</p>
<p>Examples:</p>
<p>For vType = <a class="el" href="namespacemlir_1_1vector.html">vector&lt;2x3x4&gt;</a> and targetRank = 1</p>
<p>The resulting iterator will yield: [0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2]</p>
<p>For vType = <a class="el" href="namespacemlir_1_1vector.html">vector&lt;3x[4]x5&gt;</a> and targetRank = 0</p>
<p>The scalable dimension blocks unrolling so the iterator yields only: [0], [1], [2] </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00276">276</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

</div>
</div>
<a id="ad09a4c24cd4f1765fa613e5f4d3cbeee" name="ad09a4c24cd4f1765fa613e5f4d3cbeee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09a4c24cd4f1765fa613e5f4d3cbeee">&#9670;&#160;</a></span>eliminateVectorMasks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::eliminateVectorMasks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IRRewriter.html">IRRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionOpInterface</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; VscaleRange &gt;</td>          <td class="paramname"><span class="paramname"><em>vscaleRange</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a vector.transfer operation into an in-bounds (i.e., no out-of-bounds masking) fastpath and a slowpath. </p>
<p>If <span class="tt">ifOp</span> is not null and the result is <span class="tt">success, the </span>ifOp<span class="tt"> points to the newly created conditional
/ upon function return. To accomodate for the fact that the original
/ vector.transfer indexing may be arbitrary and the slow path indexes
/ @[0...0] in the temporary buffer, the scf.if op returns a view and values
/ of type index. At this time, only vector.transfer_read case is
/ implemented.
/
/ Example (a 2-D vector.transfer_read):
/ </span><span class="tt">
/    %1 = vector.transfer_read %0[...], pad : memref&lt;A...&gt;, vector&lt;...&gt;
/ </span><span class="tt">
/ is transformed into:
/ </span><span class="tt">
/    %1:3 = scf.if (inBounds) {
/      // fastpath, direct cast
/      memref.cast A: memref&lt;A...&gt; to compatibleMemRefType
/      scf.yield view : compatibleMemRefType, index, index
/    } else {
/      // slowpath, not in-bounds vector.transfer or linalg.copy.
/      memref.cast alloc: memref&lt;B...&gt; to compatibleMemRefType
/      scf.yield %4 : compatibleMemRefType, index, index
}
/    %0 = vector.transfer_read %1#0[%1#1, %1#2] {in_bounds = [true ...
/    true]}
/ </span><span class="tt">
/ where </span>alloc<span class="tt"> is a top of the function alloca'ed buffer of one vector.
/
/ Preconditions:
/  1. </span>xferOp.permutation_map()<span class="tt"> must be a minor identity map
/  2. the rank of the </span>xferOp.memref()<span class="tt"> and the rank of the
/  </span>xferOp.vector()` must be equal. This will be relaxed in the future but / requires rank-reducing subviews. LogicalResult splitFullAndPartialTransfer( <a class="el" href="classmlir_1_1RewriterBase.html" title="This class coordinates the application of a rewrite on a set of IR, providing a way for clients to tr...">RewriterBase</a> &amp;b, VectorTransferOpInterface xferOp, <a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html" title="Structure to control the behavior of vector transform patterns.">VectorTransformsOptions</a> options = VectorTransformsOptions(), scf::IfOp *ifOp = nullptr);</p>
<p>/ Implements transfer op write to read forwarding and dead transfer write / optimizations. void transferOpflowOpt(RewriterBase &amp;rewriter, Operation *rootOp);</p>
<p>/ Cast away the leading unit dim, if exists, for the given contract op. / Return success if the transformation applies; return failure otherwise. FailureOr&lt;Value&gt; castAwayContractionLeadingOneDim(vector::ContractionOp contractOp,
                                 MaskingOpInterface maskingOp,
                                 RewriterBase &amp;rewriter);</p>
<p>Structure to hold the range of <span class="tt">vector.vscale</span>. struct VscaleRange { unsigned vscaleMin; unsigned vscaleMax; };</p>
<p>/ Attempts to eliminate redundant vector masks by replacing them with all-true / constants at the top of the function (which results in the masks folding / away). Note: Currently, this only runs for vector.create_mask ops and / requires <span class="tt">vscaleRange</span>. If <span class="tt">vscaleRange</span> is not provided this transform does nothing. This is because these redundant masks are much more likely for scalable code which requires memref/tensor dynamic sizes, whereas fixed-size code has static sizes, so simpler folds remove the masks. </p>

<p class="definition">Definition at line <a class="el" href="VectorMaskElimination_8cpp_source.html#l00095">95</a> of file <a class="el" href="VectorMaskElimination_8cpp_source.html">VectorMaskElimination.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="af32acdf7a602e7b76f6784237c2f2fa2" name="af32acdf7a602e7b76f6784237c2f2fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32acdf7a602e7b76f6784237c2f2fa2">&#9670;&#160;</a></span>getAsIntegers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::vector::getAsIntegers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>foldResults</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the integer numbers in <span class="tt">foldResults</span>. </p>
<p><span class="tt">foldResults</span> are expected to be constant operations. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00358">358</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

</div>
</div>
<a id="a817b87f0647b2d105ddb4ee8331c6e74" name="a817b87f0647b2d105ddb4ee8331c6e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817b87f0647b2d105ddb4ee8331c6e74">&#9670;&#160;</a></span>getAsIntegers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::vector::getAsIntegers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the integer numbers in <span class="tt">values</span>. </p>
<p><span class="tt">values</span> are expected to be constant operations. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00346">346</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>.</p>

</div>
</div>
<a id="ab5c8f18ea2cde21d5f5585fe430d0494" name="ab5c8f18ea2cde21d5f5585fe430d0494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c8f18ea2cde21d5f5585fe430d0494">&#9670;&#160;</a></span>getAsValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::vector::getAsValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>foldResults</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <span class="tt">foldResults</span> into Values. </p>
<p>Integer attributes are converted to constant op. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00370">370</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>.</p>

</div>
</div>
<a id="a30a2f31604d067d92eed03a981b27cc5" name="a30a2f31604d067d92eed03a981b27cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a2f31604d067d92eed03a981b27cc5">&#9670;&#160;</a></span>getConstantVscaleMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::vector::getConstantVscaleMultiplier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <span class="tt">value</span> is a constant multiple of <span class="tt">vector.vscale</span> (e.g. </p>
<p><span class="tt">cst *
/ vector.vscale</span>), return the multiplier (<span class="tt">cst</span>). Otherwise, return <span class="tt">std::nullopt</span>. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00385">385</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="XeGPUDialect_8cpp_source.html#l00972">mul</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="a2a96bb3f0e3f37f46743b34436f7b14d" name="a2a96bb3f0e3f37f46743b34436f7b14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a96bb3f0e3f37f46743b34436f7b14d">&#9670;&#160;</a></span>getDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::vector::getDims </td>
          <td>(</td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>vType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range over the dims (size and scalability) of a VectorType. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8h_source.html#l00130">130</a> of file <a class="el" href="VectorUtils_8h_source.html">VectorUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l02033">DropUnitDimsFromTransposeOp::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ad910c130857e946d9d30b58ffb708f3a" name="ad910c130857e946d9d30b58ffb708f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad910c130857e946d9d30b58ffb708f3a">&#9670;&#160;</a></span>getMixedSizesXfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::vector::getMixedSizesXfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>hasTensorSemantics</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>xfer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapper for getMixedSizes for vector.transfer_read and vector.transfer_write Ops (for source and destination, respectively). </p>
<p>Tensor and MemRef types implement their own, very similar version of getMixedSizes. This method will call the appropriate version (depending on <span class="tt">hasTensorSemantics</span>). It will also automatically extract the operand for which to call it on (source for "read" and destination for "write" ops). </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00298">298</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00077">mlir::memref::getMixedSizes()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l00066">mlir::tensor::getMixedSizes()</a>.</p>

</div>
</div>
<a id="a3221aacef9029612ded6c1d7bef1791c" name="a3221aacef9029612ded6c1d7bef1791c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3221aacef9029612ded6c1d7bef1791c">&#9670;&#160;</a></span>getTransferMinorIdentityMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::vector::getTransferMinorIdentityMap </td>
          <td>(</td>
          <td class="paramtype">ShapedType</td>          <td class="paramname"><span class="paramname"><em>shapedType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>vectorType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the default minor identity map suitable for a vector transfer. </p>
<p>This also handles the case <a class="el" href="namespacemlir_1_1memref.html">memref&lt;... x vector&lt;...&gt;&gt;</a> -&gt; <a class="el" href="namespacemlir_1_1vector.html">vector&lt;...&gt;</a> in which the rank of the identity map must take the vector element type into account. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00189">189</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00179">getEffectiveVectorRankForXferOp()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00131">mlir::AffineMap::getMinorIdentityMap()</a>.</p>

</div>
</div>
<a id="abf88d2bf2999298f815f0bc9ba05f2a4" name="abf88d2bf2999298f815f0bc9ba05f2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf88d2bf2999298f815f0bc9ba05f2a4">&#9670;&#160;</a></span>getVectorReductionOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::vector::getVectorReductionOp </td>
          <td>(</td>
          <td class="paramtype">arith::AtomicRMWKind</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value obtained by reducing the vector into a scalar using the operation kind associated with a binary AtomicRMWKind op. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00684">684</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00499">mlir::emitOptionalError()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01332">vectorizeAffineForOp()</a>.</p>

</div>
</div>
<a id="a0499bcd00b867b4665ddf0c939543cfb" name="a0499bcd00b867b4665ddf0c939543cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0499bcd00b867b4665ddf0c939543cfb">&#9670;&#160;</a></span>getVectorSubscriptAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> mlir::vector::getVectorSubscriptAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an integer array attribute containing the given values using the integer type required for subscripts in the vector dialect. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00508">508</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00281">mlir::Builder::getI64ArrayAttr()</a>.</p>

</div>
</div>
<a id="ae3cb3b0a7edef27b564ca0603fedec4a" name="ae3cb3b0a7edef27b564ca0603fedec4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cb3b0a7edef27b564ca0603fedec4a">&#9670;&#160;</a></span>getVectorSubscriptType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntegerType mlir::vector::getVectorSubscriptType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the integer type required for subscripts in the vector dialect. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00504">504</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00067">mlir::Builder::getIntegerType()</a>.</p>

</div>
</div>
<a id="a561e2afa7c375df7a7dffe273c38b8de" name="a561e2afa7c375df7a7dffe273c38b8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561e2afa7c375df7a7dffe273c38b8de">&#9670;&#160;</a></span>inferTransferOpMaskType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType mlir::vector::inferTransferOpMaskType </td>
          <td>(</td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>vecType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>permMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infers the mask type for a transfer op given its vector type and permutation map. </p>
<p>The mask in a transfer op operation applies to the tensor/buffer part of it and its type should match the vector shape <em>before</em> any permutation or broadcasting. For example,</p>
<p>vecType = <a class="el" href="namespacemlir_1_1vector.html">vector&lt;1x2x3xf32&gt;</a>, permMap = affine_map&lt;(d0, d1, d2) -&gt; (d1, d0)&gt;</p>
<p>Has inferred mask type:</p>
<p>maskType = <a class="el" href="namespacemlir_1_1vector.html">vector&lt;2x1xi1&gt;</a> </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l04823">4823</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00675">mlir::applyPermutationMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">mlir::AffineMap::compose()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00715">mlir::compressUnusedDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>.</p>

</div>
</div>
<a id="a5150a3f7aa4857a1863bd10fb551442a" name="a5150a3f7aa4857a1863bd10fb551442a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5150a3f7aa4857a1863bd10fb551442a">&#9670;&#160;</a></span>isBroadcastableTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acfee45e655b185bd625e2f7994dc2c50">BroadcastableToResult</a> mlir::vector::isBroadcastableTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>srcType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>dstVectorType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; <a class="el" href="structmlir_1_1vector_1_1VectorDim.html">VectorDim</a>, <a class="el" href="structmlir_1_1vector_1_1VectorDim.html">VectorDim</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>mismatchingDims</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l02924">2924</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorOps_8h_source.html#l00075">DimensionMismatch</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00023">mlir::getElementTypeOrSelf()</a>, <a class="el" href="VectorOps_8h_source.html#l00074">SourceRankHigher</a>, <a class="el" href="VectorOps_8h_source.html#l00076">SourceTypeNotAVector</a>, and <a class="el" href="VectorOps_8h_source.html#l00073">Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00685">broadcastIfNeeded()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l03004">foldBroadcastOfShapeCast()</a>.</p>

</div>
</div>
<a id="a2098102a54883ea02ee203ebabb4012e" name="a2098102a54883ea02ee203ebabb4012e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2098102a54883ea02ee203ebabb4012e">&#9670;&#160;</a></span>isContiguousSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::vector::isContiguousSlice </td>
          <td>(</td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>memrefType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>vectorType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if <span class="tt">vectorType</span> is a contiguous slice of <span class="tt">memrefType</span>, in the sense that it can be read/written from/to a contiguous area of the memref. </p>
<p>The leading unit dimensions of the vector type are ignored as they are not relevant to the result. Let N be the number of the vector dimensions after ignoring a leading sequence of unit ones.</p>
<p>For <span class="tt">vectorType</span> to be a contiguous slice of <span class="tt">memrefType</span> a) the N trailing dimensions of <span class="tt">memrefType</span> must be contiguous, and b) the N-1 trailing dimensions of <span class="tt">vectorType</span> and <span class="tt">memrefType</span> must match.</p>
<p>Examples:</p>
<p>Ex.1 contiguous slice, perfect match <a class="el" href="namespacemlir_1_1vector.html">vector&lt;4x3x2xi32&gt;</a> from <a class="el" href="namespacemlir_1_1memref.html">memref&lt;5x4x3x2xi32&gt;</a> Ex.2 contiguous slice, the leading dim does not match (2 != 4) <a class="el" href="namespacemlir_1_1vector.html">vector&lt;2x3x2xi32&gt;</a> from <a class="el" href="namespacemlir_1_1memref.html">memref&lt;5x4x3x2xi32&gt;</a> Ex.3 non-contiguous slice, 2 != 3 <a class="el" href="namespacemlir_1_1vector.html">vector&lt;2x2x2xi32&gt;</a> from <a class="el" href="namespacemlir_1_1memref.html">memref&lt;5x4x3x2xi32&gt;</a> Ex.4 contiguous slice, leading unit dimension of the vector ignored, 2 != 3 (allowed) <a class="el" href="namespacemlir_1_1vector.html">vector&lt;1x2x2xi32&gt;</a> from <a class="el" href="namespacemlir_1_1memref.html">memref&lt;5x4x3x2xi32&gt;</a> Ex.5. contiguous slice, leading two unit dims of the vector ignored, 2 != 3 (allowed) <a class="el" href="namespacemlir_1_1vector.html">vector&lt;1x1x2x2xi32&gt;</a> from <a class="el" href="namespacemlir_1_1memref.html">memref&lt;5x4x3x2xi32&gt;</a> Ex.6. non-contiguous slice, 2 != 3, no leading sequence of unit dims <a class="el" href="namespacemlir_1_1vector.html">vector&lt;2x1x2x2xi32&gt;</a> from <a class="el" href="namespacemlir_1_1memref.html">memref&lt;5x4x3x2xi32&gt;</a>) Ex.7 contiguous slice, memref needs to be contiguous only in the last dimension <a class="el" href="namespacemlir_1_1vector.html">vector&lt;1x1x2xi32&gt;</a> from <a class="el" href="namespacemlir_1_1memref.html">memref&lt;2x2x2xi32, strided&lt;[8, 4, 1]&gt;&gt;</a> Ex.8 non-contiguous slice, memref needs to be contiguous in the last two dimensions, and it isn't <a class="el" href="namespacemlir_1_1vector.html">vector&lt;1x2x2xi32&gt;</a> from <a class="el" href="namespacemlir_1_1memref.html">memref&lt;2x2x2xi32, strided&lt;[8, 4, 1]&gt;&gt;</a> </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00255">255</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="PolynomialApproximation_8cpp_source.html#l00047">vectorShape()</a>.</p>

</div>
</div>
<a id="a5fd4b030a7ece80ee86e9b6c41895b82" name="a5fd4b030a7ece80ee86e9b6c41895b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd4b030a7ece80ee86e9b6c41895b82">&#9670;&#160;</a></span>isDisjointTransferIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::vector::isDisjointTransferIndices </td>
          <td>(</td>
          <td class="paramtype">VectorTransferOpInterface</td>          <td class="paramname"><span class="paramname"><em>transferA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorTransferOpInterface</td>          <td class="paramname"><span class="paramname"><em>transferB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>testDynamicValueUsingBounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if we can prove that the transfer operations access disjoint memory, without requring the accessed tensor/memref to be the same. </p>
<p>If <span class="tt">testDynamicValueUsingBounds</span> is true, tries to test dynamic values via ValueBoundsOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00251">251</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00821">mlir::ValueBoundsConstraintSet::areEqual()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00676">mlir::ValueBoundsConstraintSet::computeConstantDelta()</a>, <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00169">mlir::affine::fullyComposeAndComputeConstantDelta()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00315">isDisjointTransferSet()</a>.</p>

</div>
</div>
<a id="a629666d1e621e7ad850d28cecd82a263" name="a629666d1e621e7ad850d28cecd82a263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629666d1e621e7ad850d28cecd82a263">&#9670;&#160;</a></span>isDisjointTransferSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::vector::isDisjointTransferSet </td>
          <td>(</td>
          <td class="paramtype">VectorTransferOpInterface</td>          <td class="paramname"><span class="paramname"><em>transferA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorTransferOpInterface</td>          <td class="paramname"><span class="paramname"><em>transferB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>testDynamicValueUsingBounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if we can prove that the transfer operations access disjoint memory, requiring the operations to access the same tensor/memref. </p>
<p>If <span class="tt">testDynamicValueUsingBounds</span> is true, tries to test dynamic values via ValueBoundsOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00315">315</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorOps_8cpp_source.html#l00251">isDisjointTransferIndices()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Hoisting_8cpp_source.html#l00198">mlir::linalg::hoistRedundantVectorTransfers()</a>.</p>

</div>
</div>
<a id="abdf9a8c7b9a914162f597bc6d1aa0633" name="abdf9a8c7b9a914162f597bc6d1aa0633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf9a8c7b9a914162f597bc6d1aa0633">&#9670;&#160;</a></span>isLinearizableVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::vector::isLinearizableVector </td>
          <td>(</td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the input <a class="el" href="structVector.html">Vector</a> type can be linearized. </p>
<p>Linearization is meant in the sense of flattening vectors, e.g.:</p><ul>
<li><a class="el" href="namespacemlir_1_1vector.html">vector&lt;NxMxKxi32&gt;</a> -&gt; <a class="el" href="namespacemlir_1_1vector.html">vector&lt;N*M*Kxi32&gt;</a> In this sense, Vectors that are either:</li>
<li>already linearized, or</li>
<li>contain more than 1 scalable dimensions, are not linearizable. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00315">315</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

</div>
</div>
<a id="a75d40ea32eb46ab63ab75c1b568ce4ef" name="a75d40ea32eb46ab63ab75c1b568ce4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d40ea32eb46ab63ab75c1b568ce4ef">&#9670;&#160;</a></span>isParallelIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::vector::isParallelIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <span class="tt">attr</span> has "parallel" iterator type semantics. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8h_source.html#l00151">151</a> of file <a class="el" href="VectorOps_8h_source.html">VectorOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToGPU_8cpp_source.html#l00072">contractSupportsMMAMatrixType()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00182">gpuMmaUnrollOrder()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l01736">CanonicalizeContractMatmulToMMT::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a2393c85f5a124d20d5299d422b29a140" name="a2393c85f5a124d20d5299d422b29a140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2393c85f5a124d20d5299d422b29a140">&#9670;&#160;</a></span>isReductionIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::vector::isReductionIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td>          <td class="paramname"><span class="paramname"><em>attr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <span class="tt">attr</span> has "reduction" iterator type semantics. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8h_source.html#l00156">156</a> of file <a class="el" href="VectorOps_8h_source.html">VectorOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToGPU_8cpp_source.html#l00072">contractSupportsMMAMatrixType()</a>, <a class="el" href="LowerVectorContract_8cpp_source.html#l00164">getReductionIndex()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00182">gpuMmaUnrollOrder()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l01736">CanonicalizeContractMatmulToMMT::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a87dd4973a2bd2cac230734188a21c995" name="a87dd4973a2bd2cac230734188a21c995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87dd4973a2bd2cac230734188a21c995">&#9670;&#160;</a></span>isTranspose2DSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; std::pair&lt; int, int &gt; &gt; mlir::vector::isTranspose2DSlice </td>
          <td>(</td>
          <td class="paramtype">vector::TransposeOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns two dims that are greater than one if the transposition is applied on a 2D slice. </p>
<p>Otherwise, returns a failure. </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00082">82</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorUtils_8cpp_source.html#l00066">areDimsTransposedIn2DSlice()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AVXTranspose_8cpp_source.html#l00216">TransposeOpLowering::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a341516a4c95139534df7b424b2de2598" name="a341516a4c95139534df7b424b2de2598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341516a4c95139534df7b424b2de2598">&#9670;&#160;</a></span>isValidMaskedInputVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::vector::isValidMaskedInputVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inputVectorSizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if <span class="tt">inputVectorSizes</span> is a valid masking configuraion for given <span class="tt">shape</span>, i.e., it meets: </p>
<ol type="1">
<li>The numbers of elements in both array are equal.</li>
<li><span class="tt">inputVectorSizes</span> does not have dynamic dimensions.</li>
<li>All the values in <span class="tt">inputVectorSizes</span> are greater than or equal to static sizes in <span class="tt">shape</span>. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00387">387</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a015472323cadf1a87aa5281a682eb0b9" name="a015472323cadf1a87aa5281a682eb0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015472323cadf1a87aa5281a682eb0b9">&#9670;&#160;</a></span>makeArithReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::vector::makeArithReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CombiningKind</td>          <td class="paramname"><span class="paramname"><em>kind</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>acc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arith::FastMathFlagsAttr</td>          <td class="paramname"><span class="paramname"><em>fastmath</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result value of reducing two scalar/vector values with the corresponding arith operation. </p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerVectorContract_8cpp_source.html#l00124">createContractArithOp()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02202">BreakDownVectorReduction::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ad0a5584142f33c4a2887d2e3131f7565" name="ad0a5584142f33c4a2887d2e3131f7565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a5584142f33c4a2887d2e3131f7565">&#9670;&#160;</a></span>makeVscaleConstantBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::vector::makeVscaleConstantBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a functor (<a class="el" href="classint64__t.html">int64_t</a> -&gt; <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>) which returns a constant vscale multiple. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> createVscaleMultiple = <a class="code hl_function" href="#ad0a5584142f33c4a2887d2e3131f7565">makeVscaleConstantBuilder</a>(rewriter, loc);</div>
<div class="line"><span class="keyword">auto</span> c4Vscale = createVscaleMultiple(4); <span class="comment">// 4 * vector.vscale</span></div>
<div class="ttc" id="anamespacemlir_1_1vector_html_ad0a5584142f33c4a2887d2e3131f7565"><div class="ttname"><a href="#ad0a5584142f33c4a2887d2e3131f7565">mlir::vector::makeVscaleConstantBuilder</a></div><div class="ttdeci">auto makeVscaleConstantBuilder(PatternRewriter &amp;rewriter, Location loc)</div><div class="ttdoc">Returns a functor (int64_t -&gt; Value) which returns a constant vscale multiple.</div><div class="ttdef"><b>Definition</b> <a href="VectorUtils_8h_source.html#l00118">VectorUtils.h:118</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="VectorUtils_8h_source.html#l00118">118</a> of file <a class="el" href="VectorUtils_8h_source.html">VectorUtils.h</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>.</p>

</div>
</div>
<a id="a21bfcee9196fe1a2cfa548b7df8193a9" name="a21bfcee9196fe1a2cfa548b7df8193a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bfcee9196fe1a2cfa548b7df8193a9">&#9670;&#160;</a></span>maskOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::vector::maskOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>maskableOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>passthru</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classmlir_1_1Value.html">Value</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector.mask operation around a maskable operation. </p>
<p>Returns the vector.mask operation if the mask provided is valid. Otherwise, returns the maskable operation itself. </p>

<p class="reference">Referenced by <a class="el" href="VectorUtils_8cpp_source.html#l00333">createReadOrMaskedRead()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00512">VectorizationState::maskOperation()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01166">vectorizeTensorExtract()</a>.</p>

</div>
</div>
<a id="a5f9beecd0d699bde9c3912943c0f3b13" name="a5f9beecd0d699bde9c3912943c0f3b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9beecd0d699bde9c3912943c0f3b13">&#9670;&#160;</a></span>populateDropInnerMostUnitDimsXferOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateDropInnerMostUnitDimsXferOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to collapse the most inner unit dims in xfer Ops. </p>
<p>These patters reduce the rank of the operands of vector transfer ops to operate on vectors without trailing unit dims. This helps reduce the rank of the operands, which can be helpful when lowering to dialects that only support 1D vector type such as <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02372">2372</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a2bc60b182ad08ffab9aa924a74e78129" name="a2bc60b182ad08ffab9aa924a74e78129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc60b182ad08ffab9aa924a74e78129">&#9670;&#160;</a></span>populateElementwiseToVectorOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateElementwiseToVectorOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns that fold elementwise op on vectors to the vector dialect. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02407">2407</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a7ec9916655c82acca22bdeb882303f0f" name="a7ec9916655c82acca22bdeb882303f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec9916655c82acca22bdeb882303f0f">&#9670;&#160;</a></span>populateFoldArithExtensionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateFoldArithExtensionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns that fold arithmetic extension on floating point into vector contract for the backends with native support. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02319">2319</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="aa279bf22c17b61f1bf71e434dce3f158" name="aa279bf22c17b61f1bf71e434dce3f158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa279bf22c17b61f1bf71e434dce3f158">&#9670;&#160;</a></span>populateScalarVectorTransferLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateScalarVectorTransferLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>allowMultipleUses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects patterns that lower scalar vector transfer ops to memref loads and stores when beneficial. </p>
<p>If <span class="tt">allowMultipleUses</span> is set to true, the patterns are applied to vector transfer reads with any number of uses. Otherwise, only vector transfer reads with a single use will be lowered. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l01148">1148</a> of file <a class="el" href="VectorTransferOpTransforms_8cpp_source.html">VectorTransferOpTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a848e82989f2072855d837185e7e7694a" name="a848e82989f2072855d837185e7e7694a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848e82989f2072855d837185e7e7694a">&#9670;&#160;</a></span>populateSinkVectorOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateSinkVectorOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns that remove redundant <a class="el" href="structVector.html">Vector</a> Ops by re-ordering them with e.g. </p>
<p>elementwise Ops: </p><div class="fragment"><div class="line">%at = <a class="code hl_namespace" href="namespacemlir_1_1vector.html">vector</a>.transpose %a, [1, 0]: <a class="code hl_namespace" href="namespacemlir_1_1vector.html">vector&lt;4x2xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1vector.html">vector&lt;2x4xf32&gt;</a></div>
<div class="line">%bt = <a class="code hl_namespace" href="namespacemlir_1_1vector.html">vector</a>.transpose %<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, [1, 0]: <a class="code hl_namespace" href="namespacemlir_1_1vector.html">vector&lt;4x2xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1vector.html">vector&lt;2x4xf32&gt;</a></div>
<div class="line">%r = <a class="code hl_namespace" href="namespacemlir_1_1arith.html">arith</a>.addf %at, %bt : <a class="code hl_namespace" href="namespacemlir_1_1vector.html">vector&lt;2x4xf32&gt;</a></div>
<div class="ttc" id="aLinalgTransformOps_8cpp_html_a21ad0bd836b90d08f4cf640b4c298e7c"><div class="ttname"><a href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a></div><div class="ttdeci">b</div><div class="ttdoc">Return true if permutation is a valid permutation of the outer_dims_perm (case OuterOrInnerPerm::Oute...</div><div class="ttdef"><b>Definition</b> <a href="LinalgTransformOps_8cpp_source.html#l02097">LinalgTransformOps.cpp:2097</a></div></div>
<div class="ttc" id="anamespacemlir_1_1arith_html"><div class="ttname"><a href="namespacemlir_1_1arith.html">mlir::arith</a></div><div class="ttdef"><b>Definition</b> <a href="ArithCommon_2AttrToLLVMConverter_8h_source.html#l00020">AttrToLLVMConverter.h:20</a></div></div>
<div class="ttc" id="anamespacemlir_1_1vector_html"><div class="ttname"><a href="namespacemlir_1_1vector.html">mlir::vector</a></div><div class="ttdef"><b>Definition</b> <a href="ConvertVectorToLLVM_8h_source.html#l00022">ConvertVectorToLLVM.h:22</a></div></div>
</div><!-- fragment --><p> gets converted to: </p><div class="fragment"><div class="line">%0 = <a class="code hl_namespace" href="namespacemlir_1_1arith.html">arith</a>.addf %a, %<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a> : <a class="code hl_namespace" href="namespacemlir_1_1vector.html">vector&lt;4x2xf32&gt;</a></div>
<div class="line">%r = <a class="code hl_namespace" href="namespacemlir_1_1vector.html">vector</a>.transpose %0, [1, 0] : <a class="code hl_namespace" href="namespacemlir_1_1vector.html">vector&lt;2x4xf32&gt;</a></div>
</div><!-- fragment --><p> At the moment, these patterns are limited to vector.broadcast and vector.transpose. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02379">2379</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a8cad1ef496d64e01a0d7aaa62432e1d9" name="a8cad1ef496d64e01a0d7aaa62432e1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cad1ef496d64e01a0d7aaa62432e1d9">&#9670;&#160;</a></span>populateVectorBitCastLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorBitCastLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>targetRank</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the pattern set with the following patterns: </p>
<p>[UnrollBitCastOp] A one-shot unrolling of BitCastOp to (one or more) ExtractOp + BitCastOp (of <span class="tt">targetRank</span>) + InsertOp. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorBitCast_8cpp_source.html#l00087">87</a> of file <a class="el" href="LowerVectorBitCast_8cpp_source.html">LowerVectorBitCast.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a88033aae0cb3a6e60cbca725c347676f" name="a88033aae0cb3a6e60cbca725c347676f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88033aae0cb3a6e60cbca725c347676f">&#9670;&#160;</a></span>populateVectorBroadcastLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorBroadcastLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[TransferReadToVectorLoadLowering] Progressive lowering of BroadcastOp to ExtractOp + InsertOp + lower-D BroadcastOp until dim 1. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorBroadcast_8cpp_source.html#l00145">145</a> of file <a class="el" href="LowerVectorBroadcast_8cpp_source.html">LowerVectorBroadcast.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a8461b000c4283d776959689802a7dea7" name="a8461b000c4283d776959689802a7dea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8461b000c4283d776959689802a7dea7">&#9670;&#160;</a></span>populateVectorContractCanonicalizeMatmulToMMT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorContractCanonicalizeMatmulToMMT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; LogicalResult(vector::ContractionOp)&gt;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span><span class="paramdefsep"> = </span><span class="paramdefval">[](vector::ContractionOp)&#160;{&#160;return&#160;<a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success</a>();&#160;}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalization of a <span class="tt">vector.contraction a, b, c</span> with row-major matmul semantics to a contraction with MMT semantics (matrix matrix multiplication with the RHS transposed). </p>
<p>This specific form is meant to have the vector operands are organized such that the reduction dimension is contiguous. Example: </p><div class="fragment"><div class="line"><a class="code hl_namespace" href="namespacemlir_1_1vector.html">vector</a>.contract {indexing_maps = [affine_map&lt;(m, n, k) -&gt; (m, k)&gt;,</div>
<div class="line">                                  affine_map&lt;(m, n, k) -&gt; (n, k)&gt;,</div>
<div class="line">                                  affine_map&lt;(m, n, k) -&gt; (m, n)&gt;],</div>
<div class="line">                 iterator_types = [<span class="stringliteral">&quot;parallel&quot;</span>, <span class="stringliteral">&quot;parallel&quot;</span>, <span class="stringliteral">&quot;reduction&quot;</span>],</div>
<div class="line">                 kind = #<a class="code hl_namespace" href="namespacemlir_1_1vector.html">vector</a>.kind&lt;<a class="code hl_define" href="XeGPUDialect_8cpp.html#a1a14019f88db2a0b038688cd9830ea7e">add</a>&gt;} %a, %<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, %c : ...</div>
<div class="ttc" id="aXeGPUDialect_8cpp_html_a1a14019f88db2a0b038688cd9830ea7e"><div class="ttname"><a href="XeGPUDialect_8cpp.html#a1a14019f88db2a0b038688cd9830ea7e">add</a></div><div class="ttdeci">#define add(a, b)</div><div class="ttdef"><b>Definition</b> <a href="XeGPUDialect_8cpp_source.html#l00976">XeGPUDialect.cpp:976</a></div></div>
</div><!-- fragment --><p>The <span class="tt">constraint</span> predicate is used to decide which <span class="tt">vector.contraction</span> ops to filter out. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02357">2357</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToGPU_8cpp_source.html#l01229">mlir::populatePrepareVectorToMMAPatterns()</a>.</p>

</div>
</div>
<a id="ad9cfbb0f14dc6257ab43a4638ed9ef7d" name="ad9cfbb0f14dc6257ab43a4638ed9ef7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9cfbb0f14dc6257ab43a4638ed9ef7d">&#9670;&#160;</a></span>populateVectorContractLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorContractLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorContractLowering</td>          <td class="paramname"><span class="paramname"><em>vectorContractLoweringOption</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>disableOuterProductLowering</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[<a class="el" href="classOuterProductOpLowering.html" title="Progressive lowering of OuterProductOp.">OuterProductOpLowering</a>] Progressively lower a <span class="tt">vector.outerproduct</span> to linearized <span class="tt">vector.extract</span> + <span class="tt">vector.fma</span> + <span class="tt">vector.insert</span>.</p>
<p>[ContractionOpLowering] Progressive lowering of ContractionOp. One: x = vector.contract with at least one free/batch dimension is replaced by: a = vector.contract with one less free/batch dimension b = vector.contract with one less free/batch dimension</p>
<p>[ContractionOpToMatmulOpLowering] Progressively lower a <span class="tt">vector.contract</span> with row-major matmul semantics to linearized <span class="tt">vector.shape_cast</span> + <span class="tt">vector.matmul</span> on the way to <span class="tt">llvm.matrix.multiply</span>.</p>
<p>[ContractionOpToDotLowering] Progressively lower a <span class="tt">vector.contract</span> with row-major matmul semantics to linearized <span class="tt">vector.extract</span> + <span class="tt">vector.reduce</span> + <span class="tt">vector.insert</span>.</p>
<p>[ContractionOpToOuterProductOpLowering] Progressively lower a <span class="tt">vector.contract</span> with row-major matmul semantics to linearized <span class="tt">vector.extract</span> + <span class="tt">vector.outerproduct</span> + <span class="tt">vector.insert</span>. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorContract_8cpp_source.html#l01222">1222</a> of file <a class="el" href="LowerVectorContract_8cpp_source.html">LowerVectorContract.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a30b3fc1228086cc143e4a10253983e6f" name="a30b3fc1228086cc143e4a10253983e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b3fc1228086cc143e4a10253983e6f">&#9670;&#160;</a></span>populateVectorContractToMatrixMultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorContractToMatrixMultiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">100</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[ContractionOpToMatmulOpLowering] Lowers <span class="tt">vector.contract</span> to <span class="tt">llvm.intr.matrix.multiply</span>.</p>
<p>Given the high benefit, this will be prioriotised over other contract-lowering patterns. As such, the convert-vector-to-llvm pass will only run this registration conditionally. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l02187">2187</a> of file <a class="el" href="ConvertVectorToLLVM_8cpp_source.html">ConvertVectorToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a439f87d998fc217be9e760851e5c7a63" name="a439f87d998fc217be9e760851e5c7a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439f87d998fc217be9e760851e5c7a63">&#9670;&#160;</a></span>populateVectorGatherLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorGatherLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[UnrollGather] Unrolls 2 or more dimensional <span class="tt">vector.gather</span> ops by unrolling the outermost dimension. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorGather_8cpp_source.html#l00250">250</a> of file <a class="el" href="LowerVectorGather_8cpp_source.html">LowerVectorGather.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="af2838611f578daf6c4d441da9c20dded" name="af2838611f578daf6c4d441da9c20dded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2838611f578daf6c4d441da9c20dded">&#9670;&#160;</a></span>populateVectorGatherToConditionalLoadPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorGatherToConditionalLoadPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[Gather1DToConditionalLoads] Turns 1-d <span class="tt">vector.gather</span> into a scalarized sequence of <span class="tt">vector.loads</span> or <span class="tt">tensor.extract</span>s. To avoid out-of-bounds memory accesses, these loads/extracts are made conditional using <span class="tt">scf.if</span> ops. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorGather_8cpp_source.html#l00255">255</a> of file <a class="el" href="LowerVectorGather_8cpp_source.html">LowerVectorGather.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ad3c07e592cdd88b811669bd163b93378" name="ad3c07e592cdd88b811669bd163b93378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c07e592cdd88b811669bd163b93378">&#9670;&#160;</a></span>populateVectorInterleaveLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorInterleaveLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>targetRank</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[UnrollInterleaveOp] A one-shot unrolling of InterleaveOp to (one or more) ExtractOp + InterleaveOp (of <span class="tt">targetRank</span>) + InsertOp. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorInterleave_8cpp_source.html#l00185">185</a> of file <a class="el" href="LowerVectorInterleave_8cpp_source.html">LowerVectorInterleave.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a33e5072e435d0da63d65e437f724e246" name="a33e5072e435d0da63d65e437f724e246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e5072e435d0da63d65e437f724e246">&#9670;&#160;</a></span>populateVectorInterleaveToShufflePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorInterleaveToShufflePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LowerVectorInterleave_8cpp_source.html#l00191">191</a> of file <a class="el" href="LowerVectorInterleave_8cpp_source.html">LowerVectorInterleave.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a6d67a015516dec992613685a6bb1a20b" name="a6d67a015516dec992613685a6bb1a20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d67a015516dec992613685a6bb1a20b">&#9670;&#160;</a></span>populateVectorMaskedLoadStoreEmulationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorMaskedLoadStoreEmulationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[VectorMaskedLoadOpConverter] Turns vector.maskedload to scf.if + memref.load</p>
<p>[VectorMaskedStoreOpConverter] Turns vector.maskedstore to scf.if + memref.store </p>

<p class="definition">Definition at line <a class="el" href="VectorEmulateMaskedLoadStore_8cpp_source.html#l00163">163</a> of file <a class="el" href="VectorEmulateMaskedLoadStore_8cpp_source.html">VectorEmulateMaskedLoadStore.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ad2010f10ca9e7f5df4aed9571180e3c5" name="ad2010f10ca9e7f5df4aed9571180e3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2010f10ca9e7f5df4aed9571180e3c5">&#9670;&#160;</a></span>populateVectorMaskLoweringPatternsForSideEffectingOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorMaskLoweringPatternsForSideEffectingOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates instances of <span class="tt">MaskOpRewritePattern</span> to lower masked operations with <span class="tt">vector.mask</span>. </p>
<p>Patterns should rewrite the <span class="tt">vector.mask</span> operation and not its nested <span class="tt">MaskableOpInterface</span>. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorMask_8cpp_source.html#l00304">304</a> of file <a class="el" href="LowerVectorMask_8cpp_source.html">LowerVectorMask.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a9ec71309405318dd0ed6b2b31ded892c" name="a9ec71309405318dd0ed6b2b31ded892c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec71309405318dd0ed6b2b31ded892c">&#9670;&#160;</a></span>populateVectorMaskOpLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorMaskOpLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[CreateMaskOp] Progressive lowering of CreateMaskOp to lower-D CreateMaskOp until dim 1.</p>
<p>[ConstantMaskOp] Progressive lowering of ConstantMaskOp to lower-D ConstantMaskOp until dim 1. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorMask_8cpp_source.html#l00163">163</a> of file <a class="el" href="LowerVectorMask_8cpp_source.html">LowerVectorMask.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="aa136544741125dce255ad55a91f2067a" name="aa136544741125dce255ad55a91f2067a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa136544741125dce255ad55a91f2067a">&#9670;&#160;</a></span>populateVectorMultiReductionLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorMultiReductionLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorMultiReductionLowering</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert vector.multi_reduction op into a sequence of vector.reduction ops. </p>
<p>The patterns comprise:</p>
<p>[InnerOuterDimReductionConversion] Rewrites vector.multi_reduction such that all reduction dimensions are either innermost or outermost, by adding the proper vector.transpose operations.</p>
<p>[ReduceMultiDimReductionRank] Once in innermost or outermost reduction form, rewrites n-D vector.multi_reduction into 2-D vector.multi_reduction, by introducing vector.shape_cast ops to collapse + multi-reduce + expand back.</p>
<p>[TwoDimMultiReductionToElementWise] Once in 2-D vector.multi_reduction form, with an <b>outermost</b> reduction dimension, unroll the outer dimension to obtain a sequence of 1-D vector ops. This also has an opportunity for tree-reduction (in the future).</p>
<p>[TwoDimMultiReductionToReduction] Once in 2-D vector.multi_reduction form, with an <b>innermost</b> reduction dimension, unroll the outer dimension to obtain a sequence of extract + vector.reduction + insert. This can further lower to horizontal reduction ops.</p>
<p>[OneDimMultiReductionToTwoDim] For cases that reduce to 1-D <a class="el" href="namespacemlir_1_1vector.html">vector&lt;k&gt;</a> reduction (and are thus missing either a parallel or a reduction), we lift them back up to 2-D with a simple vector.shape_cast to <a class="el" href="namespacemlir_1_1vector.html">vector&lt;1xk&gt;</a> so that the other patterns can kick in, thus fully exiting out of the vector.multi_reduction abstraction. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorMultiReduction_8cpp_source.html#l00514">514</a> of file <a class="el" href="LowerVectorMultiReduction_8cpp_source.html">LowerVectorMultiReduction.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a991e613d3d19627fd75f7c874a8e0fad" name="a991e613d3d19627fd75f7c874a8e0fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991e613d3d19627fd75f7c874a8e0fad">&#9670;&#160;</a></span>populateVectorOuterProductLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorOuterProductLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[<a class="el" href="classOuterProductOpLowering.html" title="Progressive lowering of OuterProductOp.">OuterProductOpLowering</a>] Progressively lower a <span class="tt">vector.outerproduct</span> to linearized <span class="tt">vector.extract</span> + <span class="tt">vector.fma</span> + <span class="tt">vector.insert</span>. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorContract_8cpp_source.html#l01232">1232</a> of file <a class="el" href="LowerVectorContract_8cpp_source.html">LowerVectorContract.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a42d94532ec0a3cacf8cdd83e46d21a12" name="a42d94532ec0a3cacf8cdd83e46d21a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d94532ec0a3cacf8cdd83e46d21a12">&#9670;&#160;</a></span>populateVectorRankReducingFMAPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorRankReducingFMAPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates a pattern that rank-reduces n-D FMAs into (n-1)-D FMAs where n &gt; 1. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l02182">2182</a> of file <a class="el" href="ConvertVectorToLLVM_8cpp_source.html">ConvertVectorToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="aa2c39668001ee9e2ba767b172123f1d8" name="aa2c39668001ee9e2ba767b172123f1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c39668001ee9e2ba767b172123f1d8">&#9670;&#160;</a></span>populateVectorReductionToContractPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorReductionToContractPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect patterns to convert reduction op to vector.contract and fold transpose/broadcast ops into the contract. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02365">2365</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="afbc33a6788e2401e592cce83b6c68c42" name="afbc33a6788e2401e592cce83b6c68c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc33a6788e2401e592cce83b6c68c42">&#9670;&#160;</a></span>populateVectorScanLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorScanLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[ScanToArithOps] Convert vector.scan op into arith ops and vector.insert_strided_slice / vector.extract_strided_slice. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorScan_8cpp_source.html#l00191">191</a> of file <a class="el" href="LowerVectorScan_8cpp_source.html">LowerVectorScan.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a43189fd7073752a0dc3e3ac6274a1513" name="a43189fd7073752a0dc3e3ac6274a1513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43189fd7073752a0dc3e3ac6274a1513">&#9670;&#160;</a></span>populateVectorShapeCastLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorShapeCastLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[ShapeCastOp2DDownCastRewritePattern] ShapeOp 2D -&gt; 1D downcast serves the purpose of flattening 2-D to 1-D vectors progressively.</p>
<p>[ShapeCastOp2DUpCastRewritePattern] ShapeOp 1D -&gt; 2D upcast serves the purpose of unflattening 2-D from 1-D vectors progressively.</p>
<p>[ShapeCastOpRewritePattern] Reference lowering to fully unrolled sequences of single element ExtractOp + InsertOp. Note that applying this pattern can almost always be considered a performance bug. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorShapeCast_8cpp_source.html#l00472">472</a> of file <a class="el" href="LowerVectorShapeCast_8cpp_source.html">LowerVectorShapeCast.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVConversion_8cpp_source.html#l01491">mlir::spirv::unrollVectorsInFuncBodies()</a>.</p>

</div>
</div>
<a id="a12356bde7fa3274d54af5c6a88b6cd70" name="a12356bde7fa3274d54af5c6a88b6cd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12356bde7fa3274d54af5c6a88b6cd70">&#9670;&#160;</a></span>populateVectorShuffleLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorShuffleLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LowerVectorShuffle_8cpp_source.html#l00107">107</a> of file <a class="el" href="LowerVectorShuffle_8cpp_source.html">LowerVectorShuffle.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a497578d7dbc818d7fc96548403f76542" name="a497578d7dbc818d7fc96548403f76542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497578d7dbc818d7fc96548403f76542">&#9670;&#160;</a></span>populateVectorStepLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorStepLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[StepToArithConstantOp] Convert vector.step op into arith ops if not using scalable vectors </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorStep_8cpp_source.html#l00046">46</a> of file <a class="el" href="LowerVectorStep_8cpp_source.html">LowerVectorStep.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseVectorization_8cpp_source.html#l00682">mlir::populateSparseVectorizationPatterns()</a>.</p>

</div>
</div>
<a id="a5ba5aa7f7dff77008128f92410137dfe" name="a5ba5aa7f7dff77008128f92410137dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba5aa7f7dff77008128f92410137dfe">&#9670;&#160;</a></span>populateVectorToFromElementsToShuffleTreePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorToFromElementsToShuffleTreePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns to rewrite sequences of <span class="tt">vector.to_elements</span> + <span class="tt">vector.from_elements</span> operations into a tree of <span class="tt">vector.shuffle</span> operations. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorToFromElementsToShuffleTree_8cpp_source.html#l00740">740</a> of file <a class="el" href="LowerVectorToFromElementsToShuffleTree_8cpp_source.html">LowerVectorToFromElementsToShuffleTree.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a901dfffd46bc2f80e977fdea83adc180" name="a901dfffd46bc2f80e977fdea83adc180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901dfffd46bc2f80e977fdea83adc180">&#9670;&#160;</a></span>populateVectorToVectorCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorToVectorCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of vector-to-vector canonicalization patterns. </p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ac789257ecc17a3ca9c07a9178fb530a3" name="ac789257ecc17a3ca9c07a9178fb530a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac789257ecc17a3ca9c07a9178fb530a3">&#9670;&#160;</a></span>populateVectorTransferFullPartialPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorTransferFullPartialPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate <span class="tt">patterns</span> with the following patterns. </p>
<ul>
<li>VectorTransferFullPartialRewriter</li>
</ul>
<p>Split a vector.transfer operation into an in-bounds (i.e., no out-of-bounds masking) fast path and a slow path.</p>
<p>Example (a 2-D vector.transfer_read): </p><div class="fragment"><div class="line">%1 = <a class="code hl_namespace" href="namespacemlir_1_1vector.html">vector</a>.transfer_read %0[...], %pad : <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>&lt;A...&gt;, <a class="code hl_namespace" href="namespacemlir_1_1vector.html">vector</a>&lt;...&gt;</div>
<div class="ttc" id="anamespacemlir_1_1memref_html"><div class="ttname"><a href="namespacemlir_1_1memref.html">mlir::memref</a></div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Passes_8h_source.html#l00026">Passes.h:26</a></div></div>
</div><!-- fragment --><p> is transformed into: </p><div class="fragment"><div class="line">       %1:3 = <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.if (%inBounds) {</div>
<div class="line">         <span class="comment">// fast path, direct cast</span></div>
<div class="line">         <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>.cast %A: <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>&lt;A...&gt; to compatibleMemRefType</div>
<div class="line">         <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.yield %view : compatibleMemRefType, <a class="code hl_namespace" href="namespacemlir_1_1index.html">index</a>, <a class="code hl_namespace" href="namespacemlir_1_1index.html">index</a></div>
<div class="line">       } <span class="keywordflow">else</span> {</div>
<div class="line">         <span class="comment">// slow path, not in-bounds vector.transfer or linalg.copy.</span></div>
<div class="line">         <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>.cast %alloc: <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>&lt;B...&gt; to compatibleMemRefType</div>
<div class="line">         <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.yield %4 : compatibleMemRefType, <a class="code hl_namespace" href="namespacemlir_1_1index.html">index</a>, <a class="code hl_namespace" href="namespacemlir_1_1index.html">index</a> */</div>
<div class="line"><span class="comment">//     }</span><span class="comment"></span></div>
<div class="line"><span class="comment">/**    %0 = vector.transfer_read %1#0[%1#1, %1#2] {in_bounds = [true ... true]}</span></div>
<div class="ttc" id="anamespacemlir_1_1index_html"><div class="ttname"><a href="namespacemlir_1_1index.html">mlir::index</a></div><div class="ttdef"><b>Definition</b> <a href="IndexToLLVM_8h_source.html#l00023">IndexToLLVM.h:23</a></div></div>
<div class="ttc" id="anamespacemlir_1_1scf_html"><div class="ttname"><a href="namespacemlir_1_1scf.html">mlir::scf</a></div><div class="ttdef"><b>Definition</b> <a href="SCFToGPU_8h_source.html#l00024">SCFToGPU.h:24</a></div></div>
</div><!-- fragment --><p> where <span class="tt">alloc</span> is a top of the function alloca'ed buffer of one vector.</p>
<p>Preconditions:</p><ol type="1">
<li><span class="tt">xferOp.permutation_map()</span> must be a minor identity map</li>
<li>the rank of the <span class="tt">xferOp.memref()</span> and the rank of the <span class="tt">xferOp.vector()</span> must be equal. This will be relaxed in the future but requires rank-reducing subviews. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00661">661</a> of file <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html">VectorTransferSplitRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a4c2dd6fac5a93d9d6808bf8737db1cbb" name="a4c2dd6fac5a93d9d6808bf8737db1cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2dd6fac5a93d9d6808bf8737db1cbb">&#9670;&#160;</a></span>populateVectorTransferLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorTransferLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>maxTransferRank</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[TransferReadToVectorLoadLowering] Progressive lowering of transfer_read.This pattern supports lowering of <span class="tt">vector.transfer_read</span> to a combination of <span class="tt">vector.load</span> and <span class="tt">vector.broadcast</span></p>
<p>[TransferWriteToVectorStoreLowering] Progressive lowering of transfer_write. This pattern supports lowering of <span class="tt">vector.transfer_write</span> to <span class="tt">vector.store</span></p>
<p>These patterns lower transfer ops to simpler ops like <span class="tt">vector.load</span>, <span class="tt">vector.store</span> and <span class="tt">vector.broadcast</span>. Only transfers with a transfer rank of a most <span class="tt">maxTransferRank</span> are lowered. This is useful when combined with VectorToSCF, which reduces the rank of vector transfer ops. </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorTransfer_8cpp_source.html#l00585">585</a> of file <a class="el" href="LowerVectorTransfer_8cpp_source.html">LowerVectorTransfer.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a13c619a126f79a49fafb2f76bbc67606" name="a13c619a126f79a49fafb2f76bbc67606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c619a126f79a49fafb2f76bbc67606">&#9670;&#160;</a></span>populateVectorTransferPermutationMapLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorTransferPermutationMapLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of transfer read/write lowering patterns that simplify the permutation map (e.g., converting it to a minor identity map) by inserting broadcasts and transposes. </p>
<p>More specifically:</p>
<p>[TransferReadPermutationLowering] Lower transfer_read op with permutation into a transfer_read with a permutation map composed of leading zeros followed by a minor identity + vector.transpose op. Ex: vector.transfer_read ... permutation_map: (d0, d1, d2) -&gt; (0, d1) into: v = vector.transfer_read ... permutation_map: (d0, d1, d2) -&gt; (d1, 0) vector.transpose v, [1, 0]</p>
<p>vector.transfer_read ... permutation_map: (d0, d1, d2, d3) -&gt; (0, 0, 0, d1, d3) into: v = vector.transfer_read ... permutation_map: (d0, d1, d2, d3) -&gt; (0, 0, d1, 0, d3) vector.transpose v, [0, 1, 3, 2, 4] Note that an alternative is to transform it to linalg.transpose + vector.transfer_read to do the transpose in memory instead.</p>
<p>[TransferWritePermutationLowering] Lower transfer_write op with permutation into a transfer_write with a minor identity permutation map. (transfer_write ops cannot have broadcasts.) Ex: vector.transfer_write v ... permutation_map: (d0, d1, d2) -&gt; (d2, d0, d1) into: tmp = vector.transpose v, [2, 0, 1] vector.transfer_write tmp ... permutation_map: (d0, d1, d2) -&gt; (d0, d1, d2)</p>
<p>vector.transfer_write v ... permutation_map: (d0, d1, d2, d3) -&gt; (d3, d2) into: tmp = vector.transpose v, [1, 0] v = vector.transfer_write tmp ... permutation_map: (d0, d1, d2, d3) -&gt; (d2, d3)</p>
<p>[TransferOpReduceRank] Lower transfer_read op with broadcast in the leading dimensions into transfer_read of lower rank + vector.broadcast. Ex: vector.transfer_read ... permutation_map: (d0, d1, d2, d3) -&gt; (0, d1, 0, d3) into: v = vector.transfer_read ... permutation_map: (d0, d1, d2, d3) -&gt; (d1, 0, d3) vector.broadcast v </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorTransfer_8cpp_source.html#l00382">382</a> of file <a class="el" href="LowerVectorTransfer_8cpp_source.html">LowerVectorTransfer.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a6c0272615817f617a90ce4f9ff241562" name="a6c0272615817f617a90ce4f9ff241562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0272615817f617a90ce4f9ff241562">&#9670;&#160;</a></span>populateVectorTransposeLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorTransposeLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorTransposeLowering</td>          <td class="paramname"><span class="paramname"><em>vectorTransposeLowering</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[<a class="el" href="classTransposeOpLowering.html" title="Rewrite AVX2-specific vector.transpose, for the supported cases and depending on the TransposeLowerin...">TransposeOpLowering</a>]</p>
<p>[TransposeOp2DToShuffleLowering] </p>

<p class="definition">Definition at line <a class="el" href="LowerVectorTranspose_8cpp_source.html#l00494">494</a> of file <a class="el" href="LowerVectorTranspose_8cpp_source.html">LowerVectorTranspose.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVConversion_8cpp_source.html#l01491">mlir::spirv::unrollVectorsInFuncBodies()</a>.</p>

</div>
</div>
<a id="ab0f29d74a98439c7b729ddf7ab80e0cc" name="ab0f29d74a98439c7b729ddf7ab80e0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f29d74a98439c7b729ddf7ab80e0cc">&#9670;&#160;</a></span>populateVectorTransposeToFlatTranspose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateVectorTransposeToFlatTranspose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">100</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with the following patterns: </p>
<p>[<a class="el" href="classTransposeOpLowering.html" title="Rewrite AVX2-specific vector.transpose, for the supported cases and depending on the TransposeLowerin...">TransposeOpLowering</a>] Lowers <span class="tt">vector.transpose</span> to <span class="tt">llvm.intr.matrix.flat_transpose</span>.</p>
<p>Given the high benefit, this will be prioriotised over other transpose-lowering patterns. As such, the convert-vector-to-llvm pass will only run this registration conditionally. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l02192">2192</a> of file <a class="el" href="ConvertVectorToLLVM_8cpp_source.html">ConvertVectorToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a6c711eddaf2b505fc007762dc805ecf0" name="a6c711eddaf2b505fc007762dc805ecf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c711eddaf2b505fc007762dc805ecf0">&#9670;&#160;</a></span>populateWarpExecuteOnLane0OpToScfForPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::populateWarpExecuteOnLane0OpToScfForPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1vector_1_1WarpExecuteOnLane0LoweringOptions.html">WarpExecuteOnLane0LoweringOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorDistribute_8cpp_source.html#l02267">2267</a> of file <a class="el" href="VectorDistribute_8cpp_source.html">VectorDistribute.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a8c3d017bb3f90cb64c531e7b6a4b0606" name="a8c3d017bb3f90cb64c531e7b6a4b0606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3d017bb3f90cb64c531e7b6a4b0606">&#9670;&#160;</a></span>registerBufferizableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::registerBufferizableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vector_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l00379">379</a> of file <a class="el" href="Vector_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html">BufferizableOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a79b88f639bdf96c6e729d686a3c250f6" name="a79b88f639bdf96c6e729d686a3c250f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b88f639bdf96c6e729d686a3c250f6">&#9670;&#160;</a></span>registerConvertVectorToLLVMInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::registerConvertVectorToLLVMInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l02244">2244</a> of file <a class="el" href="ConvertVectorToLLVM_8cpp_source.html">ConvertVectorToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a68d0d59b96d753e959c25829370fbac6" name="a68d0d59b96d753e959c25829370fbac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d0d59b96d753e959c25829370fbac6">&#9670;&#160;</a></span>registerLowerVectorMaskPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::registerLowerVectorMaskPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Vector_2Transforms_2Passes_8h_source.html#l00236">236</a> of file <a class="el" href="Dialect_2Vector_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ad69211351808a6034694b97a318ee5bf" name="ad69211351808a6034694b97a318ee5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69211351808a6034694b97a318ee5bf">&#9670;&#160;</a></span>registerLowerVectorMaskPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::registerLowerVectorMaskPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Vector_2Transforms_2Passes_8h_source.html#l00243">243</a> of file <a class="el" href="Dialect_2Vector_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="af58efebfc0ab2f8aeba0995520ad3848" name="af58efebfc0ab2f8aeba0995520ad3848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58efebfc0ab2f8aeba0995520ad3848">&#9670;&#160;</a></span>registerLowerVectorMultiReduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::registerLowerVectorMultiReduction </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Vector_2Transforms_2Passes_8h_source.html#l00257">257</a> of file <a class="el" href="Dialect_2Vector_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ac11e4ba933d135e38891936729671d84" name="ac11e4ba933d135e38891936729671d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11e4ba933d135e38891936729671d84">&#9670;&#160;</a></span>registerLowerVectorMultiReductionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::registerLowerVectorMultiReductionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Vector_2Transforms_2Passes_8h_source.html#l00264">264</a> of file <a class="el" href="Dialect_2Vector_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a02803c804875d166658b06881153cfef" name="a02803c804875d166658b06881153cfef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02803c804875d166658b06881153cfef">&#9670;&#160;</a></span>registerLowerVectorToFromElementsToShuffleTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::registerLowerVectorToFromElementsToShuffleTree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Vector_2Transforms_2Passes_8h_source.html#l00278">278</a> of file <a class="el" href="Dialect_2Vector_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a83ab373b8dbbc7ce2ca3129bb3d24923" name="a83ab373b8dbbc7ce2ca3129bb3d24923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ab373b8dbbc7ce2ca3129bb3d24923">&#9670;&#160;</a></span>registerLowerVectorToFromElementsToShuffleTreePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::registerLowerVectorToFromElementsToShuffleTreePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Vector_2Transforms_2Passes_8h_source.html#l00285">285</a> of file <a class="el" href="Dialect_2Vector_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a5e106dc1b48251f4b3e11566df14078a" name="a5e106dc1b48251f4b3e11566df14078a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e106dc1b48251f4b3e11566df14078a">&#9670;&#160;</a></span>registerSubsetOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::registerSubsetOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SubsetOpInterfaceImpl_8cpp_source.html#l00070">70</a> of file <a class="el" href="SubsetOpInterfaceImpl_8cpp_source.html">SubsetOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a6867327b882d46f26e5f318a023508b9" name="a6867327b882d46f26e5f318a023508b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6867327b882d46f26e5f318a023508b9">&#9670;&#160;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorTransformOps_8cpp_source.html#l00257">257</a> of file <a class="el" href="VectorTransformOps_8cpp_source.html">VectorTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00222">mlir::DialectRegistry::addExtensions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="aa5d301133c3ac8bc64957d0a9eb7006a" name="aa5d301133c3ac8bc64957d0a9eb7006a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d301133c3ac8bc64957d0a9eb7006a">&#9670;&#160;</a></span>registerValueBoundsOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::registerValueBoundsOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vector_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00045">45</a> of file <a class="el" href="Vector_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a69d670386627a2a6ed18395d5e5e44b0" name="a69d670386627a2a6ed18395d5e5e44b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d670386627a2a6ed18395d5e5e44b0">&#9670;&#160;</a></span>registerVectorPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::vector::registerVectorPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Vector_2Transforms_2Passes_8h_source.html#l00299">299</a> of file <a class="el" href="Dialect_2Vector_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllPasses_8cpp_source.html#l00059">mlir::registerAllPasses()</a>.</p>

</div>
</div>
<a id="a5af92ace2e0cbd151cca52cf528a500a" name="a5af92ace2e0cbd151cca52cf528a500a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af92ace2e0cbd151cca52cf528a500a">&#9670;&#160;</a></span>selectPassthru()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::vector::selectPassthru </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>newValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>passthru</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector select operation that picks values from <span class="tt">newValue</span> or <span class="tt">passthru</span> for each result vector lane based on <span class="tt">mask</span>. </p>
<p>This utility is used to propagate the pass-thru value for masked-out or expeculatively executed lanes. VP intrinsics do not support pass-thru values and every mask-out lane is set to poison. <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> backends are usually able to match op + select patterns and fold them into a native target instructions. </p>

<p class="reference">Referenced by <a class="el" href="LowerVectorContract_8cpp_source.html#l00124">createContractArithOp()</a>.</p>

</div>
</div>
<a id="af60d532cb151ded3380cd20c91c455e5" name="af60d532cb151ded3380cd20c91c455e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60d532cb151ded3380cd20c91c455e5">&#9670;&#160;</a></span>unrollVectorOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::vector::unrollVectorOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad578b5a1c96b2e80475b10afd0866e7b">vector::UnrollVectorOpFn</a></td>          <td class="paramname"><span class="paramname"><em>unrollFn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00448">448</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00311">mlir::VectorType::Builder::dropDim()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a99ff81229d9b99dfd500fa7168382a6e" name="a99ff81229d9b99dfd500fa7168382a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ff81229d9b99dfd500fa7168382a6e">&#9670;&#160;</a></span>unrollVectorValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; mlir::vector::unrollVectorValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a864cb5eb1fea4a548c28cda535ba7213">TypedValue</a>&lt; VectorType &gt;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic utility for unrolling values of type <a class="el" href="namespacemlir_1_1vector.html">vector&lt;NxAxBx...&gt;</a> to N values of type <a class="el" href="namespacemlir_1_1vector.html">vector&lt;AxBx...&gt;</a> using vector.extract. </p>
<p>Takes a 2+ dimensional vector as an input returns n vector values produced by n vector.extract operations.</p>
<p>If the input is rank-1 or has leading scalable dimension, failure is returned.</p>
<p>I.e. calling unrollVectorValue([[v]], rewriter) such that</p>
<p>v : <a class="el" href="namespacemlir_1_1vector.html">vector&lt;nxaxb...&gt;</a></p>
<p>will produce the following IR changes</p>
<p>v0 = vector.extract v[0] : <a class="el" href="namespacemlir_1_1vector.html">vector&lt;axbx...&gt;</a> from <a class="el" href="namespacemlir_1_1vector.html">vector&lt;nxaxb...&gt;</a> v1 = vector.extract v[1] : <a class="el" href="namespacemlir_1_1vector.html">vector&lt;axbx...&gt;</a> from <a class="el" href="namespacemlir_1_1vector.html">vector&lt;nxaxb...&gt;</a> ... vnminusone = vector.extract v[n-1] : <a class="el" href="namespacemlir_1_1vector.html">vector&lt;axbx...&gt;</a> from ...</p>
<p>and returns <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value&gt;</a> r = {[[v0]], [[v1]], ..., [[vnminusone]]} </p>

<p class="definition">Definition at line <a class="el" href="VectorUtils_8cpp_source.html#l00428">428</a> of file <a class="el" href="VectorUtils_8cpp_source.html">VectorUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
