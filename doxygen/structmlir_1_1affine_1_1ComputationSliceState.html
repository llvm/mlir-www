<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::affine::ComputationSliceState Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1affine.html">affine</a></li><li class="navelem"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structmlir_1_1affine_1_1ComputationSliceState-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::affine::ComputationSliceState Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html" title="ComputationSliceState aggregates loop IVs, loop bound AffineMaps and their associated operands for a ...">ComputationSliceState</a> aggregates loop IVs, loop bound AffineMaps and their associated operands for a set of loops within a loop nest (typically the set of loops surrounding a store operation).  
 <a href="structmlir_1_1affine_1_1ComputationSliceState.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">mlir/Dialect/Affine/Analysis/Utils.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2a55ff23adbc2491f154ec4074c665d6"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html#a2a55ff23adbc2491f154ec4074c665d6">getAsConstraints</a> (<a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *cst) const</td></tr>
<tr class="separator:a2a55ff23adbc2491f154ec4074c665d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b06d992ca662858732225827937c1f7"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html#a9b06d992ca662858732225827937c1f7">getSourceAsConstraints</a> (<a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;cst) const</td></tr>
<tr class="memdesc:a9b06d992ca662858732225827937c1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds to 'cst' constraints which represent the original loop bounds on 'ivs' in 'this'.  <a href="structmlir_1_1affine_1_1ComputationSliceState.html#a9b06d992ca662858732225827937c1f7">More...</a><br /></td></tr>
<tr class="separator:a9b06d992ca662858732225827937c1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01fc5e4aa59b1624613835b69c219a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html#ae01fc5e4aa59b1624613835b69c219a6">clearBounds</a> ()</td></tr>
<tr class="separator:ae01fc5e4aa59b1624613835b69c219a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6662e2d7b1582bfe4ff4f64eea403432"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html#a6662e2d7b1582bfe4ff4f64eea403432">isEmpty</a> () const</td></tr>
<tr class="memdesc:a6662e2d7b1582bfe4ff4f64eea403432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the computation slice is empty.  <a href="structmlir_1_1affine_1_1ComputationSliceState.html#a6662e2d7b1582bfe4ff4f64eea403432">More...</a><br /></td></tr>
<tr class="separator:a6662e2d7b1582bfe4ff4f64eea403432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7052b611c0772f9c551ee0d4b33d92"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html#abc7052b611c0772f9c551ee0d4b33d92">isMaximal</a> () const</td></tr>
<tr class="memdesc:abc7052b611c0772f9c551ee0d4b33d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the computation slice encloses all the iterations of the sliced loop nest.  <a href="structmlir_1_1affine_1_1ComputationSliceState.html#abc7052b611c0772f9c551ee0d4b33d92">More...</a><br /></td></tr>
<tr class="separator:abc7052b611c0772f9c551ee0d4b33d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a810c2f49cc44e2c5de12c6caf2727"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html#a09a810c2f49cc44e2c5de12c6caf2727">isSliceValid</a> () const</td></tr>
<tr class="memdesc:a09a810c2f49cc44e2c5de12c6caf2727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the validity of the slice computed.  <a href="structmlir_1_1affine_1_1ComputationSliceState.html#a09a810c2f49cc44e2c5de12c6caf2727">More...</a><br /></td></tr>
<tr class="separator:a09a810c2f49cc44e2c5de12c6caf2727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23715baf2fcbb66e2acd9db32956f40e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html#a23715baf2fcbb66e2acd9db32956f40e">dump</a> () const</td></tr>
<tr class="separator:a23715baf2fcbb66e2acd9db32956f40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a140bf9ff4200613fb5822bed2f1bfc18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html#a140bf9ff4200613fb5822bed2f1bfc18">ivs</a></td></tr>
<tr class="separator:a140bf9ff4200613fb5822bed2f1bfc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6c510051faa671f7758989e38b491d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html#ade6c510051faa671f7758989e38b491d">lbs</a></td></tr>
<tr class="separator:ade6c510051faa671f7758989e38b491d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0148e60f0d8d38822992cf91eb87b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html#ab0148e60f0d8d38822992cf91eb87b5b">ubs</a></td></tr>
<tr class="separator:ab0148e60f0d8d38822992cf91eb87b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8aa32fa351614ef5060a1e079dec0b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html#afd8aa32fa351614ef5060a1e079dec0b">lbOperands</a></td></tr>
<tr class="separator:afd8aa32fa351614ef5060a1e079dec0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3215ff59c18264fa4e846d9a2d5615f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html#aa3215ff59c18264fa4e846d9a2d5615f">ubOperands</a></td></tr>
<tr class="separator:aa3215ff59c18264fa4e846d9a2d5615f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc69fcff6c39da7525bb1c61b91c4492"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html#afc69fcff6c39da7525bb1c61b91c4492">insertPoint</a></td></tr>
<tr class="separator:afc69fcff6c39da7525bb1c61b91c4492"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html" title="ComputationSliceState aggregates loop IVs, loop bound AffineMaps and their associated operands for a ...">ComputationSliceState</a> aggregates loop IVs, loop bound AffineMaps and their associated operands for a set of loops within a loop nest (typically the set of loops surrounding a store operation). </p>
<p>Loop bound AffineMaps which are non-null represent slices of that loop's iteration space. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00318">318</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae01fc5e4aa59b1624613835b69c219a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01fc5e4aa59b1624613835b69c219a6">&#9670;&nbsp;</a></span>clearBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ComputationSliceState::clearBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00934">934</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">mlir::affine::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="a23715baf2fcbb66e2acd9db32956f40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23715baf2fcbb66e2acd9db32956f40e">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ComputationSliceState::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00941">941</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>.</p>

</div>
</div>
<a id="a2a55ff23adbc2491f154ec4074c665d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a55ff23adbc2491f154ec4074c665d6">&#9670;&nbsp;</a></span>getAsConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult ComputationSliceState::getAsConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td>
          <td class="paramname"><em>cst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00898">898</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00074">mlir::affine::FlatAffineValueConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::affine::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00246">mlir::affine::FlatAffineValueConstraints::addSliceBounds()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01439">mlir::FlatLinearValueConstraints::containsVar()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02801">mlir::affine::getForInductionVarOwner()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">mlir::affine::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="a9b06d992ca662858732225827937c1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b06d992ca662858732225827937c1f7">&#9670;&nbsp;</a></span>getSourceAsConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult ComputationSliceState::getSourceAsConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>cst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds to 'cst' constraints which represent the original loop bounds on 'ivs' in 'this'. </p>
<p>This corresponds to the original domain of the loop nest from which the slice is being computed. Returns failure if we cannot add loop bounds because of unsupported cases. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00882">882</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00074">mlir::affine::FlatAffineValueConstraints::addAffineForOpDomain()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02801">mlir::affine::getForInductionVarOwner()</a>.</p>

</div>
</div>
<a id="a6662e2d7b1582bfe4ff4f64eea403432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6662e2d7b1582bfe4ff4f64eea403432">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::ComputationSliceState::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the computation slice is empty. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00350">350</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00321">ivs</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00279">getAdditionalComputeFraction()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l00500">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="abc7052b611c0772f9c551ee0d4b33d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7052b611c0772f9c551ee0d4b33d92">&#9670;&nbsp;</a></span>isMaximal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; bool &gt; ComputationSliceState::isMaximal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the computation slice encloses all the iterations of the sliced loop nest. </p>
<p>Returns false if it does not. Returns std::nullopt if it cannot determine if the slice is maximal or not. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01106">1106</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00074">mlir::affine::FlatAffineValueConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00154">mlir::affine::FlatAffineValueConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02801">mlir::affine::getForInductionVarOwner()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00217">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="PresburgerRelation_8cpp_source.html#l00671">mlir::presburger::PresburgerRelation::isIntegerEmpty()</a>, and <a class="el" href="PresburgerRelation_8cpp_source.html#l01089">mlir::presburger::PresburgerSet::subtract()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00076">canRemoveSrcNodeAfterFusion()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01870">mlir::affine::getComputationSliceState()</a>.</p>

</div>
</div>
<a id="a09a810c2f49cc44e2c5de12c6caf2727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a810c2f49cc44e2c5de12c6caf2727">&#9670;&nbsp;</a></span>isSliceValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; bool &gt; ComputationSliceState::isSliceValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the validity of the slice computed. </p>
<p>Returns true if it is deterministically verified that the original iteration space of the slice is contained within the new iteration space that is created after fusing 'this' slice into its destination.</p>
<p>This is done using the following steps:</p><ol type="1">
<li>Get the new domain of the slice that would be created if fusion succeeds. This domain gets constructed with source loop IVS and destination loop IVS as dimensions.</li>
<li>Project out the dimensions of the destination loop from the domain above calculated in step(1) to express it purely in terms of the source loop IVs.</li>
<li>Calculate a set difference between the iterations of the new domain and the original domain of the source loop. If this difference is empty, the slice is declared to be valid. Otherwise, return false as it implies that the effective fusion results in at least one iteration of the slice that was not originally in the source's domain. If the validity cannot be determined, returns std::nullopt. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01036">1036</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00215">mlir::presburger::IntegerRelation::getNumLocalVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00214">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00221">mlir::presburger::IntegerRelation::getNumVars()</a>, <a class="el" href="PresburgerRelation_8cpp_source.html#l00671">mlir::presburger::PresburgerRelation::isIntegerEmpty()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01481">mlir::FlatLinearValueConstraints::projectOut()</a>, and <a class="el" href="PresburgerRelation_8cpp_source.html#l01089">mlir::presburger::PresburgerSet::subtract()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">mlir::affine::computeSliceUnion()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afc69fcff6c39da7525bb1c61b91c4492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc69fcff6c39da7525bb1c61b91c4492">&#9670;&nbsp;</a></span>insertPoint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> mlir::affine::ComputationSliceState::insertPoint</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00331">331</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">mlir::affine::computeSliceUnion()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00425">mlir::affine::fuseLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01870">mlir::affine::getComputationSliceState()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00574">mlir::affine::getFusionComputeCost()</a>.</p>

</div>
</div>
<a id="a140bf9ff4200613fb5822bed2f1bfc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140bf9ff4200613fb5822bed2f1bfc18">&#9670;&nbsp;</a></span>ivs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, 4&gt; mlir::affine::ComputationSliceState::ivs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00321">321</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01818">mlir::affine::buildSliceTripCountMap()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">mlir::affine::computeSliceUnion()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00425">mlir::affine::fuseLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01870">mlir::affine::getComputationSliceState()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00350">isEmpty()</a>.</p>

</div>
</div>
<a id="afd8aa32fa351614ef5060a1e079dec0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8aa32fa351614ef5060a1e079dec0b">&#9670;&nbsp;</a></span>lbOperands</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, 4&gt; &gt; mlir::affine::ComputationSliceState::lbOperands</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00327">327</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">mlir::affine::computeSliceUnion()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00425">mlir::affine::fuseLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01870">mlir::affine::getComputationSliceState()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01982">mlir::affine::insertBackwardComputationSlice()</a>.</p>

</div>
</div>
<a id="ade6c510051faa671f7758989e38b491d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6c510051faa671f7758989e38b491d">&#9670;&nbsp;</a></span>lbs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4&gt; mlir::affine::ComputationSliceState::lbs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00323">323</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01818">mlir::affine::buildSliceTripCountMap()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">mlir::affine::computeSliceUnion()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00425">mlir::affine::fuseLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01870">mlir::affine::getComputationSliceState()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01982">mlir::affine::insertBackwardComputationSlice()</a>.</p>

</div>
</div>
<a id="aa3215ff59c18264fa4e846d9a2d5615f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3215ff59c18264fa4e846d9a2d5615f">&#9670;&nbsp;</a></span>ubOperands</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, 4&gt; &gt; mlir::affine::ComputationSliceState::ubOperands</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00329">329</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">mlir::affine::computeSliceUnion()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00425">mlir::affine::fuseLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01870">mlir::affine::getComputationSliceState()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01982">mlir::affine::insertBackwardComputationSlice()</a>.</p>

</div>
</div>
<a id="ab0148e60f0d8d38822992cf91eb87b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0148e60f0d8d38822992cf91eb87b5b">&#9670;&nbsp;</a></span>ubs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4&gt; mlir::affine::ComputationSliceState::ubs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00325">325</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01818">mlir::affine::buildSliceTripCountMap()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">mlir::affine::computeSliceUnion()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00425">mlir::affine::fuseLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01870">mlir::affine::getComputationSliceState()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01982">mlir::affine::insertBackwardComputationSlice()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/mlir/Dialect/Affine/Analysis/<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">Utils.h</a></li>
<li>lib/Dialect/Affine/Analysis/<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 27 2025 16:33:11 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
