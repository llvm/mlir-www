<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::pdl_to_pdl_interp::OptimalBranching Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1pdl__to__pdl__interp.html">pdl_to_pdl_interp</a></li><li class="navelem"><a class="el" href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching.html">OptimalBranching</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::pdl_to_pdl_interp::OptimalBranching Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The optimal branching algorithm solver.  
 <a href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="RootOrdering_8h_source.html">Conversion/PDLToPDLInterp/RootOrdering.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a14d5d5c07e98c3fa2a5622ce36c72252"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching.html#a14d5d5c07e98c3fa2a5622ce36c72252">EdgeList</a> = std::vector&lt; std::pair&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;</td></tr>
<tr class="memdesc:a14d5d5c07e98c3fa2a5622ce36c72252"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of edges (child, parent).  <a href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching.html#a14d5d5c07e98c3fa2a5622ce36c72252">More...</a><br /></td></tr>
<tr class="separator:a14d5d5c07e98c3fa2a5622ce36c72252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a615eb91f34fc86efb260a0d25af0f3a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching.html#a615eb91f34fc86efb260a0d25af0f3a7">OptimalBranching</a> (<a class="el" href="namespacemlir_1_1pdl__to__pdl__interp.html#a759e8ed167f0c8ccb73e5e6109234c42">RootOrderingGraph</a> graph, <a class="el" href="classmlir_1_1Value.html">Value</a> root)</td></tr>
<tr class="memdesc:a615eb91f34fc86efb260a0d25af0f3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the solver for the given graph and root value.  <a href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching.html#a615eb91f34fc86efb260a0d25af0f3a7">More...</a><br /></td></tr>
<tr class="separator:a615eb91f34fc86efb260a0d25af0f3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7752a506ceb2d5b807c867f9ed50fb"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching.html#a0c7752a506ceb2d5b807c867f9ed50fb">solve</a> ()</td></tr>
<tr class="memdesc:a0c7752a506ceb2d5b807c867f9ed50fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the Edmonds' algorithm for the current <code>graph</code>, returning the total cost of the minimum-weight spanning arborescence (sum of the edge costs).  <a href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching.html#a0c7752a506ceb2d5b807c867f9ed50fb">More...</a><br /></td></tr>
<tr class="separator:a0c7752a506ceb2d5b807c867f9ed50fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac914a49ea7685654dd7387393bcf73ee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching.html#ac914a49ea7685654dd7387393bcf73ee">getRootOrderingParents</a> () const</td></tr>
<tr class="memdesc:ac914a49ea7685654dd7387393bcf73ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the computed parent map.  <a href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching.html#ac914a49ea7685654dd7387393bcf73ee">More...</a><br /></td></tr>
<tr class="separator:ac914a49ea7685654dd7387393bcf73ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8dbcdaa402abc2ac9e844876a027cd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching.html#a14d5d5c07e98c3fa2a5622ce36c72252">EdgeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching.html#ad8dbcdaa402abc2ac9e844876a027cd1">preOrderTraversal</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; nodes) const</td></tr>
<tr class="memdesc:ad8dbcdaa402abc2ac9e844876a027cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the computed edges as visited in the preorder traversal.  <a href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching.html#ad8dbcdaa402abc2ac9e844876a027cd1">More...</a><br /></td></tr>
<tr class="separator:ad8dbcdaa402abc2ac9e844876a027cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The optimal branching algorithm solver. </p>
<p>This solver accepts a graph and the root in its constructor, and is invoked via the <a class="el" href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching.html#a0c7752a506ceb2d5b807c867f9ed50fb" title="Runs the Edmonds&#39; algorithm for the current graph, returning the total cost of the minimum-weight spa...">solve()</a> member function. This is a direct implementation of the Edmonds' algorithm, see <a href="https://en.wikipedia.org/wiki/Edmonds%27_algorithm">https://en.wikipedia.org/wiki/Edmonds%27_algorithm</a>. The worst-case computational complexity of this algorithm is O(N^3), for a single root. The PDL-to-PDLInterp lowering calls this N times (once for each candidate root), so the overall complexity root ordering is O(N^4). If needed, this could be reduced to O(N^3) with a more efficient algorithm. However, note that the underlying implementation is very efficient, and N in our instances tends to be very small (&lt;10). </p>

<p class="definition">Definition at line <a class="el" href="RootOrdering_8h_source.html#l00090">90</a> of file <a class="el" href="RootOrdering_8h_source.html">RootOrdering.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a14d5d5c07e98c3fa2a5622ce36c72252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d5d5c07e98c3fa2a5622ce36c72252">&#9670;&nbsp;</a></span>EdgeList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching.html#a14d5d5c07e98c3fa2a5622ce36c72252">mlir::pdl_to_pdl_interp::OptimalBranching::EdgeList</a> =  std::vector&lt;std::pair&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of edges (child, parent). </p>

<p class="definition">Definition at line <a class="el" href="RootOrdering_8h_source.html#l00093">93</a> of file <a class="el" href="RootOrdering_8h_source.html">RootOrdering.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a615eb91f34fc86efb260a0d25af0f3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615eb91f34fc86efb260a0d25af0f3a7">&#9670;&nbsp;</a></span>OptimalBranching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OptimalBranching::OptimalBranching </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1pdl__to__pdl__interp.html#a759e8ed167f0c8ccb73e5e6109234c42">RootOrderingGraph</a>&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the solver for the given graph and root value. </p>

<p class="definition">Definition at line <a class="el" href="RootOrdering_8cpp_source.html#l00118">118</a> of file <a class="el" href="RootOrdering_8cpp_source.html">RootOrdering.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac914a49ea7685654dd7387393bcf73ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac914a49ea7685654dd7387393bcf73ee">&#9670;&nbsp;</a></span>getRootOrderingParents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>&gt;&amp; mlir::pdl_to_pdl_interp::OptimalBranching::getRootOrderingParents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the computed parent map. </p>
<p>This is the unique predecessor for each node (root) in the optimal branching. </p>

<p class="definition">Definition at line <a class="el" href="RootOrdering_8h_source.html#l00111">111</a> of file <a class="el" href="RootOrdering_8h_source.html">RootOrdering.h</a>.</p>

</div>
</div>
<a id="ad8dbcdaa402abc2ac9e844876a027cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8dbcdaa402abc2ac9e844876a027cd1">&#9670;&nbsp;</a></span>preOrderTraversal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1pdl__to__pdl__interp_1_1OptimalBranching.html#a14d5d5c07e98c3fa2a5622ce36c72252">OptimalBranching::EdgeList</a> OptimalBranching::preOrderTraversal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the computed edges as visited in the preorder traversal. </p>
<p>The specified array determines the order for breaking any ties. </p>

<p class="definition">Definition at line <a class="el" href="RootOrdering_8cpp_source.html#l00206">206</a> of file <a class="el" href="RootOrdering_8cpp_source.html">RootOrdering.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="PredicateTree_8cpp_source.html#l00611">buildPredicateList()</a>.</p>

</div>
</div>
<a id="a0c7752a506ceb2d5b807c867f9ed50fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7752a506ceb2d5b807c867f9ed50fb">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned OptimalBranching::solve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the Edmonds' algorithm for the current <code>graph</code>, returning the total cost of the minimum-weight spanning arborescence (sum of the edge costs). </p>
<p>This function first determines the optimal local choice of the parents and stores this choice in the <code>parents</code> mapping. If this choice results in an acyclic graph, the function returns immediately. Otherwise, it takes an arbitrary cycle, contracts it, and recurses on the new graph (which is guaranteed to have fewer nodes than we began with). After we return from recursion, we redirect the edges to/from the contracted node, so the <code>parents</code> map contains a valid solution for the current graph. </p>

<p class="definition">Definition at line <a class="el" href="RootOrdering_8cpp_source.html#l00121">121</a> of file <a class="el" href="RootOrdering_8cpp_source.html">RootOrdering.cpp</a>.</p>

<p class="reference">References <a class="el" href="RootOrdering_8cpp_source.html#l00046">contract()</a>, <a class="el" href="RootOrdering_8h_source.html#l00065">mlir::pdl_to_pdl_interp::RootOrderingEntry::cost</a>, and <a class="el" href="RootOrdering_8cpp_source.html#l00025">getCycle()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PredicateTree_8cpp_source.html#l00611">buildPredicateList()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>lib/Conversion/PDLToPDLInterp/<a class="el" href="RootOrdering_8h_source.html">RootOrdering.h</a></li>
<li>lib/Conversion/PDLToPDLInterp/<a class="el" href="RootOrdering_8cpp_source.html">RootOrdering.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:31 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
