<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::impl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1impl.html">impl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::impl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> collections provide a dictionary-like interface.  
<a href="namespacemlir_1_1impl.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a84b7ad6410a931dc755f96e599f36724"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a84b7ad6410a931dc755f96e599f36724">verifyHasDefaultDLTIDataLayoutTrait</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a84b7ad6410a931dc755f96e599f36724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f25aa2c985b0e6b23651eb3912983b"><td class="memItemLeft" align="right" valign="top">DataLayoutSpecInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a06f25aa2c985b0e6b23651eb3912983b">getDataLayoutSpec</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a06f25aa2c985b0e6b23651eb3912983b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbb64a5a3955613e70e2031cb3c30d3"><td class="memItemLeft" align="right" valign="top">TargetSystemSpecInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a1cbb64a5a3955613e70e2031cb3c30d3">getTargetSystemSpec</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a1cbb64a5a3955613e70e2031cb3c30d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29dfb6c5c1746815939067b8aeb67cfb"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a29dfb6c5c1746815939067b8aeb67cfb">foldCastInterfaceOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; attrOperands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;foldResults)</td></tr>
<tr class="memdesc:a29dfb6c5c1746815939067b8aeb67cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to fold the given cast operation.  <a href="namespacemlir_1_1impl.html#a29dfb6c5c1746815939067b8aeb67cfb">More...</a><br /></td></tr>
<tr class="separator:a29dfb6c5c1746815939067b8aeb67cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3037b577d983389bdae6e7708c66e8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a2d3037b577d983389bdae6e7708c66e8">verifyCastInterfaceOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a2d3037b577d983389bdae6e7708c66e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to verify the given cast operation.  <a href="namespacemlir_1_1impl.html#a2d3037b577d983389bdae6e7708c66e8">More...</a><br /></td></tr>
<tr class="separator:a2d3037b577d983389bdae6e7708c66e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7451c7364716df0ac50255d1bb0dba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a8e7451c7364716df0ac50255d1bb0dba">ensureRegionTerminator</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>)&gt; buildTerminatorOp)</td></tr>
<tr class="memdesc:a8e7451c7364716df0ac50255d1bb0dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an operation, generated by <code>buildTerminatorOp</code>, at the end of the region's only block if it does not have a terminator already.  <a href="namespacemlir_1_1impl.html#a8e7451c7364716df0ac50255d1bb0dba">More...</a><br /></td></tr>
<tr class="separator:a8e7451c7364716df0ac50255d1bb0dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89ade716be6ba0ebae6e192aa722859"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#ad89ade716be6ba0ebae6e192aa722859">ensureRegionTerminator</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>)&gt; buildTerminatorOp)</td></tr>
<tr class="memdesc:ad89ade716be6ba0ebae6e192aa722859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a simple <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations.">OpBuilder</a> and forward to the <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations.">OpBuilder</a> version of this function.  <a href="namespacemlir_1_1impl.html#ad89ade716be6ba0ebae6e192aa722859">More...</a><br /></td></tr>
<tr class="separator:ad89ade716be6ba0ebae6e192aa722859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb48e57977e8eb6644e7ef248f7fb0b"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename NameT &gt; </td></tr>
<tr class="memitem:afeb48e57977e8eb6644e7ef248f7fb0b"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; IteratorT, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#afeb48e57977e8eb6644e7ef248f7fb0b">findAttrUnsorted</a> (IteratorT first, IteratorT last, NameT name)</td></tr>
<tr class="memdesc:afeb48e57977e8eb6644e7ef248f7fb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsorted string search or identifier lookups are linear scans.  <a href="namespacemlir_1_1impl.html#afeb48e57977e8eb6644e7ef248f7fb0b">More...</a><br /></td></tr>
<tr class="separator:afeb48e57977e8eb6644e7ef248f7fb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e3488b696c6918c78edbc6b1399642"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT &gt; </td></tr>
<tr class="memitem:ad4e3488b696c6918c78edbc6b1399642"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; IteratorT, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#ad4e3488b696c6918c78edbc6b1399642">findAttrSorted</a> (IteratorT first, IteratorT last, StringRef name)</td></tr>
<tr class="memdesc:ad4e3488b696c6918c78edbc6b1399642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using llvm::lower_bound requires an extra string comparison to check whether the returned iterator points to the found element or whether it indicates the lower bound.  <a href="namespacemlir_1_1impl.html#ad4e3488b696c6918c78edbc6b1399642">More...</a><br /></td></tr>
<tr class="separator:ad4e3488b696c6918c78edbc6b1399642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c932194b18d2e50402f4ec754b30e90"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT &gt; </td></tr>
<tr class="memitem:a0c932194b18d2e50402f4ec754b30e90"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; IteratorT, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a0c932194b18d2e50402f4ec754b30e90">findAttrSorted</a> (IteratorT first, IteratorT last, StringAttr name)</td></tr>
<tr class="memdesc:a0c932194b18d2e50402f4ec754b30e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">StringAttr lookups on large attribute lists will switch to string binary search.  <a href="namespacemlir_1_1impl.html#a0c932194b18d2e50402f4ec754b30e90">More...</a><br /></td></tr>
<tr class="separator:a0c932194b18d2e50402f4ec754b30e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2377865bf1a224b5d26bcf16a3115f3"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename NameT &gt; </td></tr>
<tr class="memitem:ac2377865bf1a224b5d26bcf16a3115f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#ac2377865bf1a224b5d26bcf16a3115f3">getAttrFromSortedRange</a> (IteratorT first, IteratorT last, NameT name)</td></tr>
<tr class="memdesc:ac2377865bf1a224b5d26bcf16a3115f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an attribute from a sorted range of named attributes.  <a href="namespacemlir_1_1impl.html#ac2377865bf1a224b5d26bcf16a3115f3">More...</a><br /></td></tr>
<tr class="separator:ac2377865bf1a224b5d26bcf16a3115f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0483553f9fb437556a973a1b0d93a9fc"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT , typename NameT &gt; </td></tr>
<tr class="memitem:a0483553f9fb437556a973a1b0d93a9fc"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a0483553f9fb437556a973a1b0d93a9fc">getNamedAttrFromSortedRange</a> (IteratorT first, IteratorT last, NameT name)</td></tr>
<tr class="memdesc:a0483553f9fb437556a973a1b0d93a9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an attribute from a sorted range of named attributes.  <a href="namespacemlir_1_1impl.html#a0483553f9fb437556a973a1b0d93a9fc">More...</a><br /></td></tr>
<tr class="separator:a0483553f9fb437556a973a1b0d93a9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f4725ebab81800602d1bba2900a4c0"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#af7f4725ebab81800602d1bba2900a4c0">parseOptionalVisibilityKeyword</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;attrs)</td></tr>
<tr class="memdesc:af7f4725ebab81800602d1bba2900a4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an optional visibility attribute keyword (i.e., public, private, or nested) without quotes in a string attribute named 'attrName'.  <a href="namespacemlir_1_1impl.html#af7f4725ebab81800602d1bba2900a4c0">More...</a><br /></td></tr>
<tr class="separator:af7f4725ebab81800602d1bba2900a4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1390173752b648518b3b47fcdc98fd69"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a1390173752b648518b3b47fcdc98fd69">scalarizeVectorOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a> &amp;rewriter, const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:a1390173752b648518b3b47fcdc98fd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls op to array/vector elements.  <a href="namespacemlir_1_1impl.html#a1390173752b648518b3b47fcdc98fd69">More...</a><br /></td></tr>
<tr class="separator:a1390173752b648518b3b47fcdc98fd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> collections provide a dictionary-like interface. </p>
<p>Define common lookup functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ad89ade716be6ba0ebae6e192aa722859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89ade716be6ba0ebae6e192aa722859">&#9670;&nbsp;</a></span>ensureRegionTerminator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::impl::ensureRegionTerminator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>)&gt;&#160;</td>
          <td class="paramname"><em>buildTerminatorOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a simple <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations.">OpBuilder</a> and forward to the <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations.">OpBuilder</a> version of this function. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8cpp_source.html#l01427">1427</a> of file <a class="el" href="IR_2Operation_8cpp_source.html">Operation.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l01410">ensureRegionTerminator()</a>, and <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpDefinition_8h_source.html#l01008">mlir::OpTrait::SingleBlockImplicitTerminator&lt; TerminatorOpType &gt;::Impl&lt; ConcreteType &gt;::ensureTerminator()</a>.</p>

</div>
</div>
<a id="a8e7451c7364716df0ac50255d1bb0dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7451c7364716df0ac50255d1bb0dba">&#9670;&nbsp;</a></span>ensureRegionTerminator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::impl::ensureRegionTerminator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>)&gt;&#160;</td>
          <td class="paramname"><em>buildTerminatorOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an operation, generated by <code>buildTerminatorOp</code>, at the end of the region's only block if it does not have a terminator already. </p>
<p>If the region is empty, insert a new block first. <code>buildTerminatorOp</code> should return the terminator operation to insert. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8cpp_source.html#l01410">1410</a> of file <a class="el" href="IR_2Operation_8cpp_source.html">Operation.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00152">mlir::Block::back()</a>, <a class="el" href="IR_2Region_8h_source.html#l00064">mlir::Region::back()</a>, <a class="el" href="Builders_8cpp_source.html#l00425">mlir::OpBuilder::createBlock()</a>, <a class="el" href="Block_8h_source.html#l00148">mlir::Block::empty()</a>, <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>, <a class="el" href="Builders_8cpp_source.html#l00416">mlir::OpBuilder::insert()</a>, and <a class="el" href="Builders_8h_source.html#l00434">mlir::OpBuilder::setInsertionPointToEnd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Operation_8cpp_source.html#l01427">ensureRegionTerminator()</a>.</p>

</div>
</div>
<a id="a0c932194b18d2e50402f4ec754b30e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c932194b18d2e50402f4ec754b30e90">&#9670;&nbsp;</a></span>findAttrSorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;IteratorT, bool&gt; mlir::impl::findAttrSorted </td>
          <td>(</td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>StringAttr lookups on large attribute lists will switch to string binary search. </p>
<p>String binary searches become significantly faster than linear scans with the identifier when the attribute list becomes very large. </p>

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00763">763</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00739">findAttrSorted()</a>, and <a class="el" href="OperationSupport_8h_source.html#l00726">findAttrUnsorted()</a>.</p>

</div>
</div>
<a id="ad4e3488b696c6918c78edbc6b1399642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e3488b696c6918c78edbc6b1399642">&#9670;&nbsp;</a></span>findAttrSorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;IteratorT, bool&gt; mlir::impl::findAttrSorted </td>
          <td>(</td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using llvm::lower_bound requires an extra string comparison to check whether the returned iterator points to the found element or whether it indicates the lower bound. </p>
<p>Skip this redundant comparison by checking if <code>compare == 0</code> during the binary search. </p>

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00739">739</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00068">mlir::presburger::compare()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OperationSupport_8h_source.html#l00763">findAttrSorted()</a>, <a class="el" href="OperationSupport_8h_source.html#l00774">getAttrFromSortedRange()</a>, and <a class="el" href="OperationSupport_8h_source.html#l00783">getNamedAttrFromSortedRange()</a>.</p>

</div>
</div>
<a id="afeb48e57977e8eb6644e7ef248f7fb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb48e57977e8eb6644e7ef248f7fb0b">&#9670;&nbsp;</a></span>findAttrUnsorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename NameT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;IteratorT, bool&gt; mlir::impl::findAttrUnsorted </td>
          <td>(</td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NameT&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsorted string search or identifier lookups are linear scans. </p>

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00726">726</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OperationSupport_8h_source.html#l00763">findAttrSorted()</a>.</p>

</div>
</div>
<a id="a29dfb6c5c1746815939067b8aeb67cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29dfb6c5c1746815939067b8aeb67cfb">&#9670;&nbsp;</a></span>foldCastInterfaceOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::impl::foldCastInterfaceOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>attrOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>foldResults</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to fold the given cast operation. </p>

<p class="definition">Definition at line <a class="el" href="CastInterfaces_8cpp_source.html#l00022">22</a> of file <a class="el" href="CastInterfaces_8cpp_source.html">CastInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="ValueRange_8cpp_source.html#l00028">mlir::OperandRange::getTypes()</a>, and <a class="el" href="ValueRange_8cpp_source.html#l00038">mlir::ResultRange::getTypes()</a>.</p>

</div>
</div>
<a id="ac2377865bf1a224b5d26bcf16a3115f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2377865bf1a224b5d26bcf16a3115f3">&#9670;&nbsp;</a></span>getAttrFromSortedRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename NameT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::impl::getAttrFromSortedRange </td>
          <td>(</td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NameT&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an attribute from a sorted range of named attributes. </p>
<p>Returns null if the attribute was not found. </p>

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00774">774</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00739">findAttrSorted()</a>.</p>

</div>
</div>
<a id="a06f25aa2c985b0e6b23651eb3912983b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f25aa2c985b0e6b23651eb3912983b">&#9670;&nbsp;</a></span>getDataLayoutSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataLayoutSpecInterface mlir::impl::getDataLayoutSpec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DLTI_2Traits_8cpp_source.html#l00026">26</a> of file <a class="el" href="DLTI_2Traits_8cpp_source.html">Traits.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DLTI_2Traits_8h_source.html#l00038">mlir::HasDefaultDLTIDataLayout&lt; ConcreteOp &gt;::getDataLayoutSpec()</a>.</p>

</div>
</div>
<a id="a0483553f9fb437556a973a1b0d93a9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0483553f9fb437556a973a1b0d93a9fc">&#9670;&nbsp;</a></span>getNamedAttrFromSortedRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT , typename NameT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a>&gt; mlir::impl::getNamedAttrFromSortedRange </td>
          <td>(</td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NameT&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an attribute from a sorted range of named attributes. </p>
<p>Returns std::nullopt if the attribute was not found. </p>

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00783">783</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00739">findAttrSorted()</a>.</p>

</div>
</div>
<a id="a1cbb64a5a3955613e70e2031cb3c30d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbb64a5a3955613e70e2031cb3c30d3">&#9670;&nbsp;</a></span>getTargetSystemSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TargetSystemSpecInterface mlir::impl::getTargetSystemSpec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DLTI_2Traits_8cpp_source.html#l00031">31</a> of file <a class="el" href="DLTI_2Traits_8cpp_source.html">Traits.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DLTI_2Traits_8h_source.html#l00044">mlir::HasDefaultDLTIDataLayout&lt; ConcreteOp &gt;::getTargetSystemSpec()</a>.</p>

</div>
</div>
<a id="af7f4725ebab81800602d1bba2900a4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f4725ebab81800602d1bba2900a4c0">&#9670;&nbsp;</a></span>parseOptionalVisibilityKeyword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::impl::parseOptionalVisibilityKeyword </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an optional visibility attribute keyword (i.e., public, private, or nested) without quotes in a string attribute named 'attrName'. </p>

<p class="definition">Definition at line <a class="el" href="SymbolTable_8cpp_source.html#l01117">1117</a> of file <a class="el" href="SymbolTable_8cpp_source.html">SymbolTable.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00089">mlir::Builder::getNamedAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00257">mlir::Builder::getStringAttr()</a>, <a class="el" href="SymbolTable_8h_source.html#l00082">mlir::SymbolTable::getVisibilityAttrName()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a305f6334c61eb92a164bd865851f55f4">mlir::AsmParser::parseOptionalKeyword()</a>, and <a class="el" href="OperationSupport_8cpp_source.html#l00070">mlir::NamedAttrList::push_back()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FunctionImplementation_8cpp_source.html#l00086">mlir::function_interface_impl::parseFunctionOp()</a>.</p>

</div>
</div>
<a id="a1390173752b648518b3b47fcdc98fd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1390173752b648518b3b47fcdc98fd69">&#9670;&nbsp;</a></span>scalarizeVectorOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::impl::scalarizeVectorOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls op to array/vector elements. </p>

<p class="definition">Definition at line <a class="el" href="GPUOpsLowering_8cpp_source.html#l00635">635</a> of file <a class="el" href="GPUOpsLowering_8cpp_source.html">GPUOpsLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03027">mlir::LLVMTypeConverter::convertType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00428">mlir::Operation::getResultTypes()</a>, <a class="el" href="VectorPattern_8cpp_source.html#l00080">mlir::LLVM::detail::handleMultidimensionalVectors()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01762">mlir::ConversionPatternRewriter::replaceOp()</a>, and <a class="el" href="GPUOpsLowering_8cpp_source.html#l00606">scalarizeVectorOpHelper()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUOpsLowering_8h_source.html#l00190">mlir::ScalarizeVectorOpLowering&lt; SourceOp &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a2d3037b577d983389bdae6e7708c66e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3037b577d983389bdae6e7708c66e8">&#9670;&nbsp;</a></span>verifyCastInterfaceOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::impl::verifyCastInterfaceOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to verify the given cast operation. </p>

<p class="definition">Definition at line <a class="el" href="CastInterfaces_8cpp_source.html#l00039">39</a> of file <a class="el" href="CastInterfaces_8cpp_source.html">CastInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l00055">diag()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00672">mlir::Operation::emitOpError()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00397">mlir::Operation::getOperandTypes()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00428">mlir::Operation::getResultTypes()</a>.</p>

</div>
</div>
<a id="a84b7ad6410a931dc755f96e599f36724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b7ad6410a931dc755f96e599f36724">&#9670;&nbsp;</a></span>verifyHasDefaultDLTIDataLayoutTrait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::impl::verifyHasDefaultDLTIDataLayoutTrait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DLTI_2Traits_8cpp_source.html#l00015">15</a> of file <a class="el" href="DLTI_2Traits_8cpp_source.html">Traits.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DLTI_2Traits_8h_source.html#l00032">mlir::HasDefaultDLTIDataLayout&lt; ConcreteOp &gt;::verifyTrait()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:31 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
