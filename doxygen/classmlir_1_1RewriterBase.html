<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::RewriterBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classmlir_1_1RewriterBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::RewriterBase Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class coordinates the application of a rewrite on a set of IR, providing a way for clients to track mutations and create new operations.  
 <a href="classmlir_1_1RewriterBase.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mlir::RewriterBase:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classmlir_1_1RewriterBase__inherit__graph.svg" width="1035" height="235"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1RewriterBase_1_1ForwardingListener.html">ForwardingListener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A listener that forwards all notifications to another listener.  <a href="structmlir_1_1RewriterBase_1_1ForwardingListener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1RewriterBase_1_1Listener.html">Listener</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1RewriterBase_1_1PatternLoggingListener.html">PatternLoggingListener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A listener that logs notification events to llvm::dbgs() before forwarding to the base listener.  <a href="structmlir_1_1RewriterBase_1_1PatternLoggingListener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adaf2b23302d524eeb5643dcff7668ebf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#adaf2b23302d524eeb5643dcff7668ebf">inlineRegionBefore</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;parent, <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> before)</td></tr>
<tr class="memdesc:adaf2b23302d524eeb5643dcff7668ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the blocks that belong to "region" before the given position in another region "parent".  <a href="classmlir_1_1RewriterBase.html#adaf2b23302d524eeb5643dcff7668ebf">More...</a><br /></td></tr>
<tr class="separator:adaf2b23302d524eeb5643dcff7668ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd0cf093ad5c10fb3e12a4e1fbb5e1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#adbd0cf093ad5c10fb3e12a4e1fbb5e1b">inlineRegionBefore</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Block.html">Block</a> *before)</td></tr>
<tr class="separator:adbd0cf093ad5c10fb3e12a4e1fbb5e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c88f3ce889be590b3801b4ddee627f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a53c88f3ce889be590b3801b4ddee627f">replaceOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newValues)</td></tr>
<tr class="memdesc:a53c88f3ce889be590b3801b4ddee627f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the results of the given (original) operation with the specified list of values (replacements).  <a href="classmlir_1_1RewriterBase.html#a53c88f3ce889be590b3801b4ddee627f">More...</a><br /></td></tr>
<tr class="separator:a53c88f3ce889be590b3801b4ddee627f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8deddda655ea07575a2624c54b80f3e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#ac8deddda655ea07575a2624c54b80f3e">replaceOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *newOp)</td></tr>
<tr class="memdesc:ac8deddda655ea07575a2624c54b80f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the results of the given (original) operation with the specified new op (replacement).  <a href="classmlir_1_1RewriterBase.html#ac8deddda655ea07575a2624c54b80f3e">More...</a><br /></td></tr>
<tr class="separator:ac8deddda655ea07575a2624c54b80f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1c910a57707f518d2b9c903c2bb5bc"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:afb1c910a57707f518d2b9c903c2bb5bc"><td class="memTemplItemLeft" align="right" valign="top">OpTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#afb1c910a57707f518d2b9c903c2bb5bc">replaceOpWithNewOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:afb1c910a57707f518d2b9c903c2bb5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the results of the given (original) op with a new op that is created without verification (replacement).  <a href="classmlir_1_1RewriterBase.html#afb1c910a57707f518d2b9c903c2bb5bc">More...</a><br /></td></tr>
<tr class="separator:afb1c910a57707f518d2b9c903c2bb5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786138ac6a91e0932da343ef5c6f1e70"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a786138ac6a91e0932da343ef5c6f1e70">eraseOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a786138ac6a91e0932da343ef5c6f1e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method erases an operation that is known to have no uses.  <a href="classmlir_1_1RewriterBase.html#a786138ac6a91e0932da343ef5c6f1e70">More...</a><br /></td></tr>
<tr class="separator:a786138ac6a91e0932da343ef5c6f1e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286510e5cc47983e5b6017bad6aa6335"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a286510e5cc47983e5b6017bad6aa6335">eraseBlock</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:a286510e5cc47983e5b6017bad6aa6335"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method erases all operations in a block.  <a href="classmlir_1_1RewriterBase.html#a286510e5cc47983e5b6017bad6aa6335">More...</a><br /></td></tr>
<tr class="separator:a286510e5cc47983e5b6017bad6aa6335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d36005019112b1a9acecba1a9cfc377"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a9d36005019112b1a9acecba1a9cfc377">inlineBlockBefore</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *source, <a class="el" href="classmlir_1_1Block.html">Block</a> *dest, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> before, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> argValues={})</td></tr>
<tr class="memdesc:a9d36005019112b1a9acecba1a9cfc377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline the operations of block 'source' into block 'dest' before the given position.  <a href="classmlir_1_1RewriterBase.html#a9d36005019112b1a9acecba1a9cfc377">More...</a><br /></td></tr>
<tr class="separator:a9d36005019112b1a9acecba1a9cfc377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4307b18bc25cec55349236d556cc89bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a4307b18bc25cec55349236d556cc89bd">inlineBlockBefore</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *source, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> argValues={})</td></tr>
<tr class="memdesc:a4307b18bc25cec55349236d556cc89bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline the operations of block 'source' before the operation 'op'.  <a href="classmlir_1_1RewriterBase.html#a4307b18bc25cec55349236d556cc89bd">More...</a><br /></td></tr>
<tr class="separator:a4307b18bc25cec55349236d556cc89bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4361e432a7b6a6517beef700f3916f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#aae4361e432a7b6a6517beef700f3916f">mergeBlocks</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *source, <a class="el" href="classmlir_1_1Block.html">Block</a> *dest, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> argValues={})</td></tr>
<tr class="memdesc:aae4361e432a7b6a6517beef700f3916f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline the operations of block 'source' into the end of block 'dest'.  <a href="classmlir_1_1RewriterBase.html#aae4361e432a7b6a6517beef700f3916f">More...</a><br /></td></tr>
<tr class="separator:aae4361e432a7b6a6517beef700f3916f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495c76a07ca3e6c84a1594a64dd3cfa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a495c76a07ca3e6c84a1594a64dd3cfa4">splitBlock</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> before)</td></tr>
<tr class="memdesc:a495c76a07ca3e6c84a1594a64dd3cfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the operations starting at "before" (inclusive) out of the given block into a new block, and return it.  <a href="classmlir_1_1RewriterBase.html#a495c76a07ca3e6c84a1594a64dd3cfa4">More...</a><br /></td></tr>
<tr class="separator:a495c76a07ca3e6c84a1594a64dd3cfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c1331e070f3c4ed7f64b530007aa44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#aa0c1331e070f3c4ed7f64b530007aa44">moveOpBefore</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *existingOp)</td></tr>
<tr class="memdesc:aa0c1331e070f3c4ed7f64b530007aa44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink this operation from its current block and insert it right before <code>existingOp</code> which may be in the same or another block in the same function.  <a href="classmlir_1_1RewriterBase.html#aa0c1331e070f3c4ed7f64b530007aa44">More...</a><br /></td></tr>
<tr class="separator:aa0c1331e070f3c4ed7f64b530007aa44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91caee4a728b445e0e746ffa99b2cf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#aa91caee4a728b445e0e746ffa99b2cf8">moveOpBefore</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> iterator)</td></tr>
<tr class="memdesc:aa91caee4a728b445e0e746ffa99b2cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink this operation from its current block and insert it right before <code>iterator</code> in the specified block.  <a href="classmlir_1_1RewriterBase.html#aa91caee4a728b445e0e746ffa99b2cf8">More...</a><br /></td></tr>
<tr class="separator:aa91caee4a728b445e0e746ffa99b2cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c6fcefff138a077e883df55164302a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#ac7c6fcefff138a077e883df55164302a">moveOpAfter</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *existingOp)</td></tr>
<tr class="memdesc:ac7c6fcefff138a077e883df55164302a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink this operation from its current block and insert it right after <code>existingOp</code> which may be in the same or another block in the same function.  <a href="classmlir_1_1RewriterBase.html#ac7c6fcefff138a077e883df55164302a">More...</a><br /></td></tr>
<tr class="separator:ac7c6fcefff138a077e883df55164302a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac557b90543b8af6f2316a390b30ec30e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#ac557b90543b8af6f2316a390b30ec30e">moveOpAfter</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> iterator)</td></tr>
<tr class="memdesc:ac557b90543b8af6f2316a390b30ec30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink this operation from its current block and insert it right after <code>iterator</code> in the specified block.  <a href="classmlir_1_1RewriterBase.html#ac557b90543b8af6f2316a390b30ec30e">More...</a><br /></td></tr>
<tr class="separator:ac557b90543b8af6f2316a390b30ec30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9b9f56696bbe011288fcf9aa820826"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a5a9b9f56696bbe011288fcf9aa820826">moveBlockBefore</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1Block.html">Block</a> *anotherBlock)</td></tr>
<tr class="memdesc:a5a9b9f56696bbe011288fcf9aa820826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink this block and insert it right before <code>existingBlock</code>.  <a href="classmlir_1_1RewriterBase.html#a5a9b9f56696bbe011288fcf9aa820826">More...</a><br /></td></tr>
<tr class="separator:a5a9b9f56696bbe011288fcf9aa820826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13db8bb7b6e0a4360d0c5f25b81f0288"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a13db8bb7b6e0a4360d0c5f25b81f0288">moveBlockBefore</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1Region.html">Region</a> *region, <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> iterator)</td></tr>
<tr class="memdesc:a13db8bb7b6e0a4360d0c5f25b81f0288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink this block and insert it right before the location that the given iterator points to in the given region.  <a href="classmlir_1_1RewriterBase.html#a13db8bb7b6e0a4360d0c5f25b81f0288">More...</a><br /></td></tr>
<tr class="separator:a13db8bb7b6e0a4360d0c5f25b81f0288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1f09ffd231a52d1f2e41508a3f60dc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#afa1f09ffd231a52d1f2e41508a3f60dc">startOpModification</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:afa1f09ffd231a52d1f2e41508a3f60dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to notify the rewriter that an in-place operation modification is about to happen.  <a href="classmlir_1_1RewriterBase.html#afa1f09ffd231a52d1f2e41508a3f60dc">More...</a><br /></td></tr>
<tr class="separator:afa1f09ffd231a52d1f2e41508a3f60dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751a613cc855a12b9b1dc277dfdcc5c5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a751a613cc855a12b9b1dc277dfdcc5c5">finalizeOpModification</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a751a613cc855a12b9b1dc277dfdcc5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to signal the end of an in-place modification of the given operation.  <a href="classmlir_1_1RewriterBase.html#a751a613cc855a12b9b1dc277dfdcc5c5">More...</a><br /></td></tr>
<tr class="separator:a751a613cc855a12b9b1dc277dfdcc5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85aec3a92df442554cfa7ba825e4e226"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a85aec3a92df442554cfa7ba825e4e226">cancelOpModification</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a85aec3a92df442554cfa7ba825e4e226"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method cancels a pending in-place modification.  <a href="classmlir_1_1RewriterBase.html#a85aec3a92df442554cfa7ba825e4e226">More...</a><br /></td></tr>
<tr class="separator:a85aec3a92df442554cfa7ba825e4e226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8bae753b51386417536a36cf52d3f7"><td class="memTemplParams" colspan="2">template&lt;typename CallableT &gt; </td></tr>
<tr class="memitem:abd8bae753b51386417536a36cf52d3f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#abd8bae753b51386417536a36cf52d3f7">modifyOpInPlace</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *root, CallableT &amp;&amp;callable)</td></tr>
<tr class="memdesc:abd8bae753b51386417536a36cf52d3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is a utility wrapper around an in-place modification of an operation.  <a href="classmlir_1_1RewriterBase.html#abd8bae753b51386417536a36cf52d3f7">More...</a><br /></td></tr>
<tr class="separator:abd8bae753b51386417536a36cf52d3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b4cea69baed7a36d0cd02f5b44c176"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a61b4cea69baed7a36d0cd02f5b44c176">replaceAllUsesWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> from, <a class="el" href="classmlir_1_1Value.html">Value</a> to)</td></tr>
<tr class="memdesc:a61b4cea69baed7a36d0cd02f5b44c176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find uses of <code>from</code> and replace them with <code>to</code>.  <a href="classmlir_1_1RewriterBase.html#a61b4cea69baed7a36d0cd02f5b44c176">More...</a><br /></td></tr>
<tr class="separator:a61b4cea69baed7a36d0cd02f5b44c176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94de93eaac4c7cf2976d6a1e6ddb42dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a94de93eaac4c7cf2976d6a1e6ddb42dd">replaceAllUsesWith</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *from, <a class="el" href="classmlir_1_1Block.html">Block</a> *to)</td></tr>
<tr class="separator:a94de93eaac4c7cf2976d6a1e6ddb42dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d82a8e1d914506268e399ba2e3f4b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a59d82a8e1d914506268e399ba2e3f4b6">replaceAllUsesWith</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> from, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> to)</td></tr>
<tr class="separator:a59d82a8e1d914506268e399ba2e3f4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11a67366e4e1531f3bb0fbe6a67ec03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#af11a67366e4e1531f3bb0fbe6a67ec03">replaceAllOpUsesWith</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *from, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> to)</td></tr>
<tr class="memdesc:af11a67366e4e1531f3bb0fbe6a67ec03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find uses of <code>from</code> and replace them with <code>to</code>.  <a href="classmlir_1_1RewriterBase.html#af11a67366e4e1531f3bb0fbe6a67ec03">More...</a><br /></td></tr>
<tr class="separator:af11a67366e4e1531f3bb0fbe6a67ec03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fe9389669567e32a55dda8d9f0912d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#ab5fe9389669567e32a55dda8d9f0912d">replaceAllOpUsesWith</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *from, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *to)</td></tr>
<tr class="separator:ab5fe9389669567e32a55dda8d9f0912d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b33eb97c405cd1940ef921bbc4c297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a98b33eb97c405cd1940ef921bbc4c297">replaceUsesWithIf</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> from, <a class="el" href="classmlir_1_1Value.html">Value</a> to, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt; functor, bool *allUsesReplaced=nullptr)</td></tr>
<tr class="memdesc:a98b33eb97c405cd1940ef921bbc4c297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find uses of <code>from</code> and replace them with <code>to</code> if the <code>functor</code> returns true.  <a href="classmlir_1_1RewriterBase.html#a98b33eb97c405cd1940ef921bbc4c297">More...</a><br /></td></tr>
<tr class="separator:a98b33eb97c405cd1940ef921bbc4c297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce5dd05c050fd1ef37a05dcfa11bc38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a5ce5dd05c050fd1ef37a05dcfa11bc38">replaceUsesWithIf</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> from, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> to, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt; functor, bool *allUsesReplaced=nullptr)</td></tr>
<tr class="separator:a5ce5dd05c050fd1ef37a05dcfa11bc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2108929d0979260bd4a7ea5a0b84abab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a2108929d0979260bd4a7ea5a0b84abab">replaceOpUsesWithIf</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *from, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> to, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt; functor, bool *allUsesReplaced=nullptr)</td></tr>
<tr class="separator:a2108929d0979260bd4a7ea5a0b84abab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b31f03cc8e5dc784053dafc9d3c021"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#ae5b31f03cc8e5dc784053dafc9d3c021">replaceOpUsesWithinBlock</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newValues, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, bool *allUsesReplaced=nullptr)</td></tr>
<tr class="memdesc:ae5b31f03cc8e5dc784053dafc9d3c021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find uses of <code>from</code> within <code>block</code> and replace them with <code>to</code>.  <a href="classmlir_1_1RewriterBase.html#ae5b31f03cc8e5dc784053dafc9d3c021">More...</a><br /></td></tr>
<tr class="separator:ae5b31f03cc8e5dc784053dafc9d3c021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc0bf42591d2bf716733ed23bb8b6e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a9bc0bf42591d2bf716733ed23bb8b6e6">replaceAllUsesExcept</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> from, <a class="el" href="classmlir_1_1Value.html">Value</a> to, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *exceptedUser)</td></tr>
<tr class="memdesc:a9bc0bf42591d2bf716733ed23bb8b6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find uses of <code>from</code> and replace them with <code>to</code> except if the user is <code>exceptedUser</code>.  <a href="classmlir_1_1RewriterBase.html#a9bc0bf42591d2bf716733ed23bb8b6e6">More...</a><br /></td></tr>
<tr class="separator:a9bc0bf42591d2bf716733ed23bb8b6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e65745ef1625ce5300c8cb927a14db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#ad6e65745ef1625ce5300c8cb927a14db">replaceAllUsesExcept</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> from, <a class="el" href="classmlir_1_1Value.html">Value</a> to, const <a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;preservedUsers)</td></tr>
<tr class="separator:ad6e65745ef1625ce5300c8cb927a14db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032aa8fe5345a286681688ef10f5cb84"><td class="memTemplParams" colspan="2">template&lt;typename CallbackT &gt; </td></tr>
<tr class="memitem:a032aa8fe5345a286681688ef10f5cb84"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_convertible&lt; CallbackT, Twine &gt;::value, LogicalResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a032aa8fe5345a286681688ef10f5cb84">notifyMatchFailure</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, CallbackT &amp;&amp;reasonCallback)</td></tr>
<tr class="memdesc:a032aa8fe5345a286681688ef10f5cb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to notify the listener that the IR failed to be rewritten because of a match failure, and provide a callback to populate a diagnostic with the reason why the failure occurred.  <a href="classmlir_1_1RewriterBase.html#a032aa8fe5345a286681688ef10f5cb84">More...</a><br /></td></tr>
<tr class="separator:a032aa8fe5345a286681688ef10f5cb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081f7564cc3f62236c99e2a8098c3673"><td class="memTemplParams" colspan="2">template&lt;typename CallbackT &gt; </td></tr>
<tr class="memitem:a081f7564cc3f62236c99e2a8098c3673"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_convertible&lt; CallbackT, Twine &gt;::value, LogicalResult &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a081f7564cc3f62236c99e2a8098c3673">notifyMatchFailure</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, CallbackT &amp;&amp;reasonCallback)</td></tr>
<tr class="separator:a081f7564cc3f62236c99e2a8098c3673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1d35106b18aaf457462915e16f3ea3"><td class="memTemplParams" colspan="2">template&lt;typename ArgT &gt; </td></tr>
<tr class="memitem:a2a1d35106b18aaf457462915e16f3ea3"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a2a1d35106b18aaf457462915e16f3ea3">notifyMatchFailure</a> (ArgT &amp;&amp;arg, const Twine &amp;msg)</td></tr>
<tr class="separator:a2a1d35106b18aaf457462915e16f3ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab106a05ed09d9245211a36d3935945dd"><td class="memTemplParams" colspan="2">template&lt;typename ArgT &gt; </td></tr>
<tr class="memitem:ab106a05ed09d9245211a36d3935945dd"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#ab106a05ed09d9245211a36d3935945dd">notifyMatchFailure</a> (ArgT &amp;&amp;arg, const char *msg)</td></tr>
<tr class="separator:ab106a05ed09d9245211a36d3935945dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1OpBuilder"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1OpBuilder')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1OpBuilder.html">mlir::OpBuilder</a></td></tr>
<tr class="memitem:a245ee92bf58156a8a5bb45a291005c9b inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a245ee92bf58156a8a5bb45a291005c9b">OpBuilder</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *<a class="el" href="classmlir_1_1OpBuilder.html#a8bcc0eaf26c14812815b8b4d047d42b9">listener</a>=nullptr)</td></tr>
<tr class="memdesc:a245ee92bf58156a8a5bb45a291005c9b inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a builder with the given context.  <a href="classmlir_1_1OpBuilder.html#a245ee92bf58156a8a5bb45a291005c9b">More...</a><br /></td></tr>
<tr class="separator:a245ee92bf58156a8a5bb45a291005c9b inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090f6be0ae24f31b82e895c565548cfa inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a090f6be0ae24f31b82e895c565548cfa">OpBuilder</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> *region, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *<a class="el" href="classmlir_1_1OpBuilder.html#a8bcc0eaf26c14812815b8b4d047d42b9">listener</a>=nullptr)</td></tr>
<tr class="memdesc:a090f6be0ae24f31b82e895c565548cfa inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a builder and set the insertion point to the start of the region.  <a href="classmlir_1_1OpBuilder.html#a090f6be0ae24f31b82e895c565548cfa">More...</a><br /></td></tr>
<tr class="separator:a090f6be0ae24f31b82e895c565548cfa inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70985fb2cb05aecda60bfd0386cec307 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a70985fb2cb05aecda60bfd0386cec307">OpBuilder</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *<a class="el" href="classmlir_1_1OpBuilder.html#a8bcc0eaf26c14812815b8b4d047d42b9">listener</a>=nullptr)</td></tr>
<tr class="separator:a70985fb2cb05aecda60bfd0386cec307 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89168853412a0ce71a3860889ccf6dc9 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a89168853412a0ce71a3860889ccf6dc9">OpBuilder</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *<a class="el" href="classmlir_1_1OpBuilder.html#a8bcc0eaf26c14812815b8b4d047d42b9">listener</a>=nullptr)</td></tr>
<tr class="memdesc:a89168853412a0ce71a3860889ccf6dc9 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a builder and set insertion point to the given operation, which will cause subsequent insertions to go right before it.  <a href="classmlir_1_1OpBuilder.html#a89168853412a0ce71a3860889ccf6dc9">More...</a><br /></td></tr>
<tr class="separator:a89168853412a0ce71a3860889ccf6dc9 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876650f4cff966d33041f6d1954fb9ce inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a876650f4cff966d33041f6d1954fb9ce">OpBuilder</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> insertPoint, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *<a class="el" href="classmlir_1_1OpBuilder.html#a8bcc0eaf26c14812815b8b4d047d42b9">listener</a>=nullptr)</td></tr>
<tr class="separator:a876650f4cff966d33041f6d1954fb9ce inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d81ba0de04d9847800a26cb5bb1c83a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a3d81ba0de04d9847800a26cb5bb1c83a">setListener</a> (<a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *newListener)</td></tr>
<tr class="memdesc:a3d81ba0de04d9847800a26cb5bb1c83a inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the listener of this builder to the one provided.  <a href="classmlir_1_1OpBuilder.html#a3d81ba0de04d9847800a26cb5bb1c83a">More...</a><br /></td></tr>
<tr class="separator:a3d81ba0de04d9847800a26cb5bb1c83a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6126964a574a6d7b91d5288f2c05c42a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a6126964a574a6d7b91d5288f2c05c42a">getListener</a> () const</td></tr>
<tr class="memdesc:a6126964a574a6d7b91d5288f2c05c42a inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current listener of this builder, or nullptr if this builder doesn't have a listener.  <a href="classmlir_1_1OpBuilder.html#a6126964a574a6d7b91d5288f2c05c42a">More...</a><br /></td></tr>
<tr class="separator:a6126964a574a6d7b91d5288f2c05c42a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d8baf1c2e30971db34b30a90e1be6d inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a29d8baf1c2e30971db34b30a90e1be6d">clearInsertionPoint</a> ()</td></tr>
<tr class="memdesc:a29d8baf1c2e30971db34b30a90e1be6d inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the insertion point to no location.  <a href="classmlir_1_1OpBuilder.html#a29d8baf1c2e30971db34b30a90e1be6d">More...</a><br /></td></tr>
<tr class="separator:a29d8baf1c2e30971db34b30a90e1be6d inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02eded6623aa092edee1a9a1c5514721 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpBuilder_1_1InsertPoint.html">InsertPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a02eded6623aa092edee1a9a1c5514721">saveInsertionPoint</a> () const</td></tr>
<tr class="memdesc:a02eded6623aa092edee1a9a1c5514721 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a saved insertion point.  <a href="classmlir_1_1OpBuilder.html#a02eded6623aa092edee1a9a1c5514721">More...</a><br /></td></tr>
<tr class="separator:a02eded6623aa092edee1a9a1c5514721 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a1e767cb511f2ac91c2509198cb0a8 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a60a1e767cb511f2ac91c2509198cb0a8">restoreInsertionPoint</a> (<a class="el" href="classmlir_1_1OpBuilder_1_1InsertPoint.html">InsertPoint</a> ip)</td></tr>
<tr class="memdesc:a60a1e767cb511f2ac91c2509198cb0a8 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the insert point to a previously saved point.  <a href="classmlir_1_1OpBuilder.html#a60a1e767cb511f2ac91c2509198cb0a8">More...</a><br /></td></tr>
<tr class="separator:a60a1e767cb511f2ac91c2509198cb0a8 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4853433035d219e56febdb51d1b531cd inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a4853433035d219e56febdb51d1b531cd">setInsertionPoint</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> insertPoint)</td></tr>
<tr class="memdesc:a4853433035d219e56febdb51d1b531cd inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the insertion point to the specified location.  <a href="classmlir_1_1OpBuilder.html#a4853433035d219e56febdb51d1b531cd">More...</a><br /></td></tr>
<tr class="separator:a4853433035d219e56febdb51d1b531cd inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c80a9fbc00dc28ab4a411eee5c9b1ef inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a4c80a9fbc00dc28ab4a411eee5c9b1ef">setInsertionPoint</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a4c80a9fbc00dc28ab4a411eee5c9b1ef inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the insertion point to the specified operation, which will cause subsequent insertions to go right before it.  <a href="classmlir_1_1OpBuilder.html#a4c80a9fbc00dc28ab4a411eee5c9b1ef">More...</a><br /></td></tr>
<tr class="separator:a4c80a9fbc00dc28ab4a411eee5c9b1ef inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2bfec2b8f9c2a505a98da5252196b0 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#acd2bfec2b8f9c2a505a98da5252196b0">setInsertionPointAfter</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:acd2bfec2b8f9c2a505a98da5252196b0 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the insertion point to the node after the specified operation, which will cause subsequent insertions to go right after it.  <a href="classmlir_1_1OpBuilder.html#acd2bfec2b8f9c2a505a98da5252196b0">More...</a><br /></td></tr>
<tr class="separator:acd2bfec2b8f9c2a505a98da5252196b0 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40d8422df722bf8ba11cb360adb0534 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#ac40d8422df722bf8ba11cb360adb0534">setInsertionPointAfterValue</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:ac40d8422df722bf8ba11cb360adb0534 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the insertion point to the node after the specified value.  <a href="classmlir_1_1OpBuilder.html#ac40d8422df722bf8ba11cb360adb0534">More...</a><br /></td></tr>
<tr class="separator:ac40d8422df722bf8ba11cb360adb0534 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef0d1056cf6968a09f4989cdf12e176 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a3ef0d1056cf6968a09f4989cdf12e176">setInsertionPointToStart</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:a3ef0d1056cf6968a09f4989cdf12e176 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the insertion point to the start of the specified block.  <a href="classmlir_1_1OpBuilder.html#a3ef0d1056cf6968a09f4989cdf12e176">More...</a><br /></td></tr>
<tr class="separator:a3ef0d1056cf6968a09f4989cdf12e176 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff4c0abb5c98e53a3de90a8593026a9 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a5ff4c0abb5c98e53a3de90a8593026a9">setInsertionPointToEnd</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:a5ff4c0abb5c98e53a3de90a8593026a9 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the insertion point to the end of the specified block.  <a href="classmlir_1_1OpBuilder.html#a5ff4c0abb5c98e53a3de90a8593026a9">More...</a><br /></td></tr>
<tr class="separator:a5ff4c0abb5c98e53a3de90a8593026a9 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0f1df3c5d95482661b05b9944096c5 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#aef0f1df3c5d95482661b05b9944096c5">getInsertionBlock</a> () const</td></tr>
<tr class="memdesc:aef0f1df3c5d95482661b05b9944096c5 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the block the current insertion point belongs to.  <a href="classmlir_1_1OpBuilder.html#aef0f1df3c5d95482661b05b9944096c5">More...</a><br /></td></tr>
<tr class="separator:aef0f1df3c5d95482661b05b9944096c5 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fe4674bc755659cb9d09131c713ebc inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a10fe4674bc755659cb9d09131c713ebc">getInsertionPoint</a> () const</td></tr>
<tr class="memdesc:a10fe4674bc755659cb9d09131c713ebc inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current insertion point of the builder.  <a href="classmlir_1_1OpBuilder.html#a10fe4674bc755659cb9d09131c713ebc">More...</a><br /></td></tr>
<tr class="separator:a10fe4674bc755659cb9d09131c713ebc inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa712737d7fe61de6b4a5d3d8bffc9ab2 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#aa712737d7fe61de6b4a5d3d8bffc9ab2">getBlock</a> () const</td></tr>
<tr class="memdesc:aa712737d7fe61de6b4a5d3d8bffc9ab2 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current block of the builder.  <a href="classmlir_1_1OpBuilder.html#aa712737d7fe61de6b4a5d3d8bffc9ab2">More...</a><br /></td></tr>
<tr class="separator:aa712737d7fe61de6b4a5d3d8bffc9ab2 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a30a533645a0fda72f3a1b89c384be1 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a1a30a533645a0fda72f3a1b89c384be1">createBlock</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> *parent, <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> insertPt={}, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> argTypes={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; locs={})</td></tr>
<tr class="memdesc:a1a30a533645a0fda72f3a1b89c384be1 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new block with 'argTypes' arguments and set the insertion point to the end of it.  <a href="classmlir_1_1OpBuilder.html#a1a30a533645a0fda72f3a1b89c384be1">More...</a><br /></td></tr>
<tr class="separator:a1a30a533645a0fda72f3a1b89c384be1 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c60f784f86b090736135b93b9d0218 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a25c60f784f86b090736135b93b9d0218">createBlock</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *insertBefore, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> argTypes={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; locs={})</td></tr>
<tr class="memdesc:a25c60f784f86b090736135b93b9d0218 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new block with 'argTypes' arguments and set the insertion point to the end of it.  <a href="classmlir_1_1OpBuilder.html#a25c60f784f86b090736135b93b9d0218">More...</a><br /></td></tr>
<tr class="separator:a25c60f784f86b090736135b93b9d0218 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9f73b5462b5606846ccc58f985cf4f inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#aea9f73b5462b5606846ccc58f985cf4f">insert</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:aea9f73b5462b5606846ccc58f985cf4f inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given operation at the current insertion point and return it.  <a href="classmlir_1_1OpBuilder.html#aea9f73b5462b5606846ccc58f985cf4f">More...</a><br /></td></tr>
<tr class="separator:aea9f73b5462b5606846ccc58f985cf4f inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a6edadd39800db410864ef06a004b2 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#ac6a6edadd39800db410864ef06a004b2">create</a> (const <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;state)</td></tr>
<tr class="memdesc:ac6a6edadd39800db410864ef06a004b2 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation given the fields represented as an <a class="el" href="structmlir_1_1OperationState.html" title="This represents an operation in an abstracted form, suitable for use with the builder APIs.">OperationState</a>.  <a href="classmlir_1_1OpBuilder.html#ac6a6edadd39800db410864ef06a004b2">More...</a><br /></td></tr>
<tr class="separator:ac6a6edadd39800db410864ef06a004b2 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc48b720754f906005f4ed8f744a3d4 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a5bc48b720754f906005f4ed8f744a3d4">create</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, StringAttr opName, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt; attributes={}, <a class="el" href="classmlir_1_1BlockRange.html">BlockRange</a> successors={}, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; std::unique_ptr&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&gt; regions={})</td></tr>
<tr class="memdesc:a5bc48b720754f906005f4ed8f744a3d4 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation with the given fields.  <a href="classmlir_1_1OpBuilder.html#a5bc48b720754f906005f4ed8f744a3d4">More...</a><br /></td></tr>
<tr class="separator:a5bc48b720754f906005f4ed8f744a3d4 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879310e19a53b06e60a2622a6177af8a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:a879310e19a53b06e60a2622a6177af8a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplItemLeft" align="right" valign="top">OpTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a879310e19a53b06e60a2622a6177af8a">create</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> location, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a879310e19a53b06e60a2622a6177af8a inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an operation of specific op type at the current insertion point.  <a href="classmlir_1_1OpBuilder.html#a879310e19a53b06e60a2622a6177af8a">More...</a><br /></td></tr>
<tr class="separator:a879310e19a53b06e60a2622a6177af8a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfa9ca1c08777d5eba6276c24c0cf9a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:a9bfa9ca1c08777d5eba6276c24c0cf9a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a9bfa9ca1c08777d5eba6276c24c0cf9a">createOrFold</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;results, <a class="el" href="classmlir_1_1Location.html">Location</a> location, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a9bfa9ca1c08777d5eba6276c24c0cf9a inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an operation of specific op type at the current insertion point, and immediately try to fold it.  <a href="classmlir_1_1OpBuilder.html#a9bfa9ca1c08777d5eba6276c24c0cf9a">More...</a><br /></td></tr>
<tr class="separator:a9bfa9ca1c08777d5eba6276c24c0cf9a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25f940dbc533c64e7809a64a136b30a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:aa25f940dbc533c64e7809a64a136b30a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OpTy::template hasTrait&lt; <a class="el" href="classmlir_1_1OpTrait_1_1OneResult.html">OpTrait::OneResult</a> &gt;), <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#aa25f940dbc533c64e7809a64a136b30a">createOrFold</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> location, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:aa25f940dbc533c64e7809a64a136b30a inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload to create or fold a single result operation.  <a href="classmlir_1_1OpBuilder.html#aa25f940dbc533c64e7809a64a136b30a">More...</a><br /></td></tr>
<tr class="separator:aa25f940dbc533c64e7809a64a136b30a inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc986f724e5ed7c98c8a0c08f5c6235 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:a9bc986f724e5ed7c98c8a0c08f5c6235 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; OpTy::template hasTrait&lt; <a class="el" href="classmlir_1_1OpTrait_1_1ZeroResults.html">OpTrait::ZeroResults</a> &gt;), OpTy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a9bc986f724e5ed7c98c8a0c08f5c6235">createOrFold</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> location, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a9bc986f724e5ed7c98c8a0c08f5c6235 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload to create or fold a zero result operation.  <a href="classmlir_1_1OpBuilder.html#a9bc986f724e5ed7c98c8a0c08f5c6235">More...</a><br /></td></tr>
<tr class="separator:a9bc986f724e5ed7c98c8a0c08f5c6235 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2e6e15f9290f652919514ea93a711f inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a8b2e6e15f9290f652919514ea93a711f">tryFold</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;results, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *materializedConstants=nullptr)</td></tr>
<tr class="memdesc:a8b2e6e15f9290f652919514ea93a711f inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to fold the given operation and places new results within <code>results</code>.  <a href="classmlir_1_1OpBuilder.html#a8b2e6e15f9290f652919514ea93a711f">More...</a><br /></td></tr>
<tr class="separator:a8b2e6e15f9290f652919514ea93a711f inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394cad81296b42a24e1c37b045e15359 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a394cad81296b42a24e1c37b045e15359">clone</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapper)</td></tr>
<tr class="memdesc:a394cad81296b42a24e1c37b045e15359 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of the specified operation, remapping any operands that use values outside of the operation using the map that is provided ( leaving them alone if no entry is present).  <a href="classmlir_1_1OpBuilder.html#a394cad81296b42a24e1c37b045e15359">More...</a><br /></td></tr>
<tr class="separator:a394cad81296b42a24e1c37b045e15359 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e70a2262a26f1f73610f421a4c5f8e inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#ae2e70a2262a26f1f73610f421a4c5f8e">clone</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op)</td></tr>
<tr class="separator:ae2e70a2262a26f1f73610f421a4c5f8e inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5436a9553c7da3aa6d47b6b416916e inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#aee5436a9553c7da3aa6d47b6b416916e">cloneWithoutRegions</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapper)</td></tr>
<tr class="memdesc:aee5436a9553c7da3aa6d47b6b416916e inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this operation but keep the operation regions empty.  <a href="classmlir_1_1OpBuilder.html#aee5436a9553c7da3aa6d47b6b416916e">More...</a><br /></td></tr>
<tr class="separator:aee5436a9553c7da3aa6d47b6b416916e inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12998920bce0716f955818d0f3aa240d inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a12998920bce0716f955818d0f3aa240d">cloneWithoutRegions</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op)</td></tr>
<tr class="separator:a12998920bce0716f955818d0f3aa240d inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22db34c9d8628024441dc89ae09eb384 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplParams" colspan="2">template&lt;typename OpT &gt; </td></tr>
<tr class="memitem:a22db34c9d8628024441dc89ae09eb384 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memTemplItemLeft" align="right" valign="top">OpT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a22db34c9d8628024441dc89ae09eb384">cloneWithoutRegions</a> (OpT op)</td></tr>
<tr class="separator:a22db34c9d8628024441dc89ae09eb384 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e4f0acdeb3065333057dcac9949404 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a79e4f0acdeb3065333057dcac9949404">cloneRegionBefore</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;parent, <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> before, <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapping)</td></tr>
<tr class="memdesc:a79e4f0acdeb3065333057dcac9949404 inherit pub_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the blocks that belong to "region" before the given position in another region "parent".  <a href="classmlir_1_1OpBuilder.html#a79e4f0acdeb3065333057dcac9949404">More...</a><br /></td></tr>
<tr class="separator:a79e4f0acdeb3065333057dcac9949404 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846d9970abf379b19a049301ac70db06 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a846d9970abf379b19a049301ac70db06">cloneRegionBefore</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;parent, <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> before)</td></tr>
<tr class="separator:a846d9970abf379b19a049301ac70db06 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a862538836eafbb4207a99b9e93b72 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a43a862538836eafbb4207a99b9e93b72">cloneRegionBefore</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Block.html">Block</a> *before)</td></tr>
<tr class="separator:a43a862538836eafbb4207a99b9e93b72 inherit pub_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1Builder"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1Builder')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1Builder.html">mlir::Builder</a></td></tr>
<tr class="memitem:a826c8a69e4eb96b4f88ec839bef2d277 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a826c8a69e4eb96b4f88ec839bef2d277">Builder</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *<a class="el" href="classmlir_1_1Builder.html#a825fc6884f9ad5ac24ff3871ac5db811">context</a>)</td></tr>
<tr class="separator:a826c8a69e4eb96b4f88ec839bef2d277 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e2fc4f0a55d99d41177d2f0d654ae7 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a83e2fc4f0a55d99d41177d2f0d654ae7">Builder</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:a83e2fc4f0a55d99d41177d2f0d654ae7 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d1e114c8047cad1b014b504688a868 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aa6d1e114c8047cad1b014b504688a868">getContext</a> () const</td></tr>
<tr class="separator:aa6d1e114c8047cad1b014b504688a868 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a2a66c362dcd5e58f46508e4ce53ea inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ac9a2a66c362dcd5e58f46508e4ce53ea">getUnknownLoc</a> ()</td></tr>
<tr class="separator:ac9a2a66c362dcd5e58f46508e4ce53ea inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93df8270f308f1762fd9a3010a0aeb54 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a93df8270f308f1762fd9a3010a0aeb54">getFusedLoc</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; locs, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> metadata=<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>())</td></tr>
<tr class="separator:a93df8270f308f1762fd9a3010a0aeb54 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac728457337682b3f351e1e0a187d9c3 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aac728457337682b3f351e1e0a187d9c3">getF8E8M0Type</a> ()</td></tr>
<tr class="separator:aac728457337682b3f351e1e0a187d9c3 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99814a27f341d60847303ee8b3b276ed inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a99814a27f341d60847303ee8b3b276ed">getBF16Type</a> ()</td></tr>
<tr class="separator:a99814a27f341d60847303ee8b3b276ed inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909a9688bbdedc91cd60043a5a90ba8a inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a909a9688bbdedc91cd60043a5a90ba8a">getF16Type</a> ()</td></tr>
<tr class="separator:a909a9688bbdedc91cd60043a5a90ba8a inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f4a9321ef1ec99bd38d20d5e3708ec inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a25f4a9321ef1ec99bd38d20d5e3708ec">getTF32Type</a> ()</td></tr>
<tr class="separator:a25f4a9321ef1ec99bd38d20d5e3708ec inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a4a2d4767557f4dad38a4c5350ca4b inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a22a4a2d4767557f4dad38a4c5350ca4b">getF32Type</a> ()</td></tr>
<tr class="separator:a22a4a2d4767557f4dad38a4c5350ca4b inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21066e4cd1efbe5ed7801fb8f93755f inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#af21066e4cd1efbe5ed7801fb8f93755f">getF64Type</a> ()</td></tr>
<tr class="separator:af21066e4cd1efbe5ed7801fb8f93755f inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cbcce8f79a98541c0c76ecbd56a0bc inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a14cbcce8f79a98541c0c76ecbd56a0bc">getF80Type</a> ()</td></tr>
<tr class="separator:a14cbcce8f79a98541c0c76ecbd56a0bc inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1543bead785963a54eb35f3cbcc27f4e inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a1543bead785963a54eb35f3cbcc27f4e">getF128Type</a> ()</td></tr>
<tr class="separator:a1543bead785963a54eb35f3cbcc27f4e inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace585fd315aa2ebcc7bb87e18483f5b4 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ace585fd315aa2ebcc7bb87e18483f5b4">getIndexType</a> ()</td></tr>
<tr class="separator:ace585fd315aa2ebcc7bb87e18483f5b4 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68228481d9deafab913889e4fb01886 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ac68228481d9deafab913889e4fb01886">getI1Type</a> ()</td></tr>
<tr class="separator:ac68228481d9deafab913889e4fb01886 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136116f631ade6524d17f1faf569e807 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a136116f631ade6524d17f1faf569e807">getI2Type</a> ()</td></tr>
<tr class="separator:a136116f631ade6524d17f1faf569e807 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80362ddd9476547f615f7d92cfdebd36 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a80362ddd9476547f615f7d92cfdebd36">getI4Type</a> ()</td></tr>
<tr class="separator:a80362ddd9476547f615f7d92cfdebd36 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0a967cff48476dd805b9f320e8b4f2 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#acf0a967cff48476dd805b9f320e8b4f2">getI8Type</a> ()</td></tr>
<tr class="separator:acf0a967cff48476dd805b9f320e8b4f2 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097f1a9d19ce0db0486814cfb5b529fc inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a097f1a9d19ce0db0486814cfb5b529fc">getI16Type</a> ()</td></tr>
<tr class="separator:a097f1a9d19ce0db0486814cfb5b529fc inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6290adcfa7712b7f5c9cf84a068c6b02 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a6290adcfa7712b7f5c9cf84a068c6b02">getI32Type</a> ()</td></tr>
<tr class="separator:a6290adcfa7712b7f5c9cf84a068c6b02 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeb6bdf570be01405614c0ef5ff210f inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a5eeb6bdf570be01405614c0ef5ff210f">getI64Type</a> ()</td></tr>
<tr class="separator:a5eeb6bdf570be01405614c0ef5ff210f inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6658537562d6415b98373760c06b36d6 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a6658537562d6415b98373760c06b36d6">getIntegerType</a> (unsigned width)</td></tr>
<tr class="separator:a6658537562d6415b98373760c06b36d6 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad156864dbcd76ccad2ffe29493258d81 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ad156864dbcd76ccad2ffe29493258d81">getIntegerType</a> (unsigned width, bool isSigned)</td></tr>
<tr class="separator:ad156864dbcd76ccad2ffe29493258d81 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e44a1083e200c0aea501f30f4ddc62c inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FunctionType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a5e44a1083e200c0aea501f30f4ddc62c">getFunctionType</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> inputs, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> results)</td></tr>
<tr class="separator:a5e44a1083e200c0aea501f30f4ddc62c inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26001422e6f097cd30c6ada96cb44bc0 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">TupleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a26001422e6f097cd30c6ada96cb44bc0">getTupleType</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> elementTypes)</td></tr>
<tr class="separator:a26001422e6f097cd30c6ada96cb44bc0 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690c894559415eb666eb033a7dde5ad4 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">NoneType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a690c894559415eb666eb033a7dde5ad4">getNoneType</a> ()</td></tr>
<tr class="separator:a690c894559415eb666eb033a7dde5ad4 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc808173f53bdf075e41615577118b8 inherit pub_methods_classmlir_1_1Builder"><td class="memTemplParams" colspan="2">template&lt;typename Ty , typename... Args&gt; </td></tr>
<tr class="memitem:a7bc808173f53bdf075e41615577118b8 inherit pub_methods_classmlir_1_1Builder"><td class="memTemplItemLeft" align="right" valign="top">Ty&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a7bc808173f53bdf075e41615577118b8">getType</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a7bc808173f53bdf075e41615577118b8 inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or construct an instance of the type <code>Ty</code> with provided arguments.  <a href="classmlir_1_1Builder.html#a7bc808173f53bdf075e41615577118b8">More...</a><br /></td></tr>
<tr class="separator:a7bc808173f53bdf075e41615577118b8 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe41eef576c731d4197fe55fd61bd150 inherit pub_methods_classmlir_1_1Builder"><td class="memTemplParams" colspan="2">template&lt;typename Attr , typename... Args&gt; </td></tr>
<tr class="memitem:afe41eef576c731d4197fe55fd61bd150 inherit pub_methods_classmlir_1_1Builder"><td class="memTemplItemLeft" align="right" valign="top">Attr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#afe41eef576c731d4197fe55fd61bd150">getAttr</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:afe41eef576c731d4197fe55fd61bd150 inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or construct an instance of the attribute <code>Attr</code> with provided arguments.  <a href="classmlir_1_1Builder.html#afe41eef576c731d4197fe55fd61bd150">More...</a><br /></td></tr>
<tr class="separator:afe41eef576c731d4197fe55fd61bd150 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc5d3d4b21950f70e95fcd1a6584514 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#adbc5d3d4b21950f70e95fcd1a6584514">getNamedAttr</a> (StringRef name, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> val)</td></tr>
<tr class="separator:adbc5d3d4b21950f70e95fcd1a6584514 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba94155c8438c805c7bf379d79d36c5 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">UnitAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a0ba94155c8438c805c7bf379d79d36c5">getUnitAttr</a> ()</td></tr>
<tr class="separator:a0ba94155c8438c805c7bf379d79d36c5 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1415e9c02ceddb2baa2c6bbbad4695 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BoolAttr.html">BoolAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a7c1415e9c02ceddb2baa2c6bbbad4695">getBoolAttr</a> (bool value)</td></tr>
<tr class="separator:a7c1415e9c02ceddb2baa2c6bbbad4695 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4223706459ecde5d8c35783aafcff5c inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">DictionaryAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ad4223706459ecde5d8c35783aafcff5c">getDictionaryAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt; value)</td></tr>
<tr class="separator:ad4223706459ecde5d8c35783aafcff5c inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d04960e3b45799682ba40009a1201a inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a28d04960e3b45799682ba40009a1201a">getIntegerAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, int64_t value)</td></tr>
<tr class="separator:a28d04960e3b45799682ba40009a1201a inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b904aeae73bec8c25e402016bc7c162 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a9b904aeae73bec8c25e402016bc7c162">getIntegerAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const APInt &amp;value)</td></tr>
<tr class="separator:a9b904aeae73bec8c25e402016bc7c162 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dda5590e9c173d5b7813095640b4199 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a4dda5590e9c173d5b7813095640b4199">getFloatAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, double value)</td></tr>
<tr class="separator:a4dda5590e9c173d5b7813095640b4199 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73da014f35177bf242a185ebceb25066 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a73da014f35177bf242a185ebceb25066">getFloatAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, const APFloat &amp;value)</td></tr>
<tr class="separator:a73da014f35177bf242a185ebceb25066 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c9b2b69671833b1036e3c2a4542ff4 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">StringAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a81c9b2b69671833b1036e3c2a4542ff4">getStringAttr</a> (const Twine &amp;bytes)</td></tr>
<tr class="separator:a81c9b2b69671833b1036e3c2a4542ff4 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e0170e1b16f9c7464823b7b2fcb042 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ac9e0170e1b16f9c7464823b7b2fcb042">getArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; value)</td></tr>
<tr class="separator:ac9e0170e1b16f9c7464823b7b2fcb042 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e943986e58a8b0c88fcd51b0f0afafb inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">TypedAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a8e943986e58a8b0c88fcd51b0f0afafb">getZeroAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:a8e943986e58a8b0c88fcd51b0f0afafb inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5694e1820d98001a3b7d601694f0f5 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">TypedAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#afe5694e1820d98001a3b7d601694f0f5">getOneAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:afe5694e1820d98001a3b7d601694f0f5 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c56ae3e02345334101a0c93171b50d inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a32c56ae3e02345334101a0c93171b50d">getF16FloatAttr</a> (float value)</td></tr>
<tr class="separator:a32c56ae3e02345334101a0c93171b50d inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd243c1ec9a8c264fa9cc9e7dfdeb01 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#acfd243c1ec9a8c264fa9cc9e7dfdeb01">getF32FloatAttr</a> (float value)</td></tr>
<tr class="separator:acfd243c1ec9a8c264fa9cc9e7dfdeb01 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1a58ca9d0d2ba4819b8fd5db67f13d inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">FloatAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a2b1a58ca9d0d2ba4819b8fd5db67f13d">getF64FloatAttr</a> (double value)</td></tr>
<tr class="separator:a2b1a58ca9d0d2ba4819b8fd5db67f13d inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7b8d95ff2cfbd7092ae80db1682386 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aee7b8d95ff2cfbd7092ae80db1682386">getI8IntegerAttr</a> (int8_t value)</td></tr>
<tr class="separator:aee7b8d95ff2cfbd7092ae80db1682386 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4440d4fedcb8ebc61b33eb771fbc7f7c inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a4440d4fedcb8ebc61b33eb771fbc7f7c">getI16IntegerAttr</a> (int16_t value)</td></tr>
<tr class="separator:a4440d4fedcb8ebc61b33eb771fbc7f7c inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6e1fd34a9a089a70b6d3e4bb3b1afe inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a1a6e1fd34a9a089a70b6d3e4bb3b1afe">getI32IntegerAttr</a> (int32_t value)</td></tr>
<tr class="separator:a1a6e1fd34a9a089a70b6d3e4bb3b1afe inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646e4cb04618d56320ba37cb51c91be2 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a646e4cb04618d56320ba37cb51c91be2">getI64IntegerAttr</a> (int64_t value)</td></tr>
<tr class="separator:a646e4cb04618d56320ba37cb51c91be2 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06091b945ff2912cc077219350944b33 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a06091b945ff2912cc077219350944b33">getIndexAttr</a> (int64_t value)</td></tr>
<tr class="separator:a06091b945ff2912cc077219350944b33 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccbf998590e8215c99ccd0676bd804c inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a8ccbf998590e8215c99ccd0676bd804c">getSI32IntegerAttr</a> (int32_t value)</td></tr>
<tr class="memdesc:a8ccbf998590e8215c99ccd0676bd804c inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed and unsigned integer attribute getters.  <a href="classmlir_1_1Builder.html#a8ccbf998590e8215c99ccd0676bd804c">More...</a><br /></td></tr>
<tr class="separator:a8ccbf998590e8215c99ccd0676bd804c inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2ab0152483e78be2569eb7116bd99a inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">IntegerAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#adf2ab0152483e78be2569eb7116bd99a">getUI32IntegerAttr</a> (uint32_t value)</td></tr>
<tr class="separator:adf2ab0152483e78be2569eb7116bd99a inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224248e0bdaf028d56c3211343ff4e16 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a224248e0bdaf028d56c3211343ff4e16">getBoolVectorAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt; values)</td></tr>
<tr class="memdesc:a224248e0bdaf028d56c3211343ff4e16 inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector-typed <a class="el" href="classmlir_1_1DenseIntElementsAttr.html" title="An attribute that represents a reference to a dense integer vector or tensor object.">DenseIntElementsAttr</a> getters. <code>values</code> must not be empty.  <a href="classmlir_1_1Builder.html#a224248e0bdaf028d56c3211343ff4e16">More...</a><br /></td></tr>
<tr class="separator:a224248e0bdaf028d56c3211343ff4e16 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbb8249c04591c13ea5e460cc29132a inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aacbb8249c04591c13ea5e460cc29132a">getI32VectorAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int32_t &gt; values)</td></tr>
<tr class="separator:aacbb8249c04591c13ea5e460cc29132a inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab760708fd8802a3274d080d19ac15f98 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ab760708fd8802a3274d080d19ac15f98">getI64VectorAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="separator:ab760708fd8802a3274d080d19ac15f98 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af831b0dc7dd75d7069ff96e7f7218f05 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#af831b0dc7dd75d7069ff96e7f7218f05">getIndexVectorAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="separator:af831b0dc7dd75d7069ff96e7f7218f05 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d29deb5493b2c508d967483aaa7c518 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseFPElementsAttr.html">DenseFPElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a4d29deb5493b2c508d967483aaa7c518">getF32VectorAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; float &gt; values)</td></tr>
<tr class="separator:a4d29deb5493b2c508d967483aaa7c518 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac943184cc07285302eaca0d6c2b43296 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseFPElementsAttr.html">DenseFPElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ac943184cc07285302eaca0d6c2b43296">getF64VectorAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; double &gt; values)</td></tr>
<tr class="separator:ac943184cc07285302eaca0d6c2b43296 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557059365d9158704d2cd9c0f137a387 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a557059365d9158704d2cd9c0f137a387">getI32TensorAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int32_t &gt; values)</td></tr>
<tr class="memdesc:a557059365d9158704d2cd9c0f137a387 inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor-typed <a class="el" href="classmlir_1_1DenseIntElementsAttr.html" title="An attribute that represents a reference to a dense integer vector or tensor object.">DenseIntElementsAttr</a> getters.  <a href="classmlir_1_1Builder.html#a557059365d9158704d2cd9c0f137a387">More...</a><br /></td></tr>
<tr class="separator:a557059365d9158704d2cd9c0f137a387 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7654e378a8f6e3ec0bc098303aa84a02 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a7654e378a8f6e3ec0bc098303aa84a02">getI64TensorAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="separator:a7654e378a8f6e3ec0bc098303aa84a02 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31beecf247ee57c3378e9b39e2377d2 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aa31beecf247ee57c3378e9b39e2377d2">getIndexTensorAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="separator:aa31beecf247ee57c3378e9b39e2377d2 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbec69fc1de84da6d48c60d21df1621e inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a7dffb2feeebaff96012a0f11534ecb42">DenseBoolArrayAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#acbec69fc1de84da6d48c60d21df1621e">getDenseBoolArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt; values)</td></tr>
<tr class="memdesc:acbec69fc1de84da6d48c60d21df1621e inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor-typed DenseArrayAttr getters.  <a href="classmlir_1_1Builder.html#acbec69fc1de84da6d48c60d21df1621e">More...</a><br /></td></tr>
<tr class="separator:acbec69fc1de84da6d48c60d21df1621e inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182b43af9f71d90f46dde1c4ecd6ae85 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#ab90796fd9f1813081632c1402c9ab0f5">DenseI8ArrayAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a182b43af9f71d90f46dde1c4ecd6ae85">getDenseI8ArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int8_t &gt; values)</td></tr>
<tr class="separator:a182b43af9f71d90f46dde1c4ecd6ae85 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474ad83ea4900a0f49433ed19f0e5c1d inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a684fa3991fcdc7c970ec8a74aa461a77">DenseI16ArrayAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a474ad83ea4900a0f49433ed19f0e5c1d">getDenseI16ArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int16_t &gt; values)</td></tr>
<tr class="separator:a474ad83ea4900a0f49433ed19f0e5c1d inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac0b9cf473f1ffe21bf7b2fa13be825 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#ace9107ae5cb34fa1aa00e0fd1377ad89">DenseI32ArrayAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a1ac0b9cf473f1ffe21bf7b2fa13be825">getDenseI32ArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int32_t &gt; values)</td></tr>
<tr class="separator:a1ac0b9cf473f1ffe21bf7b2fa13be825 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e87b13185818c1d74cbb65df7d7dcfa inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a2e87b13185818c1d74cbb65df7d7dcfa">getDenseI64ArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="separator:a2e87b13185818c1d74cbb65df7d7dcfa inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab453d35ba0e98cc6f569006389a61da8 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a057c3db4d18f7bc0ebd0e5943ab4f6f8">DenseF32ArrayAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ab453d35ba0e98cc6f569006389a61da8">getDenseF32ArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; float &gt; values)</td></tr>
<tr class="separator:ab453d35ba0e98cc6f569006389a61da8 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122bbc9eebe146dc94a6049a5dafd2d0 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#accd8e5d82c207ff36cbbf5abad9ca288">DenseF64ArrayAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a122bbc9eebe146dc94a6049a5dafd2d0">getDenseF64ArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; double &gt; values)</td></tr>
<tr class="separator:a122bbc9eebe146dc94a6049a5dafd2d0 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad513744f9110000663ed9e0a92baa2 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#afad513744f9110000663ed9e0a92baa2">getAffineMapArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; values)</td></tr>
<tr class="separator:afad513744f9110000663ed9e0a92baa2 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40fe132a1059a68679775fa4c06666b inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#af40fe132a1059a68679775fa4c06666b">getBoolArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt; values)</td></tr>
<tr class="separator:af40fe132a1059a68679775fa4c06666b inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9bdaca0ca5495fd145156b03de3202 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a2d9bdaca0ca5495fd145156b03de3202">getI32ArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int32_t &gt; values)</td></tr>
<tr class="separator:a2d9bdaca0ca5495fd145156b03de3202 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd2d0313d6da2dca8c93872eac89889 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#acdd2d0313d6da2dca8c93872eac89889">getI64ArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="separator:acdd2d0313d6da2dca8c93872eac89889 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0deaca809030599e11054cf100680aec inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a0deaca809030599e11054cf100680aec">getIndexArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="separator:a0deaca809030599e11054cf100680aec inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeeb2f1dc3b6bc85aa6aac50db2520d5 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aeeeb2f1dc3b6bc85aa6aac50db2520d5">getF32ArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; float &gt; values)</td></tr>
<tr class="separator:aeeeb2f1dc3b6bc85aa6aac50db2520d5 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29b1d52fd544bda5e21b86122f2e7ec inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ac29b1d52fd544bda5e21b86122f2e7ec">getF64ArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; double &gt; values)</td></tr>
<tr class="separator:ac29b1d52fd544bda5e21b86122f2e7ec inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45a745880a80d38381fe94470acc9ef inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#af45a745880a80d38381fe94470acc9ef">getStrArrayAttr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; values)</td></tr>
<tr class="separator:af45a745880a80d38381fe94470acc9ef inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe1c29ec99bccf51c3bdfe6da4826c9 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top">ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aabe1c29ec99bccf51c3bdfe6da4826c9">getTypeArrayAttr</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> values)</td></tr>
<tr class="separator:aabe1c29ec99bccf51c3bdfe6da4826c9 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06e1494dca3f76c97dcbf0600439191 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aa06e1494dca3f76c97dcbf0600439191">getAffineDimExpr</a> (unsigned position)</td></tr>
<tr class="separator:aa06e1494dca3f76c97dcbf0600439191 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4834164298c925d6a2f4206634421506 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a4834164298c925d6a2f4206634421506">getAffineSymbolExpr</a> (unsigned position)</td></tr>
<tr class="separator:a4834164298c925d6a2f4206634421506 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532065b3a37e28c7bc34f1b78558b00e inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a532065b3a37e28c7bc34f1b78558b00e">getAffineConstantExpr</a> (int64_t constant)</td></tr>
<tr class="separator:a532065b3a37e28c7bc34f1b78558b00e inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d80016cf0c9ec35f0c0e12ab4328da inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a82d80016cf0c9ec35f0c0e12ab4328da">getEmptyAffineMap</a> ()</td></tr>
<tr class="memdesc:a82d80016cf0c9ec35f0c0e12ab4328da inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a zero result affine map with no dimensions or symbols: () -&gt; ().  <a href="classmlir_1_1Builder.html#a82d80016cf0c9ec35f0c0e12ab4328da">More...</a><br /></td></tr>
<tr class="separator:a82d80016cf0c9ec35f0c0e12ab4328da inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ba6cf21d1b7b3ad4fdcda81b4c1f8a inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#aa6ba6cf21d1b7b3ad4fdcda81b4c1f8a">getConstantAffineMap</a> (int64_t val)</td></tr>
<tr class="memdesc:aa6ba6cf21d1b7b3ad4fdcda81b4c1f8a inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single constant result affine map with 0 dimensions and 0 symbols.  <a href="classmlir_1_1Builder.html#aa6ba6cf21d1b7b3ad4fdcda81b4c1f8a">More...</a><br /></td></tr>
<tr class="separator:aa6ba6cf21d1b7b3ad4fdcda81b4c1f8a inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f55bf2d629ec55fdd702a185e89940b inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a3f55bf2d629ec55fdd702a185e89940b">getDimIdentityMap</a> ()</td></tr>
<tr class="separator:a3f55bf2d629ec55fdd702a185e89940b inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422a9ab33af4134efcb4044fb81deab1 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a422a9ab33af4134efcb4044fb81deab1">getMultiDimIdentityMap</a> (unsigned rank)</td></tr>
<tr class="separator:a422a9ab33af4134efcb4044fb81deab1 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b7c4759b2a291f442fbb1f966d5f05 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#ab7b7c4759b2a291f442fbb1f966d5f05">getSymbolIdentityMap</a> ()</td></tr>
<tr class="separator:ab7b7c4759b2a291f442fbb1f966d5f05 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07254e03f44bb2ca0960ccbe68665467 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a07254e03f44bb2ca0960ccbe68665467">getSingleDimShiftAffineMap</a> (int64_t shift)</td></tr>
<tr class="memdesc:a07254e03f44bb2ca0960ccbe68665467 inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map that shifts its (single) input dimension by 'shift'.  <a href="classmlir_1_1Builder.html#a07254e03f44bb2ca0960ccbe68665467">More...</a><br /></td></tr>
<tr class="separator:a07254e03f44bb2ca0960ccbe68665467 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5d5ea8815753c883ef11f5cc6880d6 inherit pub_methods_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a2b5d5ea8815753c883ef11f5cc6880d6">getShiftedAffineMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, int64_t shift)</td></tr>
<tr class="memdesc:a2b5d5ea8815753c883ef11f5cc6880d6 inherit pub_methods_classmlir_1_1Builder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an affine map that is a translation (shift) of all result expressions in 'map' by 'shift'.  <a href="classmlir_1_1Builder.html#a2b5d5ea8815753c883ef11f5cc6880d6">More...</a><br /></td></tr>
<tr class="separator:a2b5d5ea8815753c883ef11f5cc6880d6 inherit pub_methods_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9bf5c0ca227964c4017c0fd471c4777a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a9bf5c0ca227964c4017c0fd471c4777a">RewriterBase</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">OpBuilder::Listener</a> *<a class="el" href="classmlir_1_1OpBuilder.html#a8bcc0eaf26c14812815b8b4d047d42b9">listener</a>=nullptr)</td></tr>
<tr class="memdesc:a9bf5c0ca227964c4017c0fd471c4777a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the builder.  <a href="classmlir_1_1RewriterBase.html#a9bf5c0ca227964c4017c0fd471c4777a">More...</a><br /></td></tr>
<tr class="separator:a9bf5c0ca227964c4017c0fd471c4777a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55684591d9628c5db0b467ebea978701"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a55684591d9628c5db0b467ebea978701">RewriterBase</a> (const <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;otherBuilder)</td></tr>
<tr class="separator:a55684591d9628c5db0b467ebea978701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775e0a6b66376c4aa2fbde6354371b82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#a775e0a6b66376c4aa2fbde6354371b82">RewriterBase</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">OpBuilder::Listener</a> *<a class="el" href="classmlir_1_1OpBuilder.html#a8bcc0eaf26c14812815b8b4d047d42b9">listener</a>=nullptr)</td></tr>
<tr class="separator:a775e0a6b66376c4aa2fbde6354371b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7725fc446805838b8389b2a99ff2bc"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewriterBase.html#abc7725fc446805838b8389b2a99ff2bc">~RewriterBase</a> ()</td></tr>
<tr class="separator:abc7725fc446805838b8389b2a99ff2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1OpBuilder"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1OpBuilder')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1OpBuilder.html">mlir::OpBuilder</a></td></tr>
<tr class="memitem:a08466834f26b5779d3fbe3b86f02ff0d inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a08466834f26b5779d3fbe3b86f02ff0d">atBlockBegin</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *<a class="el" href="classmlir_1_1OpBuilder.html#a8bcc0eaf26c14812815b8b4d047d42b9">listener</a>=nullptr)</td></tr>
<tr class="memdesc:a08466834f26b5779d3fbe3b86f02ff0d inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a builder and set the insertion point to before the first operation in the block but still inside the block.  <a href="classmlir_1_1OpBuilder.html#a08466834f26b5779d3fbe3b86f02ff0d">More...</a><br /></td></tr>
<tr class="separator:a08466834f26b5779d3fbe3b86f02ff0d inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfda0879e254d7fde93ccd5811c2d8f inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a2cfda0879e254d7fde93ccd5811c2d8f">atBlockEnd</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *<a class="el" href="classmlir_1_1OpBuilder.html#a8bcc0eaf26c14812815b8b4d047d42b9">listener</a>=nullptr)</td></tr>
<tr class="memdesc:a2cfda0879e254d7fde93ccd5811c2d8f inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a builder and set the insertion point to after the last operation in the block but still inside the block.  <a href="classmlir_1_1OpBuilder.html#a2cfda0879e254d7fde93ccd5811c2d8f">More...</a><br /></td></tr>
<tr class="separator:a2cfda0879e254d7fde93ccd5811c2d8f inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb50a345347f2e8be33473ffc3df78e inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a5cb50a345347f2e8be33473ffc3df78e">atBlockTerminator</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *<a class="el" href="classmlir_1_1OpBuilder.html#a8bcc0eaf26c14812815b8b4d047d42b9">listener</a>=nullptr)</td></tr>
<tr class="memdesc:a5cb50a345347f2e8be33473ffc3df78e inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a builder and set the insertion point to before the block terminator.  <a href="classmlir_1_1OpBuilder.html#a5cb50a345347f2e8be33473ffc3df78e">More...</a><br /></td></tr>
<tr class="separator:a5cb50a345347f2e8be33473ffc3df78e inherit pub_static_methods_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmlir_1_1OpBuilder"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmlir_1_1OpBuilder')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmlir_1_1OpBuilder.html">mlir::OpBuilder</a></td></tr>
<tr class="memitem:a8bcc0eaf26c14812815b8b4d047d42b9 inherit pro_attribs_classmlir_1_1OpBuilder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">Listener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html#a8bcc0eaf26c14812815b8b4d047d42b9">listener</a></td></tr>
<tr class="memdesc:a8bcc0eaf26c14812815b8b4d047d42b9 inherit pro_attribs_classmlir_1_1OpBuilder"><td class="mdescLeft">&#160;</td><td class="mdescRight">The optional listener for events of this builder.  <a href="classmlir_1_1OpBuilder.html#a8bcc0eaf26c14812815b8b4d047d42b9">More...</a><br /></td></tr>
<tr class="separator:a8bcc0eaf26c14812815b8b4d047d42b9 inherit pro_attribs_classmlir_1_1OpBuilder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmlir_1_1Builder"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmlir_1_1Builder')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmlir_1_1Builder.html">mlir::Builder</a></td></tr>
<tr class="memitem:a825fc6884f9ad5ac24ff3871ac5db811 inherit pro_attribs_classmlir_1_1Builder"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html#a825fc6884f9ad5ac24ff3871ac5db811">context</a></td></tr>
<tr class="separator:a825fc6884f9ad5ac24ff3871ac5db811 inherit pro_attribs_classmlir_1_1Builder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class coordinates the application of a rewrite on a set of IR, providing a way for clients to track mutations and create new operations. </p>
<p>This class serves as a common API for IR mutation between pattern rewrites and non-pattern rewrites, and facilitates the development of shared IR transformation utilities. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00358">358</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9bf5c0ca227964c4017c0fd471c4777a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf5c0ca227964c4017c0fd471c4777a">&#9670;&nbsp;</a></span>RewriterBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::RewriterBase::RewriterBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">OpBuilder::Listener</a> *&#160;</td>
          <td class="paramname"><em>listener</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the builder. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00742">742</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="a55684591d9628c5db0b467ebea978701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55684591d9628c5db0b467ebea978701">&#9670;&nbsp;</a></span>RewriterBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::RewriterBase::RewriterBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>otherBuilder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00745">745</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="a775e0a6b66376c4aa2fbde6354371b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775e0a6b66376c4aa2fbde6354371b82">&#9670;&nbsp;</a></span>RewriterBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::RewriterBase::RewriterBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OpBuilder_1_1Listener.html">OpBuilder::Listener</a> *&#160;</td>
          <td class="paramname"><em>listener</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00747">747</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="abc7725fc446805838b8389b2a99ff2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7725fc446805838b8389b2a99ff2bc">&#9670;&nbsp;</a></span>~RewriterBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RewriterBase::~RewriterBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00104">104</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a85aec3a92df442554cfa7ba825e4e226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85aec3a92df442554cfa7ba825e4e226">&#9670;&nbsp;</a></span>cancelOpModification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mlir::RewriterBase::cancelOpModification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method cancels a pending in-place modification. </p>
<p>This can only be called on operations that were provided to a call to <code>startOpModification</code>. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#ab14ba50f49846a6e3ae1889ea339e951">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00622">622</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="a286510e5cc47983e5b6017bad6aa6335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286510e5cc47983e5b6017bad6aa6335">&#9670;&nbsp;</a></span>eraseBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::eraseBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method erases all operations in a block. </p>

<p>Reimplemented in <a class="el" href="structmlir_1_1detail_1_1ConversionPatternRewriterImpl_1_1SingleEraseRewriter.html#ae65765ef828b9d4f20339c949261bb84">mlir::detail::ConversionPatternRewriterImpl::SingleEraseRewriter</a>, and <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#aa6daaf4084b64e140a101b4b875d90c6">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00232">232</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8cpp_source.html#l00066">mlir::Block::erase()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00155">eraseOp()</a>, <a class="el" href="Builders_8h_source.html#l00608">mlir::OpBuilder::listener</a>, <a class="el" href="IR_2Operation_8h_source.html#l00852">mlir::Operation::use_empty()</a>, and <a class="el" href="UseDefLists_8h_source.html#l00261">mlir::IRObjectWithUseList&lt; OperandType &gt;::use_empty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l01051">mlir::detail::ConversionPatternRewriterImpl::SingleEraseRewriter::eraseBlock()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00183">mlir::eraseUnreachableBlocks()</a>, <a class="el" href="SparseIterationToScf_8cpp_source.html#l00054">genCoIterateBranchNest()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00290">inlineBlockBefore()</a>, <a class="el" href="TosaToSCF_8cpp_source.html#l00022">inlineIfCase()</a>, <a class="el" href="TosaToSCF_8cpp_source.html#l00039">inlineWhileCase()</a>, <a class="el" href="DistributionUtils_8cpp_source.html#l00024">mlir::gpu::WarpDistributionPattern::moveRegionToNewWarpOpAndReplaceReturns()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01465">mlir::normalizeForallOp()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00065">mlir::RewritePattern::Pattern()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00639">replaceForAllWithNewSignature()</a>, and <a class="el" href="VectorToGPU_8cpp_source.html#l01108">replaceForOpWithNewSignature()</a>.</p>

</div>
</div>
<a id="a786138ac6a91e0932da343ef5c6f1e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786138ac6a91e0932da343ef5c6f1e70">&#9670;&nbsp;</a></span>eraseOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::eraseOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method erases an operation that is known to have no uses. </p>
<p>If the current insertion point is before the erased operation, it is adjusted to the following operation (or the end of the block). If the current insertion point is within the erased operation, the insertion point is left in an invalid state.</p>
<p>The uses of the given operation <em>must</em> be known to be dead. </p>

<p>Reimplemented in <a class="el" href="structmlir_1_1detail_1_1ConversionPatternRewriterImpl_1_1SingleEraseRewriter.html#a801cb11ed5a3c35d9cf2729d2a568e9f">mlir::detail::ConversionPatternRewriterImpl::SingleEraseRewriter</a>, and <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#a56f841ea5c2326350a6d7182e9028a0e">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00155">155</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00538">mlir::Operation::erase()</a>, <a class="el" href="Builders_8h_source.html#l00443">mlir::OpBuilder::getInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00608">mlir::OpBuilder::listener</a>, <a class="el" href="Builders_8h_source.html#l00410">mlir::OpBuilder::setInsertionPointAfter()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00852">mlir::Operation::use_empty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00178">mlir::memref::allocToAlloca()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00520">applyTilingToAll()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00259">mlir::linalg::bufferizeToAllocation()</a>, <a class="el" href="BasicPtxBuilderInterface_8cpp_source.html#l00147">mlir::NVVM::PtxBuilder::buildAndReplaceOp()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00900">mlir::coalesceLoops()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00590">convertTransferWriteOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00894">convertTransferWriteToStores()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01173">convertYieldOp()</a>, <a class="el" href="CreateAsyncGroups_8cpp_source.html#l00152">mlir::nvgpu::createAsyncGroups()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00413">deleteDeadness()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00232">eraseBlock()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00156">mlir::memref::eraseDeadAllocAndStores()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01043">mlir::detail::ConversionPatternRewriterImpl::SingleEraseRewriter::eraseOp()</a>, <a class="el" href="Dialect_2ArmSME_2IR_2Utils_8cpp_source.html#l00118">mlir::arm_sme::eraseTriviallyDeadTileOps()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00339">mlir::linalg::fuseElementwiseOps()</a>, <a class="el" href="SparseIterationToScf_8cpp_source.html#l00054">genCoIterateBranchNest()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00154">genForeachOnSparseConstant()</a>, <a class="el" href="TosaToSCF_8cpp_source.html#l00022">inlineIfCase()</a>, <a class="el" href="TosaToSCF_8cpp_source.html#l00039">inlineWhileCase()</a>, <a class="el" href="Merger_8cpp_source.html#l01557">mlir::sparse_tensor::insertYieldOp()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00411">AllocaScopeInliner::matchAndRewrite()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00238">MultiBlockExecuteInliner::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l04259">VectorizeConvolution::matchAndRewrite()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l04311">FoldConstantCase::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l03304">mlir::linalg::LinalgCopyVTRForwardingPattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l03382">mlir::linalg::LinalgCopyVTWForwardingPattern::matchAndRewrite()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00098">mlir::memref::multiBuffer()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00113">mlir::outlineSingleBlockRegion()</a>, <a class="el" href="LoopPipelining_8cpp_source.html#l00789">mlir::scf::pipelineForLoop()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00654">mlir::scf::promote()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00786">mlir::scf::replaceAndCastForOpIterArg()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01108">replaceForOpWithNewSignature()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">replaceOp()</a>, <a class="el" href="SCFTransformOps_8cpp_source.html#l00419">replaceOpWithRegion()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00044">replaceUsesAndPropagateType()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l01044">CopyBuilder::rewrite()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00465">rewriteOneForallCommonImpl()</a>, <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00151">simplifyBrToBlockWithSinglePred()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00509">mlir::vector::splitFullAndPartialTransfer()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l02122">mlir::scf::tileAndFuseConsumerOfSlices()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00891">tileAndFuseFirstExtractUseThroughContainingOpBlockArgument()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01210">mlir::scf::tileAndFuseProducerOfSlice()</a>, <a class="el" href="Tiling_8cpp_source.html#l00589">mlir::linalg::tileReductionUsingForall()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00987">mlir::scf::tileUsingSCF()</a>.</p>

</div>
</div>
<a id="a751a613cc855a12b9b1dc277dfdcc5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751a613cc855a12b9b1dc277dfdcc5c5">&#9670;&nbsp;</a></span>finalizeOpModification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::finalizeOpModification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used to signal the end of an in-place modification of the given operation. </p>
<p>This can only be called on operations that were provided to a call to <code>startOpModification</code>. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#ae146aeccb0ec4befe51e1a988ff4380b">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00247">247</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00608">mlir::OpBuilder::listener</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l01934">mlir::ConversionPatternRewriter::finalizeOpModification()</a>, <a class="el" href="Interchange_8cpp_source.html#l00045">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l02406">RemoveUnusedLvlCrds::matchAndRewrite()</a>, <a class="el" href="PatternMatch_8h_source.html#l00628">modifyOpInPlace()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00801">padThroughLoopIterArg()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00041">mlir::affine::reorderOperandsByHoistability()</a>, and <a class="el" href="MultiBuffer_8cpp_source.html#l00044">replaceUsesAndPropagateType()</a>.</p>

</div>
</div>
<a id="a9d36005019112b1a9acecba1a9cfc377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d36005019112b1a9acecba1a9cfc377">&#9670;&nbsp;</a></span>inlineBlockBefore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::inlineBlockBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>argValues</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline the operations of block 'source' into block 'dest' before the given position. </p>
<p>The source block will be deleted and must have no uses. 'argValues' is used to replace the block arguments of 'source'.</p>
<p>If the source block is inserted at the end of the dest block, the dest block must have no successors. Similarly, if the source block is inserted somewhere in the middle (or beginning) of the dest block, the source block must have no successors. Otherwise, the resulting IR would have unreachable operations.</p>
<p>If the insertion point is within the source block, it is adjusted to the destination block. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#a8c57da304e30e1829e4ee960f7101ecb">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00290">290</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00148">mlir::Block::empty()</a>, <a class="el" href="Block_8h_source.html#l00144">mlir::Block::end()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00232">eraseBlock()</a>, <a class="el" href="Block_8h_source.html#l00153">mlir::Block::front()</a>, <a class="el" href="Block_8h_source.html#l00087">mlir::Block::getArguments()</a>, <a class="el" href="Builders_8h_source.html#l00440">mlir::OpBuilder::getInsertionBlock()</a>, <a class="el" href="Builders_8h_source.html#l00443">mlir::OpBuilder::getInsertionPoint()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getNumArguments()</a>, <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>, <a class="el" href="Block_8h_source.html#l00242">mlir::Block::hasNoPredecessors()</a>, <a class="el" href="Block_8h_source.html#l00245">mlir::Block::hasNoSuccessors()</a>, <a class="el" href="Builders_8h_source.html#l00608">mlir::OpBuilder::listener</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00407">moveOpBefore()</a>, <a class="el" href="PatternMatch_8h_source.html#l00636">replaceAllUsesWith()</a>, and <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00900">mlir::coalesceLoops()</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00166">fuseIfLegal()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00154">genForeachOnSparseConstant()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00338">inlineBlockBefore()</a>, <a class="el" href="Merger_8cpp_source.html#l01557">mlir::sparse_tensor::insertYieldOp()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00411">AllocaScopeInliner::matchAndRewrite()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l04311">FoldConstantCase::matchAndRewrite()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00343">mergeBlocks()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00654">mlir::scf::promote()</a>, and <a class="el" href="SCFTransformOps_8cpp_source.html#l00419">replaceOpWithRegion()</a>.</p>

</div>
</div>
<a id="a4307b18bc25cec55349236d556cc89bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4307b18bc25cec55349236d556cc89bd">&#9670;&nbsp;</a></span>inlineBlockBefore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::inlineBlockBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>argValues</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline the operations of block 'source' before the operation 'op'. </p>
<p>The source block will be deleted and must have no uses. 'argValues' is used to replace the block arguments of 'source'</p>
<p>The source block must have no successors. Otherwise, the resulting IR would have unreachable operations.</p>
<p>If the insertion point is within the source block, it is adjusted to the destination block. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00338">338</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00290">inlineBlockBefore()</a>.</p>

</div>
</div>
<a id="adbd0cf093ad5c10fb3e12a4e1fbb5e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd0cf093ad5c10fb3e12a4e1fbb5e1b">&#9670;&nbsp;</a></span>inlineRegionBefore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::inlineRegionBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00388">388</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8cpp_source.html#l00027">mlir::Block::getParent()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00376">inlineRegionBefore()</a>.</p>

</div>
</div>
<a id="adaf2b23302d524eeb5643dcff7668ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf2b23302d524eeb5643dcff7668ebf">&#9670;&nbsp;</a></span>inlineRegionBefore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::inlineRegionBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a>&#160;</td>
          <td class="paramname"><em>before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the blocks that belong to "region" before the given position in another region "parent". </p>
<p>Move the blocks that belong to "region" before the given position in another region.</p>
<p>The two regions must be different. The caller is responsible for creating or updating the operation transferring flow of control to the region and passing it the correct block arguments.</p>
<p>The two regions must be different. The caller is in charge to update create the operation transferring the control flow to the region and pass it the correct block arguments. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00376">376</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00060">mlir::Region::empty()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="IR_2Region_8h_source.html#l00045">mlir::Region::getBlocks()</a>, <a class="el" href="Builders_8h_source.html#l00608">mlir::OpBuilder::listener</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00392">moveBlockBefore()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncToLLVM_8cpp_source.html#l00291">mlir::convertFuncOpToLLVMFuncOp()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00186">createDecl()</a>, <a class="el" href="Generalization_8cpp_source.html#l00048">mlir::linalg::generalizeNamedOp()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00388">inlineRegionBefore()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00231">lowerAsEntryFunction()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00238">MultiBlockExecuteInliner::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00077">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="DistributionUtils_8cpp_source.html#l00024">mlir::gpu::WarpDistributionPattern::moveRegionToNewWarpOpAndReplaceReturns()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01465">mlir::normalizeForallOp()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00030">mlir::linalg::splitReduction()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00241">mlir::linalg::splitReductionByScaling()</a>, and <a class="el" href="SCFTransformOps_8cpp_source.html#l00156">wrapInExecuteRegion()</a>.</p>

</div>
</div>
<a id="aae4361e432a7b6a6517beef700f3916f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4361e432a7b6a6517beef700f3916f">&#9670;&nbsp;</a></span>mergeBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::mergeBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>argValues</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline the operations of block 'source' into the end of block 'dest'. </p>
<p>The source block will be deleted and must have no uses. 'argValues' is used to replace the block arguments of 'source'</p>
<p>The dest block must have no successors. Otherwise, the resulting IR would have unreachable operation.</p>
<p>If the insertion point is within the source block, it is adjusted to the destination block. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00343">343</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00144">mlir::Block::end()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00290">inlineBlockBefore()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00917">addInitOperandsToLoopNest()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01676">cloneToCollapsedOp&lt; GenericOp &gt;()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00084">mlir::makeRegionIsolatedFromAbove()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00093">movePaddingToFillOrGenericOp()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03609">normalizeForallLoopOp()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00113">mlir::outlineSingleBlockRegion()</a>, <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00172">populateOpPayload()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00786">mlir::scf::replaceAndCastForOpIterArg()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00043">replaceWithDifferentYield()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00388">mlir::linalg::rewriteInDestinationPassingStyle()</a>, and <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00151">simplifyBrToBlockWithSinglePred()</a>.</p>

</div>
</div>
<a id="abd8bae753b51386417536a36cf52d3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8bae753b51386417536a36cf52d3f7">&#9670;&nbsp;</a></span>modifyOpInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CallableT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::RewriterBase::modifyOpInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallableT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is a utility wrapper around an in-place modification of an operation. </p>
<p>It wraps calls to <code>startOpModification</code> and <code>finalizeOpModification</code> around the given callable. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00628">628</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00247">finalizeOpModification()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00612">startOpModification()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00259">mlir::linalg::bufferizeToAllocation()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00993">cloneAndFuseFirstUse()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00900">mlir::coalesceLoops()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03240">convertFuncOpTypes()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00088">mlir::linalg::hoistRedundantVectorBroadcasts()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02535">CollapseShapeOpMemRefCastFolder::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00077">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="FoldAddIntoDest_8cpp_source.html#l00058">FoldAddIntoDest::matchAndRewrite()</a>, <a class="el" href="CommutativityUtils_8cpp_source.html#l00234">SortCommutativeOperands::matchAndRewrite()</a>, <a class="el" href="DistributionUtils_8cpp_source.html#l00024">mlir::gpu::WarpDistributionPattern::moveRegionToNewWarpOpAndReplaceReturns()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00118">peelForLoop()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00588">relinkBranch()</a>, <a class="el" href="PatternMatch_8h_source.html#l00636">replaceAllUsesWith()</a>, <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00096">replaceAndPropagateMemRefType()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00261">replaceUsesWithIf()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02854">PadOpVectorizationWithTransferReadPattern::rewriteUser()</a>, <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00033">simplifyAffineMinMaxOp()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00509">mlir::vector::splitFullAndPartialTransfer()</a>, <a class="el" href="Split_8cpp_source.html#l00067">mlir::linalg::splitOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l02122">mlir::scf::tileAndFuseConsumerOfSlices()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00771">tileAndFuseFirstExtractUse()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00891">tileAndFuseFirstExtractUseThroughContainingOpBlockArgument()</a>, <a class="el" href="Tiling_8cpp_source.html#l00589">mlir::linalg::tileReductionUsingForall()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00924">updateDeallocIfChanged()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l01325">mlir::scf::yieldReplacementForFusedProducer()</a>.</p>

</div>
</div>
<a id="a5a9b9f56696bbe011288fcf9aa820826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9b9f56696bbe011288fcf9aa820826">&#9670;&nbsp;</a></span>moveBlockBefore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::moveBlockBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>anotherBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlink this block and insert it right before <code>existingBlock</code>. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00392">392</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8cpp_source.html#l00027">mlir::Block::getParent()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PatternMatch_8cpp_source.html#l00376">inlineRegionBefore()</a>.</p>

</div>
</div>
<a id="a13db8bb7b6e0a4360d0c5f25b81f0288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13db8bb7b6e0a4360d0c5f25b81f0288">&#9670;&nbsp;</a></span>moveBlockBefore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::moveBlockBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a>&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlink this block and insert it right before the location that the given iterator points to in the given region. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00397">397</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8cpp_source.html#l00027">mlir::Block::getParent()</a>, <a class="el" href="Builders_8h_source.html#l00608">mlir::OpBuilder::listener</a>, <a class="el" href="Block_8cpp_source.html#l00054">mlir::Block::moveBefore()</a>, and <a class="el" href="Builders_8h_source.html#l00306">mlir::OpBuilder::Listener::notifyBlockInserted()</a>.</p>

</div>
</div>
<a id="ac557b90543b8af6f2316a390b30ec30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac557b90543b8af6f2316a390b30ec30e">&#9670;&nbsp;</a></span>moveOpAfter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::moveOpAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlink this operation from its current block and insert it right after <code>iterator</code> in the specified block. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00425">425</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00144">mlir::Block::end()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00407">moveOpBefore()</a>.</p>

</div>
</div>
<a id="ac7c6fcefff138a077e883df55164302a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c6fcefff138a077e883df55164302a">&#9670;&nbsp;</a></span>moveOpAfter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::moveOpAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>existingOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlink this operation from its current block and insert it right after <code>existingOp</code> which may be in the same or another block in the same function. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00421">421</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Hoisting_8cpp_source.html#l00088">mlir::linalg::hoistRedundantVectorBroadcasts()</a>, and <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00321">hoistSubsetAtIterArg()</a>.</p>

</div>
</div>
<a id="aa91caee4a728b445e0e746ffa99b2cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91caee4a728b445e0e746ffa99b2cf8">&#9670;&nbsp;</a></span>moveOpBefore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::moveOpBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlink this operation from its current block and insert it right before <code>iterator</code> in the specified block. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00411">411</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="Builders_8h_source.html#l00608">mlir::OpBuilder::listener</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00554">mlir::Operation::moveBefore()</a>, and <a class="el" href="Builders_8h_source.html#l00296">mlir::OpBuilder::Listener::notifyOperationInserted()</a>.</p>

</div>
</div>
<a id="aa0c1331e070f3c4ed7f64b530007aa44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c1331e070f3c4ed7f64b530007aa44">&#9670;&nbsp;</a></span>moveOpBefore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::moveOpBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>existingOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlink this operation from its current block and insert it right before <code>existingOp</code> which may be in the same or another block in the same function. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00407">407</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l01416">mlir::detail::ConversionPatternRewriterImpl::applySignatureConversion()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00923">mlir::linalg::DecomposePadOpPattern::createFillOrGenerateOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01873">getConsumerFromLoopUses()</a>, <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00321">hoistSubsetAtIterArg()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00290">inlineBlockBefore()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00425">moveOpAfter()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l01064">mlir::moveOperationDependencies()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l01120">mlir::moveValueDefinitions()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00350">splitBlock()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l02122">mlir::scf::tileAndFuseConsumerOfSlices()</a>.</p>

</div>
</div>
<a id="ab106a05ed09d9245211a36d3935945dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab106a05ed09d9245211a36d3935945dd">&#9670;&nbsp;</a></span>notifyMatchFailure() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::RewriterBase::notifyMatchFailure </td>
          <td>(</td>
          <td class="paramtype">ArgT &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00736">736</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00716">notifyMatchFailure()</a>.</p>

</div>
</div>
<a id="a2a1d35106b18aaf457462915e16f3ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1d35106b18aaf457462915e16f3ea3">&#9670;&nbsp;</a></span>notifyMatchFailure() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::RewriterBase::notifyMatchFailure </td>
          <td>(</td>
          <td class="paramtype">ArgT &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00731">731</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l00055">diag()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00716">notifyMatchFailure()</a>.</p>

</div>
</div>
<a id="a032aa8fe5345a286681688ef10f5cb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032aa8fe5345a286681688ef10f5cb84">&#9670;&nbsp;</a></span>notifyMatchFailure() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CallbackT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_convertible&lt;CallbackT, Twine&gt;::value, LogicalResult&gt; mlir::RewriterBase::notifyMatchFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>reasonCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to notify the listener that the IR failed to be rewritten because of a match failure, and provide a callback to populate a diagnostic with the reason why the failure occurred. </p>
<p>This method allows for derived rewriters to optionally hook into the reason why a rewrite failed, and display it to users. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00716">716</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00608">mlir::OpBuilder::listener</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01616">alignedConversionPrecondition()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00686">areAllLLVMTypes()</a>, <a class="el" href="MaskedloadToLoad_8cpp_source.html#l00036">baseInBufferAddrSpace()</a>, <a class="el" href="BlockPackMatmul_8cpp_source.html#l00138">mlir::linalg::blockPackMatmul()</a>, <a class="el" href="IndexOps_8cpp_source.html#l00125">canonicalizeAssociativeCommutativeBinaryOp()</a>, <a class="el" href="ConversionUtils_8h_source.html#l00051">mlir::tosa::checkHasDynamicBatchDims()</a>, <a class="el" href="MathToSPIRV_8cpp_source.html#l00073">checkSourceOpTypes()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01712">mlir::linalg::collapseOpIterationDims()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01558">commonConversionPrecondition()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00039">convertCastingOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00635">convertConstantOpMmaSync()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01022">convertContractOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01043">convertContractOpToMmaSync()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01198">convertElementwiseOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00946">convertExtractStridedSlice()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00291">mlir::convertFuncOpToLLVMFuncOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03296">mlir::convertOpResultTypes()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00511">convertRoundEvenOp()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00408">convertRoundOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00538">convertTransferReadOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00862">convertTransferReadToLoads()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00590">convertTransferWriteOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00894">convertTransferWriteToStores()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00082">createLinalgBodyCalculationForElementwiseOp()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00763">createNonLdMatrixLoads()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00702">creatLdMatrixCompatibleLoads()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00095">mlir::affine::decompose()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00384">mlir::linalg::dropUnitDims()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l01002">elementwiseMatchAndRewriteHelper()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00929">emitElementwiseComputation()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00339">mlir::linalg::fuseElementwiseOps()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00865">fuseWithReshapeByExpansion()</a>, <a class="el" href="Generalization_8cpp_source.html#l00048">mlir::linalg::generalizeNamedOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00578">generateLoopNest()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00508">generateLoopNestUsingForallOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00427">generateLoopNestUsingForOp()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00055">getLibraryCallSymbolRef()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00726">getResultTilePosition()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00699">getTiledImplementation()</a>, <a class="el" href="ArithToSPIRV_8cpp_source.html#l00159">getTypeConversionFailure()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01981">getUntiledConsumerFromSlice()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l02047">getUntiledConsumerOperandsFromSlices()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00318">insertCasts()</a>, <a class="el" href="Interchange_8cpp_source.html#l00045">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00697">isAsyncWithOneDependency()</a>, <a class="el" href="ControlFlowToSPIRV_8cpp_source.html#l00028">legalizeBlockArguments()</a>, <a class="el" href="VectorLinearize_8cpp_source.html#l00030">linearizeConstAttr()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00219">mlir::linalg::lowerPack()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l02373">mlir::scf::lowerToLoopsUsingSCFForOp()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00701">YieldOpLowering::matchAndRewrite()</a>, <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00746">AssertOpLowering::matchAndRewrite()</a>, <a class="el" href="FoldMemRefsOps_8cpp_source.html#l00033">mlir::amdgpu::FoldMemRefOpsIntoGatherToLDSOp::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00077">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00758">mlir::GPUReturnOpLowering::matchAndRewrite()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00686">GPUSubgroupReduceConversion::matchAndRewrite()</a>, <a class="el" href="SCFToEmitC_8cpp_source.html#l00294">IndexSwitchOpLowering::matchAndRewrite()</a>, <a class="el" href="FoldAddIntoDest_8cpp_source.html#l00058">FoldAddIntoDest::matchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01158">mlir::linalg::DecomposeOuterUnitDimsPackOpPattern::matchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01261">mlir::linalg::DecomposeOuterUnitDimsUnPackOpPattern::matchAndRewrite()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01139">mlir::math::ErfcPolynomialApproximation::matchAndRewrite()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01018">mlir::math::ErfPolynomialApproximation::matchAndRewrite()</a>, <a class="el" href="lib_2Conversion_2SPIRVCommon_2Pattern_8h_source.html#l00027">mlir::spirv::ElementwiseOpPattern&lt; Op, SPIRVOp &gt;::matchAndRewrite()</a>, <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00178">InsertSliceOfInsertSliceFolder&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="OpToFuncCallLowering_8h_source.html#l00067">mlir::OpToFuncCallLowering&lt; SourceOp &gt;::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00344">ConvertAccessChain::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00430">ConvertLoad::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00535">ConvertStore::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00656">ConcatSliceOptimization::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00724">PadSliceOptimization::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00862">SliceDynamicSizeCanonicalization::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00388">TransposeIsReshape::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00350">ConsolidateTransposeOptimization::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l03304">mlir::linalg::LinalgCopyVTRForwardingPattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l03382">mlir::linalg::LinalgCopyVTWForwardingPattern::matchAndRewrite()</a>, <a class="el" href="AVXTranspose_8cpp_source.html#l00216">TransposeOpLowering::matchAndRewrite()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00754">mergeTilingResults()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l01064">mlir::moveOperationDependencies()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l01120">mlir::moveValueDefinitions()</a>, <a class="el" href="PatternMatch_8h_source.html#l00731">notifyMatchFailure()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00477">mlir::linalg::pack()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00766">mlir::linalg::packMatmulGreedily()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00675">mlir::linalg::packTranspose()</a>, <a class="el" href="Padding_8cpp_source.html#l00355">mlir::linalg::padAndHoistLinalgOp()</a>, <a class="el" href="Padding_8cpp_source.html#l00187">padOperandToSmallestStaticBoundingBox()</a>, <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00076">preconditionsFoldExtractOrInsertWithTransferOp()</a>, <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00219">preconditionsFoldSubViewOpImpl()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00399">processParallelLoop()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l01131">reduceMatchAndRewriteHelper()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00226">replaceWithLoadOrStore()</a>, <a class="el" href="Padding_8cpp_source.html#l00244">mlir::linalg::rewriteAsPaddedOp()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00429">mlir::linalg::rewriteInDestinationPassingStyle()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00078">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00635">mlir::impl::scalarizeVectorOp()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00030">mlir::linalg::splitReduction()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00241">mlir::linalg::splitReductionByScaling()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l02122">mlir::scf::tileAndFuseConsumerOfSlices()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01594">mlir::scf::tileConsumerAndFuseProducersUsingSCF()</a>, <a class="el" href="Tiling_8cpp_source.html#l00589">mlir::linalg::tileReductionUsingForall()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00987">mlir::scf::tileUsingSCF()</a>, <a class="el" href="TransposeMatmul_8cpp_source.html#l00087">mlir::linalg::transposeBatchMatmul()</a>, <a class="el" href="TransposeMatmul_8cpp_source.html#l00030">mlir::linalg::transposeMatmul()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00077">verifyOptions()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00781">yieldTiledValuesAndReplaceLoop()</a>.</p>

</div>
</div>
<a id="a081f7564cc3f62236c99e2a8098c3673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081f7564cc3f62236c99e2a8098c3673">&#9670;&nbsp;</a></span>notifyMatchFailure() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CallbackT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_convertible&lt;CallbackT, Twine&gt;::value, LogicalResult&gt; mlir::RewriterBase::notifyMatchFailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallbackT &amp;&amp;&#160;</td>
          <td class="paramname"><em>reasonCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00724">724</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, and <a class="el" href="Builders_8h_source.html#l00608">mlir::OpBuilder::listener</a>.</p>

</div>
</div>
<a id="ab5fe9389669567e32a55dda8d9f0912d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fe9389669567e32a55dda8d9f0912d">&#9670;&nbsp;</a></span>replaceAllOpUsesWith() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::replaceAllOpUsesWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00116">116</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="Builders_8h_source.html#l00608">mlir::OpBuilder::listener</a>, and <a class="el" href="PatternMatch_8h_source.html#l00636">replaceAllUsesWith()</a>.</p>

</div>
</div>
<a id="af11a67366e4e1531f3bb0fbe6a67ec03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11a67366e4e1531f3bb0fbe6a67ec03">&#9670;&nbsp;</a></span>replaceAllOpUsesWith() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::replaceAllOpUsesWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find uses of <code>from</code> and replace them with <code>to</code>. </p>
<p>Also notify the listener about every in-place op modification (for every use that was replaced) and that the <code>from</code> operation is about to be replaced.</p>
<p>Note: This function cannot be called <code>replaceAllUsesWith</code> because the overload resolution, when called with an op that can be implicitly converted to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>, would be ambiguous. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00108">108</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="Builders_8h_source.html#l00608">mlir::OpBuilder::listener</a>, and <a class="el" href="PatternMatch_8h_source.html#l00636">replaceAllUsesWith()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldAddIntoDest_8cpp_source.html#l00058">FoldAddIntoDest::matchAndRewrite()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00127">replaceOp()</a>.</p>

</div>
</div>
<a id="ad6e65745ef1625ce5300c8cb927a14db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e65745ef1625ce5300c8cb927a14db">&#9670;&nbsp;</a></span>replaceAllUsesExcept() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::replaceAllUsesExcept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>preservedUsers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00253">253</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00261">replaceUsesWithIf()</a>.</p>

</div>
</div>
<a id="a9bc0bf42591d2bf716733ed23bb8b6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc0bf42591d2bf716733ed23bb8b6e6">&#9670;&nbsp;</a></span>replaceAllUsesExcept() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::RewriterBase::replaceAllUsesExcept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>exceptedUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find uses of <code>from</code> and replace them with <code>to</code> except if the user is <code>exceptedUser</code>. </p>
<p>Also notify the listener about every in-place op modification (for every use that was replaced). </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00700">700</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00261">replaceUsesWithIf()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00900">mlir::coalesceLoops()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00766">mlir::denormalizeInductionVariable()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00741">denormalizeInductionVariableForIndexType()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00512">VectorizationState::maskOperation()</a>.</p>

</div>
</div>
<a id="a94de93eaac4c7cf2976d6a1e6ddb42dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94de93eaac4c7cf2976d6a1e6ddb42dd">&#9670;&nbsp;</a></span>replaceAllUsesWith() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::RewriterBase::replaceAllUsesWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00642">642</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00253">mlir::IRObjectWithUseList&lt; OperandType &gt;::getUses()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00628">modifyOpInPlace()</a>.</p>

</div>
</div>
<a id="a61b4cea69baed7a36d0cd02f5b44c176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b4cea69baed7a36d0cd02f5b44c176">&#9670;&nbsp;</a></span>replaceAllUsesWith() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::RewriterBase::replaceAllUsesWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find uses of <code>from</code> and replace them with <code>to</code>. </p>
<p>Also notify the listener about every in-place op modification (for every use that was replaced). </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00636">636</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00188">mlir::Value::getUses()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00628">modifyOpInPlace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgTransformOps_8cpp_source.html#l00520">applyTilingToAll()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00932">dropRedundantArguments()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00088">mlir::linalg::hoistRedundantVectorBroadcasts()</a>, <a class="el" href="LoopInvariantCodeMotionUtils_8cpp_source.html#l00321">hoistSubsetAtIterArg()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00290">inlineBlockBefore()</a>, <a class="el" href="WrapFuncInClass_8cpp_source.html#l00049">WrapFuncInClass::matchAndRewrite()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01126">FoldLaunchArguments::matchAndRewrite()</a>, <a class="el" href="IntRangeOptimizations_8cpp_source.html#l00062">mlir::dataflow::maybeReplaceWithConstant()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00801">padThroughLoopIterArg()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00118">peelForLoop()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00654">mlir::scf::promote()</a>, <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00066">propagateSubViewOp()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00690">pruneRedundantArguments()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00108">replaceAllOpUsesWith()</a>, <a class="el" href="PatternMatch_8h_source.html#l00648">replaceAllUsesWith()</a>, <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00096">replaceAndPropagateMemRefType()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00639">replaceForAllWithNewSignature()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l01108">replaceForOpWithNewSignature()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00456">replaceUnitMappingIdsHelper()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00465">rewriteOneForallCommonImpl()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l02122">mlir::scf::tileAndFuseConsumerOfSlices()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l01210">mlir::scf::tileAndFuseProducerOfSlice()</a>.</p>

</div>
</div>
<a id="a59d82a8e1d914506268e399ba2e3f4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d82a8e1d914506268e399ba2e3f4b6">&#9670;&nbsp;</a></span>replaceAllUsesWith() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::RewriterBase::replaceAllUsesWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00648">648</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00636">replaceAllUsesWith()</a>.</p>

</div>
</div>
<a id="ac8deddda655ea07575a2624c54b80f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8deddda655ea07575a2624c54b80f3e">&#9670;&nbsp;</a></span>replaceOp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::replaceOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>newOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the results of the given (original) operation with the specified new op (replacement). </p>
<p>This method replaces the results of the operation with the specified new op (replacement).</p>
<p>The result types of the two ops must match. The original op is erased.</p>
<p>The number of results of the two operations must match. The replaced op is erased. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#a2326d0bfed0515212c4ec39c93dbb2e5">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00141">141</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00155">eraseOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00108">replaceAllOpUsesWith()</a>.</p>

</div>
</div>
<a id="a53c88f3ce889be590b3801b4ddee627f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c88f3ce889be590b3801b4ddee627f">&#9670;&nbsp;</a></span>replaceOp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::replaceOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the results of the given (original) operation with the specified list of values (replacements). </p>
<p>This method replaces the results of the operation with the specified list of values.</p>
<p>The result types of the given op and the replacements must match. The original op is erased.</p>
<p>The number of provided values must match the number of results of the operation. The replaced op is erased. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#a12fa2633cd26e201bb171204cc1d313b">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00127">127</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00155">eraseOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00108">replaceAllOpUsesWith()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00917">addInitOperandsToLoopNest()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00326">mlir::linalg::bufferizeToAllocation()</a>, <a class="el" href="BasicPtxBuilderInterface_8cpp_source.html#l00147">mlir::NVVM::PtxBuilder::buildAndReplaceOp()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00900">mlir::coalesceLoops()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00171">convertAcoshOp()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02657">convertAffineApply()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00155">convertAsinhOp()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00187">convertAtanhOp()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00222">convertCeilOp()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00087">convertCoshOp()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00468">convertCtlzOp()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00396">convertExp2fOp()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00205">convertFmaFOp()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00251">convertFPowIOp()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00322">convertPowfOp()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00511">convertRoundEvenOp()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00408">convertRoundOp()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00071">convertSinhOp()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00143">convertTanOp()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00095">mlir::affine::decompose()</a>, <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00231">mlir::linalg::deduplicateOperandsAndRemoveDeadResults()</a>, <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00069">mlir::bufferization::dropEquivalentBufferResults()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00085">mlir::bufferization::foldToBufferToTensorPair()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01362">mlir::fuseIndependentSiblingForallLoops()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01415">mlir::fuseIndependentSiblingForLoops()</a>, <a class="el" href="Generalization_8cpp_source.html#l00048">mlir::linalg::generalizeNamedOp()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01586">generateCollapsedIndexingRegion()</a>, <a class="el" href="SparseTensorRewriting_8cpp_source.html#l00154">genForeachOnSparseConstant()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00111">mlir::OperationFolder::insertKnownConstant()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00358">mlir::LLVM::detail::intrinsicRewrite()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02804">legalizeUnresolvedMaterialization()</a>, <a class="el" href="AffineExpandIndexOps_8cpp_source.html#l00087">mlir::affine::lowerAffineDelinearizeIndexOp()</a>, <a class="el" href="AffineExpandIndexOps_8cpp_source.html#l00145">mlir::affine::lowerAffineLinearizeIndexOp()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00219">mlir::linalg::lowerPack()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00354">mlir::linalg::lowerUnPack()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01224">CanonicalizeContractAdd&lt; AddOpType &gt;::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00411">AllocaScopeInliner::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00451">AllocaScopeHoister::matchAndRewrite()</a>, <a class="el" href="TensorOps_8cpp_source.html#l04094">FoldTensorCastProducerOp::matchAndRewrite()</a>, <a class="el" href="WrapFuncInClass_8cpp_source.html#l00049">WrapFuncInClass::matchAndRewrite()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00238">MultiBlockExecuteInliner::matchAndRewrite()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00282">DecomposeNDExtractStridedSlice::matchAndRewrite()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00095">ConvertSameRankInsertStridedSliceIntoShuffle::matchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01158">mlir::linalg::DecomposeOuterUnitDimsPackOpPattern::matchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01261">mlir::linalg::DecomposeOuterUnitDimsUnPackOpPattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l04259">VectorizeConvolution::matchAndRewrite()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01139">mlir::math::ErfcPolynomialApproximation::matchAndRewrite()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01018">mlir::math::ErfPolynomialApproximation::matchAndRewrite()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05275">mlir::linalg::FoldTensorCastPackOp::matchAndRewrite()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l04311">FoldConstantCase::matchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00995">mlir::linalg::ExtractSliceOfPadTensorSwapPattern::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00449">ClampIsNoOp::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00313">ConcatOptimization::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00271">MaxPool2dIsNoOp::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00656">ConcatSliceOptimization::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00862">SliceDynamicSizeCanonicalization::matchAndRewrite()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05591">mlir::linalg::FoldTensorCastUnPackOp::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l03304">mlir::linalg::LinalgCopyVTRForwardingPattern::matchAndRewrite()</a>, <a class="el" href="AVXTranspose_8cpp_source.html#l00216">TransposeOpLowering::matchAndRewrite()</a>, <a class="el" href="XeGPUOps_8cpp_source.html#l00916">mlir::xegpu::FoldConvertLayoutOp::matchAndRewrite()</a>, <a class="el" href="DistributionUtils_8cpp_source.html#l00052">mlir::gpu::WarpDistributionPattern::moveRegionToNewWarpOpAndAppendReturns()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03609">normalizeForallLoopOp()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01465">mlir::normalizeForallOp()</a>, <a class="el" href="TensorOps_8cpp_source.html#l02710">SliceCanonicalizer::operator()()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00477">mlir::linalg::pack()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00675">mlir::linalg::packTranspose()</a>, <a class="el" href="Padding_8cpp_source.html#l00355">mlir::linalg::padAndHoistLinalgOp()</a>, <a class="el" href="LoopPipelining_8cpp_source.html#l00789">mlir::scf::pipelineForLoop()</a>, <a class="el" href="ReifyResultShapes_8cpp_source.html#l00041">reifyOpResultShapes()</a>, <a class="el" href="Loops_8cpp_source.html#l00179">replaceIndexOpsByInductionVariables()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00733">mlir::bufferization::replaceOpWithBufferizedValues()</a>, <a class="el" href="PatternMatch_8h_source.html#l00519">replaceOpWithNewOp()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00311">replaceOpWithPredicatedOp()</a>, <a class="el" href="SCFTransformOps_8cpp_source.html#l00419">replaceOpWithRegion()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00043">replaceWithDifferentYield()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01408">mlir::linalg::DownscaleSizeOneWindowed2DConvolution&lt; Conv2DOp, Conv1DOp &gt;::returningMatchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01599">mlir::linalg::DownscaleConv2DOp::returningMatchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01531">mlir::linalg::DownscaleDepthwiseConv2DNhwcHwcOp::returningMatchAndRewrite()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00261">mlir::linalg::rewriteAsPaddedOp()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00350">mlir::linalg::rewriteInDestinationPassingStyle()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00213">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02916">PadOpVectorizationWithTransferWritePattern::rewriteUser()</a>, <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00158">mlir::tensor::simplifyCollapseShapeWithRankReducingExtractSlice()</a>, <a class="el" href="Split_8cpp_source.html#l00067">mlir::linalg::splitOp()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00030">mlir::linalg::splitReduction()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00241">mlir::linalg::splitReductionByScaling()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00891">tileAndFuseFirstExtractUseThroughContainingOpBlockArgument()</a>, <a class="el" href="Tiling_8cpp_source.html#l00589">mlir::linalg::tileReductionUsingForall()</a>, <a class="el" href="TransposeMatmul_8cpp_source.html#l00087">mlir::linalg::transposeBatchMatmul()</a>, <a class="el" href="TransposeMatmul_8cpp_source.html#l00030">mlir::linalg::transposeMatmul()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00629">transposeOneLinalgOperandAndReplace()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00070">mlir::OperationFolder::tryToFold()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00730">updateExpandedGenericOpRegion()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02769">mlir::linalg::vectorizeCopy()</a>, and <a class="el" href="SCFTransformOps_8cpp_source.html#l00156">wrapInExecuteRegion()</a>.</p>

</div>
</div>
<a id="a2108929d0979260bd4a7ea5a0b84abab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2108929d0979260bd4a7ea5a0b84abab">&#9670;&nbsp;</a></span>replaceOpUsesWithIf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::RewriterBase::replaceOpUsesWithIf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>allUsesReplaced</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00677">677</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00261">replaceUsesWithIf()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l00084">mlir::makeRegionIsolatedFromAbove()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00687">replaceOpUsesWithinBlock()</a>.</p>

</div>
</div>
<a id="ae5b31f03cc8e5dc784053dafc9d3c021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b31f03cc8e5dc784053dafc9d3c021">&#9670;&nbsp;</a></span>replaceOpUsesWithinBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::RewriterBase::replaceOpUsesWithinBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>allUsesReplaced</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find uses of <code>from</code> within <code>block</code> and replace them with <code>to</code>. </p>
<p>Also notify the listener about every in-place op modification (for every use that was replaced). The optional <code>allUsesReplaced</code> flag is set to "true" if all uses were replaced. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00687">687</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Block_8cpp_source.html#l00031">mlir::Block::getParentOp()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00677">replaceOpUsesWithIf()</a>.</p>

</div>
</div>
<a id="afb1c910a57707f518d2b9c903c2bb5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1c910a57707f518d2b9c903c2bb5bc">&#9670;&nbsp;</a></span>replaceOpWithNewOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpTy mlir::RewriterBase::replaceOpWithNewOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the results of the given (original) op with a new op that is created without verification (replacement). </p>
<p>The result values of the two ops must match. The original op is erased. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00519">519</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00127">replaceOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00917">addInitOperandsToLoopNest()</a>, <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00178">mlir::memref::allocToAlloca()</a>, <a class="el" href="IndexOps_8cpp_source.html#l00125">canonicalizeAssociativeCommutativeBinaryOp()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00065">canonicalizeMinMaxOp()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00039">convertCastingOp()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00643">convertRsqrtOp()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00110">convertTanhOp()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00186">createDecl()</a>, <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html#l00040">mlir::createElementwiseOp()</a>, <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00649">dropSwitchCasesThatMatchDefault()</a>, <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00684">foldSwitch()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00085">mlir::bufferization::foldToBufferToTensorPair()</a>, <a class="el" href="Sparsification_8cpp_source.html#l01360">genResult()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00318">insertCasts()</a>, <a class="el" href="Interchange_8cpp_source.html#l00045">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="AffineExpandIndexOps_8cpp_source.html#l00145">mlir::affine::lowerAffineLinearizeIndexOp()</a>, <a class="el" href="NamedOpConversions_8cpp_source.html#l00036">matchAndReplaceDepthwiseConv()</a>, <a class="el" href="ComplexOps_8cpp_source.html#l00155">MergeArithBitcast::matchAndRewrite()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02436">SelectToExtUI::matchAndRewrite()</a>, <a class="el" href="ComplexOps_8cpp_source.html#l00127">MergeComplexBitcast::matchAndRewrite()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02169">CmpFIntToFPConst::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00260">mlir::ComposeCollapseOfExpandOp&lt; CollapseOpTy, ExpandOpTy, CastOpTy, DimOpTy, TensorTy &gt;::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02535">CollapseShapeOpMemRefCastFolder::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00361">mlir::ComposeExpandOfCollapseOp&lt; ExpandOpTy, CollapseOpTy &gt;::matchAndRewrite()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00188">Convert1DExtractStridedSliceIntoShuffle::matchAndRewrite()</a>, <a class="el" href="FoldMemRefsOps_8cpp_source.html#l00033">mlir::amdgpu::FoldMemRefOpsIntoGatherToLDSOp::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00758">mlir::GPUReturnOpLowering::matchAndRewrite()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00039">DecomposeDifferentRankInsertStridedSlice::matchAndRewrite()</a>, <a class="el" href="VectorInsertExtractStridedSliceRewritePatterns_8cpp_source.html#l00095">ConvertSameRankInsertStridedSliceIntoShuffle::matchAndRewrite()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l02300">FoldBroadcasts::matchAndRewrite()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l02089">FoldTransposeWithTranspose::matchAndRewrite()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l02114">SwapTransposeWithBroadcast::matchAndRewrite()</a>, <a class="el" href="LinalgToStandard_8cpp_source.html#l00110">mlir::linalg::LinalgOpToLibraryCallRewrite::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00213">MulExtendedFold&lt; MulOp, IsSigned &gt;::matchAndRewrite()</a>, <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00178">InsertSliceOfInsertSliceFolder&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="ReshapeOpsUtils_8h_source.html#l00192">mlir::ComposeReassociativeReshapeOps&lt; ReshapeOpTy, opKind &gt;::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00344">ConvertAccessChain::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00328">ConvertAddressOf::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00133">IAddCarryFold::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00535">ConvertStore::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00331">UModSimplification::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00289">UMulExtendedOpXOne::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03530">DeduplicateAffineMinMaxExpressions&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03573">MergeAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03714">CanonicalizeAffineMinMaxOpExprAndTermOrder&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03728">CanonicalizeSingleResultAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="SwapExtractSliceWithFillPatterns_8cpp_source.html#l00026">SwapExtractSliceOfFill::matchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00944">mlir::linalg::DecomposePadOpPattern::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00546">ClampClampOptimization::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00313">ConcatOptimization::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00724">PadSliceOptimization::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00388">TransposeIsReshape::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00350">ConsolidateTransposeOptimization::matchAndRewrite()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l01222">matchAndRewriteSortOp()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00093">movePaddingToFillOrGenericOp()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l03249">SubViewCanonicalizer::operator()()</a>, <a class="el" href="EraseUnusedOperandsAndResults_8cpp_source.html#l00172">populateOpPayload()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l01131">reduceMatchAndRewriteHelper()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00227">replaceUnitDimIndexOps()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00226">replaceWithLoadOrStore()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02485">rewriteFromElementsAsBroadcast()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00350">mlir::linalg::rewriteInDestinationPassingStyle()</a>, <a class="el" href="Vectorization_8cpp_source.html#l03188">PadOpVectorizationWithInsertSlicePattern::rewriteUser()</a>, <a class="el" href="Vectorization_8cpp_source.html#l02916">PadOpVectorizationWithTransferWritePattern::rewriteUser()</a>, <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00158">mlir::tensor::simplifyCollapseShapeWithRankReducingExtractSlice()</a>, <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00171">simplifyPassThroughBr()</a>, <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00726">simplifyPassThroughSwitch()</a>, <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00851">simplifySwitchFromDefaultSwitchOnSameCondition()</a>, <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00799">simplifySwitchFromSwitchOnSameCondition()</a>, <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00628">simplifySwitchWithOnlyDefault()</a>, and <a class="el" href="Specialize_8cpp_source.html#l00258">mlir::linalg::specializeGenericOp()</a>.</p>

</div>
</div>
<a id="a98b33eb97c405cd1940ef921bbc4c297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b33eb97c405cd1940ef921bbc4c297">&#9670;&nbsp;</a></span>replaceUsesWithIf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::replaceUsesWithIf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>allUsesReplaced</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find uses of <code>from</code> and replace them with <code>to</code> if the <code>functor</code> returns true. </p>
<p>Also notify the listener about every in-place op modification (for every use that was replaced). The optional <code>allUsesReplaced</code> flag is set to "true" if all uses were replaced. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00261">261</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00188">mlir::Value::getUses()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00628">modifyOpInPlace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8cpp_source.html#l00084">mlir::makeRegionIsolatedFromAbove()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00352">mlir::shard::maybeInsertSourceShardingAnnotation()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00890">mlir::linalg::offsetIndices()</a>, <a class="el" href="PatternMatch_8h_source.html#l00700">replaceAllUsesExcept()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00639">replaceForAllWithNewSignature()</a>, <a class="el" href="PatternMatch_8h_source.html#l00677">replaceOpUsesWithIf()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00275">replaceUsesWithIf()</a>.</p>

</div>
</div>
<a id="a5ce5dd05c050fd1ef37a05dcfa11bc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce5dd05c050fd1ef37a05dcfa11bc38">&#9670;&nbsp;</a></span>replaceUsesWithIf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RewriterBase::replaceUsesWithIf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>allUsesReplaced</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00275">275</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00261">replaceUsesWithIf()</a>.</p>

</div>
</div>
<a id="a495c76a07ca3e6c84a1594a64dd3cfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495c76a07ca3e6c84a1594a64dd3cfa4">&#9670;&nbsp;</a></span>splitBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Block.html">Block</a> * RewriterBase::splitBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the operations starting at "before" (inclusive) out of the given block into a new block, and return it. </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8cpp_source.html#l00350">350</a> of file <a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00152">mlir::Block::back()</a>, <a class="el" href="Block_8h_source.html#l00143">mlir::Block::begin()</a>, <a class="el" href="Builders_8cpp_source.html#l00425">mlir::OpBuilder::createBlock()</a>, <a class="el" href="Block_8h_source.html#l00144">mlir::Block::end()</a>, <a class="el" href="Block_8cpp_source.html#l00027">mlir::Block::getParent()</a>, <a class="el" href="Builders_8h_source.html#l00608">mlir::OpBuilder::listener</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00407">moveOpBefore()</a>, and <a class="el" href="Block_8cpp_source.html#l00308">mlir::Block::splitBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncToAsyncRuntime_8cpp_source.html#l00746">AssertOpLowering::matchAndRewrite()</a>, and <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00238">MultiBlockExecuteInliner::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="afa1f09ffd231a52d1f2e41508a3f60dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1f09ffd231a52d1f2e41508a3f60dc">&#9670;&nbsp;</a></span>startOpModification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mlir::RewriterBase::startOpModification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used to notify the rewriter that an in-place operation modification is about to happen. </p>
<p>A call to this function <em>must</em> be followed by a call to either <code>finalizeOpModification</code> or <code>cancelOpModification</code>. This is a minor efficiency win (it avoids creating a new operation and removing the old one) but also often allows simpler code in the client. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1ConversionPatternRewriter.html#a4f6463fec3adeb233a630263751dfea5">mlir::ConversionPatternRewriter</a>.</p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00612">612</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Interchange_8cpp_source.html#l00045">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l02406">RemoveUnusedLvlCrds::matchAndRewrite()</a>, <a class="el" href="PatternMatch_8h_source.html#l00628">modifyOpInPlace()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00801">padThroughLoopIterArg()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00041">mlir::affine::reorderOperandsByHoistability()</a>, and <a class="el" href="MultiBuffer_8cpp_source.html#l00044">replaceUsesAndPropagateType()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/IR/<a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a></li>
<li>lib/IR/<a class="el" href="PatternMatch_8cpp_source.html">PatternMatch.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:30 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
