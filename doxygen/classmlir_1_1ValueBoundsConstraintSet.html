<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::ValueBoundsConstraintSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html">ValueBoundsConstraintSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classmlir_1_1ValueBoundsConstraintSet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::ValueBoundsConstraintSet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A helper class to be used with <code>ValueBoundsOpInterface</code>.  
 <a href="classmlir_1_1ValueBoundsConstraintSet.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="ValueBoundsOpInterface_8h_source.html">mlir/Interfaces/ValueBoundsOpInterface.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mlir::ValueBoundsConstraintSet:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classmlir_1_1ValueBoundsConstraintSet__inherit__graph.svg" width="239" height="231"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1BoundBuilder.html">BoundBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that builds a bound for a shaped value dimension or index-typed value.  <a href="classmlir_1_1ValueBoundsConstraintSet_1_1BoundBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable that can be added to the constraint set as a "column".  <a href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6de419cb4fc58ccc729b0a1fc946f9cc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a> { <br />
&#160;&#160;<a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9cca3c60bda921433c00284e1d12691ad30c">LT</a>
, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9cca5e6b217a890b61fdd811e25487637292">LE</a>
, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9ccac6a97fc09b493c8934fd90597f019cae">EQ</a>
, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9ccada81d3c25a388334f641a2443d5c5dc2">GT</a>
, <br />
&#160;&#160;<a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9cca68a237f57af25c0f10ea1095fc9c3bc3">GE</a>
<br />
 }</td></tr>
<tr class="memdesc:a6de419cb4fc58ccc729b0a1fc946f9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for <code><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a06631ca1346abc0c35de13244e1603dc" title="Return &quot;true&quot; if &quot;lhs cmp rhs&quot; was proven to hold.">ValueBoundsConstraintSet::compare</a></code>.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9cc">More...</a><br /></td></tr>
<tr class="separator:a6de419cb4fc58ccc729b0a1fc946f9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae056756719b121863baa8d395f7280ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">StopConditionFn</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, std::optional&lt; int64_t &gt;, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html">ValueBoundsConstraintSet</a> &amp;<a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#aa050edbbd92d0354a4f6712e60b7e202">cstr</a>)&gt;</td></tr>
<tr class="memdesc:ae056756719b121863baa8d395f7280ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stop condition when traversing the backward slice of a shaped value/ index-type value.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">More...</a><br /></td></tr>
<tr class="separator:ae056756719b121863baa8d395f7280ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf8cc9c8f19a25e07857506d3b6744ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#acf8cc9c8f19a25e07857506d3b6744ca">populateConstraints</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, std::optional&lt; int64_t &gt; dim)</td></tr>
<tr class="memdesc:acf8cc9c8f19a25e07857506d3b6744ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the IR starting from the given value/dim and populate constraints as long as the stop condition holds.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#acf8cc9c8f19a25e07857506d3b6744ca">More...</a><br /></td></tr>
<tr class="separator:acf8cc9c8f19a25e07857506d3b6744ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1947c5fb677562e70ad8d29c53fc7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#aee1947c5fb677562e70ad8d29c53fc7d">populateAndCompare</a> (const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;lhs, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a> cmp, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;rhs)</td></tr>
<tr class="memdesc:aee1947c5fb677562e70ad8d29c53fc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate constraints for lhs/rhs (until the stop condition is met).  <a href="classmlir_1_1ValueBoundsConstraintSet.html#aee1947c5fb677562e70ad8d29c53fc7d">More...</a><br /></td></tr>
<tr class="separator:aee1947c5fb677562e70ad8d29c53fc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e46bfa1744b11e2adcf9f9bf5f25ef8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1BoundBuilder.html">BoundBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6e46bfa1744b11e2adcf9f9bf5f25ef8">bound</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a6e46bfa1744b11e2adcf9f9bf5f25ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a bound for the given index-typed value or shaped value.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a6e46bfa1744b11e2adcf9f9bf5f25ef8">More...</a><br /></td></tr>
<tr class="separator:a6e46bfa1744b11e2adcf9f9bf5f25ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24623069be2ea1a3a8b145201c2cd6e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a24623069be2ea1a3a8b145201c2cd6e4">getExpr</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, std::optional&lt; int64_t &gt; dim=std::nullopt)</td></tr>
<tr class="memdesc:a24623069be2ea1a3a8b145201c2cd6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an expression that represents the given index-typed value or shaped value dimension.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a24623069be2ea1a3a8b145201c2cd6e4">More...</a><br /></td></tr>
<tr class="separator:a24623069be2ea1a3a8b145201c2cd6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad261cd52134aaac33b8bef2edbec027a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ad261cd52134aaac33b8bef2edbec027a">getExpr</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:ad261cd52134aaac33b8bef2edbec027a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an expression that represents a constant or index-typed SSA value.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#ad261cd52134aaac33b8bef2edbec027a">More...</a><br /></td></tr>
<tr class="separator:ad261cd52134aaac33b8bef2edbec027a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d6a2d21f63e780bca2e988255b5d05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ac5d6a2d21f63e780bca2e988255b5d05">getExpr</a> (int64_t constant)</td></tr>
<tr class="memdesc:ac5d6a2d21f63e780bca2e988255b5d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an expression that represents a constant.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#ac5d6a2d21f63e780bca2e988255b5d05">More...</a><br /></td></tr>
<tr class="separator:ac5d6a2d21f63e780bca2e988255b5d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c75fecb7c6277a4c88ca79a40a3c8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a92c75fecb7c6277a4c88ca79a40a3c8a">dump</a> () const</td></tr>
<tr class="memdesc:a92c75fecb7c6277a4c88ca79a40a3c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging only: Dump the constraint set and the column-to-value/dim mapping to llvm::errs.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a92c75fecb7c6277a4c88ca79a40a3c8a">More...</a><br /></td></tr>
<tr class="separator:a92c75fecb7c6277a4c88ca79a40a3c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7053c23ea00d64c7b82b49c6544471bb"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a7053c23ea00d64c7b82b49c6544471bb">computeBound</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;resultMap, <a class="el" href="namespacemlir.html#a9c852d22f676b319b260b86ad21499ac">ValueDimList</a> &amp;mapOperands, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a> type, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;var, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">StopConditionFn</a> <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6d2968aa9c133f84d2041a0f1935d8a7">stopCondition</a>, bool closedUB=false)</td></tr>
<tr class="memdesc:a7053c23ea00d64c7b82b49c6544471bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bound for the given variable.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a7053c23ea00d64c7b82b49c6544471bb">More...</a><br /></td></tr>
<tr class="separator:a7053c23ea00d64c7b82b49c6544471bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd535d042c1a7d8fab6def3fa64c470"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#afbd535d042c1a7d8fab6def3fa64c470">computeDependentBound</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;resultMap, <a class="el" href="namespacemlir.html#a9c852d22f676b319b260b86ad21499ac">ValueDimList</a> &amp;mapOperands, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a> type, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;var, <a class="el" href="namespacemlir.html#a9c852d22f676b319b260b86ad21499ac">ValueDimList</a> dependencies, bool closedUB=false)</td></tr>
<tr class="memdesc:afbd535d042c1a7d8fab6def3fa64c470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bound in terms of the values/dimensions in <code>dependencies</code>.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#afbd535d042c1a7d8fab6def3fa64c470">More...</a><br /></td></tr>
<tr class="separator:afbd535d042c1a7d8fab6def3fa64c470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262e78068c435b47c6d7126325bd2098"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a262e78068c435b47c6d7126325bd2098">computeIndependentBound</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;resultMap, <a class="el" href="namespacemlir.html#a9c852d22f676b319b260b86ad21499ac">ValueDimList</a> &amp;mapOperands, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a> type, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;var, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> independencies, bool closedUB=false)</td></tr>
<tr class="memdesc:a262e78068c435b47c6d7126325bd2098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bound in that is independent of all values in <code>independencies</code>.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a262e78068c435b47c6d7126325bd2098">More...</a><br /></td></tr>
<tr class="separator:a262e78068c435b47c6d7126325bd2098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c4e6d4080fde3c945426d0cb287df5"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a92c4e6d4080fde3c945426d0cb287df5">computeConstantBound</a> (<a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a> type, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;var, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">StopConditionFn</a> <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6d2968aa9c133f84d2041a0f1935d8a7">stopCondition</a>=nullptr, bool closedUB=false)</td></tr>
<tr class="memdesc:a92c4e6d4080fde3c945426d0cb287df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a constant bound for the given variable.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a92c4e6d4080fde3c945426d0cb287df5">More...</a><br /></td></tr>
<tr class="separator:a92c4e6d4080fde3c945426d0cb287df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cb5014b195e2da13cb6408c02a7a8e"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a57cb5014b195e2da13cb6408c02a7a8e">computeConstantDelta</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value1, <a class="el" href="classmlir_1_1Value.html">Value</a> value2, std::optional&lt; int64_t &gt; dim1=std::nullopt, std::optional&lt; int64_t &gt; dim2=std::nullopt)</td></tr>
<tr class="memdesc:a57cb5014b195e2da13cb6408c02a7a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a constant delta between the given two values.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a57cb5014b195e2da13cb6408c02a7a8e">More...</a><br /></td></tr>
<tr class="separator:a57cb5014b195e2da13cb6408c02a7a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06631ca1346abc0c35de13244e1603dc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a06631ca1346abc0c35de13244e1603dc">compare</a> (const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;lhs, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a> cmp, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;rhs)</td></tr>
<tr class="memdesc:a06631ca1346abc0c35de13244e1603dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if "lhs cmp rhs" was proven to hold.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a06631ca1346abc0c35de13244e1603dc">More...</a><br /></td></tr>
<tr class="separator:a06631ca1346abc0c35de13244e1603dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbfc66cbcfe22e0865e6b580750e3b8"><td class="memItemLeft" align="right" valign="top">static llvm::FailureOr&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a5cbfc66cbcfe22e0865e6b580750e3b8">strongCompare</a> (const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;lhs, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a> cmp, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;rhs)</td></tr>
<tr class="memdesc:a5cbfc66cbcfe22e0865e6b580750e3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is similar to <code><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a06631ca1346abc0c35de13244e1603dc" title="Return &quot;true&quot; if &quot;lhs cmp rhs&quot; was proven to hold.">ValueBoundsConstraintSet::compare</a></code>, except that it returns false if <code>!(lhs cmp rhs)</code>, and <code>failure</code> if neither the relation nor its inverse relation could be proven.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a5cbfc66cbcfe22e0865e6b580750e3b8">More...</a><br /></td></tr>
<tr class="separator:a5cbfc66cbcfe22e0865e6b580750e3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06675973ae78af7d27d2e7028173f57d"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a06675973ae78af7d27d2e7028173f57d">areEqual</a> (const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;var1, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;var2)</td></tr>
<tr class="memdesc:a06675973ae78af7d27d2e7028173f57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether the given variables are equal.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a06675973ae78af7d27d2e7028173f57d">More...</a><br /></td></tr>
<tr class="separator:a06675973ae78af7d27d2e7028173f57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02d7ec8c053b397481d8f5e9b215693"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae02d7ec8c053b397481d8f5e9b215693">areOverlappingSlices</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a> slice1, <a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a> slice2)</td></tr>
<tr class="memdesc:ae02d7ec8c053b397481d8f5e9b215693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if the given slices are guaranteed to be overlapping.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#ae02d7ec8c053b397481d8f5e9b215693">More...</a><br /></td></tr>
<tr class="separator:ae02d7ec8c053b397481d8f5e9b215693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab771888cbc671f9731dc5b2e5c500682"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ab771888cbc671f9731dc5b2e5c500682">areEquivalentSlices</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a> slice1, <a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a> slice2)</td></tr>
<tr class="memdesc:ab771888cbc671f9731dc5b2e5c500682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if the given slices are guaranteed to be equivalent.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#ab771888cbc671f9731dc5b2e5c500682">More...</a><br /></td></tr>
<tr class="separator:ab771888cbc671f9731dc5b2e5c500682"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae9decec8380c34985c86d837342f67ab"><td class="memItemLeft" align="right" valign="top">static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae9decec8380c34985c86d837342f67ab">ID</a> = 0</td></tr>
<tr class="separator:ae9decec8380c34985c86d837342f67ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ac57ffad5889e7da2eb288c23dfb84556"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ac57ffad5889e7da2eb288c23dfb84556">ValueDim</a> = std::pair&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, int64_t &gt;</td></tr>
<tr class="memdesc:ac57ffad5889e7da2eb288c23dfb84556"><td class="mdescLeft">&#160;</td><td class="mdescRight">An index-typed value or the dimension of a shaped-type value.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#ac57ffad5889e7da2eb288c23dfb84556">More...</a><br /></td></tr>
<tr class="separator:ac57ffad5889e7da2eb288c23dfb84556"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a26e6385c7c163d016c68756f48da43f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a26e6385c7c163d016c68756f48da43f9">ValueBoundsConstraintSet</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">StopConditionFn</a> <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6d2968aa9c133f84d2041a0f1935d8a7">stopCondition</a>, bool <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a1c0c3000f52de037eb63b26255bfd490">addConservativeSemiAffineBounds</a>=false)</td></tr>
<tr class="separator:a26e6385c7c163d016c68756f48da43f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873ca2349d8aab548a7b1bbe93dbd515"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a873ca2349d8aab548a7b1bbe93dbd515">comparePos</a> (int64_t lhsPos, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a> cmp, int64_t rhsPos)</td></tr>
<tr class="memdesc:a873ca2349d8aab548a7b1bbe93dbd515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if, based on the current state of the constraint system, "lhs cmp rhs" was proven to hold.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a873ca2349d8aab548a7b1bbe93dbd515">More...</a><br /></td></tr>
<tr class="separator:a873ca2349d8aab548a7b1bbe93dbd515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5ab8164e75c5ce15ed2f946d3565e5"><td class="memItemLeft" align="right" valign="top">llvm::FailureOr&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#aaf5ab8164e75c5ce15ed2f946d3565e5">strongComparePos</a> (int64_t lhsPos, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a> cmp, int64_t rhsPos)</td></tr>
<tr class="memdesc:aaf5ab8164e75c5ce15ed2f946d3565e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if, based on the current state of the constraint system, "lhs cmp rhs" was proven to hold.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#aaf5ab8164e75c5ce15ed2f946d3565e5">More...</a><br /></td></tr>
<tr class="separator:aaf5ab8164e75c5ce15ed2f946d3565e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9cb692dc4b05849d4717fd2ddf41ce"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#aef9cb692dc4b05849d4717fd2ddf41ce">populateConstraints</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="namespacemlir.html#a9c852d22f676b319b260b86ad21499ac">ValueDimList</a> mapOperands)</td></tr>
<tr class="memdesc:aef9cb692dc4b05849d4717fd2ddf41ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an affine map with a single result (and map operands), add a new column to the constraint set that represents the result of the map.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#aef9cb692dc4b05849d4717fd2ddf41ce">More...</a><br /></td></tr>
<tr class="separator:aef9cb692dc4b05849d4717fd2ddf41ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae3298af91a6fcf19bbe0e99474a71d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a1ae3298af91a6fcf19bbe0e99474a71d">processWorklist</a> ()</td></tr>
<tr class="memdesc:a1ae3298af91a6fcf19bbe0e99474a71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively process all elements on the worklist until an index-typed value or shaped value meets <code>stopCondition</code>.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a1ae3298af91a6fcf19bbe0e99474a71d">More...</a><br /></td></tr>
<tr class="separator:a1ae3298af91a6fcf19bbe0e99474a71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68979f050a6943aa34f37f020fb1f056"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a68979f050a6943aa34f37f020fb1f056">addBound</a> (<a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a> type, int64_t pos, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="memdesc:a68979f050a6943aa34f37f020fb1f056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound the given column in the underlying constraint set by the given expression.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a68979f050a6943aa34f37f020fb1f056">More...</a><br /></td></tr>
<tr class="separator:a68979f050a6943aa34f37f020fb1f056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8586ef3ed7a840c87e8fd2fc24ba5c13"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a8586ef3ed7a840c87e8fd2fc24ba5c13">getPos</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, std::optional&lt; int64_t &gt; dim=std::nullopt) const</td></tr>
<tr class="memdesc:a8586ef3ed7a840c87e8fd2fc24ba5c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the column position of the given value/dimension.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a8586ef3ed7a840c87e8fd2fc24ba5c13">More...</a><br /></td></tr>
<tr class="separator:a8586ef3ed7a840c87e8fd2fc24ba5c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab057bc1bf30abd3bc8c76620ff32cd4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ab057bc1bf30abd3bc8c76620ff32cd4b">getPosExpr</a> (int64_t pos)</td></tr>
<tr class="memdesc:ab057bc1bf30abd3bc8c76620ff32cd4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an affine expression that represents column <code>pos</code> in the constraint set.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#ab057bc1bf30abd3bc8c76620ff32cd4b">More...</a><br /></td></tr>
<tr class="separator:ab057bc1bf30abd3bc8c76620ff32cd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee7f7bb79ec6cb583fe312fd59deefe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#aaee7f7bb79ec6cb583fe312fd59deefe">isMapped</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, std::optional&lt; int64_t &gt; dim=std::nullopt) const</td></tr>
<tr class="memdesc:aaee7f7bb79ec6cb583fe312fd59deefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if the given value/dim is mapped (i.e., has a corresponding column in the constraint system).  <a href="classmlir_1_1ValueBoundsConstraintSet.html#aaee7f7bb79ec6cb583fe312fd59deefe">More...</a><br /></td></tr>
<tr class="separator:aaee7f7bb79ec6cb583fe312fd59deefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863ab398668a486c2aa39c47f7fef171"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a863ab398668a486c2aa39c47f7fef171">insert</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, std::optional&lt; int64_t &gt; dim, bool isSymbol=true, bool addToWorklist=true)</td></tr>
<tr class="memdesc:a863ab398668a486c2aa39c47f7fef171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a value/dimension into the constraint set.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a863ab398668a486c2aa39c47f7fef171">More...</a><br /></td></tr>
<tr class="separator:a863ab398668a486c2aa39c47f7fef171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af271a31c4fde7430da2588bb3ce56960"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#af271a31c4fde7430da2588bb3ce56960">insert</a> (bool isSymbol=true)</td></tr>
<tr class="memdesc:af271a31c4fde7430da2588bb3ce56960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an anonymous column into the constraint set.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#af271a31c4fde7430da2588bb3ce56960">More...</a><br /></td></tr>
<tr class="separator:af271a31c4fde7430da2588bb3ce56960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d7727decb7b3672be0ddb364dacabc"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a28d7727decb7b3672be0ddb364dacabc">insert</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="namespacemlir.html#a9c852d22f676b319b260b86ad21499ac">ValueDimList</a> operands, bool isSymbol=true)</td></tr>
<tr class="memdesc:a28d7727decb7b3672be0ddb364dacabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given affine map and its bound operands as a new column in the constraint system.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a28d7727decb7b3672be0ddb364dacabc">More...</a><br /></td></tr>
<tr class="separator:a28d7727decb7b3672be0ddb364dacabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b8073f39f96b6a857040ecf255205b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ac4b8073f39f96b6a857040ecf255205b">insert</a> (const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;var, bool isSymbol=true)</td></tr>
<tr class="separator:ac4b8073f39f96b6a857040ecf255205b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f741239cfb6c63b288a16c2314a8ada"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a3f741239cfb6c63b288a16c2314a8ada">projectOut</a> (int64_t pos)</td></tr>
<tr class="memdesc:a3f741239cfb6c63b288a16c2314a8ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project out the given column in the constraint set.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a3f741239cfb6c63b288a16c2314a8ada">More...</a><br /></td></tr>
<tr class="separator:a3f741239cfb6c63b288a16c2314a8ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae7e00e049e6424079168fa8ac76a9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a1ae7e00e049e6424079168fa8ac76a9f">projectOut</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ac57ffad5889e7da2eb288c23dfb84556">ValueDim</a>)&gt; condition)</td></tr>
<tr class="memdesc:a1ae7e00e049e6424079168fa8ac76a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project out all columns for which the condition holds.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a1ae7e00e049e6424079168fa8ac76a9f">More...</a><br /></td></tr>
<tr class="separator:a1ae7e00e049e6424079168fa8ac76a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab444ead14e592768f090608fbb16a0cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ab444ead14e592768f090608fbb16a0cb">projectOutAnonymous</a> (std::optional&lt; int64_t &gt; except=std::nullopt)</td></tr>
<tr class="separator:ab444ead14e592768f090608fbb16a0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a252a2d4f3f9fe0e8c4b7808181a6233e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; std::optional&lt; <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ac57ffad5889e7da2eb288c23dfb84556">ValueDim</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a252a2d4f3f9fe0e8c4b7808181a6233e">positionToValueDim</a></td></tr>
<tr class="memdesc:a252a2d4f3f9fe0e8c4b7808181a6233e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping of columns to values/shape dimensions.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a252a2d4f3f9fe0e8c4b7808181a6233e">More...</a><br /></td></tr>
<tr class="separator:a252a2d4f3f9fe0e8c4b7808181a6233e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1400a0b15e88ed5b9c953675ae5bb223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ac57ffad5889e7da2eb288c23dfb84556">ValueDim</a>, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a1400a0b15e88ed5b9c953675ae5bb223">valueDimToPosition</a></td></tr>
<tr class="memdesc:a1400a0b15e88ed5b9c953675ae5bb223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse mapping of values/shape dimensions to columns.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a1400a0b15e88ed5b9c953675ae5bb223">More...</a><br /></td></tr>
<tr class="separator:a1400a0b15e88ed5b9c953675ae5bb223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9437e4d82b1f5f8649421e3405ac8081"><td class="memItemLeft" align="right" valign="top">std::queue&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a9437e4d82b1f5f8649421e3405ac8081">worklist</a></td></tr>
<tr class="memdesc:a9437e4d82b1f5f8649421e3405ac8081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worklist of values/shape dimensions that have not been processed yet.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a9437e4d82b1f5f8649421e3405ac8081">More...</a><br /></td></tr>
<tr class="separator:a9437e4d82b1f5f8649421e3405ac8081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa050edbbd92d0354a4f6712e60b7e202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#aa050edbbd92d0354a4f6712e60b7e202">cstr</a></td></tr>
<tr class="memdesc:aa050edbbd92d0354a4f6712e60b7e202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint system of equalities and inequalities.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#aa050edbbd92d0354a4f6712e60b7e202">More...</a><br /></td></tr>
<tr class="separator:aa050edbbd92d0354a4f6712e60b7e202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84dccc7a15710a44f413cbde1a2aa57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Builder.html">Builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae84dccc7a15710a44f413cbde1a2aa57">builder</a></td></tr>
<tr class="memdesc:ae84dccc7a15710a44f413cbde1a2aa57"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Builder.html" title="This class is a general helper class for creating context-global objects like types,...">Builder</a> for constructing affine expressions.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#ae84dccc7a15710a44f413cbde1a2aa57">More...</a><br /></td></tr>
<tr class="separator:ae84dccc7a15710a44f413cbde1a2aa57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2968aa9c133f84d2041a0f1935d8a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">StopConditionFn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6d2968aa9c133f84d2041a0f1935d8a7">stopCondition</a> = nullptr</td></tr>
<tr class="memdesc:a6d2968aa9c133f84d2041a0f1935d8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current stop condition function.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a6d2968aa9c133f84d2041a0f1935d8a7">More...</a><br /></td></tr>
<tr class="separator:a6d2968aa9c133f84d2041a0f1935d8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0c3000f52de037eb63b26255bfd490"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a1c0c3000f52de037eb63b26255bfd490">addConservativeSemiAffineBounds</a> = false</td></tr>
<tr class="memdesc:a1c0c3000f52de037eb63b26255bfd490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should conservative bounds be added for semi-affine expressions.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#a1c0c3000f52de037eb63b26255bfd490">More...</a><br /></td></tr>
<tr class="separator:a1c0c3000f52de037eb63b26255bfd490"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:afad63892c0cdb924297f073902a32735"><td class="memItemLeft" align="right" valign="top">static constexpr int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#afad63892c0cdb924297f073902a32735">kIndexValue</a> = -1</td></tr>
<tr class="memdesc:afad63892c0cdb924297f073902a32735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension identifier to indicate a value is index-typed.  <a href="classmlir_1_1ValueBoundsConstraintSet.html#afad63892c0cdb924297f073902a32735">More...</a><br /></td></tr>
<tr class="separator:afad63892c0cdb924297f073902a32735"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A helper class to be used with <code>ValueBoundsOpInterface</code>. </p>
<p>This class stores a constraint system and mapping of constrained variables to index-typed values or dimension sizes of shaped values.</p>
<p>Interface implementations of <code>ValueBoundsOpInterface</code> use <code>addBounds</code> to insert constraints about their results and/or region block arguments into the constraint set in the form of an <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a>. When a bound should be expressed in terms of another value/dimension, <code>getExpr</code> can be used to retrieve an <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> that represents the specified value/dimension.</p>
<p>When a value/dimension is retrieved for the first time through <code>getExpr</code>, it is added to an internal worklist. See <code>computeBound</code> for more details.</p>
<p>Note: Any modification of existing IR invalides the data stored in this class. Adding new operations is allowed. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00068">68</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae056756719b121863baa8d395f7280ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae056756719b121863baa8d395f7280ef">&#9670;&nbsp;</a></span>StopConditionFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">mlir::ValueBoundsConstraintSet::StopConditionFn</a> =  std::function&lt;bool( <a class="el" href="classmlir_1_1Value.html">Value</a>, std::optional&lt;int64_t&gt; , <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html">ValueBoundsConstraintSet</a> &amp;<a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#aa050edbbd92d0354a4f6712e60b7e202">cstr</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The stop condition when traversing the backward slice of a shaped value/ index-type value. </p>
<p>The traversal continues until the stop condition evaluates to "true" for a value.</p>
<p>The first parameter of the function is the shaped value/index-typed value. The second parameter is the dimension in case of a shaped value. The third parameter is this constraint set. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00162">162</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

</div>
</div>
<a id="ac57ffad5889e7da2eb288c23dfb84556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57ffad5889e7da2eb288c23dfb84556">&#9670;&nbsp;</a></span>ValueDim</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ac57ffad5889e7da2eb288c23dfb84556">mlir::ValueBoundsConstraintSet::ValueDim</a> =  std::pair&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, int64_t&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An index-typed value or the dimension of a shaped-type value. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00327">327</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a6de419cb4fc58ccc729b0a1fc946f9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de419cb4fc58ccc729b0a1fc946f9cc">&#9670;&nbsp;</a></span>ComparisonOperator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9cc">mlir::ValueBoundsConstraintSet::ComparisonOperator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator for <code><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a06631ca1346abc0c35de13244e1603dc" title="Return &quot;true&quot; if &quot;lhs cmp rhs&quot; was proven to hold.">ValueBoundsConstraintSet::compare</a></code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6de419cb4fc58ccc729b0a1fc946f9cca3c60bda921433c00284e1d12691ad30c"></a>LT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6de419cb4fc58ccc729b0a1fc946f9cca5e6b217a890b61fdd811e25487637292"></a>LE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6de419cb4fc58ccc729b0a1fc946f9ccac6a97fc09b493c8934fd90597f019cae"></a>EQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6de419cb4fc58ccc729b0a1fc946f9ccada81d3c25a388334f641a2443d5c5dc2"></a>GT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6de419cb4fc58ccc729b0a1fc946f9cca68a237f57af25c0f10ea1095fc9c3bc3"></a>GE&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">239</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a26e6385c7c163d016c68756f48da43f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e6385c7c163d016c68756f48da43f9">&#9670;&nbsp;</a></span>ValueBoundsConstraintSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueBoundsConstraintSet::ValueBoundsConstraintSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">StopConditionFn</a>&#160;</td>
          <td class="paramname"><em>stopCondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addConservativeSemiAffineBounds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00153">153</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00430">stopCondition</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a68979f050a6943aa34f37f020fb1f056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68979f050a6943aa34f37f020fb1f056">&#9670;&nbsp;</a></span>addBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueBoundsConstraintSet::addBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bound the given column in the underlying constraint set by the given expression. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00177">177</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00814">mlir::FlatLinearConstraints::addBound()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00433">addConservativeSemiAffineBounds</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00424">cstr</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00216">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00213">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>, <a class="el" href="classmlir_1_1FlatLinearConstraints.html#a77163b45dcb208f7555ddf7d8dfb7da6abafd7322c6e97d25b6299b5d6fe8920b">mlir::FlatLinearConstraints::No</a>, and <a class="el" href="classmlir_1_1FlatLinearConstraints.html#a77163b45dcb208f7555ddf7d8dfb7da6a93cba07454f06a4a960172bbd6e2a435">mlir::FlatLinearConstraints::Yes</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00305">insert()</a>.</p>

</div>
</div>
<a id="a06675973ae78af7d27d2e7028173f57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06675973ae78af7d27d2e7028173f57d">&#9670;&nbsp;</a></span>areEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; bool &gt; ValueBoundsConstraintSet::areEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute whether the given variables are equal. </p>
<p>Return "failure" if equality could not be determined. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00824">824</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00804">strongCompare()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00895">areEquivalentSlices()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00149">mlir::tensor::isCastLikeExtractSliceOp()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00125">mlir::tensor::isCastLikeInsertSliceOp()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00250">mlir::vector::isDisjointTransferIndices()</a>.</p>

</div>
</div>
<a id="ab771888cbc671f9731dc5b2e5c500682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab771888cbc671f9731dc5b2e5c500682">&#9670;&nbsp;</a></span>areEquivalentSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; bool &gt; ValueBoundsConstraintSet::areEquivalentSlices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a>&#160;</td>
          <td class="paramname"><em>slice1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a>&#160;</td>
          <td class="paramname"><em>slice2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return "true" if the given slices are guaranteed to be equivalent. </p>
<p>Return "false" if the given slices are guaranteed to be non-equivalent. Return "failure" if unknown.</p>
<p>Slices are equivalent if their offsets, sizes and strices are equal. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00895">895</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00824">areEqual()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00041">mlir::HyperrectangularSlice::getMixedOffsets()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00042">mlir::HyperrectangularSlice::getMixedSizes()</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00043">mlir::HyperrectangularSlice::getMixedStrides()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SubsetOpInterface_8cpp_source.html#l00044">mlir::detail::defaultOperatesOnEquivalentSubset()</a>.</p>

</div>
</div>
<a id="ae02d7ec8c053b397481d8f5e9b215693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02d7ec8c053b397481d8f5e9b215693">&#9670;&nbsp;</a></span>areOverlappingSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; bool &gt; ValueBoundsConstraintSet::areOverlappingSlices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a>&#160;</td>
          <td class="paramname"><em>slice1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a>&#160;</td>
          <td class="paramname"><em>slice2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return "true" if the given slices are guaranteed to be overlapping. </p>
<p>Return "false" if the given slices are guaranteed to be non-overlapping. Return "failure" if unknown.</p>
<p>Slices are overlapping if for all dimensions:</p><ul>
<li>offset1 + size1 * stride1 &lt;= offset2</li>
<li>and offset2 + size2 * stride2 &lt;= offset1</li>
</ul>
<p>Slice are non-overlapping if the above constraint is not satisfied for at least one dimension. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00830">830</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00630">computeConstantBound()</a>, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841da2dcbad7477fd40561e8b8198f173bd47">mlir::presburger::EQ</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00738">mlir::foldAttributesIntoMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00363">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00041">mlir::HyperrectangularSlice::getMixedOffsets()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00042">mlir::HyperrectangularSlice::getMixedSizes()</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00043">mlir::HyperrectangularSlice::getMixedStrides()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SubsetOpInterface_8cpp_source.html#l00065">mlir::detail::defaultOperatesOnDisjointSubset()</a>.</p>

</div>
</div>
<a id="a6e46bfa1744b11e2adcf9f9bf5f25ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e46bfa1744b11e2adcf9f9bf5f25ef8">&#9670;&nbsp;</a></span>bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1BoundBuilder.html">BoundBuilder</a> mlir::ValueBoundsConstraintSet::bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a bound for the given index-typed value or shaped value. </p>
<p>This function returns a builder that adds the bound. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00300">300</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00464">computeBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00630">computeConstantBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00200">getExpr()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">processWorklist()</a>.</p>

</div>
</div>
<a id="a06631ca1346abc0c35de13244e1603dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06631ca1346abc0c35de13244e1603dc">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ValueBoundsConstraintSet::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a>&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return "true" if "lhs cmp rhs" was proven to hold. </p>
<p>Return "false" if the specified relation could not be proven. This could be because the specified relation does in fact not hold or because there is not enough information in the constraint set. In other words, if we do not know for sure, this function returns "false".</p>
<p>This function keeps traversing the backward slice of lhs/rhs until could prove the relation or until it ran out of IR. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00785">785</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00424">cstr</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00140">mlir::ValueBoundsConstraintSet::Variable::getContext()</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00430">stopCondition</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01059">replaceAffineMinBoundingBoxExpression()</a>.</p>

</div>
</div>
<a id="a873ca2349d8aab548a7b1bbe93dbd515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873ca2349d8aab548a7b1bbe93dbd515">&#9670;&nbsp;</a></span>comparePos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ValueBoundsConstraintSet::comparePos </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lhsPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a>&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rhsPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return "true" if, based on the current state of the constraint system, "lhs cmp rhs" was proven to hold. </p>
<p>Return "false" if the specified relation could not be proven. This could be because the specified relation does in fact not hold or because there is not enough information in the constraint set. In other words, if we do not know for sure, this function returns "false".</p>
<p>This function does not analyze any IR and does not populate any additional constraints. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00692">692</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00369">mlir::presburger::IntegerRelation::addInequality()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00424">cstr</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">EQ</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">GE</a>, <a class="el" href="IntegerRelation_8h_source.html#l00223">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00227">mlir::presburger::IntegerRelation::getNumInequalities()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">GT</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00685">mlir::presburger::IntegerRelation::isEmpty()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">LE</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">LT</a>, and <a class="el" href="IntegerRelation_8cpp_source.html#l00440">mlir::presburger::IntegerRelation::removeInequality()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00777">populateAndCompare()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00739">strongComparePos()</a>.</p>

</div>
</div>
<a id="a7053c23ea00d64c7b82b49c6544471bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7053c23ea00d64c7b82b49c6544471bb">&#9670;&nbsp;</a></span>computeBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult ValueBoundsConstraintSet::computeBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>resultMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a9c852d22f676b319b260b86ad21499ac">ValueDimList</a> &amp;&#160;</td>
          <td class="paramname"><em>mapOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">StopConditionFn</a>&#160;</td>
          <td class="paramname"><em>stopCondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>closedUB</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a bound for the given variable. </p>
<p>The computed bound is stored in <code>resultMap</code>. The operands of the bound are stored in <code>mapOperands</code>. An operand is either an index-type SSA value or a shaped value and a dimension.</p>
<p>The bound is computed in terms of values/dimensions for which <code>stopCondition</code> evaluates to "true". To that end, the backward slice (reverse use-def chain) of the given value is visited in a worklist-driven manner and the constraint set is populated according to <code>ValueBoundsOpInterface</code> for each visited value.</p>
<p>By default, lower/equal bounds are closed and upper bounds are open. If <code>closedUB</code> is set to "true", upper bounds are also closed. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00464">464</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00300">bound()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00424">cstr</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00367">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00359">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00363">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00140">mlir::ValueBoundsConstraintSet::Variable::getContext()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00217">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00216">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00700">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00324">kIndexValue</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02077">mlir::presburger::IntegerRelation::projectOut()</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00430">stopCondition</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00585">computeDependentBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00596">computeIndependentBound()</a>, <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00019">mlir::affine::reifyValueBound()</a>, and <a class="el" href="Arith_2Transforms_2ReifyValueBounds_8cpp_source.html#l00064">mlir::arith::reifyValueBound()</a>.</p>

</div>
</div>
<a id="a92c4e6d4080fde3c945426d0cb287df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c4e6d4080fde3c945426d0cb287df5">&#9670;&nbsp;</a></span>computeConstantBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; int64_t &gt; ValueBoundsConstraintSet::computeConstantBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">StopConditionFn</a>&#160;</td>
          <td class="paramname"><em>stopCondition</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>closedUB</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a constant bound for the given variable. </p>
<p>This function traverses the backward slice of the given operands in a worklist-driven manner until <code>stopCondition</code> evaluates to "true". The constraint set is populated according to <code>ValueBoundsOpInterface</code> for each visited value. (No constraints are added for values for which the stop condition evaluates to "true".)</p>
<p>The stop condition is optional: If none is specified, the backward slice is traversed in a breadth-first manner until a constant bound could be computed.</p>
<p>By default, lower/equal bounds are closed and upper bounds are open. If <code>closedUB</code> is set to "true", upper bounds are also closed. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00630">630</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00300">bound()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00424">cstr</a>, <a class="el" href="IntegerRelation_8h_source.html#l00565">mlir::presburger::IntegerRelation::getConstantBound64()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00140">mlir::ValueBoundsConstraintSet::Variable::getContext()</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00430">stopCondition</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00830">areOverlappingSlices()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00677">computeConstantDelta()</a>, <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00169">mlir::affine::fullyComposeAndComputeConstantDelta()</a>, and <a class="el" href="Hoisting_8cpp_source.html#l00192">mlir::linalg::hoistRedundantVectorTransfers()</a>.</p>

</div>
</div>
<a id="a57cb5014b195e2da13cb6408c02a7a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cb5014b195e2da13cb6408c02a7a8e">&#9670;&nbsp;</a></span>computeConstantDelta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; int64_t &gt; ValueBoundsConstraintSet::computeConstantDelta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>dim1</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>dim2</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a constant delta between the given two values. </p>
<p>Return "failure" if a constant delta could not be determined.</p>
<p><code>dim1</code>/<code>dim2</code> must be <code>nullopt</code> if and only if <code>value1</code>/<code>value2</code> are index-typed. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00677">677</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00164">assertValidValueDim()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00630">computeConstantBound()</a>, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841da2dcbad7477fd40561e8b8198f173bd47">mlir::presburger::EQ</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00359">mlir::Builder::getAffineDimExpr()</a>, and <a class="el" href="Value_8h_source.html#l00108">mlir::Value::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00250">mlir::vector::isDisjointTransferIndices()</a>.</p>

</div>
</div>
<a id="afbd535d042c1a7d8fab6def3fa64c470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd535d042c1a7d8fab6def3fa64c470">&#9670;&nbsp;</a></span>computeDependentBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult ValueBoundsConstraintSet::computeDependentBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>resultMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a9c852d22f676b319b260b86ad21499ac">ValueDimList</a> &amp;&#160;</td>
          <td class="paramname"><em>mapOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a9c852d22f676b319b260b86ad21499ac">ValueDimList</a>&#160;</td>
          <td class="paramname"><em>dependencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>closedUB</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a bound in terms of the values/dimensions in <code>dependencies</code>. </p>
<p>The computed bound consists of only constant terms and dependent values (or dimension sizes thereof). </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00585">585</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00464">computeBound()</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00424">cstr</a>.</p>

</div>
</div>
<a id="a262e78068c435b47c6d7126325bd2098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262e78068c435b47c6d7126325bd2098">&#9670;&nbsp;</a></span>computeIndependentBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult ValueBoundsConstraintSet::computeIndependentBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>resultMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a9c852d22f676b319b260b86ad21499ac">ValueDimList</a> &amp;&#160;</td>
          <td class="paramname"><em>mapOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>independencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>closedUB</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a bound in that is independent of all values in <code>independencies</code>. </p>
<p>Independencies are the opposite of dependencies. The computed bound does not contain any SSA values that are part of <code>independencies</code>. E.g., this function can be used to make ops hoistable from loops. To that end, ops must be made independent of loop induction variables (in the case of "for" loops). Loop induction variables are the independencies; they may not appear in the computed bound. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00596">596</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00464">computeBound()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00424">cstr</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00421">worklist</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00019">makeIndependent()</a>.</p>

</div>
</div>
<a id="a92c75fecb7c6277a4c88ca79a40a3c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c75fecb7c6277a4c88ca79a40a3c8a">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueBoundsConstraintSet::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debugging only: Dump the constraint set and the column-to-value/dim mapping to llvm::errs. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00936">936</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00424">cstr</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02638">mlir::presburger::IntegerRelation::dump()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00028">getOwnerOfValue()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00324">kIndexValue</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00416">positionToValueDim</a>.</p>

</div>
</div>
<a id="ac5d6a2d21f63e780bca2e988255b5d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d6a2d21f63e780bca2e988255b5d05">&#9670;&nbsp;</a></span>getExpr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> ValueBoundsConstraintSet::getExpr </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>constant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an expression that represents a constant. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00257">257</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00427">builder</a>, and <a class="el" href="Builders_8cpp_source.html#l00367">mlir::Builder::getAffineConstantExpr()</a>.</p>

</div>
</div>
<a id="ad261cd52134aaac33b8bef2edbec027a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad261cd52134aaac33b8bef2edbec027a">&#9670;&nbsp;</a></span>getExpr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> ValueBoundsConstraintSet::getExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>ofr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an expression that represents a constant or index-typed SSA value. </p>
<p>In case of a value, if this value was not used so far, it is added to the worklist. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00249">249</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00427">builder</a>, <a class="el" href="Builders_8cpp_source.html#l00367">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00200">getExpr()</a>.</p>

</div>
</div>
<a id="a24623069be2ea1a3a8b145201c2cd6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24623069be2ea1a3a8b145201c2cd6e4">&#9670;&nbsp;</a></span>getExpr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> ValueBoundsConstraintSet::getExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>dim</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an expression that represents the given index-typed value or shaped value dimension. </p>
<p>If this value/dimension was not used so far, it is added to the worklist.</p>
<p><code>dim</code> must be <code>nullopt</code> if and only if the given value is of index type. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00200">200</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00164">assertValidValueDim()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00300">bound()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00427">builder</a>, <a class="el" href="Builders_8cpp_source.html#l00367">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00331">getPos()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00349">getPosExpr()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00261">insert()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00324">kIndexValue</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00418">valueDimToPosition</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00249">getExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00305">insert()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00653">populateConstraints()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">processWorklist()</a>.</p>

</div>
</div>
<a id="a8586ef3ed7a840c87e8fd2fc24ba5c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8586ef3ed7a840c87e8fd2fc24ba5c13">&#9670;&nbsp;</a></span>getPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ValueBoundsConstraintSet::getPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>dim</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the column position of the given value/dimension. </p>
<p>Asserts that the value/dimension exists in the constraint set. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00331">331</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00164">assertValidValueDim()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00028">getOwnerOfValue()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00324">kIndexValue</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00418">valueDimToPosition</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00200">getExpr()</a>.</p>

</div>
</div>
<a id="ab057bc1bf30abd3bc8c76620ff32cd4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab057bc1bf30abd3bc8c76620ff32cd4b">&#9670;&nbsp;</a></span>getPosExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> ValueBoundsConstraintSet::getPosExpr </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an affine expression that represents column <code>pos</code> in the constraint set. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00349">349</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00427">builder</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00424">cstr</a>, <a class="el" href="Builders_8cpp_source.html#l00359">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00363">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00217">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, and <a class="el" href="IntegerRelation_8h_source.html#l00216">mlir::presburger::IntegerRelation::getNumDimVars()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00200">getExpr()</a>.</p>

</div>
</div>
<a id="a28d7727decb7b3672be0ddb364dacabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d7727decb7b3672be0ddb364dacabc">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ValueBoundsConstraintSet::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a9c852d22f676b319b260b86ad21499ac">ValueDimList</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSymbol</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the given affine map and its bound operands as a new column in the constraint system. </p>
<p>Return the position of the new column. Any operands that were not analyzed yet are put on the worklist. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00305">305</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00177">addBound()</a>, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841da2dcbad7477fd40561e8b8198f173bd47">mlir::presburger::EQ</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00200">getExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00261">insert()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00087">mlir::AffineExpr::replaceDimsAndSymbols()</a>.</p>

</div>
</div>
<a id="af271a31c4fde7430da2588bb3ce56960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af271a31c4fde7430da2588bb3ce56960">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ValueBoundsConstraintSet::insert </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSymbol</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an anonymous column into the constraint set. </p>
<p>The column is not bound to any value/dimension. If <code>isSymbol</code> is set to "false", a dimension is added.</p>
<p>Note: There are certain affine restrictions wrt. dimensions. E.g., they cannot be multiplied. Furthermore, bounds can only be queried for dimensions but not for symbols. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00292">292</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00357">mlir::presburger::IntegerRelation::appendVar()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00424">cstr</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00416">positionToValueDim</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00418">valueDimToPosition</a>.</p>

</div>
</div>
<a id="ac4b8073f39f96b6a857040ecf255205b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b8073f39f96b6a857040ecf255205b">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ValueBoundsConstraintSet::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSymbol</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00327">327</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00261">insert()</a>.</p>

</div>
</div>
<a id="a863ab398668a486c2aa39c47f7fef171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863ab398668a486c2aa39c47f7fef171">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ValueBoundsConstraintSet::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSymbol</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addToWorklist</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a value/dimension into the constraint set. </p>
<p>If <code>isSymbol</code> is set to "false", a dimension is added. The value/dimension is added to the worklist if <code>addToWorklist</code> is set.</p>
<p>Note: There are certain affine restrictions wrt. dimensions. E.g., they cannot be multiplied. Furthermore, bounds can only be queried for dimensions but not for symbols. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00261">261</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00357">mlir::presburger::IntegerRelation::appendVar()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00164">assertValidValueDim()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00424">cstr</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00028">getOwnerOfValue()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00324">kIndexValue</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00416">positionToValueDim</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00418">valueDimToPosition</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00421">worklist</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00200">getExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00305">insert()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00667">populateConstraints()</a>.</p>

</div>
</div>
<a id="aaee7f7bb79ec6cb583fe312fd59deefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee7f7bb79ec6cb583fe312fd59deefe">&#9670;&nbsp;</a></span>isMapped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ValueBoundsConstraintSet::isMapped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>dim</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return "true" if the given value/dim is mapped (i.e., has a corresponding column in the constraint system). </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00356">356</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00324">kIndexValue</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00418">valueDimToPosition</a>.</p>

</div>
</div>
<a id="aee1947c5fb677562e70ad8d29c53fc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1947c5fb677562e70ad8d29c53fc7d">&#9670;&nbsp;</a></span>populateAndCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ValueBoundsConstraintSet::populateAndCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a>&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate constraints for lhs/rhs (until the stop condition is met). </p>
<p>Then, try to prove that, based on the current state of this constraint set (i.e., without analyzing additional IR or adding new constraints), the "lhs" value/dim is LE/LT/EQ/GT/GE than the "rhs" value/dim.</p>
<p>Return "true" if the specified relation between the two values/dims was proven to hold. Return "false" if the specified relation could not be proven. This could be because the specified relation does in fact not hold or because there is not enough information in the constraint set. In other words, if we do not know for sure, this function returns "false". </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00777">777</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00692">comparePos()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00653">populateConstraints()</a>.</p>

</div>
</div>
<a id="aef9cb692dc4b05849d4717fd2ddf41ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9cb692dc4b05849d4717fd2ddf41ce">&#9670;&nbsp;</a></span>populateConstraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ValueBoundsConstraintSet::populateConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a9c852d22f676b319b260b86ad21499ac">ValueDimList</a>&#160;</td>
          <td class="paramname"><em>mapOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an affine map with a single result (and map operands), add a new column to the constraint set that represents the result of the map. </p>
<p>Traverse additional IR starting from the map operands as needed (as long as the stop condition is not satisfied). Also process all values/dims that are already on the worklist. Return the position of the newly added column. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00667">667</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00261">insert()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">processWorklist()</a>.</p>

</div>
</div>
<a id="acf8cc9c8f19a25e07857506d3b6744ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8cc9c8f19a25e07857506d3b6744ca">&#9670;&nbsp;</a></span>populateConstraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueBoundsConstraintSet::populateConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the IR starting from the given value/dim and populate constraints as long as the stop condition holds. </p>
<p>Also process all values/dims that are already on the worklist. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00653">653</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00164">assertValidValueDim()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00200">getExpr()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">processWorklist()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00777">populateAndCompare()</a>.</p>

</div>
</div>
<a id="a1ae3298af91a6fcf19bbe0e99474a71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae3298af91a6fcf19bbe0e99474a71d">&#9670;&nbsp;</a></span>processWorklist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueBoundsConstraintSet::processWorklist </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iteratively process all elements on the worklist until an index-typed value or shaped value meets <code>stopCondition</code>. </p>
<p>Such values are not processed any further. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">363</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00300">bound()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00200">getExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00028">getOwnerOfValue()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00324">kIndexValue</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00416">positionToValueDim</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00430">stopCondition</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00421">worklist</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00653">populateConstraints()</a>.</p>

</div>
</div>
<a id="a1ae7e00e049e6424079168fa8ac76a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae7e00e049e6424079168fa8ac76a9f">&#9670;&nbsp;</a></span>projectOut() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueBoundsConstraintSet::projectOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ac57ffad5889e7da2eb288c23dfb84556">ValueDim</a>)&gt;&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project out all columns for which the condition holds. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00435">435</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00416">positionToValueDim</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00419">projectOut()</a>.</p>

</div>
</div>
<a id="a3f741239cfb6c63b288a16c2314a8ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f741239cfb6c63b288a16c2314a8ada">&#9670;&nbsp;</a></span>projectOut() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueBoundsConstraintSet::projectOut </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project out the given column in the constraint set. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00419">419</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00424">cstr</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00416">positionToValueDim</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02077">mlir::presburger::IntegerRelation::projectOut()</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00418">valueDimToPosition</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00435">projectOut()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00450">projectOutAnonymous()</a>.</p>

</div>
</div>
<a id="ab444ead14e592768f090608fbb16a0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab444ead14e592768f090608fbb16a0cb">&#9670;&nbsp;</a></span>projectOutAnonymous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ValueBoundsConstraintSet::projectOutAnonymous </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>except</em> = <code>std::nullopt</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00450">450</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00416">positionToValueDim</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00419">projectOut()</a>.</p>

</div>
</div>
<a id="a5cbfc66cbcfe22e0865e6b580750e3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbfc66cbcfe22e0865e6b580750e3b8">&#9670;&nbsp;</a></span>strongCompare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; bool &gt; ValueBoundsConstraintSet::strongCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a>&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is similar to <code><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a06631ca1346abc0c35de13244e1603dc" title="Return &quot;true&quot; if &quot;lhs cmp rhs&quot; was proven to hold.">ValueBoundsConstraintSet::compare</a></code>, except that it returns false if <code>!(lhs cmp rhs)</code>, and <code>failure</code> if neither the relation nor its inverse relation could be proven. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00804">804</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00424">cstr</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00140">mlir::ValueBoundsConstraintSet::Variable::getContext()</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00430">stopCondition</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00824">areEqual()</a>, and <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00033">simplifyAffineMinMaxOp()</a>.</p>

</div>
</div>
<a id="aaf5ab8164e75c5ce15ed2f946d3565e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5ab8164e75c5ce15ed2f946d3565e5">&#9670;&nbsp;</a></span>strongComparePos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; bool &gt; ValueBoundsConstraintSet::strongComparePos </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lhsPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a>&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rhsPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return "true" if, based on the current state of the constraint system, "lhs cmp rhs" was proven to hold. </p>
<p>It returns "false" if "!(lhs cmp rhs)" can be proven. Otherwise, it returns <code>failure</code> if neither the relation nor its inverse relation could be proven.</p>
<p>This function does not analyze any IR and does not populate any additional constraints. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00739">739</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00692">comparePos()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1c0c3000f52de037eb63b26255bfd490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0c3000f52de037eb63b26255bfd490">&#9670;&nbsp;</a></span>addConservativeSemiAffineBounds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::ValueBoundsConstraintSet::addConservativeSemiAffineBounds = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should conservative bounds be added for semi-affine expressions. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00433">433</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00177">addBound()</a>.</p>

</div>
</div>
<a id="ae84dccc7a15710a44f413cbde1a2aa57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84dccc7a15710a44f413cbde1a2aa57">&#9670;&nbsp;</a></span>builder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Builder.html">Builder</a> mlir::ValueBoundsConstraintSet::builder</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Builder.html" title="This class is a general helper class for creating context-global objects like types,...">Builder</a> for constructing affine expressions. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00427">427</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00200">getExpr()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00349">getPosExpr()</a>.</p>

</div>
</div>
<a id="aa050edbbd92d0354a4f6712e60b7e202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa050edbbd92d0354a4f6712e60b7e202">&#9670;&nbsp;</a></span>cstr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> mlir::ValueBoundsConstraintSet::cstr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint system of equalities and inequalities. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00424">424</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00177">addBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00785">compare()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00692">comparePos()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00464">computeBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00630">computeConstantBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00585">computeDependentBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00596">computeIndependentBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00936">dump()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00349">getPosExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00261">insert()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00975">mlir::ValueBoundsConstraintSet::BoundBuilder::operator&lt;()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l01008">mlir::ValueBoundsConstraintSet::BoundBuilder::operator&lt;=()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00997">mlir::ValueBoundsConstraintSet::BoundBuilder::operator==()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l01012">mlir::ValueBoundsConstraintSet::BoundBuilder::operator&gt;()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00990">mlir::ValueBoundsConstraintSet::BoundBuilder::operator&gt;=()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00419">projectOut()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00804">strongCompare()</a>.</p>

</div>
</div>
<a id="ae9decec8380c34985c86d837342f67ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9decec8380c34985c86d837342f67ab">&#9670;&nbsp;</a></span>ID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char ValueBoundsConstraintSet::ID = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00113">113</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

</div>
</div>
<a id="afad63892c0cdb924297f073902a32735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad63892c0cdb924297f073902a32735">&#9670;&nbsp;</a></span>kIndexValue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int64_t mlir::ValueBoundsConstraintSet::kIndexValue = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dimension identifier to indicate a value is index-typed. </p>
<p>This is used for internal data structures/API only. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00324">324</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00464">computeBound()</a>, <a class="el" href="ScalableValueBoundsConstraintSet_8cpp_source.html#l00043">mlir::vector::ScalableValueBoundsConstraintSet::computeScalableBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00936">dump()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00200">getExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00331">getPos()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00261">insert()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00356">isMapped()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">processWorklist()</a>.</p>

</div>
</div>
<a id="a252a2d4f3f9fe0e8c4b7808181a6233e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252a2d4f3f9fe0e8c4b7808181a6233e">&#9670;&nbsp;</a></span>positionToValueDim</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;std::optional&lt;<a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ac57ffad5889e7da2eb288c23dfb84556">ValueDim</a>&gt; &gt; mlir::ValueBoundsConstraintSet::positionToValueDim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mapping of columns to values/shape dimensions. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00416">416</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00936">dump()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00261">insert()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">processWorklist()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00419">projectOut()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00450">projectOutAnonymous()</a>.</p>

</div>
</div>
<a id="a6d2968aa9c133f84d2041a0f1935d8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2968aa9c133f84d2041a0f1935d8a7">&#9670;&nbsp;</a></span>stopCondition</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">StopConditionFn</a> mlir::ValueBoundsConstraintSet::stopCondition = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current stop condition function. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00430">430</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00785">compare()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00464">computeBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00630">computeConstantBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">processWorklist()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00804">strongCompare()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00153">ValueBoundsConstraintSet()</a>.</p>

</div>
</div>
<a id="a1400a0b15e88ed5b9c953675ae5bb223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1400a0b15e88ed5b9c953675ae5bb223">&#9670;&nbsp;</a></span>valueDimToPosition</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt;<a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ac57ffad5889e7da2eb288c23dfb84556">ValueDim</a>, int64_t&gt; mlir::ValueBoundsConstraintSet::valueDimToPosition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse mapping of values/shape dimensions to columns. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00418">418</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00200">getExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00331">getPos()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00261">insert()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00356">isMapped()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00419">projectOut()</a>.</p>

</div>
</div>
<a id="a9437e4d82b1f5f8649421e3405ac8081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9437e4d82b1f5f8649421e3405ac8081">&#9670;&nbsp;</a></span>worklist</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;int64_t&gt; mlir::ValueBoundsConstraintSet::worklist</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Worklist of values/shape dimensions that have not been processed yet. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00421">421</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00596">computeIndependentBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00261">insert()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">processWorklist()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Interfaces/<a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a></li>
<li>lib/Interfaces/<a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:29 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
