<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::ValueBoundsConstraintSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="classmlir_1_1ValueBoundsConstraintSet.html">ValueBoundsConstraintSet</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classmlir_1_1ValueBoundsConstraintSet-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mlir::ValueBoundsConstraintSet Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A helper class to be used with <span class="tt">ValueBoundsOpInterface</span>.  
 <a href="#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="ValueBoundsOpInterface_8h_source.html">mlir/Interfaces/ValueBoundsOpInterface.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Inheritance diagram for mlir::ValueBoundsConstraintSet:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="classmlir_1_1ValueBoundsConstraintSet__inherit__graph.svg" width="239" height="227"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:BoundBuilder" id="r_BoundBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1BoundBuilder.html">BoundBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that builds a bound for a shaped value dimension or index-typed value.  <a href="classmlir_1_1ValueBoundsConstraintSet_1_1BoundBuilder.html#details">More...</a><br /></td></tr>
<tr class="memitem:Variable" id="r_Variable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable that can be added to the constraint set as a "column".  <a href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6de419cb4fc58ccc729b0a1fc946f9cc" id="r_a6de419cb4fc58ccc729b0a1fc946f9cc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a> { <br />
&#160;&#160;<a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9cca3c60bda921433c00284e1d12691ad30c">LT</a>
, <a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9cca5e6b217a890b61fdd811e25487637292">LE</a>
, <a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9ccac6a97fc09b493c8934fd90597f019cae">EQ</a>
, <a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9ccada81d3c25a388334f641a2443d5c5dc2">GT</a>
, <br />
&#160;&#160;<a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9cca68a237f57af25c0f10ea1095fc9c3bc3">GE</a>
<br />
 }</td></tr>
<tr class="memdesc:a6de419cb4fc58ccc729b0a1fc946f9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for <span class="tt"><a class="el" href="#a06631ca1346abc0c35de13244e1603dc" title="Return &quot;true&quot; if &quot;lhs cmp rhs&quot; was proven to hold.">ValueBoundsConstraintSet::compare</a></span>.  <a href="#a6de419cb4fc58ccc729b0a1fc946f9cc">More...</a><br /></td></tr>
<tr class="memitem:a404e07bad50e360592a8dfe1056bf25c" id="r_a404e07bad50e360592a8dfe1056bf25c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a404e07bad50e360592a8dfe1056bf25c">StopConditionFn</a></td></tr>
<tr class="memdesc:a404e07bad50e360592a8dfe1056bf25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stop condition when traversing the backward slice of a shaped value/ index-type value.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf8cc9c8f19a25e07857506d3b6744ca" id="r_acf8cc9c8f19a25e07857506d3b6744ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf8cc9c8f19a25e07857506d3b6744ca">populateConstraints</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; dim)</td></tr>
<tr class="memdesc:acf8cc9c8f19a25e07857506d3b6744ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the IR starting from the given value/dim and populate constraints as long as the stop condition holds.  <br /></td></tr>
<tr class="memitem:aee1947c5fb677562e70ad8d29c53fc7d" id="r_aee1947c5fb677562e70ad8d29c53fc7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee1947c5fb677562e70ad8d29c53fc7d">populateAndCompare</a> (const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;<a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a> cmp, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;<a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memdesc:aee1947c5fb677562e70ad8d29c53fc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate constraints for lhs/rhs (until the stop condition is met).  <br /></td></tr>
<tr class="memitem:a6e46bfa1744b11e2adcf9f9bf5f25ef8" id="r_a6e46bfa1744b11e2adcf9f9bf5f25ef8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1BoundBuilder.html">BoundBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e46bfa1744b11e2adcf9f9bf5f25ef8">bound</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a6e46bfa1744b11e2adcf9f9bf5f25ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a bound for the given index-typed value or shaped value.  <br /></td></tr>
<tr class="memitem:a24623069be2ea1a3a8b145201c2cd6e4" id="r_a24623069be2ea1a3a8b145201c2cd6e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24623069be2ea1a3a8b145201c2cd6e4">getExpr</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; dim=std::nullopt)</td></tr>
<tr class="memdesc:a24623069be2ea1a3a8b145201c2cd6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an expression that represents the given index-typed value or shaped value dimension.  <br /></td></tr>
<tr class="memitem:ad261cd52134aaac33b8bef2edbec027a" id="r_ad261cd52134aaac33b8bef2edbec027a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad261cd52134aaac33b8bef2edbec027a">getExpr</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:ad261cd52134aaac33b8bef2edbec027a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an expression that represents a constant or index-typed SSA value.  <br /></td></tr>
<tr class="memitem:ac5d6a2d21f63e780bca2e988255b5d05" id="r_ac5d6a2d21f63e780bca2e988255b5d05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5d6a2d21f63e780bca2e988255b5d05">getExpr</a> (<a class="el" href="classint64__t.html">int64_t</a> constant)</td></tr>
<tr class="memdesc:ac5d6a2d21f63e780bca2e988255b5d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an expression that represents a constant.  <br /></td></tr>
<tr class="memitem:a92c75fecb7c6277a4c88ca79a40a3c8a" id="r_a92c75fecb7c6277a4c88ca79a40a3c8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92c75fecb7c6277a4c88ca79a40a3c8a">dump</a> () const</td></tr>
<tr class="memdesc:a92c75fecb7c6277a4c88ca79a40a3c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging only: Dump the constraint set and the column-to-value/dim mapping to llvm::errs.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7053c23ea00d64c7b82b49c6544471bb" id="r_a7053c23ea00d64c7b82b49c6544471bb"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7053c23ea00d64c7b82b49c6544471bb">computeBound</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;resultMap, <a class="el" href="namespacemlir.html#ae781cb86d98ed62093c16c9e8819799b">ValueDimList</a> &amp;mapOperands, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a> type, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;var, <a class="el" href="#a404e07bad50e360592a8dfe1056bf25c">StopConditionFn</a> <a class="el" href="#a6d2968aa9c133f84d2041a0f1935d8a7">stopCondition</a>, <a class="el" href="classbool.html">bool</a> closedUB=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a7053c23ea00d64c7b82b49c6544471bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bound for the given variable.  <br /></td></tr>
<tr class="memitem:afbd535d042c1a7d8fab6def3fa64c470" id="r_afbd535d042c1a7d8fab6def3fa64c470"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbd535d042c1a7d8fab6def3fa64c470">computeDependentBound</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;resultMap, <a class="el" href="namespacemlir.html#ae781cb86d98ed62093c16c9e8819799b">ValueDimList</a> &amp;mapOperands, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a> type, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;var, <a class="el" href="namespacemlir.html#ae781cb86d98ed62093c16c9e8819799b">ValueDimList</a> dependencies, <a class="el" href="classbool.html">bool</a> closedUB=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:afbd535d042c1a7d8fab6def3fa64c470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bound in terms of the values/dimensions in <span class="tt">dependencies</span>.  <br /></td></tr>
<tr class="memitem:a262e78068c435b47c6d7126325bd2098" id="r_a262e78068c435b47c6d7126325bd2098"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a262e78068c435b47c6d7126325bd2098">computeIndependentBound</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;resultMap, <a class="el" href="namespacemlir.html#ae781cb86d98ed62093c16c9e8819799b">ValueDimList</a> &amp;mapOperands, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a> type, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;var, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> independencies, <a class="el" href="classbool.html">bool</a> closedUB=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a262e78068c435b47c6d7126325bd2098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bound in that is independent of all values in <span class="tt">independencies</span>.  <br /></td></tr>
<tr class="memitem:af6b8630d15364bb4102964d6e16a5e13" id="r_af6b8630d15364bb4102964d6e16a5e13"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6b8630d15364bb4102964d6e16a5e13">computeConstantBound</a> (<a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a> type, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;var, const <a class="el" href="#a404e07bad50e360592a8dfe1056bf25c">StopConditionFn</a> &amp;<a class="el" href="#a6d2968aa9c133f84d2041a0f1935d8a7">stopCondition</a>=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classbool.html">bool</a> closedUB=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:af6b8630d15364bb4102964d6e16a5e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a constant bound for the given variable.  <br /></td></tr>
<tr class="memitem:a57cb5014b195e2da13cb6408c02a7a8e" id="r_a57cb5014b195e2da13cb6408c02a7a8e"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57cb5014b195e2da13cb6408c02a7a8e">computeConstantDelta</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value1, <a class="el" href="classmlir_1_1Value.html">Value</a> value2, std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; dim1=std::nullopt, std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; dim2=std::nullopt)</td></tr>
<tr class="memdesc:a57cb5014b195e2da13cb6408c02a7a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a constant delta between the given two values.  <br /></td></tr>
<tr class="memitem:a06631ca1346abc0c35de13244e1603dc" id="r_a06631ca1346abc0c35de13244e1603dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06631ca1346abc0c35de13244e1603dc">compare</a> (const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;<a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a> cmp, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;<a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memdesc:a06631ca1346abc0c35de13244e1603dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if "lhs cmp rhs" was proven to hold.  <br /></td></tr>
<tr class="memitem:a5cbfc66cbcfe22e0865e6b580750e3b8" id="r_a5cbfc66cbcfe22e0865e6b580750e3b8"><td class="memItemLeft" align="right" valign="top">static llvm::FailureOr&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cbfc66cbcfe22e0865e6b580750e3b8">strongCompare</a> (const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;<a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a> cmp, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;<a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memdesc:a5cbfc66cbcfe22e0865e6b580750e3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is similar to <span class="tt"><a class="el" href="#a06631ca1346abc0c35de13244e1603dc" title="Return &quot;true&quot; if &quot;lhs cmp rhs&quot; was proven to hold.">ValueBoundsConstraintSet::compare</a></span>, except that it returns false if <span class="tt">!(lhs cmp rhs)</span>, and <span class="tt">failure</span> if neither the relation nor its inverse relation could be proven.  <br /></td></tr>
<tr class="memitem:a06675973ae78af7d27d2e7028173f57d" id="r_a06675973ae78af7d27d2e7028173f57d"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06675973ae78af7d27d2e7028173f57d">areEqual</a> (const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;var1, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;var2)</td></tr>
<tr class="memdesc:a06675973ae78af7d27d2e7028173f57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute whether the given variables are equal.  <br /></td></tr>
<tr class="memitem:abbb101490afa5242e1d3a49a7423d3e6" id="r_abbb101490afa5242e1d3a49a7423d3e6"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbb101490afa5242e1d3a49a7423d3e6">areOverlappingSlices</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, const <a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a> &amp;slice1, const <a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a> &amp;slice2)</td></tr>
<tr class="memdesc:abbb101490afa5242e1d3a49a7423d3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if the given slices are guaranteed to be overlapping.  <br /></td></tr>
<tr class="memitem:a2f45c5301aaf9264e2302a2936639380" id="r_a2f45c5301aaf9264e2302a2936639380"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f45c5301aaf9264e2302a2936639380">areEquivalentSlices</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, const <a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a> &amp;slice1, const <a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a> &amp;slice2)</td></tr>
<tr class="memdesc:a2f45c5301aaf9264e2302a2936639380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if the given slices are guaranteed to be equivalent.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae9decec8380c34985c86d837342f67ab" id="r_ae9decec8380c34985c86d837342f67ab"><td class="memItemLeft" align="right" valign="top">static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9decec8380c34985c86d837342f67ab">ID</a> = 0</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-types" class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ac57ffad5889e7da2eb288c23dfb84556" id="r_ac57ffad5889e7da2eb288c23dfb84556"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac57ffad5889e7da2eb288c23dfb84556">ValueDim</a> = std::pair&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classint64__t.html">int64_t</a>&gt;</td></tr>
<tr class="memdesc:ac57ffad5889e7da2eb288c23dfb84556"><td class="mdescLeft">&#160;</td><td class="mdescRight">An index-typed value or the dimension of a shaped-type value.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4507a54a7695ceeb8493d553e46d9de3" id="r_a4507a54a7695ceeb8493d553e46d9de3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4507a54a7695ceeb8493d553e46d9de3">ValueBoundsConstraintSet</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, const <a class="el" href="#a404e07bad50e360592a8dfe1056bf25c">StopConditionFn</a> &amp;<a class="el" href="#a6d2968aa9c133f84d2041a0f1935d8a7">stopCondition</a>, <a class="el" href="classbool.html">bool</a> <a class="el" href="#a1c0c3000f52de037eb63b26255bfd490">addConservativeSemiAffineBounds</a>=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memitem:a873ca2349d8aab548a7b1bbe93dbd515" id="r_a873ca2349d8aab548a7b1bbe93dbd515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a873ca2349d8aab548a7b1bbe93dbd515">comparePos</a> (<a class="el" href="classint64__t.html">int64_t</a> lhsPos, <a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a> cmp, <a class="el" href="classint64__t.html">int64_t</a> rhsPos)</td></tr>
<tr class="memdesc:a873ca2349d8aab548a7b1bbe93dbd515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if, based on the current state of the constraint system, "lhs cmp rhs" was proven to hold.  <br /></td></tr>
<tr class="memitem:aaf5ab8164e75c5ce15ed2f946d3565e5" id="r_aaf5ab8164e75c5ce15ed2f946d3565e5"><td class="memItemLeft" align="right" valign="top">llvm::FailureOr&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf5ab8164e75c5ce15ed2f946d3565e5">strongComparePos</a> (<a class="el" href="classint64__t.html">int64_t</a> lhsPos, <a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a> cmp, <a class="el" href="classint64__t.html">int64_t</a> rhsPos)</td></tr>
<tr class="memdesc:aaf5ab8164e75c5ce15ed2f946d3565e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if, based on the current state of the constraint system, "lhs cmp rhs" was proven to hold.  <br /></td></tr>
<tr class="memitem:aef9cb692dc4b05849d4717fd2ddf41ce" id="r_aef9cb692dc4b05849d4717fd2ddf41ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef9cb692dc4b05849d4717fd2ddf41ce">populateConstraints</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="namespacemlir.html#ae781cb86d98ed62093c16c9e8819799b">ValueDimList</a> mapOperands)</td></tr>
<tr class="memdesc:aef9cb692dc4b05849d4717fd2ddf41ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an affine map with a single result (and map operands), add a new column to the constraint set that represents the result of the map.  <br /></td></tr>
<tr class="memitem:a1ae3298af91a6fcf19bbe0e99474a71d" id="r_a1ae3298af91a6fcf19bbe0e99474a71d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ae3298af91a6fcf19bbe0e99474a71d">processWorklist</a> ()</td></tr>
<tr class="memdesc:a1ae3298af91a6fcf19bbe0e99474a71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively process all elements on the worklist until an index-typed value or shaped value meets <span class="tt">stopCondition</span>.  <br /></td></tr>
<tr class="memitem:a68979f050a6943aa34f37f020fb1f056" id="r_a68979f050a6943aa34f37f020fb1f056"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68979f050a6943aa34f37f020fb1f056">addBound</a> (<a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a> type, <a class="el" href="classint64__t.html">int64_t</a> pos, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="memdesc:a68979f050a6943aa34f37f020fb1f056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound the given column in the underlying constraint set by the given expression.  <br /></td></tr>
<tr class="memitem:a8586ef3ed7a840c87e8fd2fc24ba5c13" id="r_a8586ef3ed7a840c87e8fd2fc24ba5c13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8586ef3ed7a840c87e8fd2fc24ba5c13">getPos</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; dim=std::nullopt) const</td></tr>
<tr class="memdesc:a8586ef3ed7a840c87e8fd2fc24ba5c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the column position of the given value/dimension.  <br /></td></tr>
<tr class="memitem:ab057bc1bf30abd3bc8c76620ff32cd4b" id="r_ab057bc1bf30abd3bc8c76620ff32cd4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab057bc1bf30abd3bc8c76620ff32cd4b">getPosExpr</a> (<a class="el" href="classint64__t.html">int64_t</a> pos)</td></tr>
<tr class="memdesc:ab057bc1bf30abd3bc8c76620ff32cd4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an affine expression that represents column <span class="tt">pos</span> in the constraint set.  <br /></td></tr>
<tr class="memitem:aaee7f7bb79ec6cb583fe312fd59deefe" id="r_aaee7f7bb79ec6cb583fe312fd59deefe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaee7f7bb79ec6cb583fe312fd59deefe">isMapped</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; dim=std::nullopt) const</td></tr>
<tr class="memdesc:aaee7f7bb79ec6cb583fe312fd59deefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if the given value/dim is mapped (i.e., has a corresponding column in the constraint system).  <br /></td></tr>
<tr class="memitem:a863ab398668a486c2aa39c47f7fef171" id="r_a863ab398668a486c2aa39c47f7fef171"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a863ab398668a486c2aa39c47f7fef171">insert</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; dim, <a class="el" href="classbool.html">bool</a> isSymbol=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>, <a class="el" href="classbool.html">bool</a> addToWorklist=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:a863ab398668a486c2aa39c47f7fef171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a value/dimension into the constraint set.  <br /></td></tr>
<tr class="memitem:af271a31c4fde7430da2588bb3ce56960" id="r_af271a31c4fde7430da2588bb3ce56960"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af271a31c4fde7430da2588bb3ce56960">insert</a> (<a class="el" href="classbool.html">bool</a> isSymbol=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:af271a31c4fde7430da2588bb3ce56960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an anonymous column into the constraint set.  <br /></td></tr>
<tr class="memitem:a9ff7ad8c30e9a94b10e48f1836647a53" id="r_a9ff7ad8c30e9a94b10e48f1836647a53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ff7ad8c30e9a94b10e48f1836647a53">insert</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const <a class="el" href="namespacemlir.html#ae781cb86d98ed62093c16c9e8819799b">ValueDimList</a> &amp;operands, <a class="el" href="classbool.html">bool</a> isSymbol=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:a9ff7ad8c30e9a94b10e48f1836647a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given affine map and its bound operands as a new column in the constraint system.  <br /></td></tr>
<tr class="memitem:ac4b8073f39f96b6a857040ecf255205b" id="r_ac4b8073f39f96b6a857040ecf255205b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4b8073f39f96b6a857040ecf255205b">insert</a> (const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;var, <a class="el" href="classbool.html">bool</a> isSymbol=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memitem:a3f741239cfb6c63b288a16c2314a8ada" id="r_a3f741239cfb6c63b288a16c2314a8ada"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f741239cfb6c63b288a16c2314a8ada">projectOut</a> (<a class="el" href="classint64__t.html">int64_t</a> pos)</td></tr>
<tr class="memdesc:a3f741239cfb6c63b288a16c2314a8ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project out the given column in the constraint set.  <br /></td></tr>
<tr class="memitem:a1ae7e00e049e6424079168fa8ac76a9f" id="r_a1ae7e00e049e6424079168fa8ac76a9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ae7e00e049e6424079168fa8ac76a9f">projectOut</a> (<a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="#ac57ffad5889e7da2eb288c23dfb84556">ValueDim</a>)&gt; condition)</td></tr>
<tr class="memdesc:a1ae7e00e049e6424079168fa8ac76a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project out all columns for which the condition holds.  <br /></td></tr>
<tr class="memitem:ab444ead14e592768f090608fbb16a0cb" id="r_ab444ead14e592768f090608fbb16a0cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab444ead14e592768f090608fbb16a0cb">projectOutAnonymous</a> (std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; except=std::nullopt)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-attribs" class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a252a2d4f3f9fe0e8c4b7808181a6233e" id="r_a252a2d4f3f9fe0e8c4b7808181a6233e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; std::optional&lt; <a class="el" href="#ac57ffad5889e7da2eb288c23dfb84556">ValueDim</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a252a2d4f3f9fe0e8c4b7808181a6233e">positionToValueDim</a></td></tr>
<tr class="memdesc:a252a2d4f3f9fe0e8c4b7808181a6233e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping of columns to values/shape dimensions.  <br /></td></tr>
<tr class="memitem:a1400a0b15e88ed5b9c953675ae5bb223" id="r_a1400a0b15e88ed5b9c953675ae5bb223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="#ac57ffad5889e7da2eb288c23dfb84556">ValueDim</a>, <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1400a0b15e88ed5b9c953675ae5bb223">valueDimToPosition</a></td></tr>
<tr class="memdesc:a1400a0b15e88ed5b9c953675ae5bb223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse mapping of values/shape dimensions to columns.  <br /></td></tr>
<tr class="memitem:a9437e4d82b1f5f8649421e3405ac8081" id="r_a9437e4d82b1f5f8649421e3405ac8081"><td class="memItemLeft" align="right" valign="top">std::queue&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9437e4d82b1f5f8649421e3405ac8081">worklist</a></td></tr>
<tr class="memdesc:a9437e4d82b1f5f8649421e3405ac8081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worklist of values/shape dimensions that have not been processed yet.  <br /></td></tr>
<tr class="memitem:aa050edbbd92d0354a4f6712e60b7e202" id="r_aa050edbbd92d0354a4f6712e60b7e202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa050edbbd92d0354a4f6712e60b7e202">cstr</a></td></tr>
<tr class="memdesc:aa050edbbd92d0354a4f6712e60b7e202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint system of equalities and inequalities.  <br /></td></tr>
<tr class="memitem:ae84dccc7a15710a44f413cbde1a2aa57" id="r_ae84dccc7a15710a44f413cbde1a2aa57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Builder.html">Builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae84dccc7a15710a44f413cbde1a2aa57">builder</a></td></tr>
<tr class="memdesc:ae84dccc7a15710a44f413cbde1a2aa57"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Builder.html" title="This class is a general helper class for creating context-global objects like types,...">Builder</a> for constructing affine expressions.  <br /></td></tr>
<tr class="memitem:a6d2968aa9c133f84d2041a0f1935d8a7" id="r_a6d2968aa9c133f84d2041a0f1935d8a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a404e07bad50e360592a8dfe1056bf25c">StopConditionFn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d2968aa9c133f84d2041a0f1935d8a7">stopCondition</a> = <a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></td></tr>
<tr class="memdesc:a6d2968aa9c133f84d2041a0f1935d8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current stop condition function.  <br /></td></tr>
<tr class="memitem:a1c0c3000f52de037eb63b26255bfd490" id="r_a1c0c3000f52de037eb63b26255bfd490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c0c3000f52de037eb63b26255bfd490">addConservativeSemiAffineBounds</a> = <a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></td></tr>
<tr class="memdesc:a1c0c3000f52de037eb63b26255bfd490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should conservative bounds be added for semi-affine expressions.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-static-attribs" class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:afad63892c0cdb924297f073902a32735" id="r_afad63892c0cdb924297f073902a32735"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afad63892c0cdb924297f073902a32735">kIndexValue</a> = -1</td></tr>
<tr class="memdesc:afad63892c0cdb924297f073902a32735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension identifier to indicate a value is index-typed.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A helper class to be used with <span class="tt">ValueBoundsOpInterface</span>. </p>
<p>This class stores a constraint system and mapping of constrained variables to index-typed values or dimension sizes of shaped values.</p>
<p>Interface implementations of <span class="tt">ValueBoundsOpInterface</span> use <span class="tt">addBounds</span> to insert constraints about their results and/or region block arguments into the constraint set in the form of an <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a>. When a bound should be expressed in terms of another value/dimension, <span class="tt">getExpr</span> can be used to retrieve an <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> that represents the specified value/dimension.</p>
<p>When a value/dimension is retrieved for the first time through <span class="tt">getExpr</span>, it is added to an internal worklist. See <span class="tt">computeBound</span> for more details.</p>
<p>Note: Any modification of existing IR invalides the data stored in this class. Adding new operations is allowed. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00068">68</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a404e07bad50e360592a8dfe1056bf25c" name="a404e07bad50e360592a8dfe1056bf25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404e07bad50e360592a8dfe1056bf25c">&#9670;&#160;</a></span>StopConditionFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a404e07bad50e360592a8dfe1056bf25c">mlir::ValueBoundsConstraintSet::StopConditionFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;<a class="code hl_class" href="classbool.html">bool</a>(</div>
<div class="line">      <a class="code hl_class" href="classmlir_1_1Value.html">Value</a>, std::optional&lt;int64_t&gt; , <a class="code hl_function" href="#a4507a54a7695ceeb8493d553e46d9de3">ValueBoundsConstraintSet</a> &amp;<a class="code hl_variable" href="#aa050edbbd92d0354a4f6712e60b7e202">cstr</a>)&gt;</div>
<div class="ttc" id="aclassbool_html"><div class="ttname"><a href="classbool.html">bool</a></div></div>
<div class="ttc" id="aclassmlir_1_1ValueBoundsConstraintSet_html_a4507a54a7695ceeb8493d553e46d9de3"><div class="ttname"><a href="#a4507a54a7695ceeb8493d553e46d9de3">mlir::ValueBoundsConstraintSet::ValueBoundsConstraintSet</a></div><div class="ttdeci">ValueBoundsConstraintSet(MLIRContext *ctx, const StopConditionFn &amp;stopCondition, bool addConservativeSemiAffineBounds=false)</div><div class="ttdef"><b>Definition</b> <a href="ValueBoundsOpInterface_8cpp_source.html#l00156">ValueBoundsOpInterface.cpp:156</a></div></div>
<div class="ttc" id="aclassmlir_1_1ValueBoundsConstraintSet_html_aa050edbbd92d0354a4f6712e60b7e202"><div class="ttname"><a href="#aa050edbbd92d0354a4f6712e60b7e202">mlir::ValueBoundsConstraintSet::cstr</a></div><div class="ttdeci">FlatLinearConstraints cstr</div><div class="ttdoc">Constraint system of equalities and inequalities.</div><div class="ttdef"><b>Definition</b> <a href="ValueBoundsOpInterface_8h_source.html#l00426">ValueBoundsOpInterface.h:426</a></div></div>
<div class="ttc" id="aclassmlir_1_1Value_html"><div class="ttname"><a href="classmlir_1_1Value.html">mlir::Value</a></div><div class="ttdoc">This class represents an instance of an SSA value in the MLIR system, representing a computable value...</div><div class="ttdef"><b>Definition</b> <a href="Value_8h_source.html#l00096">Value.h:96</a></div></div>
</div><!-- fragment -->
<p>The stop condition when traversing the backward slice of a shaped value/ index-type value. </p>
<p>The traversal continues until the stop condition evaluates to "true" for a value.</p>
<p>The first parameter of the function is the shaped value/index-typed value. The second parameter is the dimension in case of a shaped value. The third parameter is this constraint set. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00162">162</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

</div>
</div>
<a id="ac57ffad5889e7da2eb288c23dfb84556" name="ac57ffad5889e7da2eb288c23dfb84556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57ffad5889e7da2eb288c23dfb84556">&#9670;&#160;</a></span>ValueDim</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac57ffad5889e7da2eb288c23dfb84556">mlir::ValueBoundsConstraintSet::ValueDim</a> = std::pair&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classint64__t.html">int64_t</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An index-typed value or the dimension of a shaped-type value. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00327">327</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="a6de419cb4fc58ccc729b0a1fc946f9cc" name="a6de419cb4fc58ccc729b0a1fc946f9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de419cb4fc58ccc729b0a1fc946f9cc">&#9670;&#160;</a></span>ComparisonOperator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9cc">mlir::ValueBoundsConstraintSet::ComparisonOperator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator for <span class="tt"><a class="el" href="#a06631ca1346abc0c35de13244e1603dc" title="Return &quot;true&quot; if &quot;lhs cmp rhs&quot; was proven to hold.">ValueBoundsConstraintSet::compare</a></span>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6de419cb4fc58ccc729b0a1fc946f9cca3c60bda921433c00284e1d12691ad30c" name="a6de419cb4fc58ccc729b0a1fc946f9cca3c60bda921433c00284e1d12691ad30c"></a>LT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6de419cb4fc58ccc729b0a1fc946f9cca5e6b217a890b61fdd811e25487637292" name="a6de419cb4fc58ccc729b0a1fc946f9cca5e6b217a890b61fdd811e25487637292"></a>LE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6de419cb4fc58ccc729b0a1fc946f9ccac6a97fc09b493c8934fd90597f019cae" name="a6de419cb4fc58ccc729b0a1fc946f9ccac6a97fc09b493c8934fd90597f019cae"></a>EQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6de419cb4fc58ccc729b0a1fc946f9ccada81d3c25a388334f641a2443d5c5dc2" name="a6de419cb4fc58ccc729b0a1fc946f9ccada81d3c25a388334f641a2443d5c5dc2"></a>GT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6de419cb4fc58ccc729b0a1fc946f9cca68a237f57af25c0f10ea1095fc9c3bc3" name="a6de419cb4fc58ccc729b0a1fc946f9cca68a237f57af25c0f10ea1095fc9c3bc3"></a>GE&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">239</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4507a54a7695ceeb8493d553e46d9de3" name="a4507a54a7695ceeb8493d553e46d9de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4507a54a7695ceeb8493d553e46d9de3">&#9670;&#160;</a></span>ValueBoundsConstraintSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueBoundsConstraintSet::ValueBoundsConstraintSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a404e07bad50e360592a8dfe1056bf25c">StopConditionFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stopCondition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>addConservativeSemiAffineBounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00156">156</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00435">addConservativeSemiAffineBounds</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00429">builder</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00432">stopCondition</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00782">compare()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00463">computeBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00629">computeConstantBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00584">computeDependentBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00595">computeIndependentBound()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00801">strongCompare()</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a68979f050a6943aa34f37f020fb1f056" name="a68979f050a6943aa34f37f020fb1f056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68979f050a6943aa34f37f020fb1f056">&#9670;&#160;</a></span>addBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> ValueBoundsConstraintSet::addBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bound the given column in the underlying constraint set by the given expression. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00180">180</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00435">addConservativeSemiAffineBounds</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00426">cstr</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00070">mlir::FlatLinearConstraints::No</a>, and <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00070">mlir::FlatLinearConstraints::Yes</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00305">insert()</a>.</p>

</div>
</div>
<a id="a06675973ae78af7d27d2e7028173f57d" name="a06675973ae78af7d27d2e7028173f57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06675973ae78af7d27d2e7028173f57d">&#9670;&#160;</a></span>areEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classbool.html">bool</a> &gt; ValueBoundsConstraintSet::areEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute whether the given variables are equal. </p>
<p>Return "failure" if equality could not be determined. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00821">821</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">EQ</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00801">strongCompare()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00890">areEquivalentSlices()</a>, <a class="el" href="ReshapePatterns_8cpp_source.html#l00462">mlir::tensor::getCollapsedExtractSliceInfo()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00149">mlir::tensor::isCastLikeExtractSliceOp()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00125">mlir::tensor::isCastLikeInsertSliceOp()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00251">mlir::vector::isDisjointTransferIndices()</a>.</p>

</div>
</div>
<a id="a2f45c5301aaf9264e2302a2936639380" name="a2f45c5301aaf9264e2302a2936639380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f45c5301aaf9264e2302a2936639380">&#9670;&#160;</a></span>areEquivalentSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classbool.html">bool</a> &gt; ValueBoundsConstraintSet::areEquivalentSlices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return "true" if the given slices are guaranteed to be equivalent. </p>
<p>Return "false" if the given slices are guaranteed to be non-equivalent. Return "failure" if unknown.</p>
<p>Slices are equivalent if their offsets, sizes and strices are equal. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00890">890</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00821">areEqual()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00041">mlir::HyperrectangularSlice::getMixedOffsets()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00042">mlir::HyperrectangularSlice::getMixedSizes()</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00043">mlir::HyperrectangularSlice::getMixedStrides()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SubsetOpInterface_8cpp_source.html#l00044">mlir::detail::defaultOperatesOnEquivalentSubset()</a>.</p>

</div>
</div>
<a id="abbb101490afa5242e1d3a49a7423d3e6" name="abbb101490afa5242e1d3a49a7423d3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb101490afa5242e1d3a49a7423d3e6">&#9670;&#160;</a></span>areOverlappingSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classbool.html">bool</a> &gt; ValueBoundsConstraintSet::areOverlappingSlices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1HyperrectangularSlice.html">HyperrectangularSlice</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return "true" if the given slices are guaranteed to be overlapping. </p>
<p>Return "false" if the given slices are guaranteed to be non-overlapping. Return "failure" if unknown.</p>
<p>Slices are overlapping if for all dimensions:</p><ul>
<li>offset1 + size1 * stride1 &lt;= offset2</li>
<li>and offset2 + size2 * stride2 &lt;= offset1</li>
</ul>
<p>Slice are non-overlapping if the above constraint is not satisfied for at least one dimension. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00826">826</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00629">computeConstantBound()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00044">mlir::presburger::EQ</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00738">mlir::foldAttributesIntoMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00041">mlir::HyperrectangularSlice::getMixedOffsets()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00042">mlir::HyperrectangularSlice::getMixedSizes()</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00043">mlir::HyperrectangularSlice::getMixedStrides()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SubsetOpInterface_8cpp_source.html#l00065">mlir::detail::defaultOperatesOnDisjointSubset()</a>.</p>

</div>
</div>
<a id="a6e46bfa1744b11e2adcf9f9bf5f25ef8" name="a6e46bfa1744b11e2adcf9f9bf5f25ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e46bfa1744b11e2adcf9f9bf5f25ef8">&#9670;&#160;</a></span>bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1BoundBuilder.html">BoundBuilder</a> mlir::ValueBoundsConstraintSet::bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a bound for the given index-typed value or shaped value. </p>
<p>This function returns a builder that adds the bound. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00300">300</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00463">computeBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00629">computeConstantBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00203">getExpr()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">processWorklist()</a>.</p>

</div>
</div>
<a id="a06631ca1346abc0c35de13244e1603dc" name="a06631ca1346abc0c35de13244e1603dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06631ca1346abc0c35de13244e1603dc">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ValueBoundsConstraintSet::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return "true" if "lhs cmp rhs" was proven to hold. </p>
<p>Return "false" if the specified relation could not be proven. This could be because the specified relation does in fact not hold or because there is not enough information in the constraint set. In other words, if we do not know for sure, this function returns "false".</p>
<p>This function keeps traversing the backward slice of lhs/rhs until could prove the relation or until it ran out of IR. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00782">782</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00426">cstr</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00432">stopCondition</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00156">ValueBoundsConstraintSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01061">replaceAffineMinBoundingBoxExpression()</a>.</p>

</div>
</div>
<a id="a873ca2349d8aab548a7b1bbe93dbd515" name="a873ca2349d8aab548a7b1bbe93dbd515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873ca2349d8aab548a7b1bbe93dbd515">&#9670;&#160;</a></span>comparePos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ValueBoundsConstraintSet::comparePos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>lhsPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>rhsPos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return "true" if, based on the current state of the constraint system, "lhs cmp rhs" was proven to hold. </p>
<p>Return "false" if the specified relation could not be proven. This could be because the specified relation does in fact not hold or because there is not enough information in the constraint set. In other words, if we do not know for sure, this function returns "false".</p>
<p>This function does not analyze any IR and does not populate any additional constraints. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00691">691</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00691">comparePos()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00426">cstr</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">EQ</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">GE</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">GT</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">LE</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">LT</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00691">comparePos()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00774">populateAndCompare()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00736">strongComparePos()</a>.</p>

</div>
</div>
<a id="a7053c23ea00d64c7b82b49c6544471bb" name="a7053c23ea00d64c7b82b49c6544471bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7053c23ea00d64c7b82b49c6544471bb">&#9670;&#160;</a></span>computeBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult ValueBoundsConstraintSet::computeBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>resultMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ae781cb86d98ed62093c16c9e8819799b">ValueDimList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mapOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a404e07bad50e360592a8dfe1056bf25c">StopConditionFn</a></td>          <td class="paramname"><span class="paramname"><em>stopCondition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>closedUB</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a bound for the given variable. </p>
<p>The computed bound is stored in <span class="tt">resultMap</span>. The operands of the bound are stored in <span class="tt">mapOperands</span>. An operand is either an index-type SSA value or a shaped value and a dimension.</p>
<p>The bound is computed in terms of values/dimensions for which <span class="tt">stopCondition</span> evaluates to "true". To that end, the backward slice (reverse use-def chain) of the given value is visited in a worklist-driven manner and the constraint set is populated according to <span class="tt">ValueBoundsOpInterface</span> for each visited value.</p>
<p>By default, lower/equal bounds are closed and upper bounds are open. If <span class="tt">closedUB</span> is set to "true", upper bounds are also closed. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00463">463</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00300">bound()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00426">cstr</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00140">mlir::ValueBoundsConstraintSet::Variable::getContext()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00324">kIndexValue</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00432">stopCondition</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00156">ValueBoundsConstraintSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00584">computeDependentBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00595">computeIndependentBound()</a>, <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00019">mlir::affine::reifyValueBound()</a>, and <a class="el" href="Arith_2Transforms_2ReifyValueBounds_8cpp_source.html#l00066">mlir::arith::reifyValueBound()</a>.</p>

</div>
</div>
<a id="af6b8630d15364bb4102964d6e16a5e13" name="af6b8630d15364bb4102964d6e16a5e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b8630d15364bb4102964d6e16a5e13">&#9670;&#160;</a></span>computeConstantBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; ValueBoundsConstraintSet::computeConstantBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a404e07bad50e360592a8dfe1056bf25c">StopConditionFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stopCondition</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>closedUB</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a constant bound for the given variable. </p>
<p>This function traverses the backward slice of the given operands in a worklist-driven manner until <span class="tt">stopCondition</span> evaluates to "true". The constraint set is populated according to <span class="tt">ValueBoundsOpInterface</span> for each visited value. (No constraints are added for values for which the stop condition evaluates to "true".)</p>
<p>The stop condition is optional: If none is specified, the backward slice is traversed in a breadth-first manner until a constant bound could be computed.</p>
<p>By default, lower/equal bounds are closed and upper bounds are open. If <span class="tt">closedUB</span> is set to "true", upper bounds are also closed. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00629">629</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00300">bound()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00426">cstr</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00140">mlir::ValueBoundsConstraintSet::Variable::getContext()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00432">stopCondition</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00156">ValueBoundsConstraintSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00826">areOverlappingSlices()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00676">computeConstantDelta()</a>, <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00169">mlir::affine::fullyComposeAndComputeConstantDelta()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00198">mlir::linalg::hoistRedundantVectorTransfers()</a>, and <a class="el" href="Promotion_8cpp_source.html#l00237">mlir::linalg::promoteSubviewAsNewBuffer()</a>.</p>

</div>
</div>
<a id="a57cb5014b195e2da13cb6408c02a7a8e" name="a57cb5014b195e2da13cb6408c02a7a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cb5014b195e2da13cb6408c02a7a8e">&#9670;&#160;</a></span>computeConstantDelta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; ValueBoundsConstraintSet::computeConstantDelta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dim1</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dim2</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a constant delta between the given two values. </p>
<p>Return "failure" if a constant delta could not be determined.</p>
<p><span class="tt">dim1</span>/<span class="tt">dim2</span> must be <span class="tt">nullopt</span> if and only if <span class="tt">value1</span>/<span class="tt">value2</span> are index-typed. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00676">676</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00167">assertValidValueDim()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00629">computeConstantBound()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00044">mlir::presburger::EQ</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, and <a class="el" href="Value_8h_source.html#l00108">mlir::Value::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00251">mlir::vector::isDisjointTransferIndices()</a>.</p>

</div>
</div>
<a id="afbd535d042c1a7d8fab6def3fa64c470" name="afbd535d042c1a7d8fab6def3fa64c470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd535d042c1a7d8fab6def3fa64c470">&#9670;&#160;</a></span>computeDependentBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult ValueBoundsConstraintSet::computeDependentBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>resultMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ae781cb86d98ed62093c16c9e8819799b">ValueDimList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mapOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ae781cb86d98ed62093c16c9e8819799b">ValueDimList</a></td>          <td class="paramname"><span class="paramname"><em>dependencies</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>closedUB</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a bound in terms of the values/dimensions in <span class="tt">dependencies</span>. </p>
<p>The computed bound consists of only constant terms and dependent values (or dimension sizes thereof). </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00584">584</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00463">computeBound()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00426">cstr</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00156">ValueBoundsConstraintSet()</a>.</p>

</div>
</div>
<a id="a262e78068c435b47c6d7126325bd2098" name="a262e78068c435b47c6d7126325bd2098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262e78068c435b47c6d7126325bd2098">&#9670;&#160;</a></span>computeIndependentBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult ValueBoundsConstraintSet::computeIndependentBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>resultMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ae781cb86d98ed62093c16c9e8819799b">ValueDimList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mapOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>independencies</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>closedUB</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a bound in that is independent of all values in <span class="tt">independencies</span>. </p>
<p>Independencies are the opposite of dependencies. The computed bound does not contain any SSA values that are part of <span class="tt">independencies</span>. E.g., this function can be used to make ops hoistable from loops. To that end, ops must be made independent of loop induction variables (in the case of "for" loops). Loop induction variables are the independencies; they may not appear in the computed bound. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00595">595</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00463">computeBound()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00426">cstr</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00156">ValueBoundsConstraintSet()</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00423">worklist</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00019">makeIndependent()</a>.</p>

</div>
</div>
<a id="a92c75fecb7c6277a4c88ca79a40a3c8a" name="a92c75fecb7c6277a4c88ca79a40a3c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c75fecb7c6277a4c88ca79a40a3c8a">&#9670;&#160;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> ValueBoundsConstraintSet::dump </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debugging only: Dump the constraint set and the column-to-value/dim mapping to llvm::errs. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00931">931</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00426">cstr</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00031">getOwnerOfValue()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00324">kIndexValue</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00418">positionToValueDim</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="ac5d6a2d21f63e780bca2e988255b5d05" name="ac5d6a2d21f63e780bca2e988255b5d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d6a2d21f63e780bca2e988255b5d05">&#9670;&#160;</a></span>getExpr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> ValueBoundsConstraintSet::getExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>constant</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an expression that represents a constant. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00260">260</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00429">builder</a>.</p>

</div>
</div>
<a id="ad261cd52134aaac33b8bef2edbec027a" name="ad261cd52134aaac33b8bef2edbec027a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad261cd52134aaac33b8bef2edbec027a">&#9670;&#160;</a></span>getExpr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> ValueBoundsConstraintSet::getExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>ofr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an expression that represents a constant or index-typed SSA value. </p>
<p>In case of a value, if this value was not used so far, it is added to the worklist. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00252">252</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00429">builder</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00203">getExpr()</a>.</p>

</div>
</div>
<a id="a24623069be2ea1a3a8b145201c2cd6e4" name="a24623069be2ea1a3a8b145201c2cd6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24623069be2ea1a3a8b145201c2cd6e4">&#9670;&#160;</a></span>getExpr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> ValueBoundsConstraintSet::getExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an expression that represents the given index-typed value or shaped value dimension. </p>
<p>If this value/dimension was not used so far, it is added to the worklist.</p>
<p><span class="tt">dim</span> must be <span class="tt">nullopt</span> if and only if the given value is of index type. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00203">203</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00167">assertValidValueDim()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00300">bound()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00429">builder</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00332">getPos()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00349">getPosExpr()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00264">insert()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00324">kIndexValue</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00420">valueDimToPosition</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00252">getExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00305">insert()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00652">populateConstraints()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">processWorklist()</a>.</p>

</div>
</div>
<a id="a8586ef3ed7a840c87e8fd2fc24ba5c13" name="a8586ef3ed7a840c87e8fd2fc24ba5c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8586ef3ed7a840c87e8fd2fc24ba5c13">&#9670;&#160;</a></span>getPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> ValueBoundsConstraintSet::getPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the column position of the given value/dimension. </p>
<p>Asserts that the value/dimension exists in the constraint set. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00332">332</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00167">assertValidValueDim()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00031">getOwnerOfValue()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00324">kIndexValue</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00420">valueDimToPosition</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00203">getExpr()</a>.</p>

</div>
</div>
<a id="ab057bc1bf30abd3bc8c76620ff32cd4b" name="ab057bc1bf30abd3bc8c76620ff32cd4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab057bc1bf30abd3bc8c76620ff32cd4b">&#9670;&#160;</a></span>getPosExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> ValueBoundsConstraintSet::getPosExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an affine expression that represents column <span class="tt">pos</span> in the constraint set. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00349">349</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00429">builder</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00426">cstr</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00203">getExpr()</a>.</p>

</div>
</div>
<a id="a9ff7ad8c30e9a94b10e48f1836647a53" name="a9ff7ad8c30e9a94b10e48f1836647a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff7ad8c30e9a94b10e48f1836647a53">&#9670;&#160;</a></span>insert() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> ValueBoundsConstraintSet::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#ae781cb86d98ed62093c16c9e8819799b">ValueDimList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isSymbol</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the given affine map and its bound operands as a new column in the constraint system. </p>
<p>Return the position of the new column. Any operands that were not analyzed yet are put on the worklist. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00305">305</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00180">addBound()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00044">mlir::presburger::EQ</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00203">getExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00264">insert()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00087">mlir::AffineExpr::replaceDimsAndSymbols()</a>.</p>

</div>
</div>
<a id="af271a31c4fde7430da2588bb3ce56960" name="af271a31c4fde7430da2588bb3ce56960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af271a31c4fde7430da2588bb3ce56960">&#9670;&#160;</a></span>insert() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> ValueBoundsConstraintSet::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isSymbol</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an anonymous column into the constraint set. </p>
<p>The column is not bound to any value/dimension. If <span class="tt">isSymbol</span> is set to "false", a dimension is added.</p>
<p>Note: There are certain affine restrictions wrt. dimensions. E.g., they cannot be multiplied. Furthermore, bounds can only be queried for dimensions but not for symbols. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00293">293</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00426">cstr</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00418">positionToValueDim</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00420">valueDimToPosition</a>.</p>

</div>
</div>
<a id="ac4b8073f39f96b6a857040ecf255205b" name="ac4b8073f39f96b6a857040ecf255205b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b8073f39f96b6a857040ecf255205b">&#9670;&#160;</a></span>insert() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> ValueBoundsConstraintSet::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isSymbol</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00328">328</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

</div>
</div>
<a id="a863ab398668a486c2aa39c47f7fef171" name="a863ab398668a486c2aa39c47f7fef171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863ab398668a486c2aa39c47f7fef171">&#9670;&#160;</a></span>insert() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> ValueBoundsConstraintSet::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isSymbol</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>addToWorklist</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a value/dimension into the constraint set. </p>
<p>If <span class="tt">isSymbol</span> is set to "false", a dimension is added. The value/dimension is added to the worklist if <span class="tt">addToWorklist</span> is set.</p>
<p>Note: There are certain affine restrictions wrt. dimensions. E.g., they cannot be multiplied. Furthermore, bounds can only be queried for dimensions but not for symbols. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00264">264</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00167">assertValidValueDim()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00426">cstr</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00031">getOwnerOfValue()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00324">kIndexValue</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00418">positionToValueDim</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00420">valueDimToPosition</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00423">worklist</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00203">getExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00305">insert()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00666">populateConstraints()</a>.</p>

</div>
</div>
<a id="aaee7f7bb79ec6cb583fe312fd59deefe" name="aaee7f7bb79ec6cb583fe312fd59deefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee7f7bb79ec6cb583fe312fd59deefe">&#9670;&#160;</a></span>isMapped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ValueBoundsConstraintSet::isMapped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return "true" if the given value/dim is mapped (i.e., has a corresponding column in the constraint system). </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00356">356</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00324">kIndexValue</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00420">valueDimToPosition</a>.</p>

</div>
</div>
<a id="aee1947c5fb677562e70ad8d29c53fc7d" name="aee1947c5fb677562e70ad8d29c53fc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1947c5fb677562e70ad8d29c53fc7d">&#9670;&#160;</a></span>populateAndCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ValueBoundsConstraintSet::populateAndCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate constraints for lhs/rhs (until the stop condition is met). </p>
<p>Then, try to prove that, based on the current state of this constraint set (i.e., without analyzing additional IR or adding new constraints), the "lhs" value/dim is LE/LT/EQ/GT/GE than the "rhs" value/dim.</p>
<p>Return "true" if the specified relation between the two values/dims was proven to hold. Return "false" if the specified relation could not be proven. This could be because the specified relation does in fact not hold or because there is not enough information in the constraint set. In other words, if we do not know for sure, this function returns "false". </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00774">774</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00691">comparePos()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00652">populateConstraints()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="aef9cb692dc4b05849d4717fd2ddf41ce" name="aef9cb692dc4b05849d4717fd2ddf41ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9cb692dc4b05849d4717fd2ddf41ce">&#9670;&#160;</a></span>populateConstraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> ValueBoundsConstraintSet::populateConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ae781cb86d98ed62093c16c9e8819799b">ValueDimList</a></td>          <td class="paramname"><span class="paramname"><em>mapOperands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an affine map with a single result (and map operands), add a new column to the constraint set that represents the result of the map. </p>
<p>Traverse additional IR starting from the map operands as needed (as long as the stop condition is not satisfied). Also process all values/dims that are already on the worklist. Return the position of the newly added column. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00666">666</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00264">insert()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">processWorklist()</a>.</p>

</div>
</div>
<a id="acf8cc9c8f19a25e07857506d3b6744ca" name="acf8cc9c8f19a25e07857506d3b6744ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8cc9c8f19a25e07857506d3b6744ca">&#9670;&#160;</a></span>populateConstraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> ValueBoundsConstraintSet::populateConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the IR starting from the given value/dim and populate constraints as long as the stop condition holds. </p>
<p>Also process all values/dims that are already on the worklist. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00652">652</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00167">assertValidValueDim()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00203">getExpr()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">processWorklist()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00774">populateAndCompare()</a>.</p>

</div>
</div>
<a id="a1ae3298af91a6fcf19bbe0e99474a71d" name="a1ae3298af91a6fcf19bbe0e99474a71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae3298af91a6fcf19bbe0e99474a71d">&#9670;&#160;</a></span>processWorklist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> ValueBoundsConstraintSet::processWorklist </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iteratively process all elements on the worklist until an index-typed value or shaped value meets <span class="tt">stopCondition</span>. </p>
<p>Such values are not processed any further. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">363</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00300">bound()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00203">getExpr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00031">getOwnerOfValue()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00324">kIndexValue</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00418">positionToValueDim</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00432">stopCondition</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00423">worklist</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00666">populateConstraints()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00652">populateConstraints()</a>.</p>

</div>
</div>
<a id="a1ae7e00e049e6424079168fa8ac76a9f" name="a1ae7e00e049e6424079168fa8ac76a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae7e00e049e6424079168fa8ac76a9f">&#9670;&#160;</a></span>projectOut() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> ValueBoundsConstraintSet::projectOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="#ac57ffad5889e7da2eb288c23dfb84556">ValueDim</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>condition</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project out all columns for which the condition holds. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00434">434</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00418">positionToValueDim</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00418">projectOut()</a>.</p>

</div>
</div>
<a id="a3f741239cfb6c63b288a16c2314a8ada" name="a3f741239cfb6c63b288a16c2314a8ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f741239cfb6c63b288a16c2314a8ada">&#9670;&#160;</a></span>projectOut() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> ValueBoundsConstraintSet::projectOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project out the given column in the constraint set. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00418">418</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00426">cstr</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00418">positionToValueDim</a>, and <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00420">valueDimToPosition</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00434">projectOut()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00449">projectOutAnonymous()</a>.</p>

</div>
</div>
<a id="ab444ead14e592768f090608fbb16a0cb" name="ab444ead14e592768f090608fbb16a0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab444ead14e592768f090608fbb16a0cb">&#9670;&#160;</a></span>projectOutAnonymous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> ValueBoundsConstraintSet::projectOutAnonymous </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>except</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00449">449</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00418">positionToValueDim</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00418">projectOut()</a>.</p>

</div>
</div>
<a id="a5cbfc66cbcfe22e0865e6b580750e3b8" name="a5cbfc66cbcfe22e0865e6b580750e3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbfc66cbcfe22e0865e6b580750e3b8">&#9670;&#160;</a></span>strongCompare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classbool.html">bool</a> &gt; ValueBoundsConstraintSet::strongCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is similar to <span class="tt"><a class="el" href="#a06631ca1346abc0c35de13244e1603dc" title="Return &quot;true&quot; if &quot;lhs cmp rhs&quot; was proven to hold.">ValueBoundsConstraintSet::compare</a></span>, except that it returns false if <span class="tt">!(lhs cmp rhs)</span>, and <span class="tt">failure</span> if neither the relation nor its inverse relation could be proven. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00801">801</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00426">cstr</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00432">stopCondition</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00156">ValueBoundsConstraintSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00821">areEqual()</a>, and <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00033">simplifyAffineMinMaxOp()</a>.</p>

</div>
</div>
<a id="aaf5ab8164e75c5ce15ed2f946d3565e5" name="aaf5ab8164e75c5ce15ed2f946d3565e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5ab8164e75c5ce15ed2f946d3565e5">&#9670;&#160;</a></span>strongComparePos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classbool.html">bool</a> &gt; ValueBoundsConstraintSet::strongComparePos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>lhsPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6de419cb4fc58ccc729b0a1fc946f9cc">ComparisonOperator</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>rhsPos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return "true" if, based on the current state of the constraint system, "lhs cmp rhs" was proven to hold. </p>
<p>It returns "false" if "!(lhs cmp rhs)" can be proven. Otherwise, it returns <span class="tt">failure</span> if neither the relation nor its inverse relation could be proven.</p>
<p>This function does not analyze any IR and does not populate any additional constraints. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00736">736</a> of file <a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00691">comparePos()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">EQ</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">GE</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">GT</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">LE</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">LT</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00736">strongComparePos()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00736">strongComparePos()</a>.</p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a1c0c3000f52de037eb63b26255bfd490" name="a1c0c3000f52de037eb63b26255bfd490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0c3000f52de037eb63b26255bfd490">&#9670;&#160;</a></span>addConservativeSemiAffineBounds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::ValueBoundsConstraintSet::addConservativeSemiAffineBounds = <a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should conservative bounds be added for semi-affine expressions. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00435">435</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00180">addBound()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00156">ValueBoundsConstraintSet()</a>.</p>

</div>
</div>
<a id="ae84dccc7a15710a44f413cbde1a2aa57" name="ae84dccc7a15710a44f413cbde1a2aa57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84dccc7a15710a44f413cbde1a2aa57">&#9670;&#160;</a></span>builder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Builder.html">Builder</a> mlir::ValueBoundsConstraintSet::builder</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Builder.html" title="This class is a general helper class for creating context-global objects like types,...">Builder</a> for constructing affine expressions. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00429">429</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00260">getExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00252">getExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00203">getExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00349">getPosExpr()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00156">ValueBoundsConstraintSet()</a>.</p>

</div>
</div>
<a id="aa050edbbd92d0354a4f6712e60b7e202" name="aa050edbbd92d0354a4f6712e60b7e202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa050edbbd92d0354a4f6712e60b7e202">&#9670;&#160;</a></span>cstr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FlatLinearConstraints.html">FlatLinearConstraints</a> mlir::ValueBoundsConstraintSet::cstr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constraint system of equalities and inequalities. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00426">426</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00180">addBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00782">compare()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00691">comparePos()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00463">computeBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00629">computeConstantBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00584">computeDependentBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00595">computeIndependentBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00931">dump()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00349">getPosExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00293">insert()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00264">insert()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00418">projectOut()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00801">strongCompare()</a>.</p>

</div>
</div>
<a id="ae9decec8380c34985c86d837342f67ab" name="ae9decec8380c34985c86d837342f67ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9decec8380c34985c86d837342f67ab">&#9670;&#160;</a></span>ID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char ValueBoundsConstraintSet::ID = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00113">113</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

</div>
</div>
<a id="afad63892c0cdb924297f073902a32735" name="afad63892c0cdb924297f073902a32735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad63892c0cdb924297f073902a32735">&#9670;&#160;</a></span>kIndexValue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> mlir::ValueBoundsConstraintSet::kIndexValue = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dimension identifier to indicate a value is index-typed. </p>
<p>This is used for internal data structures/API only. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00324">324</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00463">computeBound()</a>, <a class="el" href="ScalableValueBoundsConstraintSet_8cpp_source.html#l00043">mlir::vector::ScalableValueBoundsConstraintSet::computeScalableBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00931">dump()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00203">getExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00332">getPos()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00264">insert()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00356">isMapped()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">processWorklist()</a>.</p>

</div>
</div>
<a id="a252a2d4f3f9fe0e8c4b7808181a6233e" name="a252a2d4f3f9fe0e8c4b7808181a6233e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252a2d4f3f9fe0e8c4b7808181a6233e">&#9670;&#160;</a></span>positionToValueDim</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;std::optional&lt;<a class="el" href="#ac57ffad5889e7da2eb288c23dfb84556">ValueDim</a>&gt; &gt; mlir::ValueBoundsConstraintSet::positionToValueDim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mapping of columns to values/shape dimensions. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00418">418</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00931">dump()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00293">insert()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00264">insert()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">processWorklist()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00434">projectOut()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00418">projectOut()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00449">projectOutAnonymous()</a>.</p>

</div>
</div>
<a id="a6d2968aa9c133f84d2041a0f1935d8a7" name="a6d2968aa9c133f84d2041a0f1935d8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2968aa9c133f84d2041a0f1935d8a7">&#9670;&#160;</a></span>stopCondition</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a404e07bad50e360592a8dfe1056bf25c">StopConditionFn</a> mlir::ValueBoundsConstraintSet::stopCondition = <a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current stop condition function. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00432">432</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00782">compare()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00463">computeBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00629">computeConstantBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">processWorklist()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00801">strongCompare()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00156">ValueBoundsConstraintSet()</a>.</p>

</div>
</div>
<a id="a1400a0b15e88ed5b9c953675ae5bb223" name="a1400a0b15e88ed5b9c953675ae5bb223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1400a0b15e88ed5b9c953675ae5bb223">&#9670;&#160;</a></span>valueDimToPosition</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt;<a class="el" href="#ac57ffad5889e7da2eb288c23dfb84556">ValueDim</a>, <a class="el" href="classint64__t.html">int64_t</a>&gt; mlir::ValueBoundsConstraintSet::valueDimToPosition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse mapping of values/shape dimensions to columns. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00420">420</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00203">getExpr()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00332">getPos()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00293">insert()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00264">insert()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00356">isMapped()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00418">projectOut()</a>.</p>

</div>
</div>
<a id="a9437e4d82b1f5f8649421e3405ac8081" name="a9437e4d82b1f5f8649421e3405ac8081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9437e4d82b1f5f8649421e3405ac8081">&#9670;&#160;</a></span>worklist</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;<a class="el" href="classint64__t.html">int64_t</a>&gt; mlir::ValueBoundsConstraintSet::worklist</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Worklist of values/shape dimensions that have not been processed yet. </p>

<p class="definition">Definition at line <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00423">423</a> of file <a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00595">computeIndependentBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00264">insert()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00363">processWorklist()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Interfaces/<a class="el" href="ValueBoundsOpInterface_8h_source.html">ValueBoundsOpInterface.h</a></li>
<li>lib/Interfaces/<a class="el" href="ValueBoundsOpInterface_8cpp_source.html">ValueBoundsOpInterface.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
