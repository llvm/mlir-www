<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Affine/IR/AffineOps.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a href="dir_30022079959872f4a1874dfcab7bb1fc.html">Affine</a></li><li class="navelem"><a href="dir_253b99abdc8fa8576ac945bee537f5fd.html">IR</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">AffineOps.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineValueMap_8h_source.html">mlir/Dialect/Affine/IR/AffineValueMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2MemRef_2IR_2MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="UBOps_8h_source.html">mlir/Dialect/UB/IR/UBOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StaticValueUtils_8h_source.html">mlir/Dialect/Utils/StaticValueUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">mlir/IR/AffineExpr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineExprVisitor_8h_source.html">mlir/IR/AffineExprVisitor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IRMapping_8h_source.html">mlir/IR/IRMapping.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2IntegerSet_8h_source.html">mlir/IR/IntegerSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Matchers_8h_source.html">mlir/IR/Matchers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OpDefinition_8h_source.html">mlir/IR/OpDefinition.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Value_8h_source.html">mlir/IR/Value.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ShapedOpInterfaces_8h_source.html">mlir/Interfaces/ShapedOpInterfaces.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ValueBoundsOpInterface_8h_source.html">mlir/Interfaces/ValueBoundsOpInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InliningUtils_8h_source.html">mlir/Transforms/InliningUtils.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallBitVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallVectorExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/TypeSwitch.h&quot;</code><br />
<code>#include &quot;llvm/Support/DebugLog.h&quot;</code><br />
<code>#include &quot;llvm/Support/LogicalResult.h&quot;</code><br />
<code>#include &quot;llvm/Support/MathExtras.h&quot;</code><br />
<code>#include &lt;numeric&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &quot;mlir/Dialect/Affine/IR/AffineOpsDialect.cpp.inc&quot;</code><br />
<code>#include &quot;mlir/Dialect/Affine/IR/AffineOps.cpp.inc&quot;</code><br />
</div>
<p><a href="AffineOps_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:DeduplicateAffineMinMaxExpressions_3C_20T_20_3E" id="r_DeduplicateAffineMinMaxExpressions_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDeduplicateAffineMinMaxExpressions.html">DeduplicateAffineMinMaxExpressions&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicated expressions in affine min/max ops.  <a href="structDeduplicateAffineMinMaxExpressions.html#details">More...</a><br /></td></tr>
<tr class="memitem:MergeAffineMinMaxOp_3C_20T_20_3E" id="r_MergeAffineMinMaxOp_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMergeAffineMinMaxOp.html">MergeAffineMinMaxOp&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge an affine min/max op to its consumers if its consumer is also an affine min/max op.  <a href="structMergeAffineMinMaxOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:CanonicalizeAffineMinMaxOpExprAndTermOrder_3C_20T_20_3E" id="r_CanonicalizeAffineMinMaxOpExprAndTermOrder_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCanonicalizeAffineMinMaxOpExprAndTermOrder.html">CanonicalizeAffineMinMaxOpExprAndTermOrder&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize the affine map result expression order of an affine min/max operation.  <a href="structCanonicalizeAffineMinMaxOpExprAndTermOrder.html#details">More...</a><br /></td></tr>
<tr class="memitem:CanonicalizeSingleResultAffineMinMaxOp_3C_20T_20_3E" id="r_CanonicalizeSingleResultAffineMinMaxOp_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCanonicalizeSingleResultAffineMinMaxOp.html">CanonicalizeSingleResultAffineMinMaxOp&lt; T &gt;</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d" id="r_ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;affine-ops&quot;</td></tr>
<tr class="memitem:aeb4eeb99d83d4a53327f3c7a9574ad6f" id="r_aeb4eeb99d83d4a53327f3c7a9574ad6f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb4eeb99d83d4a53327f3c7a9574ad6f">GET_OP_LIST</a></td></tr>
<tr class="memitem:a52c883a38e577b8b12282ff70c95a16d" id="r_a52c883a38e577b8b12282ff70c95a16d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52c883a38e577b8b12282ff70c95a16d">GET_OP_CLASSES</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0d3be33f83c44ec2bd88e94fff40fd18" id="r_a0d3be33f83c44ec2bd88e94fff40fd18"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d3be33f83c44ec2bd88e94fff40fd18">remainsLegalAfterInline</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Region.html">Region</a> *dest, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapping, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; legalityCheck)</td></tr>
<tr class="memdesc:a0d3be33f83c44ec2bd88e94fff40fd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <span class="tt">value</span> known to be a legal affine dimension or symbol in <span class="tt">src</span> region remains legal if the operation that uses it is inlined into <span class="tt">dest</span> with the given value mapping.  <br /></td></tr>
<tr class="memitem:ae3a9b3c718db4723ffe1fb5538ea0ead" id="r_ae3a9b3c718db4723ffe1fb5538ea0ead"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3a9b3c718db4723ffe1fb5538ea0ead">remainsLegalAfterInline</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Region.html">Region</a> *dest, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapping, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; legalityCheck)</td></tr>
<tr class="memdesc:ae3a9b3c718db4723ffe1fb5538ea0ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all values known to be legal affine dimensions or symbols in <span class="tt">src</span> remain so if their respective users are inlined into <span class="tt">dest</span>.  <br /></td></tr>
<tr class="memitem:ae826612e07e64373b1612baac8fb6819" id="r_ae826612e07e64373b1612baac8fb6819"><td class="memTemplParams" colspan="2">template&lt;typename OpTy&gt; </td></tr>
<tr class="memitem:ae826612e07e64373b1612baac8fb6819 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae826612e07e64373b1612baac8fb6819">remainsLegalAfterInline</a> (OpTy op, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Region.html">Region</a> *dest, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapping)</td></tr>
<tr class="memdesc:ae826612e07e64373b1612baac8fb6819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an affine read or write operation remains legal after inlining from <span class="tt">src</span> to <span class="tt">dest</span>.  <br /></td></tr>
<tr class="memitem:a403f2f69de4c2a980fe6265cb311c94b" id="r_a403f2f69de4c2a980fe6265cb311c94b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a403f2f69de4c2a980fe6265cb311c94b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a403f2f69de4c2a980fe6265cb311c94b">remainsLegalAfterInline</a> (AffineApplyOp op, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Region.html">Region</a> *dest, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapping)</td></tr>
<tr class="memdesc:a403f2f69de4c2a980fe6265cb311c94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an affine apply operation remains legal after inlining from <span class="tt">src</span> to <span class="tt">dest</span>.  <br /></td></tr>
<tr class="memitem:a6db62c4fe9a0af0edf33f735e7450913" id="r_a6db62c4fe9a0af0edf33f735e7450913"><td class="memTemplParams" colspan="2">template&lt;typename AnyMemRefDefOp&gt; </td></tr>
<tr class="memitem:a6db62c4fe9a0af0edf33f735e7450913 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6db62c4fe9a0af0edf33f735e7450913">isMemRefSizeValidSymbol</a> (AnyMemRefDefOp memrefDefOp, <a class="el" href="classunsigned.html">unsigned</a> index, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:a6db62c4fe9a0af0edf33f735e7450913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the 'index' dimension of the <span class="tt">memref</span> defined by <span class="tt">memrefDefOp</span> is a statically shaped one or defined using a valid symbol for <span class="tt">region</span>.  <br /></td></tr>
<tr class="memitem:abb7f0f42fc1a8809ab9d7ae95aac496a" id="r_abb7f0f42fc1a8809ab9d7ae95aac496a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb7f0f42fc1a8809ab9d7ae95aac496a">isDimOpValidSymbol</a> (ShapedDimOpInterface dimOp, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:abb7f0f42fc1a8809ab9d7ae95aac496a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the result of the dim op is a valid symbol for <span class="tt">region</span>.  <br /></td></tr>
<tr class="memitem:a2ac7dca41a4290b140937ea9a17c1861" id="r_a2ac7dca41a4290b140937ea9a17c1861"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ac7dca41a4290b140937ea9a17c1861">isTopLevelValueOrAbove</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:a2ac7dca41a4290b140937ea9a17c1861"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to check if a value is defined at the top level of <span class="tt">region</span> or is an argument of <span class="tt">region</span> or is defined above the region.  <br /></td></tr>
<tr class="memitem:a40425801875310c2151577ce17a33acd" id="r_a40425801875310c2151577ce17a33acd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40425801875310c2151577ce17a33acd">isValidAffineIndexOperand</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memitem:a909b810a734e0872e03164db8d7fa7f8" id="r_a909b810a734e0872e03164db8d7fa7f8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a909b810a734e0872e03164db8d7fa7f8">printDimAndSymbolList</a> (<a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a> begin, <a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a> end, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer)</td></tr>
<tr class="memdesc:a909b810a734e0872e03164db8d7fa7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints dimension and symbol list.  <br /></td></tr>
<tr class="memitem:aaf19ea7311ad162852c482c8523b7120" id="r_aaf19ea7311ad162852c482c8523b7120"><td class="memTemplParams" colspan="2">template&lt;typename OpTy&gt; </td></tr>
<tr class="memitem:aaf19ea7311ad162852c482c8523b7120 template"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf19ea7311ad162852c482c8523b7120">verifyDimAndSymbolIdentifiers</a> (OpTy &amp;op, <a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a> operands, <a class="el" href="classunsigned.html">unsigned</a> numDims)</td></tr>
<tr class="memdesc:aaf19ea7311ad162852c482c8523b7120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to verify that a set of operands are valid dimension and symbol identifiers.  <br /></td></tr>
<tr class="memitem:a9113c24d7d445c3728e0d7945c064421" id="r_a9113c24d7d445c3728e0d7945c064421"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9113c24d7d445c3728e0d7945c064421">getLargestKnownDivisor</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> e, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:a9113c24d7d445c3728e0d7945c064421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest known divisor of <span class="tt">e</span>.  <br /></td></tr>
<tr class="memitem:a764b24362c096adadc31e0db757b0bbc" id="r_a764b24362c096adadc31e0db757b0bbc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a764b24362c096adadc31e0db757b0bbc">isNonNegativeBoundedBy</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> e, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, <a class="el" href="classint64__t.html">int64_t</a> k)</td></tr>
<tr class="memdesc:a764b24362c096adadc31e0db757b0bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <span class="tt">e</span> is known to be: 0 &lt;= <span class="tt">e</span> &lt; <span class="tt">k</span>.  <br /></td></tr>
<tr class="memitem:ac607329b2b966b06fe88ec201119aea3" id="r_ac607329b2b966b06fe88ec201119aea3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac607329b2b966b06fe88ec201119aea3">isQTimesDPlusR</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> e, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, <a class="el" href="classint64__t.html">int64_t</a> &amp;<a class="el" href="XeGPUDialect_8cpp.html#a5029d66da963c87e7314612c3102276a">div</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;quotientTimesDiv, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;<a class="el" href="XeGPUDialect_8cpp.html#a743d167a9a43b752fbaaf17e2a3994ad">rem</a>)</td></tr>
<tr class="memdesc:ac607329b2b966b06fe88ec201119aea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if expression <span class="tt">e</span> is of the form d*e_1 + e_2 where 0 &lt;= e_2 &lt; d.  <br /></td></tr>
<tr class="memitem:ad8ed4f376d87fe5a27188d8a10a89877" id="r_ad8ed4f376d87fe5a27188d8a10a89877"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8ed4f376d87fe5a27188d8a10a89877">getLowerBound</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> iv)</td></tr>
<tr class="memdesc:ad8ed4f376d87fe5a27188d8a10a89877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the constant lower bound on an <span class="tt">iv</span>.  <br /></td></tr>
<tr class="memitem:a98e9ed6e4f1e37d487c2628f2e897b29" id="r_a98e9ed6e4f1e37d487c2628f2e897b29"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98e9ed6e4f1e37d487c2628f2e897b29">getUpperBound</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> iv)</td></tr>
<tr class="memdesc:a98e9ed6e4f1e37d487c2628f2e897b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the constant upper bound on an affine.for <span class="tt">iv</span>.  <br /></td></tr>
<tr class="memitem:a75d1fbe4376d496fc50d1d10abd040a8" id="r_a75d1fbe4376d496fc50d1d10abd040a8"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75d1fbe4376d496fc50d1d10abd040a8">getUpperBound</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:a75d1fbe4376d496fc50d1d10abd040a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine a constant upper bound for <span class="tt">expr</span> if one exists while exploiting values in <span class="tt">operands</span>.  <br /></td></tr>
<tr class="memitem:a4a644559016b45a8a9408562d59ee347" id="r_a4a644559016b45a8a9408562d59ee347"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a644559016b45a8a9408562d59ee347">getLowerBound</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:a4a644559016b45a8a9408562d59ee347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine a constant lower bound for <span class="tt">expr</span> if one exists while exploiting values in <span class="tt">operands</span>.  <br /></td></tr>
<tr class="memitem:a3816c76427483b6523a3d129753e4715" id="r_a3816c76427483b6523a3d129753e4715"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3816c76427483b6523a3d129753e4715">simplifyExprAndOperands</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;expr, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classunsigned.html">unsigned</a> numSymbols, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:a3816c76427483b6523a3d129753e4715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify <span class="tt">expr</span> while exploiting information from the values in <span class="tt">operands</span>.  <br /></td></tr>
<tr class="memitem:a68ad81c63548091cb2fbc65b7d0136d5" id="r_a68ad81c63548091cb2fbc65b7d0136d5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68ad81c63548091cb2fbc65b7d0136d5">simplifyMinOrMaxExprWithOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, <a class="el" href="classbool.html">bool</a> isMax)</td></tr>
<tr class="memdesc:a68ad81c63548091cb2fbc65b7d0136d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the expressions in <span class="tt">map</span> while making use of lower or upper bounds of its operands.  <br /></td></tr>
<tr class="memitem:a87764ebcc2accde4c56f10872a823e72" id="r_a87764ebcc2accde4c56f10872a823e72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87764ebcc2accde4c56f10872a823e72">simplifyMapWithOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:a87764ebcc2accde4c56f10872a823e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the map while exploiting information on the values in <span class="tt">operands</span>.  <br /></td></tr>
<tr class="memitem:aa41cad291d738e5a50788d88be46a771" id="r_aa41cad291d738e5a50788d88be46a771"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa41cad291d738e5a50788d88be46a771">replaceAffineMinBoundingBoxExpression</a> (AffineMinOp minOp, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> dimOrSym, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dims, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> syms)</td></tr>
<tr class="memdesc:aa41cad291d738e5a50788d88be46a771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming <span class="tt">dimOrSym</span> is a quantity in the apply op map <span class="tt">map</span> and defined by <span class="tt">minOp = affine_min(x_1, ..., x_n)</span>.  <br /></td></tr>
<tr class="memitem:aeb6dd004d59edf13c5d01cc8b429f414" id="r_aeb6dd004d59edf13c5d01cc8b429f414"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb6dd004d59edf13c5d01cc8b429f414">shortenAddChainsContainingAll</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> e, const llvm::SmallDenseSet&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; &amp;exprsToRemove, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> newVal, <a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;replacementsMap)</td></tr>
<tr class="memdesc:aeb6dd004d59edf13c5d01cc8b429f414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively traverse <span class="tt">e</span>.  <br /></td></tr>
<tr class="memitem:a6cf33457ed6729b5821f85f2392f6a50" id="r_a6cf33457ed6729b5821f85f2392f6a50"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cf33457ed6729b5821f85f2392f6a50">replaceAffineDelinearizeIndexInverseExpression</a> (AffineDelinearizeIndexOp delinOp, <a class="el" href="classmlir_1_1Value.html">Value</a> resultToReplace, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dims, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;syms)</td></tr>
<tr class="memdesc:a6cf33457ed6729b5821f85f2392f6a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this map contains of the expression <span class="tt">x_1 + x_1 * C_1 + ... x_n * C_N +
/ ...</span> (not necessarily in order) where the set of the <span class="tt">x_i</span> is the set of outputs of an <span class="tt">affine.delinearize_index</span> whos inverse is that expression, replace that expression with the input of that delinearize_index op.  <br /></td></tr>
<tr class="memitem:ad80a73e1cfd4840702a6f60c34d37202" id="r_ad80a73e1cfd4840702a6f60c34d37202"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad80a73e1cfd4840702a6f60c34d37202">replaceDimOrSym</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classunsigned.html">unsigned</a> dimOrSymbolPosition, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dims, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;syms, <a class="el" href="classbool.html">bool</a> replaceAffineMin)</td></tr>
<tr class="memdesc:ad80a73e1cfd4840702a6f60c34d37202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> at position <span class="tt">pos</span> in <span class="tt">map</span> by the defining AffineApplyOp expression and operands.  <br /></td></tr>
<tr class="memitem:a92322a2a849cf48212dc80aae89615e1" id="r_a92322a2a849cf48212dc80aae89615e1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92322a2a849cf48212dc80aae89615e1">composeAffineMapAndOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands, <a class="el" href="classbool.html">bool</a> composeAffineMin=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a92322a2a849cf48212dc80aae89615e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over <span class="tt">operands</span> and fold away all those produced by an AffineApplyOp iteratively.  <br /></td></tr>
<tr class="memitem:af3d09bbb1d05d79cd31ad13d4797a2ab" id="r_af3d09bbb1d05d79cd31ad13d4797a2ab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3d09bbb1d05d79cd31ad13d4797a2ab">composeMultiResultAffineMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands, <a class="el" href="classbool.html">bool</a> composeAffineMin=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:af3d09bbb1d05d79cd31ad13d4797a2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes the given affine map with the given list of operands, pulling in the maps from any affine.apply operations that supply the operands.  <br /></td></tr>
<tr class="memitem:a97a6105410cad46cb66cca3f7efb4b00" id="r_a97a6105410cad46cb66cca3f7efb4b00"><td class="memTemplParams" colspan="2">template&lt;typename OpTy&gt; </td></tr>
<tr class="memitem:a97a6105410cad46cb66cca3f7efb4b00 template"><td class="memItemLeft" align="right" valign="top">static OpTy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97a6105410cad46cb66cca3f7efb4b00">makeComposedMinMax</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands)</td></tr>
<tr class="memitem:aaf870053b51991e5999a553ab45e4819" id="r_aaf870053b51991e5999a553ab45e4819"><td class="memTemplParams" colspan="2">template&lt;typename OpTy&gt; </td></tr>
<tr class="memitem:aaf870053b51991e5999a553ab45e4819 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf870053b51991e5999a553ab45e4819">makeComposedFoldedMinMax</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands)</td></tr>
<tr class="memitem:a622cab33387384a309422bb2c690772f" id="r_a622cab33387384a309422bb2c690772f"><td class="memTemplParams" colspan="2">template&lt;class MapOrSet&gt; </td></tr>
<tr class="memitem:a622cab33387384a309422bb2c690772f template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a622cab33387384a309422bb2c690772f">canonicalizePromotedSymbols</a> (MapOrSet *mapOrSet, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memitem:a93de5cae93c64100cbc920a9dc8e3dc6" id="r_a93de5cae93c64100cbc920a9dc8e3dc6"><td class="memTemplParams" colspan="2">template&lt;class MapOrSet&gt; </td></tr>
<tr class="memitem:a93de5cae93c64100cbc920a9dc8e3dc6 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93de5cae93c64100cbc920a9dc8e3dc6">legalizeDemotedDims</a> (MapOrSet &amp;mapOrSet, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands)</td></tr>
<tr class="memdesc:a93de5cae93c64100cbc920a9dc8e3dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A valid affine dimension may appear as a symbol in affine.apply operations.  <br /></td></tr>
<tr class="memitem:a43a13ffbd2aefb7089f0b7a1e5411b11" id="r_a43a13ffbd2aefb7089f0b7a1e5411b11"><td class="memTemplParams" colspan="2">template&lt;class MapOrSet&gt; </td></tr>
<tr class="memitem:a43a13ffbd2aefb7089f0b7a1e5411b11 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43a13ffbd2aefb7089f0b7a1e5411b11">canonicalizeMapOrSetAndOperands</a> (MapOrSet *mapOrSet, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memitem:a4de10d06704729af9438e5f4ae91bdec" id="r_a4de10d06704729af9438e5f4ae91bdec"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4de10d06704729af9438e5f4ae91bdec">parseBound</a> (<a class="el" href="classbool.html">bool</a> isLower, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>, <a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;p)</td></tr>
<tr class="memdesc:a4de10d06704729af9438e5f4ae91bdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a for operation loop bounds.  <br /></td></tr>
<tr class="memitem:ae2978fd47e940232657b5ae684d7ccce" id="r_ae2978fd47e940232657b5ae684d7ccce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2978fd47e940232657b5ae684d7ccce">printBound</a> (AffineMapAttr boundMap, <a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a> boundOperands, const char *prefix, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p)</td></tr>
<tr class="memitem:a9e1b5f51edb6d5cd35b45da7063f72a2" id="r_a9e1b5f51edb6d5cd35b45da7063f72a2"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e1b5f51edb6d5cd35b45da7063f72a2">foldLoopBounds</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a9e1b5f51edb6d5cd35b45da7063f72a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold the constant bounds of a loop.  <br /></td></tr>
<tr class="memitem:ad9265e0f14d0039506ec469afeba4af6" id="r_ad9265e0f14d0039506ec469afeba4af6"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9265e0f14d0039506ec469afeba4af6">getTrivialConstantTripCount</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:ad9265e0f14d0039506ec469afeba4af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns constant trip count in trivial cases.  <br /></td></tr>
<tr class="memitem:aaae707d50f816a62829c7d851593a914" id="r_aaae707d50f816a62829c7d851593a914"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaae707d50f816a62829c7d851593a914">AffineForEmptyLoopFolder</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:aaae707d50f816a62829c7d851593a914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold the empty loop.  <br /></td></tr>
<tr class="memitem:a2e08e1a0a3c19566aeaa94fbfc188ddb" id="r_a2e08e1a0a3c19566aeaa94fbfc188ddb"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e08e1a0a3c19566aeaa94fbfc188ddb">canonicalizeLoopBounds</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a2e08e1a0a3c19566aeaa94fbfc188ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize the bounds of the given loop.  <br /></td></tr>
<tr class="memitem:a021d91d70aa35c1c72efff729a5d296a" id="r_a021d91d70aa35c1c72efff729a5d296a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a021d91d70aa35c1c72efff729a5d296a">hasTrivialZeroTripCount</a> (AffineForOp op)</td></tr>
<tr class="memdesc:a021d91d70aa35c1c72efff729a5d296a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the affine.for has zero iterations in trivial cases.  <br /></td></tr>
<tr class="memitem:a9db09c19adc76e23ac2943fef4a17051" id="r_a9db09c19adc76e23ac2943fef4a17051"><td class="memTemplParams" colspan="2">template&lt;typename BoundListTy, typename LoopCreatorTy&gt; </td></tr>
<tr class="memitem:a9db09c19adc76e23ac2943fef4a17051 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9db09c19adc76e23ac2943fef4a17051">buildAffineLoopNestImpl</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, BoundListTy lbs, BoundListTy ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; steps, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn, LoopCreatorTy &amp;&amp;loopCreatorFn)</td></tr>
<tr class="memdesc:a9db09c19adc76e23ac2943fef4a17051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an affine loop nest, using "loopCreatorFn" to create individual loop operations.  <br /></td></tr>
<tr class="memitem:a000ad2f44506c1fbce68e3f31a6aa2b5" id="r_a000ad2f44506c1fbce68e3f31a6aa2b5"><td class="memItemLeft" align="right" valign="top">static AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a000ad2f44506c1fbce68e3f31a6aa2b5">buildAffineLoopFromConstants</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classint64__t.html">int64_t</a> lb, <a class="el" href="classint64__t.html">int64_t</a> ub, <a class="el" href="classint64__t.html">int64_t</a> step, AffineForOp::BodyBuilderFn bodyBuilderFn)</td></tr>
<tr class="memdesc:a000ad2f44506c1fbce68e3f31a6aa2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an affine loop from the bounds known to be constants.  <br /></td></tr>
<tr class="memitem:a834861d11a6a7baca945d6ffbc3a8ed2" id="r_a834861d11a6a7baca945d6ffbc3a8ed2"><td class="memItemLeft" align="right" valign="top">static AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a834861d11a6a7baca945d6ffbc3a8ed2">buildAffineLoopFromValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> lb, <a class="el" href="classmlir_1_1Value.html">Value</a> ub, <a class="el" href="classint64__t.html">int64_t</a> step, AffineForOp::BodyBuilderFn bodyBuilderFn)</td></tr>
<tr class="memdesc:a834861d11a6a7baca945d6ffbc3a8ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an affine loop from the bounds that may or may not be constants.  <br /></td></tr>
<tr class="memitem:a6d918662708baf501a1d9f1899126d21" id="r_a6d918662708baf501a1d9f1899126d21"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d918662708baf501a1d9f1899126d21">composeSetAndOperands</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> &amp;set, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands, <a class="el" href="classbool.html">bool</a> composeAffineMin=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a6d918662708baf501a1d9f1899126d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose any affine.apply ops feeding into <span class="tt">operands</span> of the integer set <span class="tt">set</span> by composing the maps of such affine.apply ops with the integer set constraints.  <br /></td></tr>
<tr class="memitem:a0ad5dc7b7e393187c5b9ae0d51786ab6" id="r_a0ad5dc7b7e393187c5b9ae0d51786ab6"><td class="memTemplParams" colspan="2">template&lt;typename AffineMemOpTy&gt; </td></tr>
<tr class="memitem:a0ad5dc7b7e393187c5b9ae0d51786ab6 template"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ad5dc7b7e393187c5b9ae0d51786ab6">verifyMemoryOpIndexing</a> (AffineMemOpTy op, AffineMapAttr mapAttr, <a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a> mapOperands, MemRefType memrefType, <a class="el" href="classunsigned.html">unsigned</a> numIndexOperands)</td></tr>
<tr class="memdesc:a0ad5dc7b7e393187c5b9ae0d51786ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify common indexing invariants of affine.load, affine.store, affine.vector_load and affine.vector_store.  <br /></td></tr>
<tr class="memitem:ae0fa7df47a2dd4686dfd19868542977a" id="r_ae0fa7df47a2dd4686dfd19868542977a"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ae0fa7df47a2dd4686dfd19868542977a template"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0fa7df47a2dd4686dfd19868542977a">verifyAffineMinMaxOp</a> (T op)</td></tr>
<tr class="memitem:a0bc66ae957af7e80fc8e9101d997a109" id="r_a0bc66ae957af7e80fc8e9101d997a109"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a0bc66ae957af7e80fc8e9101d997a109 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bc66ae957af7e80fc8e9101d997a109">printAffineMinMaxOp</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, T op)</td></tr>
<tr class="memitem:a6b90328357d17ae6c877a3e306f88360" id="r_a6b90328357d17ae6c877a3e306f88360"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a6b90328357d17ae6c877a3e306f88360 template"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b90328357d17ae6c877a3e306f88360">parseAffineMinMaxOp</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memitem:a239b29451081bbe685157a5388f032ca" id="r_a239b29451081bbe685157a5388f032ca"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a239b29451081bbe685157a5388f032ca template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a239b29451081bbe685157a5388f032ca">foldMinMaxOp</a> (T op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands)</td></tr>
<tr class="memdesc:a239b29451081bbe685157a5388f032ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold an affine min or max operation with the given operands.  <br /></td></tr>
<tr class="memitem:aff2906e3ab99c40d772adeef8e53417d" id="r_aff2906e3ab99c40d772adeef8e53417d"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff2906e3ab99c40d772adeef8e53417d">canonicalizeMapExprAndTermOrder</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map)</td></tr>
<tr class="memdesc:aff2906e3ab99c40d772adeef8e53417d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize the result expression order of an affine map and return success if the order changed.  <br /></td></tr>
<tr class="memitem:a0c0743e18871599ff8ff8e2d8659d4c2" id="r_a0c0743e18871599ff8ff8e2d8659d4c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c0743e18871599ff8ff8e2d8659d4c2">isResultTypeMatchAtomicRMWKind</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> resultType, arith::AtomicRMWKind op)</td></tr>
<tr class="memitem:a45c2749d394c9d62ad34650fed76d26d" id="r_a45c2749d394c9d62ad34650fed76d26d"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45c2749d394c9d62ad34650fed76d26d">canonicalizeLoopBounds</a> (AffineParallelOp op)</td></tr>
<tr class="memdesc:a45c2749d394c9d62ad34650fed76d26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize the bounds of the given loop.  <br /></td></tr>
<tr class="memitem:a0fef8d134535c158ca70408a89d5f54e" id="r_a0fef8d134535c158ca70408a89d5f54e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fef8d134535c158ca70408a89d5f54e">printMinMaxBound</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, AffineMapAttr mapAttr, <a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a> group, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, StringRef keyword)</td></tr>
<tr class="memdesc:a0fef8d134535c158ca70408a89d5f54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a lower(upper) bound of an affine parallel loop with max(min) conditions in it.  <br /></td></tr>
<tr class="memitem:a426ac94f9af6a5b0e23dce16fbdebbe7" id="r_a426ac94f9af6a5b0e23dce16fbdebbe7"><td class="memItemLeft" align="right" valign="top">p&lt;&lt; &quot; : &quot;&lt;&lt; getMemRefType()&lt;&lt; &quot;, &quot;&lt;&lt; getType();}static LogicalResult verifyVectorMemoryOp(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, MemRefType memrefType, VectorType vectorType) { <a class="el" href="LoopUtils_8cpp.html#a38d8eb4db64049cbfcc770fdb9f2e522">if</a>(<a class="el" href="LLVMDialect_8cpp.html#a9b22482fd4c8f88526fc005d8447a66c">memrefType.getElementType</a>() !=<a class="el" href="LLVMDialect_8cpp.html#a9b22482fd4c8f88526fc005d8447a66c">vectorType.getElementType</a>()) return op-&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a426ac94f9af6a5b0e23dce16fbdebbe7">emitOpError</a> (&quot;requires memref and vector types of the same elemental type&quot;)</td></tr>
<tr class="memdesc:a426ac94f9af6a5b0e23dce16fbdebbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of lists of parsed operands, populates <span class="tt">uniqueOperands</span> with unique operands.  <br /></td></tr>
<tr class="memitem:aa2afc59a21f80839c29f2812f75c36a4" id="r_aa2afc59a21f80839c29f2812f75c36a4"><td class="memItemLeft" align="right" valign="top">return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2afc59a21f80839c29f2812f75c36a4">success</a> ()</td></tr>
<tr class="memitem:a578e3d34bcd3345c3674173aee98cded" id="r_a578e3d34bcd3345c3674173aee98cded"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a578e3d34bcd3345c3674173aee98cded">foldCstValueToCstAttrBasis</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedBasis, <a class="el" href="classmlir_1_1MutableOperandRange.html">MutableOperandRange</a> mutableDynamicBasis, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; dynamicBasis)</td></tr>
<tr class="memdesc:a578e3d34bcd3345c3674173aee98cded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given mixed basis of affine.delinearize_index/linearize_index replace constant SSA values with the constant integer value and return the new static basis. In case no such candidate for replacement exists, this utility returns std::nullopt.  <br /></td></tr>
</table>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&#160;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;affine-ops&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00042">42</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

</div>
</div>
<a id="a52c883a38e577b8b12282ff70c95a16d" name="a52c883a38e577b8b12282ff70c95a16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c883a38e577b8b12282ff70c95a16d">&#9670;&#160;</a></span>GET_OP_CLASSES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_OP_CLASSES</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l05699">5699</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

</div>
</div>
<a id="aeb4eeb99d83d4a53327f3c7a9574ad6f" name="aeb4eeb99d83d4a53327f3c7a9574ad6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4eeb99d83d4a53327f3c7a9574ad6f">&#9670;&#160;</a></span>GET_OP_LIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_OP_LIST</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="aaae707d50f816a62829c7d851593a914" name="aaae707d50f816a62829c7d851593a914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae707d50f816a62829c7d851593a914">&#9670;&#160;</a></span>AffineForEmptyLoopFolder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; AffineForEmptyLoopFolder </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fold the empty loop. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02614">2614</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02604">getTrivialConstantTripCount()</a>.</p>

</div>
</div>
<a id="a000ad2f44506c1fbce68e3f31a6aa2b5" name="a000ad2f44506c1fbce68e3f31a6aa2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000ad2f44506c1fbce68e3f31a6aa2b5">&#9670;&#160;</a></span>buildAffineLoopFromConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp buildAffineLoopFromConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>step</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp::BodyBuilderFn</td>          <td class="paramname"><span class="paramname"><em>bodyBuilderFn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an affine loop from the bounds known to be constants. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03026">3026</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02103">ValueRange</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l03035">buildAffineLoopFromValues()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l03048">mlir::affine::buildAffineLoopNest()</a>.</p>

</div>
</div>
<a id="a834861d11a6a7baca945d6ffbc3a8ed2" name="a834861d11a6a7baca945d6ffbc3a8ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834861d11a6a7baca945d6ffbc3a8ed2">&#9670;&#160;</a></span>buildAffineLoopFromValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp buildAffineLoopFromValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>step</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp::BodyBuilderFn</td>          <td class="paramname"><span class="paramname"><em>bodyBuilderFn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an affine loop from the bounds that may or may not be constants. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03035">3035</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l03026">buildAffineLoopFromConstants()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, and <a class="el" href="Builders_8cpp_source.html#l00383">mlir::Builder::getDimIdentityMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l03056">mlir::affine::buildAffineLoopNest()</a>.</p>

</div>
</div>
<a id="a9db09c19adc76e23ac2943fef4a17051" name="a9db09c19adc76e23ac2943fef4a17051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db09c19adc76e23ac2943fef4a17051">&#9670;&#160;</a></span>buildAffineLoopNestImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BoundListTy, typename LoopCreatorTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> buildAffineLoopNestImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundListTy</td>          <td class="paramname"><span class="paramname"><em>lbs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundListTy</td>          <td class="paramname"><span class="paramname"><em>ubs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>steps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>bodyBuilderFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoopCreatorTy &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>loopCreatorFn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds an affine loop nest, using "loopCreatorFn" to create individual loop operations. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02985">2985</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02103">ValueRange</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l03048">mlir::affine::buildAffineLoopNest()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l03056">mlir::affine::buildAffineLoopNest()</a>.</p>

</div>
</div>
<a id="a2e08e1a0a3c19566aeaa94fbfc188ddb" name="a2e08e1a0a3c19566aeaa94fbfc188ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e08e1a0a3c19566aeaa94fbfc188ddb">&#9670;&#160;</a></span>canonicalizeLoopBounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult canonicalizeLoopBounds </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Canonicalize the bounds of the given loop. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02663">2663</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01759">mlir::affine::canonicalizeMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00776">mlir::removeDuplicateExprs()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00925">simplifyMinOrMaxExprWithOperands()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a45c2749d394c9d62ad34650fed76d26d" name="a45c2749d394c9d62ad34650fed76d26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c2749d394c9d62ad34650fed76d26d">&#9670;&#160;</a></span>canonicalizeLoopBounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult canonicalizeLoopBounds </td>
          <td>(</td>
          <td class="paramtype">AffineParallelOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Canonicalize the bounds of the given loop. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l04348">4348</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l04337">mlir::affine::AffineValueMap::canonicalize()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00110">mlir::affine::AffineValueMap::getAffineMap()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00106">mlir::affine::AffineValueMap::getOperands()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="aff2906e3ab99c40d772adeef8e53417d" name="aff2906e3ab99c40d772adeef8e53417d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2906e3ab99c40d772adeef8e53417d">&#9670;&#160;</a></span>canonicalizeMapExprAndTermOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult canonicalizeMapExprAndTermOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Canonicalize the result expression order of an affine map and return success if the order changed. </p>
<p>The function flattens the map's affine expressions to coefficient arrays and sorts them in lexicographic order. A coefficient array contains a multiplier for every dimension/symbol and a constant term. The canonicalization fails if a result expression is not pure or if the flattening requires local variables that, unlike dimensions and symbols, have no global order. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03796">3796</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00362">mlir::SimpleAffineExprFlattener::operandExprStack</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="AffineExprVisitor_8h_source.html#l00150">mlir::AffineExprVisitor&lt; SubClass, RetTy &gt;::walkPostOrder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l03853">CanonicalizeAffineMinMaxOpExprAndTermOrder&lt; T &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a43a13ffbd2aefb7089f0b7a1e5411b11" name="a43a13ffbd2aefb7089f0b7a1e5411b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a13ffbd2aefb7089f0b7a1e5411b11">&#9670;&#160;</a></span>canonicalizeMapOrSetAndOperands()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapOrSet&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> canonicalizeMapOrSetAndOperands </td>
          <td>(</td>
          <td class="paramtype">MapOrSet *</td>          <td class="paramname"><span class="paramname"><em>mapOrSet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01682">1682</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01588">canonicalizePromotedSymbols()</a>, <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>, <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>, <a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">mlir::getAffineSymbolExpr()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01636">legalizeDemotedDims()</a>, <a class="el" href="Matchers_8h_source.html#l00369">mlir::m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01759">mlir::affine::canonicalizeMapAndOperands()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01764">mlir::affine::canonicalizeSetAndOperands()</a>.</p>

</div>
</div>
<a id="a622cab33387384a309422bb2c690772f" name="a622cab33387384a309422bb2c690772f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622cab33387384a309422bb2c690772f">&#9670;&#160;</a></span>canonicalizePromotedSymbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapOrSet&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> canonicalizePromotedSymbols </td>
          <td>(</td>
          <td class="paramtype">MapOrSet *</td>          <td class="paramname"><span class="paramname"><em>mapOrSet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01588">1588</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>, <a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">mlir::getAffineSymbolExpr()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01682">canonicalizeMapOrSetAndOperands()</a>.</p>

</div>
</div>
<a id="a92322a2a849cf48212dc80aae89615e1" name="a92322a2a849cf48212dc80aae89615e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92322a2a849cf48212dc80aae89615e1">&#9670;&#160;</a></span>composeAffineMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> composeAffineMapAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>composeAffineMin</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over <span class="tt">operands</span> and fold away all those produced by an AffineApplyOp iteratively. </p>
<p>Perform canonicalization of map and operands as well as <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> simplification. <span class="tt">map</span> and <span class="tt">operands</span> are mutated in place. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01336">1336</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01759">mlir::affine::canonicalizeMapAndOperands()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00285">mlir::changed</a>, <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>, <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>, <a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">mlir::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00221">mlir::AffineMap::isFunctionOfDim()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00228">mlir::AffineMap::isFunctionOfSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01275">replaceDimOrSym()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00496">mlir::AffineMap::replaceDimsAndSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00766">mlir::simplifyAffineMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l04337">mlir::affine::AffineValueMap::canonicalize()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02663">canonicalizeLoopBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03311">composeSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01400">mlir::affine::fullyComposeAffineMapAndOperands()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01416">mlir::affine::makeComposedAffineApply()</a>.</p>

</div>
</div>
<a id="af3d09bbb1d05d79cd31ad13d4797a2ab" name="af3d09bbb1d05d79cd31ad13d4797a2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d09bbb1d05d79cd31ad13d4797a2ab">&#9670;&#160;</a></span>composeMultiResultAffineMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> composeMultiResultAffineMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>composeAffineMin</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes the given affine map with the given list of operands, pulling in the maps from any affine.apply operations that supply the operands. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01439">1439</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01759">mlir::affine::canonicalizeMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01400">mlir::affine::fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">mlir::AffineMap::getSubMap()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00267">mlir::AffineMap::shiftDims()</a>, and <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00280">mlir::AffineMap::shiftSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01525">makeComposedMinMax()</a>.</p>

</div>
</div>
<a id="a6d918662708baf501a1d9f1899126d21" name="a6d918662708baf501a1d9f1899126d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d918662708baf501a1d9f1899126d21">&#9670;&#160;</a></span>composeSetAndOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> composeSetAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>composeAffineMin</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compose any affine.apply ops feeding into <span class="tt">operands</span> of the integer set <span class="tt">set</span> by composing the maps of such affine.apply ops with the integer set constraints. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03311">3311</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01250">mlir::IntegerSet::get()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00041">mlir::IntegerSet::getConstraints()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00057">mlir::IntegerSet::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00051">mlir::IntegerSet::getEqFlags()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00015">mlir::IntegerSet::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00016">mlir::IntegerSet::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>.</p>

</div>
</div>
<a id="a426ac94f9af6a5b0e23dce16fbdebbe7" name="a426ac94f9af6a5b0e23dce16fbdebbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426ac94f9af6a5b0e23dce16fbdebbe7">&#9670;&#160;</a></span>emitOpError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">p&lt;&lt; &quot; : &quot;&lt;&lt; getMemRefType()&lt;&lt; &quot;, &quot;&lt;&lt; getType();}static LogicalResult verifyVectorMemoryOp(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, MemRefType memrefType, VectorType vectorType) { <a class="el" href="LoopUtils_8cpp.html#a38d8eb4db64049cbfcc770fdb9f2e522">if</a>(<a class="el" href="LLVMDialect_8cpp.html#a9b22482fd4c8f88526fc005d8447a66c">memrefType.getElementType</a>() !=<a class="el" href="LLVMDialect_8cpp.html#a9b22482fd4c8f88526fc005d8447a66c">vectorType.getElementType</a>()) return op-&gt; emitOpError </td>
          <td>(</td>
          <td class="paramtype">&quot;requires memref and vector types of the same elemental type&quot;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of lists of parsed operands, populates <span class="tt">uniqueOperands</span> with unique operands. </p>
<p>Also populates <span class="tt">replacements with affine expressions of
/ </span>kind<span class="tt"> that can be used to update affine maps previously accepting a
/ </span>operands<span class="tt"> to accept </span>uniqueOperands` instead. static ParseResult deduplicateAndResolveOperands(
    OpAsmParser &amp;parser,
    ArrayRef&lt;SmallVector&lt;OpAsmParser::UnresolvedOperand&gt;&gt; operands,
    SmallVectorImpl&lt;Value&gt; &amp;uniqueOperands,
    SmallVectorImpl&lt;AffineExpr&gt; &amp;replacements, AffineExprKind kind) { assert((kind == AffineExprKind::DimId || kind == AffineExprKind::SymbolId) &amp;&amp; "expected operands to be dim or symbol expression");</p>
<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> indexType = parser.getBuilder().getIndexType(); for (const auto &amp;list : operands) { <a class="el" href="classSmallVector.html">SmallVector&lt;Value&gt;</a> valueOperands; if (parser.resolveOperands(list, indexType, valueOperands)) return failure(); for (<a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> operand : valueOperands) { unsigned pos = std::distance(uniqueOperands.begin(), llvm::find(uniqueOperands, operand)); if (pos == uniqueOperands.size()) uniqueOperands.push_back(operand); replacements.push_back( kind == AffineExprKind::DimId ? getAffineDimExpr(pos, parser.getContext()) : getAffineSymbolExpr(pos, parser.getContext())); } } return <a class="el" href="#aa2afc59a21f80839c29f2812f75c36a4">success()</a>; }</p>
<p>namespace { enum class MinMaxKind { Min, Max }; } // namespace</p>
<p>/ Parses an affine map that can contain a min/max for groups of its results, / e.g., max(expr-1, expr-2), expr-3, max(expr-4, expr-5, expr-6). Populates / <span class="tt">result</span> attributes with the map (flat list of expressions) and the grouping / (list of integers that specify how many expressions to put into each / min/max) attributes. Deduplicates repeated operands. / / parallel-bound ::= <span class="tt">(</span> parallel-group-list <span class="tt">)</span> / parallel-group-list ::= parallel-group (<span class="tt">,</span> parallel-group-list)? / parallel-group ::= simple-group | min-max-group / simple-group ::= expr-of-ssa-ids / min-max-group ::= ( <span class="tt">min</span> | <span class="tt">max</span> ) <span class="tt">(</span> expr-of-ssa-ids-list <span class="tt">)</span> / expr-of-ssa-ids-list ::= expr-of-ssa-ids (<span class="tt">,</span> expr-of-ssa-id-list)? / / Examples: / (%0, min(%1 + %2, %3), %4, min(%5 floordiv 32, %6)) / (%0, max(%1 - 2 * %2)) static ParseResult parseAffineMapWithMinMax(OpAsmParser &amp;parser,
                                            OperationState &amp;result,
                                            MinMaxKind kind) { Using <span class="tt">const</span> not <span class="tt">constexpr</span> below to workaround a MSVC optimizer bug, see: <a href="https://reviews.llvm.org/D134227#3821753">https://reviews.llvm.org/D134227#3821753</a> const llvm::StringLiteral tmpAttrStrName = "__pseudo_bound_map";</p>
<p>StringRef mapName = kind == MinMaxKind::Min ? AffineParallelOp::getUpperBoundsMapAttrStrName() : AffineParallelOp::getLowerBoundsMapAttrStrName(); StringRef groupsName = kind == MinMaxKind::Min ? AffineParallelOp::getUpperBoundsGroupsAttrStrName() : AffineParallelOp::getLowerBoundsGroupsAttrStrName();</p>
<p>if (failed(parser.parseLParen())) return failure();</p>
<p>if (succeeded(parser.parseOptionalRParen())) { result.addAttribute( mapName, AffineMapAttr::get(parser.getBuilder().getEmptyAffineMap())); result.addAttribute(groupsName, parser.getBuilder().getI32TensorAttr({})); return <a class="el" href="#aa2afc59a21f80839c29f2812f75c36a4">success()</a>; }</p>
<p><a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;AffineExpr&gt;</a> flatExprs; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;SmallVector&lt;OpAsmParser::UnresolvedOperand&gt;&gt;</a> flatDimOperands; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;SmallVector&lt;OpAsmParser::UnresolvedOperand&gt;&gt;</a> flatSymOperands; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;int32_t&gt;</a> numMapsPerGroup; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;OpAsmParser::UnresolvedOperand&gt;</a> mapOperands; auto parseOperands = [&amp;]() { if (succeeded(parser.parseOptionalKeyword( kind == MinMaxKind::Min ? "min" : "max"))) { mapOperands.clear(); AffineMapAttr map; if (failed(parser.parseAffineMapOfSSAIds(mapOperands, map, tmpAttrStrName, result.attributes, OpAsmParser::Delimiter::Paren))) return failure(); result.attributes.erase(tmpAttrStrName); llvm::append_range(flatExprs, map.getValue().getResults()); auto operandsRef = <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef(mapOperands)</a>; auto dimsRef = operandsRef.take_front(map.getValue().getNumDims()); <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;OpAsmParser::UnresolvedOperand&gt;</a> dims(dimsRef); auto symsRef = operandsRef.drop_front(map.getValue().getNumDims()); <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;OpAsmParser::UnresolvedOperand&gt;</a> syms(symsRef); flatDimOperands.append(map.getValue().getNumResults(), dims); flatSymOperands.append(map.getValue().getNumResults(), syms); numMapsPerGroup.push_back(map.getValue().getNumResults()); } else { if (failed(parser.parseAffineExprOfSSAIds(flatDimOperands.emplace_back(), flatSymOperands.emplace_back(), flatExprs.emplace_back()))) return failure(); numMapsPerGroup.push_back(1); } return <a class="el" href="#aa2afc59a21f80839c29f2812f75c36a4">success()</a>; }; if (parser.parseCommaSeparatedList(parseOperands) || parser.parseRParen()) return failure();</p>
<p>unsigned totalNumDims = 0; unsigned totalNumSyms = 0; for (unsigned i = 0, e = flatExprs.size(); i &lt; e; ++i) { unsigned numDims = flatDimOperands[i].size(); unsigned numSyms = flatSymOperands[i].size(); flatExprs[i] = flatExprs[i] .shiftDims(numDims, totalNumDims) .shiftSymbols(numSyms, totalNumSyms); totalNumDims += numDims; totalNumSyms += numSyms; }</p>
<p>Deduplicate map operands. <a class="el" href="classSmallVector.html">SmallVector&lt;Value&gt;</a> dimOperands, symOperands; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;AffineExpr&gt;</a> dimRplacements, symRepacements; if (deduplicateAndResolveOperands(parser, flatDimOperands, dimOperands,
                                    dimRplacements, AffineExprKind::DimId) || deduplicateAndResolveOperands(parser, flatSymOperands, symOperands,
                                    symRepacements, AffineExprKind::SymbolId)) return failure();</p>
<p>result.operands.append(dimOperands.begin(), dimOperands.end()); result.operands.append(symOperands.begin(), symOperands.end());</p>
<p><a class="el" href="classmlir_1_1Builder.html" title="This class is a general helper class for creating context-global objects like types,...">Builder</a> &amp;builder = parser.getBuilder(); auto flatMap = <a class="el" href="classmlir_1_1AffineMap.html#a3cfca2eb29fddf3c4bda714cccaa53f9" title="Returns a zero result affine map with no dimensions or symbols: () -&gt; ().">AffineMap::get</a>(totalNumDims, totalNumSyms, flatExprs, parser.getContext()); flatMap = flatMap.replaceDimsAndSymbols( dimRplacements, symRepacements, dimOperands.size(), symOperands.size());</p>
<p>result.addAttribute(mapName, AffineMapAttr::get(flatMap)); result.addAttribute(groupsName, builder.getI32TensorAttr(numMapsPerGroup)); return <a class="el" href="#aa2afc59a21f80839c29f2812f75c36a4">success()</a>; }</p>
<p>operation ::= <span class="tt">affine.parallel</span> <span class="tt">(</span> ssa-ids <span class="tt">)</span> <span class="tt">=</span> parallel-bound <span class="tt">to</span> parallel-bound steps? region attr-dict? steps ::= <span class="tt">steps</span> <span class="tt">(</span> integer-literals <span class="tt">)</span></p>
<p>ParseResult AffineParallelOp::parse(OpAsmParser &amp;parser,
                                    OperationState &amp;result) { auto &amp;builder = parser.getBuilder(); auto indexType = builder.getIndexType(); <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;OpAsmParser::Argument, 4&gt;</a> ivs; if (parser.parseArgumentList(ivs, OpAsmParser::Delimiter::Paren) || parser.parseEqual() || parseAffineMapWithMinMax(parser, result, MinMaxKind::Max) || parser.parseKeyword("to") || parseAffineMapWithMinMax(parser, result, MinMaxKind::Min)) return failure();</p>
<p>AffineMapAttr stepsMapAttr; <a class="el" href="classmlir_1_1NamedAttrList.html" title="NamedAttrList is array of NamedAttributes that tracks whether it is sorted and does some basic work t...">NamedAttrList</a> stepsAttrs; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;OpAsmParser::UnresolvedOperand, 4&gt;</a> stepsMapOperands; if (failed(parser.parseOptionalKeyword("step"))) { <a class="el" href="classSmallVector.html">SmallVector&lt;int64_t, 4&gt;</a> steps(ivs.size(), 1); result.addAttribute(AffineParallelOp::getStepsAttrStrName(), builder.getI64ArrayAttr(steps)); } else { if (parser.parseAffineMapOfSSAIds(stepsMapOperands, stepsMapAttr,
                                      AffineParallelOp::getStepsAttrStrName(),
                                      stepsAttrs,
                                      OpAsmParser::Delimiter::Paren)) return failure();</p>
<p>Convert steps from an <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> into an I64ArrayAttr. <a class="el" href="classSmallVector.html">SmallVector&lt;int64_t, 4&gt;</a> steps; auto stepsMap = stepsMapAttr.getValue(); for (const auto &amp;result : stepsMap.getResults()) { auto constExpr = dyn_cast&lt;AffineConstantExpr&gt;(result); if (!constExpr) return parser.emitError(parser.getNameLoc(), "steps must be constant integers"); steps.push_back(constExpr.getValue()); } result.addAttribute(AffineParallelOp::getStepsAttrStrName(), builder.getI64ArrayAttr(steps)); }</p>
<p>Parse optional clause of the form: <span class="tt">reduce ("addf", "maxf")</span>, where the quoted strings are a member of the enum AtomicRMWKind. <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;Attribute, 4&gt;</a> reductions; if (succeeded(parser.parseOptionalKeyword("reduce"))) { if (parser.parseLParen()) return failure(); auto parseAttributes = [&amp;]() -&gt; ParseResult { Parse a single quoted string via the attribute parsing, and then verify it is a member of the enum and convert to it's integer representation. StringAttr attrVal; <a class="el" href="classmlir_1_1NamedAttrList.html" title="NamedAttrList is array of NamedAttributes that tracks whether it is sorted and does some basic work t...">NamedAttrList</a> attrStorage; auto loc = parser.getCurrentLocation(); if (parser.parseAttribute(attrVal, builder.getNoneType(), "reduce", attrStorage)) return failure(); std::optional&lt;arith::AtomicRMWKind&gt; reduction = arith::symbolizeAtomicRMWKind(attrVal.getValue()); if (!reduction) return parser.emitError(loc, "invalid reduction value: ") &lt;&lt; attrVal; reductions.push_back( builder.getI64IntegerAttr(static_cast&lt;int64_t&gt;(reduction.value()))); While we keep getting commas, keep parsing. return <a class="el" href="#aa2afc59a21f80839c29f2812f75c36a4">success()</a>; }; if (parser.parseCommaSeparatedList(parseAttributes) || parser.parseRParen()) return failure(); } result.addAttribute(AffineParallelOp::getReductionsAttrStrName(), builder.getArrayAttr(reductions));</p>
<p>Parse return types of reductions (if any) if (parser.parseOptionalArrowTypeList(result.types)) return failure();</p>
<p>Now parse the body. <a class="el" href="classmlir_1_1Region.html" title="This class contains a list of basic blocks and a link to the parent operation it is attached to.">Region</a> *body = result.addRegion(); for (auto &amp;iv : ivs) iv.type = indexType; if (parser.parseRegion(*body, ivs) || parser.parseOptionalAttrDict(result.attributes)) return failure();</p>
<p>Add a terminator if none was parsed. AffineParallelOp::ensureTerminator(*body, builder, result.location); return <a class="el" href="#aa2afc59a21f80839c29f2812f75c36a4">success()</a>; }</p>
<p>===-------------------------------------------------------------------&mdash;===// AffineYieldOp ===-------------------------------------------------------------------&mdash;===//</p>
<p>LogicalResult AffineYieldOp::verify() { auto *parentOp = (*this)-&gt;getParentOp(); auto results = parentOp-&gt;getResults(); auto operands = getOperands();</p>
<p>if (!isa&lt;AffineParallelOp, AffineIfOp, AffineForOp&gt;(parentOp)) return <a class="el" href="#a426ac94f9af6a5b0e23dce16fbdebbe7" title="Given a list of lists of parsed operands, populates uniqueOperands with unique operands.">emitOpError()</a> &lt;&lt; "only terminates affine.if/for/parallel regions"; if (parentOp-&gt;getNumResults() != getNumOperands()) return <a class="el" href="#a426ac94f9af6a5b0e23dce16fbdebbe7" title="Given a list of lists of parsed operands, populates uniqueOperands with unique operands.">emitOpError()</a> &lt;&lt; "parent of yield must have same number of " "results as the yield operands"; for (auto it : llvm::zip(results, operands)) { if (std::get&lt;0&gt;(it).<a class="el" href="namespacemlir.html#a348ed9fcbefe1f5094cc571c346c7080" title="Returns the int type of the integer in ofr.">getType()</a> != std::get&lt;1&gt;(it).<a class="el" href="namespacemlir.html#a348ed9fcbefe1f5094cc571c346c7080" title="Returns the int type of the integer in ofr.">getType()</a>) return <a class="el" href="#a426ac94f9af6a5b0e23dce16fbdebbe7" title="Given a list of lists of parsed operands, populates uniqueOperands with unique operands.">emitOpError()</a> &lt;&lt; "types mismatch between yield op and its parent"; }</p>
<p>return <a class="el" href="#aa2afc59a21f80839c29f2812f75c36a4">success()</a>; }</p>
<p>===-------------------------------------------------------------------&mdash;===// AffineVectorLoadOp ===-------------------------------------------------------------------&mdash;===//</p>
<p>void AffineVectorLoadOp::build(OpBuilder &amp;builder, OperationState &amp;result,
                               VectorType resultType, AffineMap map,
                               ValueRange operands) { assert(operands.size() == 1 + map.getNumInputs() &amp;&amp; "inconsistent operands"); result.addOperands(operands); if (map) result.addAttribute(getMapAttrStrName(), AffineMapAttr::get(map)); result.types.push_back(resultType); }</p>
<p>void AffineVectorLoadOp::build(OpBuilder &amp;builder, OperationState &amp;result,
                               VectorType resultType, Value memref,
                               AffineMap map, ValueRange mapOperands) { assert(map.getNumInputs() == mapOperands.size() &amp;&amp; "inconsistent index info"); result.addOperands(memref); result.addOperands(mapOperands); result.addAttribute(getMapAttrStrName(), AffineMapAttr::get(map)); result.types.push_back(resultType); }</p>
<p>void AffineVectorLoadOp::build(OpBuilder &amp;builder, OperationState &amp;result,
                               VectorType resultType, Value memref,
                               ValueRange indices) { auto memrefType = llvm::cast&lt;MemRefType&gt;(memref.getType()); <a class="el" href="classint64__t.html">int64_t</a> rank = memrefType.getRank(); Create identity map for memrefs with at least one dimension or () -&gt; () for zero-dimensional memrefs. auto map = rank ? builder.getMultiDimIdentityMap(rank) : builder.getEmptyAffineMap(); build(builder, result, resultType, memref, map, indices); }</p>
<p>void AffineVectorLoadOp::getCanonicalizationPatterns(RewritePatternSet &amp;results,
                                                     MLIRContext *context) { results.add&lt;SimplifyAffineOp&lt;AffineVectorLoadOp&gt;&gt;(context); }</p>
<p>ParseResult AffineVectorLoadOp::parse(OpAsmParser &amp;parser,
                                      OperationState &amp;result) { auto &amp;builder = parser.getBuilder(); auto indexTy = builder.getIndexType();</p>
<p>MemRefType memrefType; VectorType resultType; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html" title="This is the representation of an operand reference.">OpAsmParser::UnresolvedOperand</a> memrefInfo; AffineMapAttr mapAttr; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;OpAsmParser::UnresolvedOperand, 1&gt;</a> mapOperands; return failure( parser.parseOperand(memrefInfo) || parser.parseAffineMapOfSSAIds(mapOperands, mapAttr, AffineVectorLoadOp::getMapAttrStrName(), result.attributes) || parser.parseOptionalAttrDict(result.attributes) || parser.parseColonType(memrefType) || parser.parseComma() || parser.parseType(resultType) || parser.resolveOperand(memrefInfo, memrefType, result.operands) || parser.resolveOperands(mapOperands, indexTy, result.operands) || parser.addTypeToList(resultType, result.types)); }</p>
<p>void AffineVectorLoadOp::print(OpAsmPrinter &amp;p) { p &lt;&lt; " " &lt;&lt; <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp.html#a0714cd1626efd69db4b0f9b362baf91a" title="Returns the memref being read/written by a memref/affine load/store op.">getMemRef()</a> &lt;&lt; '['; if (AffineMapAttr mapAttr = (*this)-&gt;getAttrOfType&lt;AffineMapAttr&gt;(getMapAttrStrName())) p.printAffineMapOfSSAIds(mapAttr, getMapOperands()); p &lt;&lt; ']'; p.printOptionalAttrDict((*this)-&gt;getAttrs(), /*elidedAttrs= </p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l04696">verifyPermutationMap()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00814">verifyStructIndices()</a>, and <a class="el" href="LLVMDialect_8cpp_source.html#l00774">verifyStructIndices()</a>.</p>

</div>
</div>
<a id="a578e3d34bcd3345c3674173aee98cded" name="a578e3d34bcd3345c3674173aee98cded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578e3d34bcd3345c3674173aee98cded">&#9670;&#160;</a></span>foldCstValueToCstAttrBasis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt; foldCstValueToCstAttrBasis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mixedBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MutableOperandRange.html">MutableOperandRange</a></td>          <td class="paramname"><span class="paramname"><em>mutableDynamicBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dynamicBasis</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given mixed basis of affine.delinearize_index/linearize_index replace constant SSA values with the constant integer value and return the new static basis. In case no such candidate for replacement exists, this utility returns std::nullopt. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l04965">4965</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8cpp_source.html#l00479">mlir::MutableOperandRange::erase()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>.</p>

</div>
</div>
<a id="a9e1b5f51edb6d5cd35b45da7063f72a2" name="a9e1b5f51edb6d5cd35b45da7063f72a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1b5f51edb6d5cd35b45da7063f72a2">&#9670;&#160;</a></span>foldLoopBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult foldLoopBounds </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fold the constant bounds of a loop. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02558">2558</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00430">mlir::AffineMap::constantFold()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="Matchers_8h_source.html#l00369">mlir::m_Constant()</a>, <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a239b29451081bbe685157a5388f032ca" name="a239b29451081bbe685157a5388f032ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239b29451081bbe685157a5388f032ca">&#9670;&#160;</a></span>foldMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> foldMinMaxOp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fold an affine min or max operation with the given operands. </p>
<p>The operand list may contain nulls, which are interpreted as the operand not being a constant. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03633">3633</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

</div>
</div>
<a id="a9113c24d7d445c3728e0d7945c064421" name="a9113c24d7d445c3728e0d7945c064421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9113c24d7d445c3728e0d7945c064421">&#9670;&#160;</a></span>getLargestKnownDivisor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> getLargestKnownDivisor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the largest known divisor of <span class="tt">e</span>. </p>
<p>Exploits information from the values in <span class="tt">operands</span>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00659">659</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="XeGPUDialect_8cpp_source.html#l00964">div</a>, <a class="el" href="AffineOps_8cpp_source.html#l02938">mlir::affine::getForInductionVarOwner()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00241">mlir::AffineExpr::getLargestKnownDivisor()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00725">isQTimesDPlusR()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>.</p>

</div>
</div>
<a id="a4a644559016b45a8a9408562d59ee347" name="a4a644559016b45a8a9408562d59ee347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a644559016b45a8a9408562d59ee347">&#9670;&#160;</a></span>getLowerBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; getLowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numSymbols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine a constant lower bound for <span class="tt">expr</span> if one exists while exploiting values in <span class="tt">operands</span>. </p>
<p>Note that the upper bound is an inclusive one. <span class="tt">expr</span> is guaranteed to be less than or equal to it. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00798">798</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01641">mlir::getBoundForAffineExpr()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00749">getLowerBound()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00757">getUpperBound()</a>.</p>

</div>
</div>
<a id="ad8ed4f376d87fe5a27188d8a10a89877" name="ad8ed4f376d87fe5a27188d8a10a89877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ed4f376d87fe5a27188d8a10a89877">&#9670;&#160;</a></span>getLowerBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; getLowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>iv</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the constant lower bound on an <span class="tt">iv</span>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00749">749</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02938">mlir::affine::getForInductionVarOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00798">getLowerBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00775">getUpperBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00925">simplifyMinOrMaxExprWithOperands()</a>.</p>

</div>
</div>
<a id="ad9265e0f14d0039506ec469afeba4af6" name="ad9265e0f14d0039506ec469afeba4af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9265e0f14d0039506ec469afeba4af6">&#9670;&#160;</a></span>getTrivialConstantTripCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; uint64_t &gt; getTrivialConstantTripCount </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns constant trip count in trivial cases. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02604">2604</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02614">AffineForEmptyLoopFolder()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02694">hasTrivialZeroTripCount()</a>.</p>

</div>
</div>
<a id="a75d1fbe4376d496fc50d1d10abd040a8" name="a75d1fbe4376d496fc50d1d10abd040a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d1fbe4376d496fc50d1d10abd040a8">&#9670;&#160;</a></span>getUpperBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; getUpperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numSymbols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine a constant upper bound for <span class="tt">expr</span> if one exists while exploiting values in <span class="tt">operands</span>. </p>
<p>Note that the upper bound is an inclusive one. <span class="tt">expr</span> is guaranteed to be less than or equal to it. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00775">775</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01641">mlir::getBoundForAffineExpr()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00749">getLowerBound()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00757">getUpperBound()</a>.</p>

</div>
</div>
<a id="a98e9ed6e4f1e37d487c2628f2e897b29" name="a98e9ed6e4f1e37d487c2628f2e897b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e9ed6e4f1e37d487c2628f2e897b29">&#9670;&#160;</a></span>getUpperBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; getUpperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>iv</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the constant upper bound on an affine.for <span class="tt">iv</span>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00757">757</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02938">mlir::affine::getForInductionVarOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00798">getLowerBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00775">getUpperBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00925">simplifyMinOrMaxExprWithOperands()</a>.</p>

</div>
</div>
<a id="a021d91d70aa35c1c72efff729a5d296a" name="a021d91d70aa35c1c72efff729a5d296a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021d91d70aa35c1c72efff729a5d296a">&#9670;&#160;</a></span>hasTrivialZeroTripCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> hasTrivialZeroTripCount </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the affine.for has zero iterations in trivial cases. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02694">2694</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02604">getTrivialConstantTripCount()</a>.</p>

</div>
</div>
<a id="abb7f0f42fc1a8809ab9d7ae95aac496a" name="abb7f0f42fc1a8809ab9d7ae95aac496a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7f0f42fc1a8809ab9d7ae95aac496a">&#9670;&#160;</a></span>isDimOpValidSymbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isDimOpValidSymbol </td>
          <td>(</td>
          <td class="paramtype">ShapedDimOpInterface</td>          <td class="paramname"><span class="paramname"><em>dimOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>region</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the result of the dim op is a valid symbol for <span class="tt">region</span>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00368">368</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00349">isMemRefSizeValidSymbol()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00250">mlir::affine::isTopLevelValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00457">mlir::affine::isValidSymbol()</a>.</p>

</div>
</div>
<a id="a6db62c4fe9a0af0edf33f735e7450913" name="a6db62c4fe9a0af0edf33f735e7450913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db62c4fe9a0af0edf33f735e7450913">&#9670;&#160;</a></span>isMemRefSizeValidSymbol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AnyMemRefDefOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isMemRefSizeValidSymbol </td>
          <td>(</td>
          <td class="paramtype">AnyMemRefDefOp</td>          <td class="paramname"><span class="paramname"><em>memrefDefOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>region</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the 'index' dimension of the <span class="tt">memref</span> defined by <span class="tt">memrefDefOp</span> is a statically shaped one or defined using a valid symbol for <span class="tt">region</span>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00349">349</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00368">isDimOpValidSymbol()</a>.</p>

</div>
</div>
<a id="a764b24362c096adadc31e0db757b0bbc" name="a764b24362c096adadc31e0db757b0bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764b24362c096adadc31e0db757b0bbc">&#9670;&#160;</a></span>isNonNegativeBoundedBy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isNonNegativeBoundedBy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <span class="tt">e</span> is known to be: 0 &lt;= <span class="tt">e</span> &lt; <span class="tt">k</span>. </p>
<p>Handles the simple cases of <span class="tt">e</span> being an affine dim expression or a constant. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00697">697</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02938">mlir::affine::getForInductionVarOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00725">isQTimesDPlusR()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>.</p>

</div>
</div>
<a id="ac607329b2b966b06fe88ec201119aea3" name="ac607329b2b966b06fe88ec201119aea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac607329b2b966b06fe88ec201119aea3">&#9670;&#160;</a></span>isQTimesDPlusR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isQTimesDPlusR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>div</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>quotientTimesDiv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rem</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if expression <span class="tt">e</span> is of the form d*e_1 + e_2 where 0 &lt;= e_2 &lt; d. </p>
<p>Set <span class="tt">div</span> to <span class="tt">d</span>, <span class="tt">quotientTimesDiv</span> to e_1 and <span class="tt">rem</span> to e_2 if the expression is in that form. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00725">725</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00041">mlir::Add</a>, <a class="el" href="XeGPUDialect_8cpp_source.html#l00964">div</a>, <a class="el" href="AffineOps_8cpp_source.html#l00659">getLargestKnownDivisor()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00697">isNonNegativeBoundedBy()</a>, and <a class="el" href="XeGPUDialect_8cpp_source.html#l00968">rem</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>.</p>

</div>
</div>
<a id="a0c0743e18871599ff8ff8e2d8659d4c2" name="a0c0743e18871599ff8ff8e2d8659d4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0743e18871599ff8ff8e2d8659d4c2">&#9670;&#160;</a></span>isResultTypeMatchAtomicRMWKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isResultTypeMatchAtomicRMWKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>resultType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arith::AtomicRMWKind</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l04230">4230</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

</div>
</div>
<a id="a2ac7dca41a4290b140937ea9a17c1861" name="a2ac7dca41a4290b140937ea9a17c1861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac7dca41a4290b140937ea9a17c1861">&#9670;&#160;</a></span>isTopLevelValueOrAbove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isTopLevelValueOrAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>region</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A utility function to check if a value is defined at the top level of <span class="tt">region</span> or is an argument of <span class="tt">region</span> or is defined above the region. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00432">432</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>, <a class="el" href="Value_8cpp_source.html#l00039">mlir::Value::getParentRegion()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00457">mlir::affine::isValidSymbol()</a>.</p>

</div>
</div>
<a id="a40425801875310c2151577ce17a33acd" name="a40425801875310c2151577ce17a33acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40425801875310c2151577ce17a33acd">&#9670;&#160;</a></span>isValidAffineIndexOperand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isValidAffineIndexOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>region</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00492">492</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00290">mlir::affine::isValidDim()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02012">mlir::affine::AffineDmaStartOp::verifyInvariantsImpl()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02148">mlir::affine::AffineDmaWaitOp::verifyInvariantsImpl()</a>.</p>

</div>
</div>
<a id="a93de5cae93c64100cbc920a9dc8e3dc6" name="a93de5cae93c64100cbc920a9dc8e3dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93de5cae93c64100cbc920a9dc8e3dc6">&#9670;&#160;</a></span>legalizeDemotedDims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapOrSet&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> legalizeDemotedDims </td>
          <td>(</td>
          <td class="paramtype">MapOrSet &amp;</td>          <td class="paramname"><span class="paramname"><em>mapOrSet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A valid affine dimension may appear as a symbol in affine.apply operations. </p>
<p>Given an application of <span class="tt">operands</span> to an affine map or integer set <span class="tt">mapOrSet</span>, this function canonicalizes symbols of <span class="tt">mapOrSet</span> that are valid dims, but not valid symbols into actual dims. Without such a legalization, the affine.apply will be invalid. This method is the exact inverse of canonicalizePromotedSymbols. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01636">1636</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>, <a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">mlir::getAffineSymbolExpr()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00290">mlir::affine::isValidDim()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01682">canonicalizeMapOrSetAndOperands()</a>.</p>

</div>
</div>
<a id="aaf870053b51991e5999a553ab45e4819" name="aaf870053b51991e5999a553ab45e4819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf870053b51991e5999a553ab45e4819">&#9670;&#160;</a></span>makeComposedFoldedMinMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> makeComposedFoldedMinMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01540">1540</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Matchers_8h_source.html#l00369">mlir::m_Constant()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01525">makeComposedMinMax()</a>, <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>, and <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01579">mlir::affine::makeComposedFoldedAffineMax()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01572">mlir::affine::makeComposedFoldedAffineMin()</a>.</p>

</div>
</div>
<a id="a97a6105410cad46cb66cca3f7efb4b00" name="a97a6105410cad46cb66cca3f7efb4b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a6105410cad46cb66cca3f7efb4b00">&#9670;&#160;</a></span>makeComposedMinMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpTy makeComposedMinMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01525">1525</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="AffineOps_8cpp_source.html#l01439">composeMultiResultAffineMap()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00738">mlir::foldAttributesIntoMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01534">mlir::affine::makeComposedAffineMin()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01540">makeComposedFoldedMinMax()</a>.</p>

</div>
</div>
<a id="a6b90328357d17ae6c877a3e306f88360" name="a6b90328357d17ae6c877a3e306f88360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b90328357d17ae6c877a3e306f88360">&#9670;&#160;</a></span>parseAffineMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult parseAffineMinMaxOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03610">3610</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="OpImplementation_8h_source.html#l01382">mlir::AsmParser::addTypeToList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a1d400e969b4479eec3faf8f272c99f44">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00051">mlir::Builder::getIndexType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00826">mlir::AsmParser::OptionalSquare</a>, <a class="el" href="OpImplementation_8h_source.html#l00816">mlir::AsmParser::Paren</a>, <a class="el" href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#af16d3e3ef46bd2bd45b4e8db657c221a">mlir::OpAsmParser::parseOperandList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf4b8149e630797ac1ac90d8e118c4b">mlir::AsmParser::parseOptionalAttrDict()</a>, <a class="el" href="OpImplementation_8h_source.html#l01634">mlir::OpAsmParser::resolveOperands()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="a4de10d06704729af9438e5f4ae91bdec" name="a4de10d06704729af9438e5f4ae91bdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de10d06704729af9438e5f4ae91bdec">&#9670;&#160;</a></span>parseBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult parseBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isLower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a for operation loop bounds. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02293">2293</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a1d400e969b4479eec3faf8f272c99f44">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00378">mlir::Builder::getConstantAffineMap()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a7850fe0a2961f835384adb372758d58b">mlir::AsmParser::getCurrentLocation()</a>, <a class="el" href="Builders_8cpp_source.html#l00051">mlir::Builder::getIndexType()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, <a class="el" href="Builders_8cpp_source.html#l00396">mlir::Builder::getSymbolIdentityMap()</a>, <a class="el" href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00507">mlir::affine::parseDimAndSymbolList()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#af16d3e3ef46bd2bd45b4e8db657c221a">mlir::OpAsmParser::parseOperandList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a305f6334c61eb92a164bd865851f55f4">mlir::AsmParser::parseOptionalKeyword()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a8c583b0d425ac93c7f8a867f5546db6a">mlir::OpAsmParser::resolveOperand()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a0bc66ae957af7e80fc8e9101d997a109" name="a0bc66ae957af7e80fc8e9101d997a109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc66ae957af7e80fc8e9101d997a109">&#9670;&#160;</a></span>printAffineMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> printAffineMinMaxOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03597">3597</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#a681280bde1406e824e1d4626fe257e1b">mlir::OpAsmPrinter::printOptionalAttrDict()</a>.</p>

</div>
</div>
<a id="ae2978fd47e940232657b5ae684d7ccce" name="ae2978fd47e940232657b5ae684d7ccce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2978fd47e940232657b5ae684d7ccce">&#9670;&#160;</a></span>printBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> printBound </td>
          <td>(</td>
          <td class="paramtype">AffineMapAttr</td>          <td class="paramname"><span class="paramname"><em>boundMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a></td>          <td class="paramname"><span class="paramname"><em>boundOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02468">2468</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00497">printDimAndSymbolList()</a>, and <a class="el" href="classmlir_1_1OpAsmPrinter.html#acddd5eb143c94fa8528920c75799e3ba">mlir::OpAsmPrinter::printOperand()</a>.</p>

</div>
</div>
<a id="a909b810a734e0872e03164db8d7fa7f8" name="a909b810a734e0872e03164db8d7fa7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909b810a734e0872e03164db8d7fa7f8">&#9670;&#160;</a></span>printDimAndSymbolList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> printDimAndSymbolList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>printer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints dimension and symbol list. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00497">497</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02468">printBound()</a>.</p>

</div>
</div>
<a id="a0fef8d134535c158ca70408a89d5f54e" name="a0fef8d134535c158ca70408a89d5f54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fef8d134535c158ca70408a89d5f54e">&#9670;&#160;</a></span>printMinMaxBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> printMinMaxBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineMapAttr</td>          <td class="paramname"><span class="paramname"><em>mapAttr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a></td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>keyword</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a lower(upper) bound of an affine parallel loop with max(min) conditions in it. </p>
<p><span class="tt">mapAttr</span> is a flat list of affine expressions and <span class="tt">group</span> identifies which of the those expressions form max/min groups. <span class="tt">operands</span> are the SSA values of dimensions and symbols and <span class="tt">keyword</span> is either "min" or "max". </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l04377">4377</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00655">mlir::AffineMap::getSliceMap()</a>, <a class="el" href="classmlir_1_1OpAsmPrinter.html#a92e834f0b1924f751616f89def818263">mlir::OpAsmPrinter::printAffineExprOfSSAIds()</a>, and <a class="el" href="classmlir_1_1OpAsmPrinter.html#aa04de9fec0531cddf28646b119a770af">mlir::OpAsmPrinter::printAffineMapOfSSAIds()</a>.</p>

</div>
</div>
<a id="a403f2f69de4c2a980fe6265cb311c94b" name="a403f2f69de4c2a980fe6265cb311c94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403f2f69de4c2a980fe6265cb311c94b">&#9670;&#160;</a></span>remainsLegalAfterInline() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> remainsLegalAfterInline </td>
          <td>(</td>
          <td class="paramtype">AffineApplyOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mapping</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an affine apply operation remains legal after inlining from <span class="tt">src</span> to <span class="tt">dest</span>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00128">128</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00290">mlir::affine::isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00062">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="ae826612e07e64373b1612baac8fb6819" name="ae826612e07e64373b1612baac8fb6819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae826612e07e64373b1612baac8fb6819">&#9670;&#160;</a></span>remainsLegalAfterInline() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> remainsLegalAfterInline </td>
          <td>(</td>
          <td class="paramtype">OpTy</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mapping</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an affine read or write operation remains legal after inlining from <span class="tt">src</span> to <span class="tt">dest</span>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00102">102</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00290">mlir::affine::isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00062">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="a0d3be33f83c44ec2bd88e94fff40fd18" name="a0d3be33f83c44ec2bd88e94fff40fd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3be33f83c44ec2bd88e94fff40fd18">&#9670;&#160;</a></span>remainsLegalAfterInline() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> remainsLegalAfterInline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>legalityCheck</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <span class="tt">value</span> known to be a legal affine dimension or symbol in <span class="tt">src</span> region remains legal if the operation that uses it is inlined into <span class="tt">dest</span> with the given value mapping. </p>
<p><span class="tt">legalityCheck</span> is either <span class="tt">isValidDim</span> or <span class="tt">isValidSymbol</span>, depending on the value being required to remain a valid dimension or symbol. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00062">62</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00250">mlir::affine::isTopLevelValue()</a>, <a class="el" href="IRMapping_8h_source.html#l00072">mlir::IRMapping::lookup()</a>, <a class="el" href="Matchers_8h_source.html#l00369">mlir::m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00128">remainsLegalAfterInline()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00102">remainsLegalAfterInline()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00091">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="ae3a9b3c718db4723ffe1fb5538ea0ead" name="ae3a9b3c718db4723ffe1fb5538ea0ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a9b3c718db4723ffe1fb5538ea0ead">&#9670;&#160;</a></span>remainsLegalAfterInline() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> remainsLegalAfterInline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mapping</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>legalityCheck</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if all values known to be legal affine dimensions or symbols in <span class="tt">src</span> remain so if their respective users are inlined into <span class="tt">dest</span>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00091">91</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00062">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="a6cf33457ed6729b5821f85f2392f6a50" name="a6cf33457ed6729b5821f85f2392f6a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf33457ed6729b5821f85f2392f6a50">&#9670;&#160;</a></span>replaceAffineDelinearizeIndexInverseExpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult replaceAffineDelinearizeIndexInverseExpression </td>
          <td>(</td>
          <td class="paramtype">AffineDelinearizeIndexOp</td>          <td class="paramname"><span class="paramname"><em>delinOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>resultToReplace</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>syms</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this map contains of the expression <span class="tt">x_1 + x_1 * C_1 + ... x_n * C_N +
/ ...</span> (not necessarily in order) where the set of the <span class="tt">x_i</span> is the set of outputs of an <span class="tt">affine.delinearize_index</span> whos inverse is that expression, replace that expression with the input of that delinearize_index op. </p>
<p><span class="tt">unitDimInput</span> is the input that was detected as the potential start to this replacement chain - if it isn't the rightmost result of the delinearization, this method fails. (This is intended to ensure we don't have redundant scans over the same expression).</p>
<p>While this currently only handles delinearizations with a constant basis, that isn't a fundamental limitation.</p>
<p>This is a utility function for <span class="tt">replaceDimOrSym</span> below. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01190">1190</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>, <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>, <a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">mlir::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00221">mlir::AffineMap::isFunctionOfDim()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00228">mlir::AffineMap::isFunctionOfSymbol()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00511">mlir::AffineMap::replace()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01133">shortenAddChainsContainingAll()</a>, and <a class="el" href="#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01275">replaceDimOrSym()</a>.</p>

</div>
</div>
<a id="aa41cad291d738e5a50788d88be46a771" name="aa41cad291d738e5a50788d88be46a771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41cad291d738e5a50788d88be46a771">&#9670;&#160;</a></span>replaceAffineMinBoundingBoxExpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult replaceAffineMinBoundingBoxExpression </td>
          <td>(</td>
          <td class="paramtype">AffineMinOp</td>          <td class="paramname"><span class="paramname"><em>minOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>dimOrSym</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>syms</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming <span class="tt">dimOrSym</span> is a quantity in the apply op map <span class="tt">map</span> and defined by <span class="tt">minOp = affine_min(x_1, ..., x_n)</span>. </p>
<p>This function checks that: <span class="tt">0 &lt; affine_min(x_1, ..., x_n)</span> and proceeds with replacing the patterns: </p><div class="fragment"><div class="line">dimOrSym.ceildiv(x_k)</div>
<div class="line">(dimOrSym + x_k - 1).floordiv(x_k)</div>
</div><!-- fragment --><p> by <span class="tt">1</span> for all <span class="tt">k</span> in <span class="tt">1, ..., n</span>. This is possible because <span class="tt">x / x_k &lt;= 1</span>.</p>
<p>Warning: <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#af6b8630d15364bb4102964d6e16a5e13" title="Compute a constant bound for the given variable.">ValueBoundsConstraintSet::computeConstantBound</a> is needed to check <span class="tt">minOp</span> is positive. </p>
<p>Convert affine symbols and dimensions in minOp to symbols or dimensions in the apply op affine map.</p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01061">1061</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01006">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00782">mlir::ValueBoundsConstraintSet::compare()</a>, <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>, <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>, <a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">mlir::getAffineSymbolExpr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00106">mlir::getAsIndexOpFoldResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00655">mlir::AffineMap::getSliceMap()</a>, <a class="el" href="ValueBoundsOpInterface_8h_source.html#l00239">mlir::ValueBoundsConstraintSet::LT</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00179">mlir::AffineExpr::replace()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00511">mlir::AffineMap::replace()</a>, and <a class="el" href="#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01275">replaceDimOrSym()</a>.</p>

</div>
</div>
<a id="ad80a73e1cfd4840702a6f60c34d37202" name="ad80a73e1cfd4840702a6f60c34d37202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80a73e1cfd4840702a6f60c34d37202">&#9670;&#160;</a></span>replaceDimOrSym()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult replaceDimOrSym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dimOrSymbolPosition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>syms</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>replaceAffineMin</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace all occurrences of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> at position <span class="tt">pos</span> in <span class="tt">map</span> by the defining AffineApplyOp expression and operands. </p>
<p>When <span class="tt">dimOrSymbolPosition &lt; dims.size()</span>, <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a>@[pos] is replaced. When <span class="tt">dimOrSymbolPosition &gt;= dims.size()</span>, <a class="el" href="classmlir_1_1AffineSymbolExpr.html" title="A symbolic identifier appearing in an affine expression.">AffineSymbolExpr</a>@[pos - dims.size()] is replaced. Mutate <span class="tt">map</span>,<span class="tt">dims</span> and <span class="tt">syms</span> in place as follows:</p><ol type="1">
<li><span class="tt">dims</span> and <span class="tt">syms</span> are only appended to.</li>
<li><span class="tt">map</span> dim and symbols are gradually shifted to higher positions.</li>
<li>Old <span class="tt">dim</span> and <span class="tt">sym</span> entries are replaced by nullptr This avoids the need for any bookkeeping. If <span class="tt">replaceAffineMin</span> is set to true, additionally triggers more expensive replacements involving affine_min operations. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01275">1275</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01759">mlir::affine::canonicalizeMapAndOperands()</a>, <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>, <a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">mlir::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00511">mlir::AffineMap::replace()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01190">replaceAffineDelinearizeIndexInverseExpression()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01061">replaceAffineMinBoundingBoxExpression()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00267">mlir::AffineMap::shiftDims()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00280">mlir::AffineMap::shiftSymbols()</a>, and <a class="el" href="#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>.</p>

</div>
</div>
<a id="aeb6dd004d59edf13c5d01cc8b429f414" name="aeb6dd004d59edf13c5d01cc8b429f414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6dd004d59edf13c5d01cc8b429f414">&#9670;&#160;</a></span>shortenAddChainsContainingAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> shortenAddChainsContainingAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallDenseSet&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>exprsToRemove</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>newVal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>replacementsMap</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively traverse <span class="tt">e</span>. </p>
<p>If <span class="tt">e</span> or one of its sub-expressions has the form e1 + e2 + ... + eK, where the e_i are a super(multi)set of <span class="tt">exprsToRemove</span>, place a map between e and <span class="tt">newVal</span> + sum({e1, e2, .. eK} - exprsToRemove) into <span class="tt">replacementsMap</span>. If no entries were added to <span class="tt">replacementsMap</span>, nothing was found. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01133">1133</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00041">mlir::Add</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01133">shortenAddChainsContainingAll()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01190">replaceAffineDelinearizeIndexInverseExpression()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01133">shortenAddChainsContainingAll()</a>.</p>

</div>
</div>
<a id="a3816c76427483b6523a3d129753e4715" name="a3816c76427483b6523a3d129753e4715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3816c76427483b6523a3d129753e4715">&#9670;&#160;</a></span>simplifyExprAndOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> simplifyExprAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numSymbols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplify <span class="tt">expr</span> while exploiting information from the values in <span class="tt">operands</span>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00822">822</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00050">mlir::CeilDiv</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00048">mlir::FloorDiv</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00959">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00068">mlir::getAffineBinaryOpExpr()</a>, <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00031">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00033">mlir::AffineExpr::getKind()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00659">getLargestKnownDivisor()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00749">getLowerBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00757">getUpperBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00697">isNonNegativeBoundedBy()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00725">isQTimesDPlusR()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00046">mlir::Mod</a>, <a class="el" href="XeGPUDialect_8cpp_source.html#l00968">rem</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01035">simplifyMapWithOperands()</a>.</p>

</div>
</div>
<a id="a87764ebcc2accde4c56f10872a823e72" name="a87764ebcc2accde4c56f10872a823e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87764ebcc2accde4c56f10872a823e72">&#9670;&#160;</a></span>simplifyMapWithOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> simplifyMapWithOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplify the map while exploiting information on the values in <span class="tt">operands</span>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01035">1035</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>.</p>

</div>
</div>
<a id="a68ad81c63548091cb2fbc65b7d0136d5" name="a68ad81c63548091cb2fbc65b7d0136d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ad81c63548091cb2fbc65b7d0136d5">&#9670;&#160;</a></span>simplifyMinOrMaxExprWithOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> simplifyMinOrMaxExprWithOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isMax</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplify the expressions in <span class="tt">map</span> while making use of lower or upper bounds of its operands. </p>
<p>If <span class="tt">isMax</span> is true, the map is to be treated as a max of its result expressions, and min otherwise. Eg: min (d0, d1) -&gt; (8, 4 * d0 + d1) can be simplified to (8) if the operands are respectively lower bounded by 2 and 0 (the second expression can't be lower than 8). </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00925">925</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01641">mlir::getBoundForAffineExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00031">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00749">getLowerBound()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00757">getUpperBound()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02663">canonicalizeLoopBounds()</a>.</p>

</div>
</div>
<a id="aa2afc59a21f80839c29f2812f75c36a4" name="aa2afc59a21f80839c29f2812f75c36a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2afc59a21f80839c29f2812f75c36a4">&#9670;&#160;</a></span>success()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return success </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01190">replaceAffineDelinearizeIndexInverseExpression()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01061">replaceAffineMinBoundingBoxExpression()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01275">replaceDimOrSym()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00529">verifyDimAndSymbolIdentifiers()</a>.</p>

</div>
</div>
<a id="ae0fa7df47a2dd4686dfd19868542977a" name="ae0fa7df47a2dd4686dfd19868542977a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0fa7df47a2dd4686dfd19868542977a">&#9670;&#160;</a></span>verifyAffineMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult verifyAffineMinMaxOp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03584">3584</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="aaf19ea7311ad162852c482c8523b7120" name="aaf19ea7311ad162852c482c8523b7120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf19ea7311ad162852c482c8523b7120">&#9670;&#160;</a></span>verifyDimAndSymbolIdentifiers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult verifyDimAndSymbolIdentifiers </td>
          <td>(</td>
          <td class="paramtype">OpTy &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a></td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numDims</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to verify that a set of operands are valid dimension and symbol identifiers. </p>
<p>The operands should be laid out such that the dimension operands are before the symbol operands. This function returns failure if there was an invalid operand. An operation is provided to emit any necessary errors. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00529">529</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00265">mlir::affine::getAffineScope()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00290">mlir::affine::isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>, and <a class="el" href="#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l03419">verifyMemoryOpIndexing()</a>.</p>

</div>
</div>
<a id="a0ad5dc7b7e393187c5b9ae0d51786ab6" name="a0ad5dc7b7e393187c5b9ae0d51786ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad5dc7b7e393187c5b9ae0d51786ab6">&#9670;&#160;</a></span>verifyMemoryOpIndexing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AffineMemOpTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult verifyMemoryOpIndexing </td>
          <td>(</td>
          <td class="paramtype">AffineMemOpTy</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineMapAttr</td>          <td class="paramname"><span class="paramname"><em>mapAttr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a></td>          <td class="paramname"><span class="paramname"><em>mapOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>memrefType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numIndexOperands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify common indexing invariants of affine.load, affine.store, affine.vector_load and affine.vector_store. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03419">3419</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00529">verifyDimAndSymbolIdentifiers()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
