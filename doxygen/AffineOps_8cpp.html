<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Affine/IR/AffineOps.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_30022079959872f4a1874dfcab7bb1fc.html">Affine</a></li><li class="navelem"><a class="el" href="dir_253b99abdc8fa8576ac945bee537f5fd.html">IR</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">AffineOps.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineValueMap_8h_source.html">mlir/Dialect/Affine/IR/AffineValueMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2MemRef_2IR_2MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="UBOps_8h_source.html">mlir/Dialect/UB/IR/UBOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StaticValueUtils_8h_source.html">mlir/Dialect/Utils/StaticValueUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">mlir/IR/AffineExpr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineExprVisitor_8h_source.html">mlir/IR/AffineExprVisitor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IRMapping_8h_source.html">mlir/IR/IRMapping.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2IntegerSet_8h_source.html">mlir/IR/IntegerSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Matchers_8h_source.html">mlir/IR/Matchers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OpDefinition_8h_source.html">mlir/IR/OpDefinition.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Value_8h_source.html">mlir/IR/Value.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ShapedOpInterfaces_8h_source.html">mlir/Interfaces/ShapedOpInterfaces.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ValueBoundsOpInterface_8h_source.html">mlir/Interfaces/ValueBoundsOpInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InliningUtils_8h_source.html">mlir/Transforms/InliningUtils.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallBitVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallVectorExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/TypeSwitch.h&quot;</code><br />
<code>#include &quot;llvm/Support/DebugLog.h&quot;</code><br />
<code>#include &quot;llvm/Support/LogicalResult.h&quot;</code><br />
<code>#include &quot;llvm/Support/MathExtras.h&quot;</code><br />
<code>#include &lt;numeric&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &quot;mlir/Dialect/Affine/IR/AffineOpsDialect.cpp.inc&quot;</code><br />
<code>#include &quot;mlir/Dialect/Affine/IR/AffineOps.cpp.inc&quot;</code><br />
</div>
<p><a href="AffineOps_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDeduplicateAffineMinMaxExpressions.html">DeduplicateAffineMinMaxExpressions&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicated expressions in affine min/max ops.  <a href="structDeduplicateAffineMinMaxExpressions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMergeAffineMinMaxOp.html">MergeAffineMinMaxOp&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge an affine min/max op to its consumers if its consumer is also an affine min/max op.  <a href="structMergeAffineMinMaxOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCanonicalizeAffineMinMaxOpExprAndTermOrder.html">CanonicalizeAffineMinMaxOpExprAndTermOrder&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize the affine map result expression order of an affine min/max operation.  <a href="structCanonicalizeAffineMinMaxOpExprAndTermOrder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCanonicalizeSingleResultAffineMinMaxOp.html">CanonicalizeSingleResultAffineMinMaxOp&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;affine-ops&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4eeb99d83d4a53327f3c7a9574ad6f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#aeb4eeb99d83d4a53327f3c7a9574ad6f">GET_OP_LIST</a></td></tr>
<tr class="separator:aeb4eeb99d83d4a53327f3c7a9574ad6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c883a38e577b8b12282ff70c95a16d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a52c883a38e577b8b12282ff70c95a16d">GET_OP_CLASSES</a></td></tr>
<tr class="separator:a52c883a38e577b8b12282ff70c95a16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0d3be33f83c44ec2bd88e94fff40fd18"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a0d3be33f83c44ec2bd88e94fff40fd18">remainsLegalAfterInline</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Region.html">Region</a> *dest, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapping, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; legalityCheck)</td></tr>
<tr class="memdesc:a0d3be33f83c44ec2bd88e94fff40fd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>value</code> known to be a legal affine dimension or symbol in <code>src</code> region remains legal if the operation that uses it is inlined into <code>dest</code> with the given value mapping.  <a href="AffineOps_8cpp.html#a0d3be33f83c44ec2bd88e94fff40fd18">More...</a><br /></td></tr>
<tr class="separator:a0d3be33f83c44ec2bd88e94fff40fd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a9b3c718db4723ffe1fb5538ea0ead"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#ae3a9b3c718db4723ffe1fb5538ea0ead">remainsLegalAfterInline</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Region.html">Region</a> *dest, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapping, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt; legalityCheck)</td></tr>
<tr class="memdesc:ae3a9b3c718db4723ffe1fb5538ea0ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all values known to be legal affine dimensions or symbols in <code>src</code> remain so if their respective users are inlined into <code>dest</code>.  <a href="AffineOps_8cpp.html#ae3a9b3c718db4723ffe1fb5538ea0ead">More...</a><br /></td></tr>
<tr class="separator:ae3a9b3c718db4723ffe1fb5538ea0ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae826612e07e64373b1612baac8fb6819"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:ae826612e07e64373b1612baac8fb6819"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#ae826612e07e64373b1612baac8fb6819">remainsLegalAfterInline</a> (OpTy op, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Region.html">Region</a> *dest, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapping)</td></tr>
<tr class="memdesc:ae826612e07e64373b1612baac8fb6819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an affine read or write operation remains legal after inlining from <code>src</code> to <code>dest</code>.  <a href="AffineOps_8cpp.html#ae826612e07e64373b1612baac8fb6819">More...</a><br /></td></tr>
<tr class="separator:ae826612e07e64373b1612baac8fb6819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2a967a96c1bc19f73af2077b9ab5c1"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3c2a967a96c1bc19f73af2077b9ab5c1"><td class="memTemplItemLeft" align="right" valign="top">bool LLVM_ATTRIBUTE_UNUSED&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a3c2a967a96c1bc19f73af2077b9ab5c1">remainsLegalAfterInline</a> (AffineApplyOp op, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Region.html">Region</a> *dest, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;mapping)</td></tr>
<tr class="memdesc:a3c2a967a96c1bc19f73af2077b9ab5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an affine apply operation remains legal after inlining from <code>src</code> to <code>dest</code>.  <a href="AffineOps_8cpp.html#a3c2a967a96c1bc19f73af2077b9ab5c1">More...</a><br /></td></tr>
<tr class="separator:a3c2a967a96c1bc19f73af2077b9ab5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db62c4fe9a0af0edf33f735e7450913"><td class="memTemplParams" colspan="2">template&lt;typename AnyMemRefDefOp &gt; </td></tr>
<tr class="memitem:a6db62c4fe9a0af0edf33f735e7450913"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a6db62c4fe9a0af0edf33f735e7450913">isMemRefSizeValidSymbol</a> (AnyMemRefDefOp memrefDefOp, unsigned index, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:a6db62c4fe9a0af0edf33f735e7450913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the 'index' dimension of the <code>memref</code> defined by <code>memrefDefOp</code> is a statically shaped one or defined using a valid symbol for <code>region</code>.  <a href="AffineOps_8cpp.html#a6db62c4fe9a0af0edf33f735e7450913">More...</a><br /></td></tr>
<tr class="separator:a6db62c4fe9a0af0edf33f735e7450913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7f0f42fc1a8809ab9d7ae95aac496a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#abb7f0f42fc1a8809ab9d7ae95aac496a">isDimOpValidSymbol</a> (ShapedDimOpInterface dimOp, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:abb7f0f42fc1a8809ab9d7ae95aac496a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the result of the dim op is a valid symbol for <code>region</code>.  <a href="AffineOps_8cpp.html#abb7f0f42fc1a8809ab9d7ae95aac496a">More...</a><br /></td></tr>
<tr class="separator:abb7f0f42fc1a8809ab9d7ae95aac496a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac7dca41a4290b140937ea9a17c1861"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a2ac7dca41a4290b140937ea9a17c1861">isTopLevelValueOrAbove</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:a2ac7dca41a4290b140937ea9a17c1861"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to check if a value is defined at the top level of <code>region</code> or is an argument of <code>region</code> or is defined above the region.  <a href="AffineOps_8cpp.html#a2ac7dca41a4290b140937ea9a17c1861">More...</a><br /></td></tr>
<tr class="separator:a2ac7dca41a4290b140937ea9a17c1861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40425801875310c2151577ce17a33acd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a40425801875310c2151577ce17a33acd">isValidAffineIndexOperand</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="separator:a40425801875310c2151577ce17a33acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909b810a734e0872e03164db8d7fa7f8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a909b810a734e0872e03164db8d7fa7f8">printDimAndSymbolList</a> (<a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a> begin, <a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a> end, unsigned numDims, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer)</td></tr>
<tr class="memdesc:a909b810a734e0872e03164db8d7fa7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints dimension and symbol list.  <a href="AffineOps_8cpp.html#a909b810a734e0872e03164db8d7fa7f8">More...</a><br /></td></tr>
<tr class="separator:a909b810a734e0872e03164db8d7fa7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf19ea7311ad162852c482c8523b7120"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:aaf19ea7311ad162852c482c8523b7120"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#aaf19ea7311ad162852c482c8523b7120">verifyDimAndSymbolIdentifiers</a> (OpTy &amp;op, <a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a> operands, unsigned numDims)</td></tr>
<tr class="memdesc:aaf19ea7311ad162852c482c8523b7120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to verify that a set of operands are valid dimension and symbol identifiers.  <a href="AffineOps_8cpp.html#aaf19ea7311ad162852c482c8523b7120">More...</a><br /></td></tr>
<tr class="separator:aaf19ea7311ad162852c482c8523b7120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9113c24d7d445c3728e0d7945c064421"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a9113c24d7d445c3728e0d7945c064421">getLargestKnownDivisor</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> e, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:a9113c24d7d445c3728e0d7945c064421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest known divisor of <code>e</code>.  <a href="AffineOps_8cpp.html#a9113c24d7d445c3728e0d7945c064421">More...</a><br /></td></tr>
<tr class="separator:a9113c24d7d445c3728e0d7945c064421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764b24362c096adadc31e0db757b0bbc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a764b24362c096adadc31e0db757b0bbc">isNonNegativeBoundedBy</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> e, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, int64_t k)</td></tr>
<tr class="memdesc:a764b24362c096adadc31e0db757b0bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>e</code> is known to be: 0 &lt;= <code>e</code> &lt; <code>k</code>.  <a href="AffineOps_8cpp.html#a764b24362c096adadc31e0db757b0bbc">More...</a><br /></td></tr>
<tr class="separator:a764b24362c096adadc31e0db757b0bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac607329b2b966b06fe88ec201119aea3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#ac607329b2b966b06fe88ec201119aea3">isQTimesDPlusR</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> e, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, int64_t &amp;div, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;quotientTimesDiv, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;rem)</td></tr>
<tr class="memdesc:ac607329b2b966b06fe88ec201119aea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if expression <code>e</code> is of the form d*e_1 + e_2 where 0 &lt;= e_2 &lt; d.  <a href="AffineOps_8cpp.html#ac607329b2b966b06fe88ec201119aea3">More...</a><br /></td></tr>
<tr class="separator:ac607329b2b966b06fe88ec201119aea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de441801e41781cbf59fcdc9179aae0"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a4de441801e41781cbf59fcdc9179aae0">getLowerBound</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> iv)</td></tr>
<tr class="memdesc:a4de441801e41781cbf59fcdc9179aae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the constant lower bound on an <code>iv</code>.  <a href="AffineOps_8cpp.html#a4de441801e41781cbf59fcdc9179aae0">More...</a><br /></td></tr>
<tr class="separator:a4de441801e41781cbf59fcdc9179aae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d64763cb25e2dc784e9d2de026decea"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a4d64763cb25e2dc784e9d2de026decea">getUpperBound</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> iv)</td></tr>
<tr class="memdesc:a4d64763cb25e2dc784e9d2de026decea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the constant upper bound on an affine.for <code>iv</code>.  <a href="AffineOps_8cpp.html#a4d64763cb25e2dc784e9d2de026decea">More...</a><br /></td></tr>
<tr class="separator:a4d64763cb25e2dc784e9d2de026decea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa379911bb6c00b0120f54f67bff7b7b3"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#aa379911bb6c00b0120f54f67bff7b7b3">getUpperBound</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, unsigned numDims, unsigned numSymbols, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:aa379911bb6c00b0120f54f67bff7b7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine a constant upper bound for <code>expr</code> if one exists while exploiting values in <code>operands</code>.  <a href="AffineOps_8cpp.html#aa379911bb6c00b0120f54f67bff7b7b3">More...</a><br /></td></tr>
<tr class="separator:aa379911bb6c00b0120f54f67bff7b7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c2a14fa757c0d7181e4fab47050731"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#aa3c2a14fa757c0d7181e4fab47050731">getLowerBound</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, unsigned numDims, unsigned numSymbols, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:aa3c2a14fa757c0d7181e4fab47050731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine a constant lower bound for <code>expr</code> if one exists while exploiting values in <code>operands</code>.  <a href="AffineOps_8cpp.html#aa3c2a14fa757c0d7181e4fab47050731">More...</a><br /></td></tr>
<tr class="separator:aa3c2a14fa757c0d7181e4fab47050731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3816c76427483b6523a3d129753e4715"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a3816c76427483b6523a3d129753e4715">simplifyExprAndOperands</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;expr, unsigned numDims, unsigned numSymbols, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:a3816c76427483b6523a3d129753e4715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify <code>expr</code> while exploiting information from the values in <code>operands</code>.  <a href="AffineOps_8cpp.html#a3816c76427483b6523a3d129753e4715">More...</a><br /></td></tr>
<tr class="separator:a3816c76427483b6523a3d129753e4715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ad81c63548091cb2fbc65b7d0136d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a68ad81c63548091cb2fbc65b7d0136d5">simplifyMinOrMaxExprWithOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, bool isMax)</td></tr>
<tr class="memdesc:a68ad81c63548091cb2fbc65b7d0136d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the expressions in <code>map</code> while making use of lower or upper bounds of its operands.  <a href="AffineOps_8cpp.html#a68ad81c63548091cb2fbc65b7d0136d5">More...</a><br /></td></tr>
<tr class="separator:a68ad81c63548091cb2fbc65b7d0136d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c002a789228f4f6ca08ecf5d775ef3"><td class="memItemLeft" align="right" valign="top">static void LLVM_ATTRIBUTE_UNUSED&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a15c002a789228f4f6ca08ecf5d775ef3">simplifyMapWithOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:a15c002a789228f4f6ca08ecf5d775ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the map while exploiting information on the values in <code>operands</code>.  <a href="AffineOps_8cpp.html#a15c002a789228f4f6ca08ecf5d775ef3">More...</a><br /></td></tr>
<tr class="separator:a15c002a789228f4f6ca08ecf5d775ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41cad291d738e5a50788d88be46a771"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#aa41cad291d738e5a50788d88be46a771">replaceAffineMinBoundingBoxExpression</a> (AffineMinOp minOp, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> dimOrSym, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dims, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> syms)</td></tr>
<tr class="memdesc:aa41cad291d738e5a50788d88be46a771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming <code>dimOrSym</code> is a quantity in the apply op map <code>map</code> and defined by <code>minOp = affine_min(x_1, ..., x_n)</code>.  <a href="AffineOps_8cpp.html#aa41cad291d738e5a50788d88be46a771">More...</a><br /></td></tr>
<tr class="separator:aa41cad291d738e5a50788d88be46a771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80a73e1cfd4840702a6f60c34d37202"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#ad80a73e1cfd4840702a6f60c34d37202">replaceDimOrSym</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, unsigned dimOrSymbolPosition, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dims, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;syms, bool replaceAffineMin)</td></tr>
<tr class="memdesc:ad80a73e1cfd4840702a6f60c34d37202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of AffineExpr at position <code>pos</code> in <code>map</code> by the defining AffineApplyOp expression and operands.  <a href="AffineOps_8cpp.html#ad80a73e1cfd4840702a6f60c34d37202">More...</a><br /></td></tr>
<tr class="separator:ad80a73e1cfd4840702a6f60c34d37202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92322a2a849cf48212dc80aae89615e1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a92322a2a849cf48212dc80aae89615e1">composeAffineMapAndOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands, bool composeAffineMin=false)</td></tr>
<tr class="memdesc:a92322a2a849cf48212dc80aae89615e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over <code>operands</code> and fold away all those produced by an AffineApplyOp iteratively.  <a href="AffineOps_8cpp.html#a92322a2a849cf48212dc80aae89615e1">More...</a><br /></td></tr>
<tr class="separator:a92322a2a849cf48212dc80aae89615e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d09bbb1d05d79cd31ad13d4797a2ab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#af3d09bbb1d05d79cd31ad13d4797a2ab">composeMultiResultAffineMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands, bool composeAffineMin=false)</td></tr>
<tr class="memdesc:af3d09bbb1d05d79cd31ad13d4797a2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes the given affine map with the given list of operands, pulling in the maps from any affine.apply operations that supply the operands.  <a href="AffineOps_8cpp.html#af3d09bbb1d05d79cd31ad13d4797a2ab">More...</a><br /></td></tr>
<tr class="separator:af3d09bbb1d05d79cd31ad13d4797a2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a6105410cad46cb66cca3f7efb4b00"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:a97a6105410cad46cb66cca3f7efb4b00"><td class="memTemplItemLeft" align="right" valign="top">static OpTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a97a6105410cad46cb66cca3f7efb4b00">makeComposedMinMax</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands)</td></tr>
<tr class="separator:a97a6105410cad46cb66cca3f7efb4b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf870053b51991e5999a553ab45e4819"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:aaf870053b51991e5999a553ab45e4819"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#aaf870053b51991e5999a553ab45e4819">makeComposedFoldedMinMax</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands)</td></tr>
<tr class="separator:aaf870053b51991e5999a553ab45e4819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622cab33387384a309422bb2c690772f"><td class="memTemplParams" colspan="2">template&lt;class MapOrSet &gt; </td></tr>
<tr class="memitem:a622cab33387384a309422bb2c690772f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a622cab33387384a309422bb2c690772f">canonicalizePromotedSymbols</a> (MapOrSet *mapOrSet, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="separator:a622cab33387384a309422bb2c690772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93de5cae93c64100cbc920a9dc8e3dc6"><td class="memTemplParams" colspan="2">template&lt;class MapOrSet &gt; </td></tr>
<tr class="memitem:a93de5cae93c64100cbc920a9dc8e3dc6"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a93de5cae93c64100cbc920a9dc8e3dc6">legalizeDemotedDims</a> (MapOrSet &amp;mapOrSet, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands)</td></tr>
<tr class="memdesc:a93de5cae93c64100cbc920a9dc8e3dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A valid affine dimension may appear as a symbol in affine.apply operations.  <a href="AffineOps_8cpp.html#a93de5cae93c64100cbc920a9dc8e3dc6">More...</a><br /></td></tr>
<tr class="separator:a93de5cae93c64100cbc920a9dc8e3dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a13ffbd2aefb7089f0b7a1e5411b11"><td class="memTemplParams" colspan="2">template&lt;class MapOrSet &gt; </td></tr>
<tr class="memitem:a43a13ffbd2aefb7089f0b7a1e5411b11"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a43a13ffbd2aefb7089f0b7a1e5411b11">canonicalizeMapOrSetAndOperands</a> (MapOrSet *mapOrSet, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="separator:a43a13ffbd2aefb7089f0b7a1e5411b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de10d06704729af9438e5f4ae91bdec"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a4de10d06704729af9438e5f4ae91bdec">parseBound</a> (bool isLower, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result, <a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;p)</td></tr>
<tr class="memdesc:a4de10d06704729af9438e5f4ae91bdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a for operation loop bounds.  <a href="AffineOps_8cpp.html#a4de10d06704729af9438e5f4ae91bdec">More...</a><br /></td></tr>
<tr class="separator:a4de10d06704729af9438e5f4ae91bdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2978fd47e940232657b5ae684d7ccce"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#ae2978fd47e940232657b5ae684d7ccce">printBound</a> (AffineMapAttr boundMap, <a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a> boundOperands, const char *prefix, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p)</td></tr>
<tr class="separator:ae2978fd47e940232657b5ae684d7ccce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1b5f51edb6d5cd35b45da7063f72a2"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a9e1b5f51edb6d5cd35b45da7063f72a2">foldLoopBounds</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a9e1b5f51edb6d5cd35b45da7063f72a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold the constant bounds of a loop.  <a href="AffineOps_8cpp.html#a9e1b5f51edb6d5cd35b45da7063f72a2">More...</a><br /></td></tr>
<tr class="separator:a9e1b5f51edb6d5cd35b45da7063f72a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e08e1a0a3c19566aeaa94fbfc188ddb"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a2e08e1a0a3c19566aeaa94fbfc188ddb">canonicalizeLoopBounds</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a2e08e1a0a3c19566aeaa94fbfc188ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize the bounds of the given loop.  <a href="AffineOps_8cpp.html#a2e08e1a0a3c19566aeaa94fbfc188ddb">More...</a><br /></td></tr>
<tr class="separator:a2e08e1a0a3c19566aeaa94fbfc188ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021d91d70aa35c1c72efff729a5d296a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a021d91d70aa35c1c72efff729a5d296a">hasTrivialZeroTripCount</a> (AffineForOp op)</td></tr>
<tr class="memdesc:a021d91d70aa35c1c72efff729a5d296a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the affine.for has zero iterations in trivial cases.  <a href="AffineOps_8cpp.html#a021d91d70aa35c1c72efff729a5d296a">More...</a><br /></td></tr>
<tr class="separator:a021d91d70aa35c1c72efff729a5d296a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db09c19adc76e23ac2943fef4a17051"><td class="memTemplParams" colspan="2">template&lt;typename BoundListTy , typename LoopCreatorTy &gt; </td></tr>
<tr class="memitem:a9db09c19adc76e23ac2943fef4a17051"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a9db09c19adc76e23ac2943fef4a17051">buildAffineLoopNestImpl</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, BoundListTy lbs, BoundListTy ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; steps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn, LoopCreatorTy &amp;&amp;loopCreatorFn)</td></tr>
<tr class="memdesc:a9db09c19adc76e23ac2943fef4a17051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an affine loop nest, using "loopCreatorFn" to create individual loop operations.  <a href="AffineOps_8cpp.html#a9db09c19adc76e23ac2943fef4a17051">More...</a><br /></td></tr>
<tr class="separator:a9db09c19adc76e23ac2943fef4a17051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000ad2f44506c1fbce68e3f31a6aa2b5"><td class="memItemLeft" align="right" valign="top">static AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a000ad2f44506c1fbce68e3f31a6aa2b5">buildAffineLoopFromConstants</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, int64_t lb, int64_t ub, int64_t step, AffineForOp::BodyBuilderFn bodyBuilderFn)</td></tr>
<tr class="memdesc:a000ad2f44506c1fbce68e3f31a6aa2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an affine loop from the bounds known to be constants.  <a href="AffineOps_8cpp.html#a000ad2f44506c1fbce68e3f31a6aa2b5">More...</a><br /></td></tr>
<tr class="separator:a000ad2f44506c1fbce68e3f31a6aa2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834861d11a6a7baca945d6ffbc3a8ed2"><td class="memItemLeft" align="right" valign="top">static AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a834861d11a6a7baca945d6ffbc3a8ed2">buildAffineLoopFromValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> lb, <a class="el" href="classmlir_1_1Value.html">Value</a> ub, int64_t step, AffineForOp::BodyBuilderFn bodyBuilderFn)</td></tr>
<tr class="memdesc:a834861d11a6a7baca945d6ffbc3a8ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an affine loop from the bounds that may or may not be constants.  <a href="AffineOps_8cpp.html#a834861d11a6a7baca945d6ffbc3a8ed2">More...</a><br /></td></tr>
<tr class="separator:a834861d11a6a7baca945d6ffbc3a8ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d918662708baf501a1d9f1899126d21"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a6d918662708baf501a1d9f1899126d21">composeSetAndOperands</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> &amp;set, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands, bool composeAffineMin=false)</td></tr>
<tr class="memdesc:a6d918662708baf501a1d9f1899126d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose any affine.apply ops feeding into <code>operands</code> of the integer set <code>set</code> by composing the maps of such affine.apply ops with the integer set constraints.  <a href="AffineOps_8cpp.html#a6d918662708baf501a1d9f1899126d21">More...</a><br /></td></tr>
<tr class="separator:a6d918662708baf501a1d9f1899126d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad5dc7b7e393187c5b9ae0d51786ab6"><td class="memTemplParams" colspan="2">template&lt;typename AffineMemOpTy &gt; </td></tr>
<tr class="memitem:a0ad5dc7b7e393187c5b9ae0d51786ab6"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a0ad5dc7b7e393187c5b9ae0d51786ab6">verifyMemoryOpIndexing</a> (AffineMemOpTy op, AffineMapAttr mapAttr, <a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a> mapOperands, MemRefType memrefType, unsigned numIndexOperands)</td></tr>
<tr class="memdesc:a0ad5dc7b7e393187c5b9ae0d51786ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify common indexing invariants of affine.load, affine.store, affine.vector_load and affine.vector_store.  <a href="AffineOps_8cpp.html#a0ad5dc7b7e393187c5b9ae0d51786ab6">More...</a><br /></td></tr>
<tr class="separator:a0ad5dc7b7e393187c5b9ae0d51786ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fa7df47a2dd4686dfd19868542977a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae0fa7df47a2dd4686dfd19868542977a"><td class="memTemplItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#ae0fa7df47a2dd4686dfd19868542977a">verifyAffineMinMaxOp</a> (T op)</td></tr>
<tr class="separator:ae0fa7df47a2dd4686dfd19868542977a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc66ae957af7e80fc8e9101d997a109"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0bc66ae957af7e80fc8e9101d997a109"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a0bc66ae957af7e80fc8e9101d997a109">printAffineMinMaxOp</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, T op)</td></tr>
<tr class="separator:a0bc66ae957af7e80fc8e9101d997a109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b90328357d17ae6c877a3e306f88360"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b90328357d17ae6c877a3e306f88360"><td class="memTemplItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a6b90328357d17ae6c877a3e306f88360">parseAffineMinMaxOp</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result)</td></tr>
<tr class="separator:a6b90328357d17ae6c877a3e306f88360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239b29451081bbe685157a5388f032ca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a239b29451081bbe685157a5388f032ca"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a239b29451081bbe685157a5388f032ca">foldMinMaxOp</a> (T op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands)</td></tr>
<tr class="memdesc:a239b29451081bbe685157a5388f032ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold an affine min or max operation with the given operands.  <a href="AffineOps_8cpp.html#a239b29451081bbe685157a5388f032ca">More...</a><br /></td></tr>
<tr class="separator:a239b29451081bbe685157a5388f032ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2906e3ab99c40d772adeef8e53417d"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#aff2906e3ab99c40d772adeef8e53417d">canonicalizeMapExprAndTermOrder</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map)</td></tr>
<tr class="memdesc:aff2906e3ab99c40d772adeef8e53417d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize the result expression order of an affine map and return success if the order changed.  <a href="AffineOps_8cpp.html#aff2906e3ab99c40d772adeef8e53417d">More...</a><br /></td></tr>
<tr class="separator:aff2906e3ab99c40d772adeef8e53417d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0743e18871599ff8ff8e2d8659d4c2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a0c0743e18871599ff8ff8e2d8659d4c2">isResultTypeMatchAtomicRMWKind</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> resultType, arith::AtomicRMWKind op)</td></tr>
<tr class="separator:a0c0743e18871599ff8ff8e2d8659d4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c2749d394c9d62ad34650fed76d26d"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a45c2749d394c9d62ad34650fed76d26d">canonicalizeLoopBounds</a> (AffineParallelOp op)</td></tr>
<tr class="memdesc:a45c2749d394c9d62ad34650fed76d26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize the bounds of the given loop.  <a href="AffineOps_8cpp.html#a45c2749d394c9d62ad34650fed76d26d">More...</a><br /></td></tr>
<tr class="separator:a45c2749d394c9d62ad34650fed76d26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fef8d134535c158ca70408a89d5f54e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a0fef8d134535c158ca70408a89d5f54e">printMinMaxBound</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, AffineMapAttr mapAttr, <a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a> group, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, StringRef keyword)</td></tr>
<tr class="memdesc:a0fef8d134535c158ca70408a89d5f54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a lower(upper) bound of an affine parallel loop with max(min) conditions in it.  <a href="AffineOps_8cpp.html#a0fef8d134535c158ca70408a89d5f54e">More...</a><br /></td></tr>
<tr class="separator:a0fef8d134535c158ca70408a89d5f54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65c3bf6127907b60e2e625d6520af2a"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#ac65c3bf6127907b60e2e625d6520af2a">deduplicateAndResolveOperands</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt;&gt; operands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;uniqueOperands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;replacements, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a> <a class="el" href="LinalgOps_8cpp.html#a13cd3ed9dcb153ca533c4ad45950c3b8">kind</a>)</td></tr>
<tr class="memdesc:ac65c3bf6127907b60e2e625d6520af2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of lists of parsed operands, populates <code>uniqueOperands</code> with unique operands.  <a href="AffineOps_8cpp.html#ac65c3bf6127907b60e2e625d6520af2a">More...</a><br /></td></tr>
<tr class="separator:ac65c3bf6127907b60e2e625d6520af2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afe1ec9e8058baa1d0329155fe863cf"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a7afe1ec9e8058baa1d0329155fe863cf">parseAffineMapWithMinMax</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result, MinMaxKind <a class="el" href="LinalgOps_8cpp.html#a13cd3ed9dcb153ca533c4ad45950c3b8">kind</a>)</td></tr>
<tr class="memdesc:a7afe1ec9e8058baa1d0329155fe863cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an affine map that can contain a min/max for groups of its results, e.g., max(expr-1, expr-2), expr-3, max(expr-4, expr-5, expr-6).  <a href="AffineOps_8cpp.html#a7afe1ec9e8058baa1d0329155fe863cf">More...</a><br /></td></tr>
<tr class="separator:a7afe1ec9e8058baa1d0329155fe863cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669ae7d5e51e45da0b7f33d95e846a8b"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#a669ae7d5e51e45da0b7f33d95e846a8b">verifyVectorMemoryOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, MemRefType memrefType, VectorType vectorType)</td></tr>
<tr class="memdesc:a669ae7d5e51e45da0b7f33d95e846a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify common invariants of affine.vector_load and affine.vector_store.  <a href="AffineOps_8cpp.html#a669ae7d5e51e45da0b7f33d95e846a8b">More...</a><br /></td></tr>
<tr class="separator:a669ae7d5e51e45da0b7f33d95e846a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f14d2df9881ffaabba674bf19df8c7"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AffineOps_8cpp.html#af8f14d2df9881ffaabba674bf19df8c7">foldCstValueToCstAttrBasis</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedBasis, <a class="el" href="classmlir_1_1MutableOperandRange.html">MutableOperandRange</a> mutableDynamicBasis, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; dynamicBasis)</td></tr>
<tr class="memdesc:af8f14d2df9881ffaabba674bf19df8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given mixed basis of affine.delinearize_index/linearize_index replace constant SSA values with the constant integer value and return the new static basis.  <a href="AffineOps_8cpp.html#af8f14d2df9881ffaabba674bf19df8c7">More...</a><br /></td></tr>
<tr class="separator:af8f14d2df9881ffaabba674bf19df8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;affine-ops&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00042">42</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

</div>
</div>
<a id="a52c883a38e577b8b12282ff70c95a16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c883a38e577b8b12282ff70c95a16d">&#9670;&nbsp;</a></span>GET_OP_CLASSES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_OP_CLASSES</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l05562">5562</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

</div>
</div>
<a id="aeb4eeb99d83d4a53327f3c7a9574ad6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4eeb99d83d4a53327f3c7a9574ad6f">&#9670;&nbsp;</a></span>GET_OP_LIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_OP_LIST</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a000ad2f44506c1fbce68e3f31a6aa2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000ad2f44506c1fbce68e3f31a6aa2b5">&#9670;&nbsp;</a></span>buildAffineLoopFromConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static AffineForOp buildAffineLoopFromConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp::BodyBuilderFn&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an affine loop from the bounds known to be constants. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02889">2889</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02898">buildAffineLoopFromValues()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02911">mlir::affine::buildAffineLoopNest()</a>.</p>

</div>
</div>
<a id="a834861d11a6a7baca945d6ffbc3a8ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834861d11a6a7baca945d6ffbc3a8ed2">&#9670;&nbsp;</a></span>buildAffineLoopFromValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static AffineForOp buildAffineLoopFromValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp::BodyBuilderFn&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an affine loop from the bounds that may or may not be constants. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02898">2898</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02889">buildAffineLoopFromConstants()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, and <a class="el" href="Builders_8cpp_source.html#l00383">mlir::Builder::getDimIdentityMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02919">mlir::affine::buildAffineLoopNest()</a>.</p>

</div>
</div>
<a id="a9db09c19adc76e23ac2943fef4a17051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db09c19adc76e23ac2943fef4a17051">&#9670;&nbsp;</a></span>buildAffineLoopNestImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BoundListTy , typename LoopCreatorTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buildAffineLoopNestImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundListTy&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoundListTy&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoopCreatorTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>loopCreatorFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds an affine loop nest, using "loopCreatorFn" to create individual loop operations. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02848">2848</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02911">mlir::affine::buildAffineLoopNest()</a>.</p>

</div>
</div>
<a id="a2e08e1a0a3c19566aeaa94fbfc188ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e08e1a0a3c19566aeaa94fbfc188ddb">&#9670;&nbsp;</a></span>canonicalizeLoopBounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult canonicalizeLoopBounds </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Canonicalize the bounds of the given loop. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02464">2464</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01619">mlir::affine::canonicalizeMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01196">composeAffineMapAndOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00776">mlir::removeDuplicateExprs()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00925">simplifyMinOrMaxExprWithOperands()</a>.</p>

</div>
</div>
<a id="a45c2749d394c9d62ad34650fed76d26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c2749d394c9d62ad34650fed76d26d">&#9670;&nbsp;</a></span>canonicalizeLoopBounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult canonicalizeLoopBounds </td>
          <td>(</td>
          <td class="paramtype">AffineParallelOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Canonicalize the bounds of the given loop. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l04211">4211</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l04200">mlir::affine::AffineValueMap::canonicalize()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00110">mlir::affine::AffineValueMap::getAffineMap()</a>, and <a class="el" href="AffineValueMap_8cpp_source.html#l00106">mlir::affine::AffineValueMap::getOperands()</a>.</p>

</div>
</div>
<a id="aff2906e3ab99c40d772adeef8e53417d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2906e3ab99c40d772adeef8e53417d">&#9670;&nbsp;</a></span>canonicalizeMapExprAndTermOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult canonicalizeMapExprAndTermOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Canonicalize the result expression order of an affine map and return success if the order changed. </p>
<p>The function flattens the map's affine expressions to coefficient arrays and sorts them in lexicographic order. A coefficient array contains a multiplier for every dimension/symbol and a constant term. The canonicalization fails if a result expression is not pure or if the flattening requires local variables that, unlike dimensions and symbols, have no global order. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03659">3659</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01221">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00362">mlir::SimpleAffineExprFlattener::operandExprStack</a>, and <a class="el" href="AffineExprVisitor_8h_source.html#l00150">mlir::AffineExprVisitor&lt; SubClass, RetTy &gt;::walkPostOrder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l03716">CanonicalizeAffineMinMaxOpExprAndTermOrder&lt; T &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a43a13ffbd2aefb7089f0b7a1e5411b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a13ffbd2aefb7089f0b7a1e5411b11">&#9670;&nbsp;</a></span>canonicalizeMapOrSetAndOperands()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapOrSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void canonicalizeMapOrSetAndOperands </td>
          <td>(</td>
          <td class="paramtype">MapOrSet *&#160;</td>
          <td class="paramname"><em>mapOrSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01542">1542</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00643">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00619">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00629">mlir::getAffineSymbolExpr()</a>, <a class="el" href="Matchers_8h_source.html#l00369">mlir::m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>.</p>

</div>
</div>
<a id="a622cab33387384a309422bb2c690772f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622cab33387384a309422bb2c690772f">&#9670;&nbsp;</a></span>canonicalizePromotedSymbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapOrSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void canonicalizePromotedSymbols </td>
          <td>(</td>
          <td class="paramtype">MapOrSet *&#160;</td>
          <td class="paramname"><em>mapOrSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01448">1448</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00619">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00629">mlir::getAffineSymbolExpr()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>.</p>

</div>
</div>
<a id="a92322a2a849cf48212dc80aae89615e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92322a2a849cf48212dc80aae89615e1">&#9670;&nbsp;</a></span>composeAffineMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void composeAffineMapAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>composeAffineMin</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over <code>operands</code> and fold away all those produced by an AffineApplyOp iteratively. </p>
<p>Perform canonicalization of map and operands as well as AffineMap simplification. <code>map</code> and <code>operands</code> are mutated in place. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01196">1196</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01619">mlir::affine::canonicalizeMapAndOperands()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00285">mlir::changed</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00643">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00619">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00629">mlir::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00221">mlir::AffineMap::isFunctionOfDim()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00228">mlir::AffineMap::isFunctionOfSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01140">replaceDimOrSym()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00496">mlir::AffineMap::replaceDimsAndSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00766">mlir::simplifyAffineMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l04200">mlir::affine::AffineValueMap::canonicalize()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02464">canonicalizeLoopBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03174">composeSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01260">mlir::affine::fullyComposeAffineMapAndOperands()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01276">mlir::affine::makeComposedAffineApply()</a>.</p>

</div>
</div>
<a id="af3d09bbb1d05d79cd31ad13d4797a2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d09bbb1d05d79cd31ad13d4797a2ab">&#9670;&nbsp;</a></span>composeMultiResultAffineMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void composeMultiResultAffineMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>composeAffineMin</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composes the given affine map with the given list of operands, pulling in the maps from any affine.apply operations that supply the operands. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01299">1299</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01619">mlir::affine::canonicalizeMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01260">mlir::affine::fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01221">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">mlir::AffineMap::getSubMap()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00267">mlir::AffineMap::shiftDims()</a>, and <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00280">mlir::AffineMap::shiftSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01385">makeComposedMinMax()</a>.</p>

</div>
</div>
<a id="a6d918662708baf501a1d9f1899126d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d918662708baf501a1d9f1899126d21">&#9670;&nbsp;</a></span>composeSetAndOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void composeSetAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>composeAffineMin</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compose any affine.apply ops feeding into <code>operands</code> of the integer set <code>set</code> by composing the maps of such affine.apply ops with the integer set constraints. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03174">3174</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01196">composeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01221">mlir::AffineMap::get()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01247">mlir::IntegerSet::get()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00041">mlir::IntegerSet::getConstraints()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00057">mlir::IntegerSet::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00051">mlir::IntegerSet::getEqFlags()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00015">mlir::IntegerSet::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00016">mlir::IntegerSet::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>.</p>

</div>
</div>
<a id="ac65c3bf6127907b60e2e625d6520af2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65c3bf6127907b60e2e625d6520af2a">&#9670;&nbsp;</a></span>deduplicateAndResolveOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ParseResult deduplicateAndResolveOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>uniqueOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a list of lists of parsed operands, populates <code>uniqueOperands</code> with unique operands. </p>
<p>Also populates <code>replacements with affine expressions of </code>kind<code>that can be used to update affine maps previously accepting a </code>operands<code>to accept</code>uniqueOperands` instead. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l04308">4308</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641">mlir::DimId</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00619">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00629">mlir::getAffineSymbolExpr()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00072">mlir::AsmParser::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00051">mlir::Builder::getIndexType()</a>, <a class="el" href="LinalgOps_8cpp.html#a13cd3ed9dcb153ca533c4ad45950c3b8">kind</a>, <a class="el" href="OpImplementation_8h_source.html#l01634">mlir::OpAsmParser::resolveOperands()</a>, and <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff">mlir::SymbolId</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l04355">parseAffineMapWithMinMax()</a>.</p>

</div>
</div>
<a id="af8f14d2df9881ffaabba674bf19df8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f14d2df9881ffaabba674bf19df8c7">&#9670;&nbsp;</a></span>foldCstValueToCstAttrBasis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; &gt; foldCstValueToCstAttrBasis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MutableOperandRange.html">MutableOperandRange</a>&#160;</td>
          <td class="paramname"><em>mutableDynamicBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>dynamicBasis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given mixed basis of affine.delinearize_index/linearize_index replace constant SSA values with the constant integer value and return the new static basis. </p>
<p>In case no such candidate for replacement exists, this utility returns std::nullopt. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l04828">4828</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8cpp_source.html#l00481">mlir::MutableOperandRange::erase()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>.</p>

</div>
</div>
<a id="a9e1b5f51edb6d5cd35b45da7063f72a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1b5f51edb6d5cd35b45da7063f72a2">&#9670;&nbsp;</a></span>foldLoopBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult foldLoopBounds </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fold the constant bounds of a loop. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02418">2418</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00430">mlir::AffineMap::constantFold()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="Matchers_8h_source.html#l00369">mlir::m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>.</p>

</div>
</div>
<a id="a239b29451081bbe685157a5388f032ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239b29451081bbe685157a5388f032ca">&#9670;&nbsp;</a></span>foldMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> foldMinMaxOp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fold an affine min or max operation with the given operands. </p>
<p>The operand list may contain nulls, which are interpreted as the operand not being a constant. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03496">3496</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

</div>
</div>
<a id="a9113c24d7d445c3728e0d7945c064421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9113c24d7d445c3728e0d7945c064421">&#9670;&nbsp;</a></span>getLargestKnownDivisor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t getLargestKnownDivisor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the largest known divisor of <code>e</code>. </p>
<p>Exploits information from the values in <code>operands</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00659">659</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02801">mlir::affine::getForInductionVarOwner()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00241">mlir::AffineExpr::getLargestKnownDivisor()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00725">isQTimesDPlusR()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>.</p>

</div>
</div>
<a id="aa3c2a14fa757c0d7181e4fab47050731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c2a14fa757c0d7181e4fab47050731">&#9670;&nbsp;</a></span>getLowerBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;int64_t&gt; getLowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine a constant lower bound for <code>expr</code> if one exists while exploiting values in <code>operands</code>. </p>
<p>Note that the upper bound is an inclusive one. <code>expr</code> is guaranteed to be less than or equal to it. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00798">798</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01641">mlir::getBoundForAffineExpr()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00749">getLowerBound()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00757">getUpperBound()</a>.</p>

</div>
</div>
<a id="a4de441801e41781cbf59fcdc9179aae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de441801e41781cbf59fcdc9179aae0">&#9670;&nbsp;</a></span>getLowerBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;int64_t&gt; getLowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>iv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the constant lower bound on an <code>iv</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00749">749</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02801">mlir::affine::getForInductionVarOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00798">getLowerBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00775">getUpperBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00925">simplifyMinOrMaxExprWithOperands()</a>.</p>

</div>
</div>
<a id="aa379911bb6c00b0120f54f67bff7b7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa379911bb6c00b0120f54f67bff7b7b3">&#9670;&nbsp;</a></span>getUpperBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;int64_t&gt; getUpperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine a constant upper bound for <code>expr</code> if one exists while exploiting values in <code>operands</code>. </p>
<p>Note that the upper bound is an inclusive one. <code>expr</code> is guaranteed to be less than or equal to it. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00775">775</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01641">mlir::getBoundForAffineExpr()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00749">getLowerBound()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00757">getUpperBound()</a>.</p>

</div>
</div>
<a id="a4d64763cb25e2dc784e9d2de026decea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d64763cb25e2dc784e9d2de026decea">&#9670;&nbsp;</a></span>getUpperBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;int64_t&gt; getUpperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>iv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the constant upper bound on an affine.for <code>iv</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00757">757</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02801">mlir::affine::getForInductionVarOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00798">getLowerBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00775">getUpperBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00925">simplifyMinOrMaxExprWithOperands()</a>.</p>

</div>
</div>
<a id="a021d91d70aa35c1c72efff729a5d296a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021d91d70aa35c1c72efff729a5d296a">&#9670;&nbsp;</a></span>hasTrivialZeroTripCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hasTrivialZeroTripCount </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the affine.for has zero iterations in trivial cases. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02610">2610</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

</div>
</div>
<a id="abb7f0f42fc1a8809ab9d7ae95aac496a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7f0f42fc1a8809ab9d7ae95aac496a">&#9670;&nbsp;</a></span>isDimOpValidSymbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isDimOpValidSymbol </td>
          <td>(</td>
          <td class="paramtype">ShapedDimOpInterface&#160;</td>
          <td class="paramname"><em>dimOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the result of the dim op is a valid symbol for <code>region</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00368">368</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00349">isMemRefSizeValidSymbol()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00250">mlir::affine::isTopLevelValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00457">mlir::affine::isValidSymbol()</a>.</p>

</div>
</div>
<a id="a6db62c4fe9a0af0edf33f735e7450913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db62c4fe9a0af0edf33f735e7450913">&#9670;&nbsp;</a></span>isMemRefSizeValidSymbol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AnyMemRefDefOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isMemRefSizeValidSymbol </td>
          <td>(</td>
          <td class="paramtype">AnyMemRefDefOp&#160;</td>
          <td class="paramname"><em>memrefDefOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the 'index' dimension of the <code>memref</code> defined by <code>memrefDefOp</code> is a statically shaped one or defined using a valid symbol for <code>region</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00349">349</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00368">isDimOpValidSymbol()</a>.</p>

</div>
</div>
<a id="a764b24362c096adadc31e0db757b0bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764b24362c096adadc31e0db757b0bbc">&#9670;&nbsp;</a></span>isNonNegativeBoundedBy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isNonNegativeBoundedBy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>e</code> is known to be: 0 &lt;= <code>e</code> &lt; <code>k</code>. </p>
<p>Handles the simple cases of <code>e</code> being an affine dim expression or a constant. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00697">697</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02801">mlir::affine::getForInductionVarOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00725">isQTimesDPlusR()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>.</p>

</div>
</div>
<a id="ac607329b2b966b06fe88ec201119aea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac607329b2b966b06fe88ec201119aea3">&#9670;&nbsp;</a></span>isQTimesDPlusR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isQTimesDPlusR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>div</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>quotientTimesDiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>rem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if expression <code>e</code> is of the form d*e_1 + e_2 where 0 &lt;= e_2 &lt; d. </p>
<p>Set <code>div</code> to <code>d</code>, <code>quotientTimesDiv</code> to e_1 and <code>rem</code> to e_2 if the expression is in that form. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00725">725</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9">mlir::Add</a>, <a class="el" href="AffineOps_8cpp_source.html#l00659">getLargestKnownDivisor()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00697">isNonNegativeBoundedBy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>.</p>

</div>
</div>
<a id="a0c0743e18871599ff8ff8e2d8659d4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0743e18871599ff8ff8e2d8659d4c2">&#9670;&nbsp;</a></span>isResultTypeMatchAtomicRMWKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isResultTypeMatchAtomicRMWKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>resultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arith::AtomicRMWKind&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l04093">4093</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

</div>
</div>
<a id="a2ac7dca41a4290b140937ea9a17c1861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac7dca41a4290b140937ea9a17c1861">&#9670;&nbsp;</a></span>isTopLevelValueOrAbove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isTopLevelValueOrAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A utility function to check if a value is defined at the top level of <code>region</code> or is an argument of <code>region</code> or is defined above the region. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00432">432</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>, <a class="el" href="Value_8cpp_source.html#l00039">mlir::Value::getParentRegion()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00457">mlir::affine::isValidSymbol()</a>.</p>

</div>
</div>
<a id="a40425801875310c2151577ce17a33acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40425801875310c2151577ce17a33acd">&#9670;&nbsp;</a></span>isValidAffineIndexOperand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isValidAffineIndexOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00492">492</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00290">mlir::affine::isValidDim()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01872">mlir::affine::AffineDmaStartOp::verifyInvariantsImpl()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02008">mlir::affine::AffineDmaWaitOp::verifyInvariantsImpl()</a>.</p>

</div>
</div>
<a id="a93de5cae93c64100cbc920a9dc8e3dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93de5cae93c64100cbc920a9dc8e3dc6">&#9670;&nbsp;</a></span>legalizeDemotedDims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MapOrSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void legalizeDemotedDims </td>
          <td>(</td>
          <td class="paramtype">MapOrSet &amp;&#160;</td>
          <td class="paramname"><em>mapOrSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A valid affine dimension may appear as a symbol in affine.apply operations. </p>
<p>Given an application of <code>operands</code> to an affine map or integer set <code>mapOrSet</code>, this function canonicalizes symbols of <code>mapOrSet</code> that are valid dims, but not valid symbols into actual dims. Without such a legalization, the affine.apply will be invalid. This method is the exact inverse of canonicalizePromotedSymbols. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01496">1496</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00619">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00629">mlir::getAffineSymbolExpr()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00290">mlir::affine::isValidDim()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>.</p>

</div>
</div>
<a id="aaf870053b51991e5999a553ab45e4819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf870053b51991e5999a553ab45e4819">&#9670;&nbsp;</a></span>makeComposedFoldedMinMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> makeComposedFoldedMinMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01400">1400</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8h_source.html#l00442">mlir::OpBuilder::getInsertionBlock()</a>, <a class="el" href="Builders_8h_source.html#l00445">mlir::OpBuilder::getInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00320">mlir::OpBuilder::getListener()</a>, <a class="el" href="Matchers_8h_source.html#l00369">mlir::m_Constant()</a>, <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>, and <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a97a6105410cad46cb66cca3f7efb4b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a6105410cad46cb66cca3f7efb4b00">&#9670;&nbsp;</a></span>makeComposedMinMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static OpTy makeComposedMinMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01385">1385</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01299">composeMultiResultAffineMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00738">mlir::foldAttributesIntoMap()</a>, and <a class="el" href="Builders_8cpp_source.html#l00051">mlir::Builder::getIndexType()</a>.</p>

</div>
</div>
<a id="a7afe1ec9e8058baa1d0329155fe863cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afe1ec9e8058baa1d0329155fe863cf">&#9670;&nbsp;</a></span>parseAffineMapWithMinMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ParseResult parseAffineMapWithMinMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MinMaxKind&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses an affine map that can contain a min/max for groups of its results, e.g., max(expr-1, expr-2), expr-3, max(expr-4, expr-5, expr-6). </p>
<p>Populates <code>result</code> attributes with the map (flat list of expressions) and the grouping (list of integers that specify how many expressions to put into each min/max) attributes. Deduplicates repeated operands.</p>
<p>parallel-bound ::= <code>(</code> parallel-group-list <code>)</code> parallel-group-list ::= parallel-group (<code>,</code> parallel-group-list)? parallel-group ::= simple-group | min-max-group simple-group ::= expr-of-ssa-ids min-max-group ::= ( <code>min</code> | <code>max</code> ) <code>(</code> expr-of-ssa-ids-list <code>)</code> expr-of-ssa-ids-list ::= expr-of-ssa-ids (<code>,</code> expr-of-ssa-id-list)?</p>
<p>Examples: (%0, min(%1 + %2, %3), %4, min(%5 floordiv 32, %6)) (%0, max(%1 - 2 * %2)) </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l04355">4355</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l01075">mlir::OperationState::addAttribute()</a>, <a class="el" href="OperationSupport_8h_source.html#l00954">mlir::OperationState::attributes</a>, <a class="el" href="AffineOps_8cpp_source.html#l04308">deduplicateAndResolveOperands()</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641">mlir::DimId</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00141">mlir::NamedAttrList::erase()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01221">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00072">mlir::AsmParser::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00376">mlir::Builder::getEmptyAffineMap()</a>, <a class="el" href="Builders_8cpp_source.html#l00179">mlir::Builder::getI32TensorAttr()</a>, <a class="el" href="LinalgOps_8cpp.html#a13cd3ed9dcb153ca533c4ad45950c3b8">kind</a>, <a class="el" href="OperationSupport_8h_source.html#l00951">mlir::OperationState::operands</a>, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba3f5a1b4ee2e68aebee8e1fa43e0eed27">mlir::AsmParser::Paren</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#ac96f497332866979248e25e170e6bd40">mlir::OpAsmParser::parseAffineExprOfSSAIds()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a55ebc9079a03a42c71c883b21e733dfa">mlir::OpAsmParser::parseAffineMapOfSSAIds()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2839f5b817f7fd118a6b0381da695436">mlir::AsmParser::parseCommaSeparatedList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#ab4382d557de477b5b1b7bbfbbf7ba03f">mlir::AsmParser::parseLParen()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a305f6334c61eb92a164bd865851f55f4">mlir::AsmParser::parseOptionalKeyword()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a5451069c3f54f92ff35dae3b0b316078">mlir::AsmParser::parseOptionalRParen()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a33657a4e5f2cd8018b6d57d468b5f04a">mlir::AsmParser::parseRParen()</a>, and <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff">mlir::SymbolId</a>.</p>

</div>
</div>
<a id="a6b90328357d17ae6c877a3e306f88360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b90328357d17ae6c877a3e306f88360">&#9670;&nbsp;</a></span>parseAffineMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ParseResult parseAffineMinMaxOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03473">3473</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="OpImplementation_8h_source.html#l01382">mlir::AsmParser::addTypeToList()</a>, <a class="el" href="OperationSupport_8h_source.html#l00954">mlir::OperationState::attributes</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00051">mlir::Builder::getIndexType()</a>, <a class="el" href="OperationSupport_8h_source.html#l00951">mlir::OperationState::operands</a>, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95bae4e85fd5ca8927b9be287e34162aab21">mlir::AsmParser::OptionalSquare</a>, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba3f5a1b4ee2e68aebee8e1fa43e0eed27">mlir::AsmParser::Paren</a>, <a class="el" href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#af16d3e3ef46bd2bd45b4e8db657c221a">mlir::OpAsmParser::parseOperandList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf4b8149e630797ac1ac90d8e118c4b">mlir::AsmParser::parseOptionalAttrDict()</a>, <a class="el" href="OpImplementation_8h_source.html#l01634">mlir::OpAsmParser::resolveOperands()</a>, and <a class="el" href="OperationSupport_8h_source.html#l00953">mlir::OperationState::types</a>.</p>

</div>
</div>
<a id="a4de10d06704729af9438e5f4ae91bdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de10d06704729af9438e5f4ae91bdec">&#9670;&nbsp;</a></span>parseBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ParseResult parseBound </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a for operation loop bounds. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02153">2153</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l01075">mlir::OperationState::addAttribute()</a>, <a class="el" href="OperationSupport_8h_source.html#l00954">mlir::OperationState::attributes</a>, <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00378">mlir::Builder::getConstantAffineMap()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a7850fe0a2961f835384adb372758d58b">mlir::AsmParser::getCurrentLocation()</a>, <a class="el" href="Builders_8cpp_source.html#l00051">mlir::Builder::getIndexType()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="Builders_8cpp_source.html#l00396">mlir::Builder::getSymbolIdentityMap()</a>, <a class="el" href="OperationSupport_8h_source.html#l00950">mlir::OperationState::name</a>, <a class="el" href="OperationSupport_8h_source.html#l00951">mlir::OperationState::operands</a>, <a class="el" href="classmlir_1_1AsmParser.html#afc30172e59d0a9e4a28d8ba7ddf1ac42">mlir::AsmParser::parseAttribute()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00507">mlir::affine::parseDimAndSymbolList()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#af16d3e3ef46bd2bd45b4e8db657c221a">mlir::OpAsmParser::parseOperandList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a305f6334c61eb92a164bd865851f55f4">mlir::AsmParser::parseOptionalKeyword()</a>, <a class="el" href="OperationSupport_8h_source.html#l00874">mlir::NamedAttrList::pop_back()</a>, and <a class="el" href="classmlir_1_1OpAsmParser.html#a8c583b0d425ac93c7f8a867f5546db6a">mlir::OpAsmParser::resolveOperand()</a>.</p>

</div>
</div>
<a id="a0bc66ae957af7e80fc8e9101d997a109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc66ae957af7e80fc8e9101d997a109">&#9670;&nbsp;</a></span>printAffineMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void printAffineMinMaxOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03460">3460</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#a681280bde1406e824e1d4626fe257e1b">mlir::OpAsmPrinter::printOptionalAttrDict()</a>.</p>

</div>
</div>
<a id="ae2978fd47e940232657b5ae684d7ccce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2978fd47e940232657b5ae684d7ccce">&#9670;&nbsp;</a></span>printBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void printBound </td>
          <td>(</td>
          <td class="paramtype">AffineMapAttr&#160;</td>
          <td class="paramname"><em>boundMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a>&#160;</td>
          <td class="paramname"><em>boundOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02328">2328</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00497">printDimAndSymbolList()</a>, and <a class="el" href="classmlir_1_1OpAsmPrinter.html#acddd5eb143c94fa8528920c75799e3ba">mlir::OpAsmPrinter::printOperand()</a>.</p>

</div>
</div>
<a id="a909b810a734e0872e03164db8d7fa7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909b810a734e0872e03164db8d7fa7f8">&#9670;&nbsp;</a></span>printDimAndSymbolList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void printDimAndSymbolList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints dimension and symbol list. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00497">497</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02328">printBound()</a>.</p>

</div>
</div>
<a id="a0fef8d134535c158ca70408a89d5f54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fef8d134535c158ca70408a89d5f54e">&#9670;&nbsp;</a></span>printMinMaxBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void printMinMaxBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineMapAttr&#160;</td>
          <td class="paramname"><em>mapAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>keyword</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a lower(upper) bound of an affine parallel loop with max(min) conditions in it. </p>
<p><code>mapAttr</code> is a flat list of affine expressions and <code>group</code> identifies which of the those expressions form max/min groups. <code>operands</code> are the SSA values of dimensions and symbols and <code>keyword</code> is either "min" or "max". </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l04240">4240</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00655">mlir::AffineMap::getSliceMap()</a>, <a class="el" href="classmlir_1_1OpAsmPrinter.html#a92e834f0b1924f751616f89def818263">mlir::OpAsmPrinter::printAffineExprOfSSAIds()</a>, and <a class="el" href="classmlir_1_1OpAsmPrinter.html#aa04de9fec0531cddf28646b119a770af">mlir::OpAsmPrinter::printAffineMapOfSSAIds()</a>.</p>

</div>
</div>
<a id="a3c2a967a96c1bc19f73af2077b9ab5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2a967a96c1bc19f73af2077b9ab5c1">&#9670;&nbsp;</a></span>remainsLegalAfterInline() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool LLVM_ATTRIBUTE_UNUSED remainsLegalAfterInline </td>
          <td>(</td>
          <td class="paramtype">AffineApplyOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an affine apply operation remains legal after inlining from <code>src</code> to <code>dest</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00128">128</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00290">mlir::affine::isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00062">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="ae826612e07e64373b1612baac8fb6819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae826612e07e64373b1612baac8fb6819">&#9670;&nbsp;</a></span>remainsLegalAfterInline() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool remainsLegalAfterInline </td>
          <td>(</td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an affine read or write operation remains legal after inlining from <code>src</code> to <code>dest</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00102">102</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00290">mlir::affine::isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00062">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="a0d3be33f83c44ec2bd88e94fff40fd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3be33f83c44ec2bd88e94fff40fd18">&#9670;&nbsp;</a></span>remainsLegalAfterInline() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool remainsLegalAfterInline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>legalityCheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>value</code> known to be a legal affine dimension or symbol in <code>src</code> region remains legal if the operation that uses it is inlined into <code>dest</code> with the given value mapping. </p>
<p><code>legalityCheck</code> is either <code>isValidDim</code> or <code>isValidSymbol</code>, depending on the value being required to remain a valid dimension or symbol. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00062">62</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00250">mlir::affine::isTopLevelValue()</a>, <a class="el" href="IRMapping_8h_source.html#l00072">mlir::IRMapping::lookup()</a>, <a class="el" href="Matchers_8h_source.html#l00369">mlir::m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00091">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="ae3a9b3c718db4723ffe1fb5538ea0ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a9b3c718db4723ffe1fb5538ea0ead">&#9670;&nbsp;</a></span>remainsLegalAfterInline() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool remainsLegalAfterInline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>legalityCheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if all values known to be legal affine dimensions or symbols in <code>src</code> remain so if their respective users are inlined into <code>dest</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00091">91</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00062">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="aa41cad291d738e5a50788d88be46a771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41cad291d738e5a50788d88be46a771">&#9670;&nbsp;</a></span>replaceAffineMinBoundingBoxExpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult replaceAffineMinBoundingBoxExpression </td>
          <td>(</td>
          <td class="paramtype">AffineMinOp&#160;</td>
          <td class="paramname"><em>minOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>dimOrSym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>syms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming <code>dimOrSym</code> is a quantity in the apply op map <code>map</code> and defined by <code>minOp = affine_min(x_1, ..., x_n)</code>. </p>
<p>This function checks that: <code>0 &lt; affine_min(x_1, ..., x_n)</code> and proceeds with replacing the patterns: </p><div class="fragment"><div class="line">dimOrSym.ceildiv(x_k)</div>
<div class="line">(dimOrSym + x_k - 1).floordiv(x_k)</div>
</div><!-- fragment --><p> by <code>1</code> for all <code>k</code> in <code>1, ..., n</code>. This is possible because <code>x / x_k &lt;= 1</code>.</p>
<p>Warning: ValueBoundsConstraintSet::computeConstantBound is needed to check <code>minOp</code> is positive. </p>
<p>Convert affine symbols and dimensions in minOp to symbols or dimensions in the apply op affine map.</p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01061">1061</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01006">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00788">mlir::ValueBoundsConstraintSet::compare()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00643">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00619">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00629">mlir::getAffineSymbolExpr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00106">mlir::getAsIndexOpFoldResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00655">mlir::AffineMap::getSliceMap()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00179">mlir::AffineExpr::replace()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00511">mlir::AffineMap::replace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01140">replaceDimOrSym()</a>.</p>

</div>
</div>
<a id="ad80a73e1cfd4840702a6f60c34d37202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80a73e1cfd4840702a6f60c34d37202">&#9670;&nbsp;</a></span>replaceDimOrSym()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult replaceDimOrSym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dimOrSymbolPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>syms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceAffineMin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace all occurrences of AffineExpr at position <code>pos</code> in <code>map</code> by the defining AffineApplyOp expression and operands. </p>
<p>When <code>dimOrSymbolPosition &lt; dims.size()</code>, AffineDimExpr@[pos] is replaced. When <code>dimOrSymbolPosition &gt;= dims.size()</code>, AffineSymbolExpr@[pos - dims.size()] is replaced. Mutate <code>map</code>,<code>dims</code> and <code>syms</code> in place as follows:</p><ol type="1">
<li><code>dims</code> and <code>syms</code> are only appended to.</li>
<li><code>map</code> dim and symbols are gradually shifted to higher positions.</li>
<li>Old <code>dim</code> and <code>sym</code> entries are replaced by nullptr This avoids the need for any bookkeeping. If <code>replaceAffineMin</code> is set to true, additionally triggers more expensive replacements involving affine_min operations. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01140">1140</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01619">mlir::affine::canonicalizeMapAndOperands()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00619">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00629">mlir::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00511">mlir::AffineMap::replace()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01061">replaceAffineMinBoundingBoxExpression()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00267">mlir::AffineMap::shiftDims()</a>, and <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00280">mlir::AffineMap::shiftSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01196">composeAffineMapAndOperands()</a>.</p>

</div>
</div>
<a id="a3816c76427483b6523a3d129753e4715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3816c76427483b6523a3d129753e4715">&#9670;&nbsp;</a></span>simplifyExprAndOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void simplifyExprAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplify <code>expr</code> while exploiting information from the values in <code>operands</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00822">822</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a">mlir::CeilDiv</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a">mlir::FloorDiv</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00959">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00068">mlir::getAffineBinaryOpExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00643">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00031">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00033">mlir::AffineExpr::getKind()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00659">getLargestKnownDivisor()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00749">getLowerBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00757">getUpperBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00697">isNonNegativeBoundedBy()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00725">isQTimesDPlusR()</a>, and <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942">mlir::Mod</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01036">simplifyMapWithOperands()</a>.</p>

</div>
</div>
<a id="a15c002a789228f4f6ca08ecf5d775ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c002a789228f4f6ca08ecf5d775ef3">&#9670;&nbsp;</a></span>simplifyMapWithOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LLVM_ATTRIBUTE_UNUSED simplifyMapWithOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplify the map while exploiting information on the values in <code>operands</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01036">1036</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01221">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>.</p>

</div>
</div>
<a id="a68ad81c63548091cb2fbc65b7d0136d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ad81c63548091cb2fbc65b7d0136d5">&#9670;&nbsp;</a></span>simplifyMinOrMaxExprWithOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void simplifyMinOrMaxExprWithOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplify the expressions in <code>map</code> while making use of lower or upper bounds of its operands. </p>
<p>If <code>isMax</code> is true, the map is to be treated as a max of its result expressions, and min otherwise. Eg: min (d0, d1) -&gt; (8, 4 * d0 + d1) can be simplified to (8) if the operands are respectively lower bounded by 2 and 0 (the second expression can't be lower than 8). </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00925">925</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01221">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00643">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01641">mlir::getBoundForAffineExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00031">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00749">getLowerBound()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00757">getUpperBound()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02464">canonicalizeLoopBounds()</a>.</p>

</div>
</div>
<a id="ae0fa7df47a2dd4686dfd19868542977a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0fa7df47a2dd4686dfd19868542977a">&#9670;&nbsp;</a></span>verifyAffineMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult verifyAffineMinMaxOp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03447">3447</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

</div>
</div>
<a id="aaf19ea7311ad162852c482c8523b7120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf19ea7311ad162852c482c8523b7120">&#9670;&nbsp;</a></span>verifyDimAndSymbolIdentifiers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult verifyDimAndSymbolIdentifiers </td>
          <td>(</td>
          <td class="paramtype">OpTy &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to verify that a set of operands are valid dimension and symbol identifiers. </p>
<p>The operands should be laid out such that the dimension operands are before the symbol operands. This function returns failure if there was an invalid operand. An operation is provided to emit any necessary errors. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00529">529</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00265">mlir::affine::getAffineScope()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00290">mlir::affine::isValidDim()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l03282">verifyMemoryOpIndexing()</a>.</p>

</div>
</div>
<a id="a0ad5dc7b7e393187c5b9ae0d51786ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad5dc7b7e393187c5b9ae0d51786ab6">&#9670;&nbsp;</a></span>verifyMemoryOpIndexing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AffineMemOpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult verifyMemoryOpIndexing </td>
          <td>(</td>
          <td class="paramtype">AffineMemOpTy&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineMapAttr&#160;</td>
          <td class="paramname"><em>mapAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a>&#160;</td>
          <td class="paramname"><em>mapOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>memrefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numIndexOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify common indexing invariants of affine.load, affine.store, affine.vector_load and affine.vector_store. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03282">3282</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00529">verifyDimAndSymbolIdentifiers()</a>.</p>

</div>
</div>
<a id="a669ae7d5e51e45da0b7f33d95e846a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669ae7d5e51e45da0b7f33d95e846a8b">&#9670;&nbsp;</a></span>verifyVectorMemoryOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult verifyVectorMemoryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>memrefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>vectorType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify common invariants of affine.vector_load and affine.vector_store. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l04642">4642</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00672">mlir::Operation::emitOpError()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 27 2025 16:33:08 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
