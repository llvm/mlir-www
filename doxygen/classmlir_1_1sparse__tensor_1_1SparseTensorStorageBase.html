<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::sparse_tensor::SparseTensorStorageBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1sparse__tensor.html">sparse_tensor</a></li><li class="navelem"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">SparseTensorStorageBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::sparse_tensor::SparseTensorStorageBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract base class for <code><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html" title="A memory-resident sparse tensor using a storage scheme based on per-level sparse/dense annotations.">SparseTensorStorage</a>&lt;P,C,V&gt;</code>.  
 <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="Storage_8h_source.html">mlir/ExecutionEngine/SparseTensor/Storage.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mlir::sparse_tensor::SparseTensorStorageBase:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase__inherit__graph.svg" width="210" height="156"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac643e910d002e371327925f84323fc71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ac643e910d002e371327925f84323fc71">SparseTensorStorageBase</a> (uint64_t dimRank, const uint64_t *dimSizes, uint64_t lvlRank, const uint64_t *lvlSizes, const <a class="el" href="structmlir_1_1sparse__tensor_1_1LevelType.html">LevelType</a> *lvlTypes, const uint64_t *dim2lvl, const uint64_t *lvl2dim)</td></tr>
<tr class="memdesc:ac643e910d002e371327925f84323fc71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new sparse-tensor storage object with the given encoding.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ac643e910d002e371327925f84323fc71">More...</a><br /></td></tr>
<tr class="separator:ac643e910d002e371327925f84323fc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6473d9303808ece08e5dfc2f7fbab2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#abb6473d9303808ece08e5dfc2f7fbab2">~SparseTensorStorageBase</a> ()=default</td></tr>
<tr class="separator:abb6473d9303808ece08e5dfc2f7fbab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951a7c4d47f59ce53933d91748e2552f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a951a7c4d47f59ce53933d91748e2552f">getDimRank</a> () const</td></tr>
<tr class="memdesc:a951a7c4d47f59ce53933d91748e2552f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of tensor-dimensions.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a951a7c4d47f59ce53933d91748e2552f">More...</a><br /></td></tr>
<tr class="separator:a951a7c4d47f59ce53933d91748e2552f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fbb19a13b3a5b34940092f5d291bae"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a01fbb19a13b3a5b34940092f5d291bae">getLvlRank</a> () const</td></tr>
<tr class="memdesc:a01fbb19a13b3a5b34940092f5d291bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of storage-levels.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a01fbb19a13b3a5b34940092f5d291bae">More...</a><br /></td></tr>
<tr class="separator:a01fbb19a13b3a5b34940092f5d291bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f47a827baeaf94643e87241063a296"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; uint64_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a97f47a827baeaf94643e87241063a296">getDimSizes</a> () const</td></tr>
<tr class="memdesc:a97f47a827baeaf94643e87241063a296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the tensor-dimension sizes array.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a97f47a827baeaf94643e87241063a296">More...</a><br /></td></tr>
<tr class="separator:a97f47a827baeaf94643e87241063a296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad710f72a2198d3e4633586d4453cedb7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ad710f72a2198d3e4633586d4453cedb7">getDimSize</a> (uint64_t d) const</td></tr>
<tr class="memdesc:ad710f72a2198d3e4633586d4453cedb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely looks up the size of the given tensor-dimension.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ad710f72a2198d3e4633586d4453cedb7">More...</a><br /></td></tr>
<tr class="separator:ad710f72a2198d3e4633586d4453cedb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a172e13cb70df18e26a157bd80c9e60"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; uint64_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a0a172e13cb70df18e26a157bd80c9e60">getLvlSizes</a> () const</td></tr>
<tr class="memdesc:a0a172e13cb70df18e26a157bd80c9e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the storage-level sizes array.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a0a172e13cb70df18e26a157bd80c9e60">More...</a><br /></td></tr>
<tr class="separator:a0a172e13cb70df18e26a157bd80c9e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35ef43f4ebda82a9b1284f2975b0db8"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ab35ef43f4ebda82a9b1284f2975b0db8">getLvlSize</a> (uint64_t l) const</td></tr>
<tr class="memdesc:ab35ef43f4ebda82a9b1284f2975b0db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely looks up the size of the given storage-level.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ab35ef43f4ebda82a9b1284f2975b0db8">More...</a><br /></td></tr>
<tr class="separator:ab35ef43f4ebda82a9b1284f2975b0db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0801629c1e99f3ae8c9a77fdcce7614a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structmlir_1_1sparse__tensor_1_1LevelType.html">LevelType</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a0801629c1e99f3ae8c9a77fdcce7614a">getLvlTypes</a> () const</td></tr>
<tr class="memdesc:a0801629c1e99f3ae8c9a77fdcce7614a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the level-types array.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a0801629c1e99f3ae8c9a77fdcce7614a">More...</a><br /></td></tr>
<tr class="separator:a0801629c1e99f3ae8c9a77fdcce7614a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56d5845cbd5102944cd14de11a41b93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1sparse__tensor_1_1LevelType.html">LevelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ae56d5845cbd5102944cd14de11a41b93">getLvlType</a> (uint64_t l) const</td></tr>
<tr class="memdesc:ae56d5845cbd5102944cd14de11a41b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely looks up the type of the given level.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ae56d5845cbd5102944cd14de11a41b93">More...</a><br /></td></tr>
<tr class="separator:ae56d5845cbd5102944cd14de11a41b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf1f7b9b30f425c0241d3c0804fec34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#aacf1f7b9b30f425c0241d3c0804fec34">isDenseLvl</a> (uint64_t l) const</td></tr>
<tr class="memdesc:aacf1f7b9b30f425c0241d3c0804fec34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely checks if the level uses dense storage.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#aacf1f7b9b30f425c0241d3c0804fec34">More...</a><br /></td></tr>
<tr class="separator:aacf1f7b9b30f425c0241d3c0804fec34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e7d55cb3b70a2d8d7a7d72466d0a30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a39e7d55cb3b70a2d8d7a7d72466d0a30">isCompressedLvl</a> (uint64_t l) const</td></tr>
<tr class="memdesc:a39e7d55cb3b70a2d8d7a7d72466d0a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely checks if the level uses compressed storage.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a39e7d55cb3b70a2d8d7a7d72466d0a30">More...</a><br /></td></tr>
<tr class="separator:a39e7d55cb3b70a2d8d7a7d72466d0a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02686736cc0e72d4720d40395629c8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#af02686736cc0e72d4720d40395629c8f">isLooseCompressedLvl</a> (uint64_t l) const</td></tr>
<tr class="memdesc:af02686736cc0e72d4720d40395629c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely checks if the level uses loose compressed storage.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#af02686736cc0e72d4720d40395629c8f">More...</a><br /></td></tr>
<tr class="separator:af02686736cc0e72d4720d40395629c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1410bd49c277324ad4f11f89343e47e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a1410bd49c277324ad4f11f89343e47e1">isSingletonLvl</a> (uint64_t l) const</td></tr>
<tr class="memdesc:a1410bd49c277324ad4f11f89343e47e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely checks if the level uses singleton storage.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a1410bd49c277324ad4f11f89343e47e1">More...</a><br /></td></tr>
<tr class="separator:a1410bd49c277324ad4f11f89343e47e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e018b96a77b7d24ac7ee047479a7a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ac1e018b96a77b7d24ac7ee047479a7a7">isNOutOfMLvl</a> (uint64_t l) const</td></tr>
<tr class="memdesc:ac1e018b96a77b7d24ac7ee047479a7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely checks if the level uses n out of m storage.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ac1e018b96a77b7d24ac7ee047479a7a7">More...</a><br /></td></tr>
<tr class="separator:ac1e018b96a77b7d24ac7ee047479a7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96ecae4dbd7285aafa1469c409ec058"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ad96ecae4dbd7285aafa1469c409ec058">isOrderedLvl</a> (uint64_t l) const</td></tr>
<tr class="memdesc:ad96ecae4dbd7285aafa1469c409ec058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely checks if the level is ordered.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ad96ecae4dbd7285aafa1469c409ec058">More...</a><br /></td></tr>
<tr class="separator:ad96ecae4dbd7285aafa1469c409ec058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66de0da542436d3e98b70a77019a6c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#af66de0da542436d3e98b70a77019a6c6">isUniqueLvl</a> (uint64_t l) const</td></tr>
<tr class="memdesc:af66de0da542436d3e98b70a77019a6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely checks if the level is unique.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#af66de0da542436d3e98b70a77019a6c6">More...</a><br /></td></tr>
<tr class="separator:af66de0da542436d3e98b70a77019a6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7517d6bf8da382944fdd880235e1a0f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ae7517d6bf8da382944fdd880235e1a0f">endLexInsert</a> ()=0</td></tr>
<tr class="memdesc:ae7517d6bf8da382944fdd880235e1a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes lexicographic insertions.  <a href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#ae7517d6bf8da382944fdd880235e1a0f">More...</a><br /></td></tr>
<tr class="separator:ae7517d6bf8da382944fdd880235e1a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4b67a9f19f16f2eb12b14158492032a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a4b67a9f19f16f2eb12b14158492032a1">SparseTensorStorageBase</a> (const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">SparseTensorStorageBase</a> &amp;)=default</td></tr>
<tr class="separator:a4b67a9f19f16f2eb12b14158492032a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ddf953946e62decb2b7716c8969ac2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">SparseTensorStorageBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a44ddf953946e62decb2b7716c8969ac2">operator=</a> (const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">SparseTensorStorageBase</a> &amp;)=delete</td></tr>
<tr class="separator:a44ddf953946e62decb2b7716c8969ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0a86544b07512f313dbf9a0915d4c207"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1sparse__tensor_1_1MapRef.html">MapRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a0a86544b07512f313dbf9a0915d4c207">map</a></td></tr>
<tr class="separator:a0a86544b07512f313dbf9a0915d4c207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3139465eec43eff00829fea7c01c8db1"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html#a3139465eec43eff00829fea7c01c8db1">allDense</a></td></tr>
<tr class="separator:a3139465eec43eff00829fea7c01c8db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract base class for <code><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html" title="A memory-resident sparse tensor using a storage scheme based on per-level sparse/dense annotations.">SparseTensorStorage</a>&lt;P,C,V&gt;</code>. </p>
<p>This class takes responsibility for all the <code>&lt;P,C,V&gt;</code>-independent aspects of the tensor (e.g., sizes, sparsity, mapping). In addition, we use function overloading to implement "partial" method specialization, which the C-API relies on to catch type errors arising from our use of opaque pointers.</p>
<p>Because this class forms a bridge between the denotational semantics of "tensors" and the operational semantics of how we store and compute with them, it also distinguishes between two different coordinate spaces (and their associated rank, sizes, etc). Denotationally, we have the <em>dimensions</em> of the tensor represented by this object. Operationally, we have the <em>levels</em> of the storage representation itself.</p>
<p>The <em>size</em> of an axis is the cardinality of possible coordinate values along that axis (regardless of which coordinates have stored element values). As such, each size must be non-zero since if any axis has size-zero then the whole tensor would have trivial storage (since there are no possible coordinates). Thus we use the plural term <em>sizes</em> for a collection of non-zero cardinalities, and use this term whenever referring to run-time cardinalities. Whereas we use the term <em>shape</em> for a collection of compile-time cardinalities, where zero is used to indicate cardinalities which are dynamic (i.e., unknown/unspecified at compile-time). At run-time, these dynamic cardinalities will be inferred from or checked against sizes otherwise specified. Thus, dynamic cardinalities always have an "immutable but
unknown" value; so the term "dynamic" should not be taken to indicate run-time mutability. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00063">63</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4b67a9f19f16f2eb12b14158492032a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b67a9f19f16f2eb12b14158492032a1">&#9670;&nbsp;</a></span>SparseTensorStorageBase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::sparse_tensor::SparseTensorStorageBase::SparseTensorStorageBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">SparseTensorStorageBase</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac643e910d002e371327925f84323fc71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac643e910d002e371327925f84323fc71">&#9670;&nbsp;</a></span>SparseTensorStorageBase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparseTensorStorageBase::SparseTensorStorageBase </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>dimRank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>dimSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lvlRank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>lvlSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1sparse__tensor_1_1LevelType.html">LevelType</a> *&#160;</td>
          <td class="paramname"><em>lvlTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>dim2lvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>lvl2dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new sparse-tensor storage object with the given encoding. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8cpp_source.html#l00027">27</a> of file <a class="el" href="Storage_8cpp_source.html">Storage.cpp</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00113">isCompressedLvl()</a>, <a class="el" href="Storage_8h_source.html#l00110">isDenseLvl()</a>, <a class="el" href="Storage_8h_source.html#l00118">isLooseCompressedLvl()</a>, <a class="el" href="Storage_8h_source.html#l00126">isNOutOfMLvl()</a>, and <a class="el" href="Storage_8h_source.html#l00123">isSingletonLvl()</a>.</p>

</div>
</div>
<a id="abb6473d9303808ece08e5dfc2f7fbab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6473d9303808ece08e5dfc2f7fbab2">&#9670;&nbsp;</a></span>~SparseTensorStorageBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual mlir::sparse_tensor::SparseTensorStorageBase::~SparseTensorStorageBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae7517d6bf8da382944fdd880235e1a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7517d6bf8da382944fdd880235e1a0f">&#9670;&nbsp;</a></span>endLexInsert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mlir::sparse_tensor::SparseTensorStorageBase::endLexInsert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalizes lexicographic insertions. </p>

<p>Implemented in <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorage.html#afa19fd687ffb920220c6b262efac17d2">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;</a>.</p>

</div>
</div>
<a id="a951a7c4d47f59ce53933d91748e2552f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951a7c4d47f59ce53933d91748e2552f">&#9670;&nbsp;</a></span>getDimRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::sparse_tensor::SparseTensorStorageBase::getDimRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of tensor-dimensions. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00077">77</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Storage_8h_source.html#l00086">getDimSize()</a>.</p>

</div>
</div>
<a id="ad710f72a2198d3e4633586d4453cedb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad710f72a2198d3e4633586d4453cedb7">&#9670;&nbsp;</a></span>getDimSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::sparse_tensor::SparseTensorStorageBase::getDimSize </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely looks up the size of the given tensor-dimension. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00086">86</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00077">getDimRank()</a>.</p>

</div>
</div>
<a id="a97f47a827baeaf94643e87241063a296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f47a827baeaf94643e87241063a296">&#9670;&nbsp;</a></span>getDimSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;uint64_t&gt;&amp; mlir::sparse_tensor::SparseTensorStorageBase::getDimSizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the tensor-dimension sizes array. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00083">83</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

</div>
</div>
<a id="a01fbb19a13b3a5b34940092f5d291bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fbb19a13b3a5b34940092f5d291bae">&#9670;&nbsp;</a></span>getLvlRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::sparse_tensor::SparseTensorStorageBase::getLvlRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of storage-levels. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00080">80</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Storage_8h_source.html#l00315">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::expInsert()</a>, <a class="el" href="Storage_8h_source.html#l00255">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::getCoordinates()</a>, <a class="el" href="Storage_8h_source.html#l00260">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::getCoordinatesBuffer()</a>, <a class="el" href="Storage_8h_source.html#l00095">getLvlSize()</a>, <a class="el" href="Storage_8h_source.html#l00104">getLvlType()</a>, <a class="el" href="Storage_8h_source.html#l00250">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::getPositions()</a>, <a class="el" href="Storage_8h_source.html#l00291">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::lexInsert()</a>, and <a class="el" href="Storage_8h_source.html#l00356">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::sortInPlace()</a>.</p>

</div>
</div>
<a id="ab35ef43f4ebda82a9b1284f2975b0db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35ef43f4ebda82a9b1284f2975b0db8">&#9670;&nbsp;</a></span>getLvlSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::sparse_tensor::SparseTensorStorageBase::getLvlSize </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely looks up the size of the given storage-level. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00095">95</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00080">getLvlRank()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Storage_8h_source.html#l00291">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::lexInsert()</a>.</p>

</div>
</div>
<a id="a0a172e13cb70df18e26a157bd80c9e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a172e13cb70df18e26a157bd80c9e60">&#9670;&nbsp;</a></span>getLvlSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;uint64_t&gt;&amp; mlir::sparse_tensor::SparseTensorStorageBase::getLvlSizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the storage-level sizes array. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00092">92</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

</div>
</div>
<a id="ae56d5845cbd5102944cd14de11a41b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56d5845cbd5102944cd14de11a41b93">&#9670;&nbsp;</a></span>getLvlType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1sparse__tensor_1_1LevelType.html">LevelType</a> mlir::sparse_tensor::SparseTensorStorageBase::getLvlType </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely looks up the type of the given level. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00104">104</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00080">getLvlRank()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Storage_8h_source.html#l00113">isCompressedLvl()</a>, <a class="el" href="Storage_8h_source.html#l00110">isDenseLvl()</a>, <a class="el" href="Storage_8h_source.html#l00118">isLooseCompressedLvl()</a>, <a class="el" href="Storage_8h_source.html#l00126">isNOutOfMLvl()</a>, <a class="el" href="Storage_8h_source.html#l00129">isOrderedLvl()</a>, <a class="el" href="Storage_8h_source.html#l00123">isSingletonLvl()</a>, and <a class="el" href="Storage_8h_source.html#l00132">isUniqueLvl()</a>.</p>

</div>
</div>
<a id="a0801629c1e99f3ae8c9a77fdcce7614a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0801629c1e99f3ae8c9a77fdcce7614a">&#9670;&nbsp;</a></span>getLvlTypes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structmlir_1_1sparse__tensor_1_1LevelType.html">LevelType</a>&gt;&amp; mlir::sparse_tensor::SparseTensorStorageBase::getLvlTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the level-types array. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00101">101</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

</div>
</div>
<a id="a39e7d55cb3b70a2d8d7a7d72466d0a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e7d55cb3b70a2d8d7a7d72466d0a30">&#9670;&nbsp;</a></span>isCompressedLvl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorStorageBase::isCompressedLvl </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely checks if the level uses compressed storage. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00113">113</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00104">getLvlType()</a>, and <a class="el" href="Enums_8h_source.html#l00415">mlir::sparse_tensor::isCompressedLT()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Storage_8h_source.html#l00617">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::SparseTensorStorage()</a>, and <a class="el" href="Storage_8cpp_source.html#l00027">SparseTensorStorageBase()</a>.</p>

</div>
</div>
<a id="aacf1f7b9b30f425c0241d3c0804fec34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf1f7b9b30f425c0241d3c0804fec34">&#9670;&nbsp;</a></span>isDenseLvl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorStorageBase::isDenseLvl </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely checks if the level uses dense storage. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00110">110</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00104">getLvlType()</a>, and <a class="el" href="Enums_8h_source.html#l00413">mlir::sparse_tensor::isDenseLT()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Storage_8h_source.html#l00617">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::SparseTensorStorage()</a>, and <a class="el" href="Storage_8cpp_source.html#l00027">SparseTensorStorageBase()</a>.</p>

</div>
</div>
<a id="af02686736cc0e72d4720d40395629c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02686736cc0e72d4720d40395629c8f">&#9670;&nbsp;</a></span>isLooseCompressedLvl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorStorageBase::isLooseCompressedLvl </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely checks if the level uses loose compressed storage. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00118">118</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00104">getLvlType()</a>, and <a class="el" href="Enums_8h_source.html#l00418">mlir::sparse_tensor::isLooseCompressedLT()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Storage_8h_source.html#l00617">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::SparseTensorStorage()</a>, and <a class="el" href="Storage_8cpp_source.html#l00027">SparseTensorStorageBase()</a>.</p>

</div>
</div>
<a id="ac1e018b96a77b7d24ac7ee047479a7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e018b96a77b7d24ac7ee047479a7a7">&#9670;&nbsp;</a></span>isNOutOfMLvl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorStorageBase::isNOutOfMLvl </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely checks if the level uses n out of m storage. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00126">126</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00104">getLvlType()</a>, and <a class="el" href="Enums_8h_source.html#l00424">mlir::sparse_tensor::isNOutOfMLT()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Storage_8h_source.html#l00617">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::SparseTensorStorage()</a>, and <a class="el" href="Storage_8cpp_source.html#l00027">SparseTensorStorageBase()</a>.</p>

</div>
</div>
<a id="ad96ecae4dbd7285aafa1469c409ec058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96ecae4dbd7285aafa1469c409ec058">&#9670;&nbsp;</a></span>isOrderedLvl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorStorageBase::isOrderedLvl </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely checks if the level is ordered. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00129">129</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00104">getLvlType()</a>, and <a class="el" href="Enums_8h_source.html#l00425">mlir::sparse_tensor::isOrderedLT()</a>.</p>

</div>
</div>
<a id="a1410bd49c277324ad4f11f89343e47e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1410bd49c277324ad4f11f89343e47e1">&#9670;&nbsp;</a></span>isSingletonLvl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorStorageBase::isSingletonLvl </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely checks if the level uses singleton storage. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00123">123</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00104">getLvlType()</a>, and <a class="el" href="Enums_8h_source.html#l00421">mlir::sparse_tensor::isSingletonLT()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Storage_8h_source.html#l00617">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::SparseTensorStorage()</a>, and <a class="el" href="Storage_8cpp_source.html#l00027">SparseTensorStorageBase()</a>.</p>

</div>
</div>
<a id="af66de0da542436d3e98b70a77019a6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66de0da542436d3e98b70a77019a6c6">&#9670;&nbsp;</a></span>isUniqueLvl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::sparse_tensor::SparseTensorStorageBase::isUniqueLvl </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely checks if the level is unique. </p>

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00132">132</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">References <a class="el" href="Storage_8h_source.html#l00104">getLvlType()</a>, and <a class="el" href="Enums_8h_source.html#l00428">mlir::sparse_tensor::isUniqueLT()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Storage_8h_source.html#l00671">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::SparseTensorStorage()</a>.</p>

</div>
</div>
<a id="a44ddf953946e62decb2b7716c8969ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ddf953946e62decb2b7716c8969ac2">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">SparseTensorStorageBase</a>&amp; mlir::sparse_tensor::SparseTensorStorageBase::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorStorageBase.html">SparseTensorStorageBase</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3139465eec43eff00829fea7c01c8db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3139465eec43eff00829fea7c01c8db1">&#9670;&nbsp;</a></span>allDense</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool mlir::sparse_tensor::SparseTensorStorageBase::allDense</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00184">184</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Storage_8h_source.html#l00345">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::endLexInsert()</a>, <a class="el" href="Storage_8h_source.html#l00291">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::lexInsert()</a>, and <a class="el" href="Storage_8h_source.html#l00617">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::SparseTensorStorage()</a>.</p>

</div>
</div>
<a id="a0a86544b07512f313dbf9a0915d4c207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a86544b07512f313dbf9a0915d4c207">&#9670;&nbsp;</a></span>map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1sparse__tensor_1_1MapRef.html">MapRef</a> mlir::sparse_tensor::SparseTensorStorageBase::map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Storage_8h_source.html#l00183">183</a> of file <a class="el" href="Storage_8h_source.html">Storage.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/ExecutionEngine/SparseTensor/<a class="el" href="Storage_8h_source.html">Storage.h</a></li>
<li>lib/ExecutionEngine/SparseTensor/<a class="el" href="Storage_8cpp_source.html">Storage.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:32 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
