<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::OpTrait Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="namespacemlir_1_1OpTrait.html">OpTrait</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mlir::OpTrait Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:detail" id="r_detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1detail.html">detail</a></td></tr>
<tr class="memitem:impl" id="r_impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html">impl</a></td></tr>
<tr class="memitem:spirv" id="r_spirv"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1spirv.html">spirv</a></td></tr>
<tr class="memitem:tosa" id="r_tosa"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1tosa.html">tosa</a></td></tr>
<tr class="memitem:util" id="r_util"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1util.html">util</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:AffineScope" id="r_AffineScope"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AffineScope.html">AffineScope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait of region holding operations that defines a new scope for polyhedral optimization purposes.  <a href="classmlir_1_1OpTrait_1_1AffineScope.html#details">More...</a><br /></td></tr>
<tr class="memitem:AlwaysSpeculatableImplTrait" id="r_AlwaysSpeculatableImplTrait"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1AlwaysSpeculatableImplTrait.html">AlwaysSpeculatableImplTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait marks an op (which must be tagged as implementing the ConditionallySpeculatable interface) as being always speculatable.  <a href="structmlir_1_1OpTrait_1_1AlwaysSpeculatableImplTrait.html#details">More...</a><br /></td></tr>
<tr class="memitem:AtLeastNOperands" id="r_AtLeastNOperands"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNOperands.html">AtLeastNOperands</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a at least a specified number of operands.  <a href="classmlir_1_1OpTrait_1_1AtLeastNOperands.html#details">More...</a><br /></td></tr>
<tr class="memitem:AtLeastNRegions" id="r_AtLeastNRegions"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNRegions.html">AtLeastNRegions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs for ops that are known to have at least a specified number of regions.  <a href="classmlir_1_1OpTrait_1_1AtLeastNRegions.html#details">More...</a><br /></td></tr>
<tr class="memitem:AtLeastNResults" id="r_AtLeastNResults"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNResults.html">AtLeastNResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have at least a specified number of results.  <a href="classmlir_1_1OpTrait_1_1AtLeastNResults.html#details">More...</a><br /></td></tr>
<tr class="memitem:AtLeastNSuccessors" id="r_AtLeastNSuccessors"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNSuccessors.html">AtLeastNSuccessors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs for ops that are known to have at least a specified number of successors.  <a href="classmlir_1_1OpTrait_1_1AtLeastNSuccessors.html#details">More...</a><br /></td></tr>
<tr class="memitem:AtMostOneChildOf" id="r_AtMostOneChildOf"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtMostOneChildOf.html">AtMostOneChildOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Characterize operations that have at most a single operation of certain types in their region.  <a href="classmlir_1_1OpTrait_1_1AtMostOneChildOf.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrSizedOperandSegments" id="r_AttrSizedOperandSegments"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AttrSizedOperandSegments.html">AttrSizedOperandSegments</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait for operations that have an attribute specifying operand segments.  <a href="classmlir_1_1OpTrait_1_1AttrSizedOperandSegments.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttrSizedResultSegments" id="r_AttrSizedResultSegments"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AttrSizedResultSegments.html">AttrSizedResultSegments</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classmlir_1_1OpTrait_1_1AttrSizedOperandSegments.html" title="A trait for operations that have an attribute specifying operand segments.">AttrSizedOperandSegments</a> but used for results.  <a href="classmlir_1_1OpTrait_1_1AttrSizedResultSegments.html#details">More...</a><br /></td></tr>
<tr class="memitem:AutomaticAllocationScope" id="r_AutomaticAllocationScope"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AutomaticAllocationScope.html">AutomaticAllocationScope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait of region holding operations that define a new scope for automatic allocations, i.e., allocations that are freed when control is transferred back from the operation's region.  <a href="classmlir_1_1OpTrait_1_1AutomaticAllocationScope.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConstantLike" id="r_ConstantLike"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ConstantLike.html">ConstantLike</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for a sub-set of ops that are known to be constant-like.  <a href="classmlir_1_1OpTrait_1_1ConstantLike.html#details">More...</a><br /></td></tr>
<tr class="memitem:DistinctObjectsTrait" id="r_DistinctObjectsTrait"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1DistinctObjectsTrait.html">DistinctObjectsTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trai indicates that pointer-like objects (such as memrefs) returned from this operation will never alias with each other.  <a href="classmlir_1_1OpTrait_1_1DistinctObjectsTrait.html#details">More...</a><br /></td></tr>
<tr class="memitem:Elementwise" id="r_Elementwise"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1Elementwise.html">Elementwise</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait tags element-wise ops on vectors or tensors.  <a href="structmlir_1_1OpTrait_1_1Elementwise.html#details">More...</a><br /></td></tr>
<tr class="memitem:HasOnlyGraphRegion" id="r_HasOnlyGraphRegion"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1HasOnlyGraphRegion.html">HasOnlyGraphRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait that specifies that an operation only defines graph regions.  <a href="classmlir_1_1OpTrait_1_1HasOnlyGraphRegion.html#details">More...</a><br /></td></tr>
<tr class="memitem:HasParallelRegion" id="r_HasParallelRegion"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1HasParallelRegion.html">HasParallelRegion</a></td></tr>
<tr class="memitem:HasParent" id="r_HasParent"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1HasParent.html">HasParent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a verifier for ops that are expecting their parent to be one of the given parent ops.  <a href="structmlir_1_1OpTrait_1_1HasParent.html#details">More...</a><br /></td></tr>
<tr class="memitem:HasRecursiveMemoryEffects" id="r_HasRecursiveMemoryEffects"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1HasRecursiveMemoryEffects.html">HasRecursiveMemoryEffects</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait indicates that the memory effects of an operation includes the effects of operations nested within its regions.  <a href="classmlir_1_1OpTrait_1_1HasRecursiveMemoryEffects.html#details">More...</a><br /></td></tr>
<tr class="memitem:hasSingleBlockImplicitTerminator" id="r_hasSingleBlockImplicitTerminator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1hasSingleBlockImplicitTerminator.html">hasSingleBlockImplicitTerminator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support to check if an operation has the <a class="el" href="structmlir_1_1OpTrait_1_1SingleBlockImplicitTerminator.html" title="This class provides APIs and verifiers for ops with regions having a single block that must terminate...">SingleBlockImplicitTerminator</a> trait.  <a href="structmlir_1_1OpTrait_1_1hasSingleBlockImplicitTerminator.html#details">More...</a><br /></td></tr>
<tr class="memitem:hasSingleBlockImplicitTerminator_3C_20Op_2C_20false_20_3E" id="r_hasSingleBlockImplicitTerminator_3C_20Op_2C_20false_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1hasSingleBlockImplicitTerminator_3_01Op_00_01false_01_4.html">hasSingleBlockImplicitTerminator&lt; Op, false &gt;</a></td></tr>
<tr class="memitem:InferShapedTypeOpAdaptor" id="r_InferShapedTypeOpAdaptor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1InferShapedTypeOpAdaptor.html">InferShapedTypeOpAdaptor</a></td></tr>
<tr class="memitem:InferTensorType" id="r_InferTensorType"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1InferTensorType.html">InferTensorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor type inference trait that constructs a tensor from the inferred shape and elemental types.  <a href="classmlir_1_1OpTrait_1_1InferTensorType.html#details">More...</a><br /></td></tr>
<tr class="memitem:InferTypeOpAdaptor" id="r_InferTypeOpAdaptor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1InferTypeOpAdaptor.html">InferTypeOpAdaptor</a></td></tr>
<tr class="memitem:IsCommutative" id="r_IsCommutative"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsCommutative.html">IsCommutative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adds property that the operation is commutative.  <a href="classmlir_1_1OpTrait_1_1IsCommutative.html#details">More...</a><br /></td></tr>
<tr class="memitem:IsIdempotent" id="r_IsIdempotent"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsIdempotent.html">IsIdempotent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adds property that the operation is idempotent.  <a href="classmlir_1_1OpTrait_1_1IsIdempotent.html#details">More...</a><br /></td></tr>
<tr class="memitem:IsInvolution" id="r_IsInvolution"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsInvolution.html">IsInvolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adds property that the operation is an involution.  <a href="classmlir_1_1OpTrait_1_1IsInvolution.html#details">More...</a><br /></td></tr>
<tr class="memitem:IsIsolatedFromAbove" id="r_IsIsolatedFromAbove"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsIsolatedFromAbove.html">IsIsolatedFromAbove</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to be isolated from above.  <a href="classmlir_1_1OpTrait_1_1IsIsolatedFromAbove.html#details">More...</a><br /></td></tr>
<tr class="memitem:IsTerminator" id="r_IsTerminator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsTerminator.html">IsTerminator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to be terminators.  <a href="classmlir_1_1OpTrait_1_1IsTerminator.html#details">More...</a><br /></td></tr>
<tr class="memitem:MemRefsNormalizable" id="r_MemRefsNormalizable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1MemRefsNormalizable.html">MemRefsNormalizable</a></td></tr>
<tr class="memitem:NOperands" id="r_NOperands"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NOperands.html">NOperands</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a specified number of operands.  <a href="classmlir_1_1OpTrait_1_1NOperands.html#details">More...</a><br /></td></tr>
<tr class="memitem:NoRegionArguments" id="r_NoRegionArguments"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1NoRegionArguments.html">NoRegionArguments</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait provides a verifier for ops that are expecting their regions to not have any arguments.  <a href="structmlir_1_1OpTrait_1_1NoRegionArguments.html#details">More...</a><br /></td></tr>
<tr class="memitem:NoTerminator" id="r_NoTerminator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NoTerminator.html">NoTerminator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class indicates that the regions associated with this op don't have terminators.  <a href="classmlir_1_1OpTrait_1_1NoTerminator.html#details">More...</a><br /></td></tr>
<tr class="memitem:NRegions" id="r_NRegions"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NRegions.html">NRegions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a specified number of regions.  <a href="classmlir_1_1OpTrait_1_1NRegions.html#details">More...</a><br /></td></tr>
<tr class="memitem:NResults" id="r_NResults"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NResults.html">NResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a specified number of results.  <a href="classmlir_1_1OpTrait_1_1NResults.html#details">More...</a><br /></td></tr>
<tr class="memitem:NSuccessors" id="r_NSuccessors"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NSuccessors.html">NSuccessors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a specified number of successors.  <a href="classmlir_1_1OpTrait_1_1NSuccessors.html#details">More...</a><br /></td></tr>
<tr class="memitem:NVVMRequiresSM" id="r_NVVMRequiresSM"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NVVMRequiresSM.html">NVVMRequiresSM</a></td></tr>
<tr class="memitem:NVVMRequiresSMa" id="r_NVVMRequiresSMa"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NVVMRequiresSMa.html">NVVMRequiresSMa</a></td></tr>
<tr class="memitem:OneOperand" id="r_OneOperand"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneOperand.html">OneOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have exactly one SSA operand.  <a href="classmlir_1_1OpTrait_1_1OneOperand.html#details">More...</a><br /></td></tr>
<tr class="memitem:OneRegion" id="r_OneRegion"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneRegion.html">OneRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs for ops that are known to have a single region.  <a href="classmlir_1_1OpTrait_1_1OneRegion.html#details">More...</a><br /></td></tr>
<tr class="memitem:OneResult" id="r_OneResult"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneResult.html">OneResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides return value APIs for ops that are known to have a single result.  <a href="classmlir_1_1OpTrait_1_1OneResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:OneSuccessor" id="r_OneSuccessor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneSuccessor.html">OneSuccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs for ops that are known to have a single successor.  <a href="classmlir_1_1OpTrait_1_1OneSuccessor.html#details">More...</a><br /></td></tr>
<tr class="memitem:OneTypedResult" id="r_OneTypedResult"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneTypedResult.html">OneTypedResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait is used for return value APIs for ops that are known to have a specific type other than <span class="tt"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a></span>.  <a href="classmlir_1_1OpTrait_1_1OneTypedResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:OperandsAreFloatLike" id="r_OperandsAreFloatLike"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OperandsAreFloatLike.html">OperandsAreFloatLike</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that all operands of the specified op have a float type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1OperandsAreFloatLike.html#details">More...</a><br /></td></tr>
<tr class="memitem:OperandsAreSignlessIntegerLike" id="r_OperandsAreSignlessIntegerLike"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OperandsAreSignlessIntegerLike.html">OperandsAreSignlessIntegerLike</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that all operands of the specified op have a signless integer or index type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1OperandsAreSignlessIntegerLike.html#details">More...</a><br /></td></tr>
<tr class="memitem:OpInvariants" id="r_OpInvariants"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OpInvariants.html">OpInvariants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="tt">verifyInvariantsImpl</span> verifies the invariants like the types, attrs, .etc.  <a href="classmlir_1_1OpTrait_1_1OpInvariants.html#details">More...</a><br /></td></tr>
<tr class="memitem:RecursivelySpeculatableImplTrait" id="r_RecursivelySpeculatableImplTrait"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1RecursivelySpeculatableImplTrait.html">RecursivelySpeculatableImplTrait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait marks an op (which must be tagged as implementing the ConditionallySpeculatable interface) as being recursively speculatable.  <a href="structmlir_1_1OpTrait_1_1RecursivelySpeculatableImplTrait.html#details">More...</a><br /></td></tr>
<tr class="memitem:ResultsAreBoolLike" id="r_ResultsAreBoolLike"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ResultsAreBoolLike.html">ResultsAreBoolLike</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that any results of the specified op have a boolean type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1ResultsAreBoolLike.html#details">More...</a><br /></td></tr>
<tr class="memitem:ResultsAreFloatLike" id="r_ResultsAreFloatLike"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ResultsAreFloatLike.html">ResultsAreFloatLike</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that any results of the specified op have a floating point type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1ResultsAreFloatLike.html#details">More...</a><br /></td></tr>
<tr class="memitem:ResultsAreSignlessIntegerLike" id="r_ResultsAreSignlessIntegerLike"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ResultsAreSignlessIntegerLike.html">ResultsAreSignlessIntegerLike</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that any results of the specified op have a signless integer or index type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1ResultsAreSignlessIntegerLike.html#details">More...</a><br /></td></tr>
<tr class="memitem:ResultsBroadcastableShape" id="r_ResultsBroadcastableShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ResultsBroadcastableShape.html">ResultsBroadcastableShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait for ops that are known to have broadcast compatible operands and result types.  <a href="classmlir_1_1OpTrait_1_1ResultsBroadcastableShape.html#details">More...</a><br /></td></tr>
<tr class="memitem:ReturnLike" id="r_ReturnLike"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1ReturnLike.html">ReturnLike</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait indicates that a terminator operation is "return-like".  <a href="structmlir_1_1OpTrait_1_1ReturnLike.html#details">More...</a><br /></td></tr>
<tr class="memitem:SameOperandsAndResultElementType" id="r_SameOperandsAndResultElementType"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsAndResultElementType.html">SameOperandsAndResultElementType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand and result element type (or the type itself if it is scalar).  <a href="classmlir_1_1OpTrait_1_1SameOperandsAndResultElementType.html#details">More...</a><br /></td></tr>
<tr class="memitem:SameOperandsAndResultRank" id="r_SameOperandsAndResultRank"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsAndResultRank.html">SameOperandsAndResultRank</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that op has same ranks for all operands and results types, if known.  <a href="classmlir_1_1OpTrait_1_1SameOperandsAndResultRank.html#details">More...</a><br /></td></tr>
<tr class="memitem:SameOperandsAndResultShape" id="r_SameOperandsAndResultShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsAndResultShape.html">SameOperandsAndResultShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand and result shape: both are scalars, vectors/tensors of the same shape.  <a href="classmlir_1_1OpTrait_1_1SameOperandsAndResultShape.html#details">More...</a><br /></td></tr>
<tr class="memitem:SameOperandsAndResultType" id="r_SameOperandsAndResultType"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsAndResultType.html">SameOperandsAndResultType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand and result type.  <a href="classmlir_1_1OpTrait_1_1SameOperandsAndResultType.html#details">More...</a><br /></td></tr>
<tr class="memitem:SameOperandsElementType" id="r_SameOperandsElementType"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsElementType.html">SameOperandsElementType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand element type (or the type itself if it is scalar).  <a href="classmlir_1_1OpTrait_1_1SameOperandsElementType.html#details">More...</a><br /></td></tr>
<tr class="memitem:SameOperandsShape" id="r_SameOperandsShape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsShape.html">SameOperandsShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand shape: all operands are scalars, vectors/tensors of the same shape.  <a href="classmlir_1_1OpTrait_1_1SameOperandsShape.html#details">More...</a><br /></td></tr>
<tr class="memitem:SameTypeOperands" id="r_SameTypeOperands"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameTypeOperands.html">SameTypeOperands</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that all operands of the specified op have the same type.  <a href="classmlir_1_1OpTrait_1_1SameTypeOperands.html#details">More...</a><br /></td></tr>
<tr class="memitem:Scalarizable" id="r_Scalarizable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1Scalarizable.html">Scalarizable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait tags <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Elementwise.html" title="This trait tags element-wise ops on vectors or tensors.">Elementwise</a></span> operatons that can be systematically scalarized.  <a href="structmlir_1_1OpTrait_1_1Scalarizable.html#details">More...</a><br /></td></tr>
<tr class="memitem:SingleBlock" id="r_SingleBlock"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1SingleBlock.html">SingleBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs and verifiers for ops with regions having a single block.  <a href="structmlir_1_1OpTrait_1_1SingleBlock.html#details">More...</a><br /></td></tr>
<tr class="memitem:SingleBlockImplicitTerminator" id="r_SingleBlockImplicitTerminator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1SingleBlockImplicitTerminator.html">SingleBlockImplicitTerminator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs and verifiers for ops with regions having a single block that must terminate with <span class="tt">TerminatorOpType</span>.  <a href="structmlir_1_1OpTrait_1_1SingleBlockImplicitTerminator.html#details">More...</a><br /></td></tr>
<tr class="memitem:SymbolTable" id="r_SymbolTable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SymbolTable.html">SymbolTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait used to provide symbol table functionalities to a region operation.  <a href="classmlir_1_1OpTrait_1_1SymbolTable.html#details">More...</a><br /></td></tr>
<tr class="memitem:Tensorizable" id="r_Tensorizable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1Tensorizable.html">Tensorizable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait tags <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Elementwise.html" title="This trait tags element-wise ops on vectors or tensors.">Elementwise</a></span> operatons that can be systematically tensorized.  <a href="structmlir_1_1OpTrait_1_1Tensorizable.html#details">More...</a><br /></td></tr>
<tr class="memitem:TraitBase" id="r_TraitBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html">TraitBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for implementing traits.  <a href="classmlir_1_1OpTrait_1_1TraitBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:VariadicOperands" id="r_VariadicOperands"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1VariadicOperands.html">VariadicOperands</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops which have an unknown number of SSA operands.  <a href="classmlir_1_1OpTrait_1_1VariadicOperands.html#details">More...</a><br /></td></tr>
<tr class="memitem:VariadicRegions" id="r_VariadicRegions"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1VariadicRegions.html">VariadicRegions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops which have an unknown number of regions.  <a href="classmlir_1_1OpTrait_1_1VariadicRegions.html#details">More...</a><br /></td></tr>
<tr class="memitem:VariadicResults" id="r_VariadicResults"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1VariadicResults.html">VariadicResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops which have an unknown number of results.  <a href="classmlir_1_1OpTrait_1_1VariadicResults.html#details">More...</a><br /></td></tr>
<tr class="memitem:VariadicSuccessors" id="r_VariadicSuccessors"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1VariadicSuccessors.html">VariadicSuccessors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops which have an unknown number of successors.  <a href="classmlir_1_1OpTrait_1_1VariadicSuccessors.html#details">More...</a><br /></td></tr>
<tr class="memitem:Vectorizable" id="r_Vectorizable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1Vectorizable.html">Vectorizable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait tags <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Elementwise.html" title="This trait tags element-wise ops on vectors or tensors.">Elementwise</a></span> operatons that can be systematically vectorized.  <a href="structmlir_1_1OpTrait_1_1Vectorizable.html#details">More...</a><br /></td></tr>
<tr class="memitem:ZeroOperands" id="r_ZeroOperands"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ZeroOperands.html">ZeroOperands</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have no SSA operand.  <a href="classmlir_1_1OpTrait_1_1ZeroOperands.html#details">More...</a><br /></td></tr>
<tr class="memitem:ZeroRegions" id="r_ZeroRegions"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ZeroRegions.html">ZeroRegions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have zero regions.  <a href="classmlir_1_1OpTrait_1_1ZeroRegions.html#details">More...</a><br /></td></tr>
<tr class="memitem:ZeroResults" id="r_ZeroResults"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ZeroResults.html">ZeroResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides return value APIs for ops that are known to have zero results.  <a href="classmlir_1_1OpTrait_1_1ZeroResults.html#details">More...</a><br /></td></tr>
<tr class="memitem:ZeroSuccessors" id="r_ZeroSuccessors"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ZeroSuccessors.html">ZeroSuccessors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have zero successors.  <a href="classmlir_1_1OpTrait_1_1ZeroSuccessors.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4c5fad6da649fd35570ab4588816c6ac" id="r_a4c5fad6da649fd35570ab4588816c6ac"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a4c5fad6da649fd35570ab4588816c6ac template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c5fad6da649fd35570ab4588816c6ac">has_implicit_terminator_t</a> = typename T::ImplicitTerminatorOpT</td></tr>
<tr class="memdesc:a4c5fad6da649fd35570ab4588816c6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check is an op defines the <span class="tt">ImplicitTerminatorOpT</span> member.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0c5480822c4898f287f588dfe98d1c85" id="r_a0c5480822c4898f287f588dfe98d1c85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c5480822c4898f287f588dfe98d1c85">hasElementwiseMappableTraits</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a0c5480822c4898f287f588dfe98d1c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Together, <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Elementwise.html" title="This trait tags element-wise ops on vectors or tensors.">Elementwise</a></span>, <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Scalarizable.html" title="This trait tags Elementwise operatons that can be systematically scalarized.">Scalarizable</a></span>, <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Vectorizable.html" title="This trait tags Elementwise operatons that can be systematically vectorized.">Vectorizable</a></span>, and <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Tensorizable.html" title="This trait tags Elementwise operatons that can be systematically tensorized.">Tensorizable</a></span> provide an easy way for scalar operations to conveniently generalize their behavior to vectors/tensors, and systematize conversion between these forms.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a4c5fad6da649fd35570ab4588816c6ac" name="a4c5fad6da649fd35570ab4588816c6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5fad6da649fd35570ab4588816c6ac">&#9670;&#160;</a></span>has_implicit_terminator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4c5fad6da649fd35570ab4588816c6ac">mlir::OpTrait::has_implicit_terminator_t</a> = typename T::ImplicitTerminatorOpT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check is an op defines the <span class="tt">ImplicitTerminatorOpT</span> member. </p>
<p>This is intended to be used with <span class="tt">llvm::is_detected</span>. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01024">1024</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a0c5480822c4898f287f588dfe98d1c85" name="a0c5480822c4898f287f588dfe98d1c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5480822c4898f287f588dfe98d1c85">&#9670;&#160;</a></span>hasElementwiseMappableTraits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::OpTrait::hasElementwiseMappableTraits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Together, <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Elementwise.html" title="This trait tags element-wise ops on vectors or tensors.">Elementwise</a></span>, <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Scalarizable.html" title="This trait tags Elementwise operatons that can be systematically scalarized.">Scalarizable</a></span>, <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Vectorizable.html" title="This trait tags Elementwise operatons that can be systematically vectorized.">Vectorizable</a></span>, and <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Tensorizable.html" title="This trait tags Elementwise operatons that can be systematically tensorized.">Tensorizable</a></span> provide an easy way for scalar operations to conveniently generalize their behavior to vectors/tensors, and systematize conversion between these forms. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Operation_8cpp_source.html#l01390">1390</a> of file <a class="el" href="IR_2Operation_8cpp_source.html">Operation.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVConversion_8cpp_source.html#l01462">mlir::spirv::getNativeVectorShape()</a>, <a class="el" href="GPUTransformOps_8cpp_source.html#l00213">getSubgroupMmaNativeVectorSize()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00201">mlir::linalg::hasOnlyScalarElementwiseOp()</a>, <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00027">isElementwiseMappableOpOnRankedTensors()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01337">vectorizeOneOp()</a>, and <a class="el" href="classmlir_1_1xegpu_1_1impl_1_1XeGPUWgToSgDistributeBase.html#a1ccbe8201a22af02bb5ea4d6b9cd042a">mlir::xegpu::impl::XeGPUWgToSgDistributeBase&lt; DerivedT &gt;::~XeGPUWgToSgDistributeBase()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
