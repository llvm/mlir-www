<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Affine/Transforms/LoopFusion.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a href="dir_30022079959872f4a1874dfcab7bb1fc.html">Affine</a></li><li class="navelem"><a href="dir_20e768baa5d01a8ee51c7c9b68e644ce.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">LoopFusion.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Dialect_2Affine_2Passes_8h_source.html">mlir/Dialect/Affine/Passes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineStructures_8h_source.html">mlir/Dialect/Affine/Analysis/AffineStructures.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopAnalysis_8h_source.html">mlir/Dialect/Affine/Analysis/LoopAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">mlir/Dialect/Affine/Analysis/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopFusionUtils_8h_source.html">mlir/Dialect/Affine/LoopFusionUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopUtils_8h_source.html">mlir/Dialect/Affine/LoopUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Affine_2Utils_8h_source.html">mlir/Dialect/Affine/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2MemRef_2IR_2MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">mlir/IR/AffineExpr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineMap_8h_source.html">mlir/IR/AffineMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Builders_8h_source.html">mlir/IR/Builders.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/DenseMap.h&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/Support/CommandLine.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
<code>#include &quot;llvm/Support/DebugLog.h&quot;</code><br />
<code>#include &quot;llvm/Support/raw_ostream.h&quot;</code><br />
<code>#include &lt;iomanip&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &quot;mlir/Dialect/Affine/Passes.h.inc&quot;</code><br />
</div>
<p><a href="LoopFusion_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:mlir_3A_3Aaffine_3A_3Aimpl_3A_3AAffineLoopFusionBase_3C_20DerivedT_20_3E" id="r_mlir_3A_3Aaffine_3A_3Aimpl_3A_3AAffineLoopFusionBase_3C_20DerivedT_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1impl_1_1AffineLoopFusionBase.html">mlir::affine::impl::AffineLoopFusionBase&lt; DerivedT &gt;</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:mlir" id="r_mlir"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="memitem:mlir_3A_3Aaffine" id="r_mlir_3A_3Aaffine"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html">mlir::affine</a></td></tr>
<tr class="memitem:mlir_3A_3Aaffine_3A_3Aimpl" id="r_mlir_3A_3Aaffine_3A_3Aimpl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine_1_1impl.html">mlir::affine::impl</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a5625d45190429949682e481ca9e71fa3" id="r_a5625d45190429949682e481ca9e71fa3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5625d45190429949682e481ca9e71fa3">GEN_PASS_DEF_AFFINELOOPFUSION</a></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d" id="r_ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;affine-fusion&quot;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad080a47dc9767a288da575eddd2482d7" id="r_ad080a47dc9767a288da575eddd2482d7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad080a47dc9767a288da575eddd2482d7">canRemoveSrcNodeAfterFusion</a> (<a class="el" href="classunsigned.html">unsigned</a> srcId, <a class="el" href="classunsigned.html">unsigned</a> dstId, const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;fusionSlice, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *fusedLoopInsPoint, const <a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;escapingMemRefs, const <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;mdg)</td></tr>
<tr class="memdesc:ad080a47dc9767a288da575eddd2482d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if node 'srcId' can be removed after fusing it with node 'dstId'.  <br /></td></tr>
<tr class="memitem:a780e9cd601e0939ffe078229d4da4897" id="r_a780e9cd601e0939ffe078229d4da4897"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a780e9cd601e0939ffe078229d4da4897">getProducerCandidates</a> (<a class="el" href="classunsigned.html">unsigned</a> dstId, const <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;mdg, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;srcIdCandidates)</td></tr>
<tr class="memdesc:a780e9cd601e0939ffe078229d4da4897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'srcIdCandidates' the producer fusion candidates for consumer 'dstId'.  <br /></td></tr>
<tr class="memitem:ae8734b91aa5f22990be85d662b70cc7b" id="r_ae8734b91aa5f22990be85d662b70cc7b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8734b91aa5f22990be85d662b70cc7b">gatherProducerConsumerMemrefs</a> (<a class="el" href="classunsigned.html">unsigned</a> srcId, <a class="el" href="classunsigned.html">unsigned</a> dstId, const <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;mdg, <a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;producerConsumerMemrefs)</td></tr>
<tr class="memdesc:ae8734b91aa5f22990be85d662b70cc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'producerConsumerMemrefs' the memrefs involved in a producer-consumer dependence between 'srcId' and 'dstId'.  <br /></td></tr>
<tr class="memitem:aa6dcdb4f38b90b6d61e0a4e56d754d0a" id="r_aa6dcdb4f38b90b6d61e0a4e56d754d0a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6dcdb4f38b90b6d61e0a4e56d754d0a">isEscapingMemref</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> memref, <a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:aa6dcdb4f38b90b6d61e0a4e56d754d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memref escapes in the context of the fusion pass if either:  <br /></td></tr>
<tr class="memitem:ae124344b5ba3c49778b95f91c643fea0" id="r_ae124344b5ba3c49778b95f91c643fea0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae124344b5ba3c49778b95f91c643fea0">gatherEscapingMemrefs</a> (<a class="el" href="classunsigned.html">unsigned</a> id, const <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;mdg, <a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;escapingMemRefs)</td></tr>
<tr class="memdesc:ae124344b5ba3c49778b95f91c643fea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'escapingMemRefs' the memrefs from affine store ops in node 'id' that escape the block or are accessed in a non-affine way.  <br /></td></tr>
<tr class="memitem:aeea7018d373460b6bd2c29760b2c4390" id="r_aeea7018d373460b6bd2c29760b2c4390"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeea7018d373460b6bd2c29760b2c4390">sinkSequentialLoops</a> (<a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">MemRefDependenceGraph::Node</a> *node)</td></tr>
<tr class="memitem:a85f9f0eb1d87eccc182b1b1b10c59c91" id="r_a85f9f0eb1d87eccc182b1b1b10c59c91"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85f9f0eb1d87eccc182b1b1b10c59c91">getDominanceFilterForPrivateMemRefRepl</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *sliceInsertionBlock, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; producerStores)</td></tr>
<tr class="memdesc:a85f9f0eb1d87eccc182b1b1b10c59c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the operation that should act as a dominance filter while replacing memref uses with a private memref for which <span class="tt">producerStores</span> and <span class="tt">sliceInsertionBlock</span> are provided.  <br /></td></tr>
<tr class="memitem:ac36644b96cdb12294f478d9214b4a673" id="r_ac36644b96cdb12294f478d9214b4a673"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac36644b96cdb12294f478d9214b4a673">getAdditionalComputeFraction</a> (AffineForOp srcForOp, AffineForOp dstForOp, <a class="el" href="classunsigned.html">unsigned</a> depth, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &gt; depthSliceUnions, <a class="el" href="classint64__t.html">int64_t</a> &amp;sliceCost, <a class="el" href="classint64__t.html">int64_t</a> &amp;fusedLoopNestComputeCost)</td></tr>
<tr class="memdesc:ac36644b96cdb12294f478d9214b4a673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of additional (redundant) computation that will be done as a fraction of the total computation if <span class="tt">srcForOp</span> is fused into <span class="tt">dstForOp</span> at depth <span class="tt">depth</span>.  <br /></td></tr>
<tr class="memitem:ad48914db7d780253b07ba8fe5257b977" id="r_ad48914db7d780253b07ba8fe5257b977"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad48914db7d780253b07ba8fe5257b977">createPrivateMemRef</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; storeOps, <a class="el" href="classunsigned.html">unsigned</a> dstLoopDepth, std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; fastMemorySpace, <a class="el" href="classmlir_1_1Block.html">Block</a> *sliceInsertionBlock, uint64_t localBufSizeThreshold)</td></tr>
<tr class="memitem:aa1e7f1676d78b5805b24689f77174dcc" id="r_aa1e7f1676d78b5805b24689f77174dcc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1e7f1676d78b5805b24689f77174dcc">isFusionProfitable</a> (AffineForOp srcForOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; producerStores, AffineForOp dstForOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &gt; depthSliceUnions, <a class="el" href="classunsigned.html">unsigned</a> maxLegalFusionDepth, <a class="el" href="classunsigned.html">unsigned</a> *dstLoopDepth, double computeToleranceThreshold)</td></tr>
</table>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&#160;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;affine-fusion&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00042">42</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

</div>
</div>
<a id="a5625d45190429949682e481ca9e71fa3" name="a5625d45190429949682e481ca9e71fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5625d45190429949682e481ca9e71fa3">&#9670;&#160;</a></span>GEN_PASS_DEF_AFFINELOOPFUSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEN_PASS_DEF_AFFINELOOPFUSION</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00037">37</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ad080a47dc9767a288da575eddd2482d7" name="ad080a47dc9767a288da575eddd2482d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad080a47dc9767a288da575eddd2482d7">&#9670;&#160;</a></span>canRemoveSrcNodeAfterFusion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> canRemoveSrcNodeAfterFusion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>srcId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dstId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fusionSlice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>fusedLoopInsPoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>escapingMemRefs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mdg</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if node 'srcId' can be removed after fusing it with node 'dstId'. </p>
<p>The node can be removed if any of the following conditions are met:</p><ol type="1">
<li>'srcId' has no output dependences after fusion and no escaping memrefs.</li>
<li>'srcId' has no output dependences after fusion, has escaping memrefs and the fusion slice is maximal.</li>
<li>'srcId' has output dependences after fusion, the fusion slice is maximal and the fusion insertion point dominates all the dependences. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00076">76</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00452">mlir::affine::MemRefDependenceGraph::getNode()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00383">mlir::Operation::isBeforeInBlock()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01106">mlir::affine::ComputationSliceState::isMaximal()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00071">mlir::affine::MemRefDependenceGraph::Node::op</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00147">mlir::affine::MemRefDependenceGraph::outEdges</a>.</p>

</div>
</div>
<a id="ad48914db7d780253b07ba8fe5257b977" name="ad48914db7d780253b07ba8fe5257b977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48914db7d780253b07ba8fe5257b977">&#9670;&#160;</a></span>createPrivateMemRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> createPrivateMemRef </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>storeOps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dstLoopDepth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>fastMemorySpace</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>sliceInsertionBlock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>localBufSizeThreshold</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00333">333</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01160">mlir::affine::MemRefRegion::getConstantBoundingSizeAndShape()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00535">mlir::affine::MemRefRegion::getConstraints()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00244">getDominanceFilterForPrivateMemRefRepl()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01419">mlir::affine::getMemRefIntOrFloatEltSizeInBytes()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00232">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00238">mlir::Operation::getParentOfType()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00364">mlir::FlatLinearValueConstraints::getValues()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01612">mlir::simplifyAffineExpr()</a>.</p>

</div>
</div>
<a id="ae124344b5ba3c49778b95f91c643fea0" name="ae124344b5ba3c49778b95f91c643fea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae124344b5ba3c49778b95f91c643fea0">&#9670;&#160;</a></span>gatherEscapingMemrefs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> gatherEscapingMemrefs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mdg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>escapingMemRefs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns in 'escapingMemRefs' the memrefs from affine store ops in node 'id' that escape the block or are accessed in a non-affine way. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00216">216</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00270">mlir::affine::MemRefDependenceGraph::block</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00452">mlir::affine::MemRefDependenceGraph::getNode()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l00185">isEscapingMemref()</a>.</p>

</div>
</div>
<a id="ae8734b91aa5f22990be85d662b70cc7b" name="ae8734b91aa5f22990be85d662b70cc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8734b91aa5f22990be85d662b70cc7b">&#9670;&#160;</a></span>gatherProducerConsumerMemrefs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> gatherProducerConsumerMemrefs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>srcId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dstId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mdg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producerConsumerMemrefs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns in 'producerConsumerMemrefs' the memrefs involved in a producer-consumer dependence between 'srcId' and 'dstId'. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00169">169</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopFusionUtils_8cpp_source.html#l00639">mlir::affine::gatherProducerConsumerMemrefs()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00452">mlir::affine::MemRefDependenceGraph::getNode()</a>.</p>

</div>
</div>
<a id="ac36644b96cdb12294f478d9214b4a673" name="ac36644b96cdb12294f478d9214b4a673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36644b96cdb12294f478d9214b4a673">&#9670;&#160;</a></span>getAdditionalComputeFraction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; getAdditionalComputeFraction </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>srcForOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>dstForOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>depthSliceUnions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sliceCost</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fusedLoopNestComputeCost</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the amount of additional (redundant) computation that will be done as a fraction of the total computation if <span class="tt">srcForOp</span> is fused into <span class="tt">dstForOp</span> at depth <span class="tt">depth</span>. </p>
<p>The method returns the compute cost of the slice and the fused nest's compute cost in the trailing output arguments. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00279">279</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00500">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a85f9f0eb1d87eccc182b1b1b10c59c91" name="a85f9f0eb1d87eccc182b1b1b10c59c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f9f0eb1d87eccc182b1b1b10c59c91">&#9670;&#160;</a></span>getDominanceFilterForPrivateMemRefRepl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * getDominanceFilterForPrivateMemRefRepl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>sliceInsertionBlock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>producerStores</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the operation that should act as a dominance filter while replacing memref uses with a private memref for which <span class="tt">producerStores</span> and <span class="tt">sliceInsertionBlock</span> are provided. </p>
<p>This effectively determines in what part of the IR we should be performing the replacement. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00244">244</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00333">createPrivateMemRef()</a>.</p>

</div>
</div>
<a id="a780e9cd601e0939ffe078229d4da4897" name="a780e9cd601e0939ffe078229d4da4897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780e9cd601e0939ffe078229d4da4897">&#9670;&#160;</a></span>getProducerCandidates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> getProducerCandidates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dstId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mdg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>srcIdCandidates</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns in 'srcIdCandidates' the producer fusion candidates for consumer 'dstId'. </p>
<p>Candidates are sorted by node id order. This order corresponds to the program order when the 'mdg' is created. However, program order is not guaranteed and must not be required by the client. Program order won't be held if the 'mdg' is reused from a previous fusion step or if the node creation order changes in the future to support more advance cases. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00134">134</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00246">getMemRef()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00452">mlir::affine::MemRefDependenceGraph::getNode()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00144">mlir::affine::MemRefDependenceGraph::inEdges</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01923">load</a>.</p>

</div>
</div>
<a id="aa6dcdb4f38b90b6d61e0a4e56d754d0a" name="aa6dcdb4f38b90b6d61e0a4e56d754d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6dcdb4f38b90b6d61e0a4e56d754d0a">&#9670;&#160;</a></span>isEscapingMemref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isEscapingMemref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>memref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A memref escapes in the context of the fusion pass if either: </p>
<ol type="1">
<li>it (or its alias) is a block argument, or</li>
<li>created by an op not known to guarantee alias freedom,</li>
<li>it (or its alias) are used by ops other than affine dereferencing ops (e.g., by call op, memref load/store ops, alias creating ops, unknown ops, terminator ops, etc.); such ops do not deference the memref in an affine way. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00185">185</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00113">mlir::hasSingleEffect()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l00185">isEscapingMemref()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00216">gatherEscapingMemrefs()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l00185">isEscapingMemref()</a>.</p>

</div>
</div>
<a id="aa1e7f1676d78b5805b24689f77174dcc" name="aa1e7f1676d78b5805b24689f77174dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e7f1676d78b5805b24689f77174dcc">&#9670;&#160;</a></span>isFusionProfitable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isFusionProfitable </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>srcForOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>producerStores</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>dstForOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>depthSliceUnions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>maxLegalFusionDepth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *</td>          <td class="paramname"><span class="paramname"><em>dstLoopDepth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>computeToleranceThreshold</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00500">500</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00279">getAdditionalComputeFraction()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00563">mlir::affine::getComputeCost()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00474">mlir::affine::getLoopNestStats()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02173">mlir::affine::getMemoryFootprintBytes()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01438">mlir::affine::MemRefRegion::getRegionSize()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00350">mlir::affine::ComputationSliceState::isEmpty()</a>.</p>

</div>
</div>
<a id="aeea7018d373460b6bd2c29760b2c4390" name="aeea7018d373460b6bd2c29760b2c4390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea7018d373460b6bd2c29760b2c4390">&#9670;&#160;</a></span>sinkSequentialLoops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> sinkSequentialLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">MemRefDependenceGraph::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00233">233</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00071">mlir::affine::MemRefDependenceGraph::Node::op</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01453">mlir::affine::sinkSequentialLoops()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
