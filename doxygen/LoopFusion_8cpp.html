<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Affine/Transforms/LoopFusion.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_30022079959872f4a1874dfcab7bb1fc.html">Affine</a></li><li class="navelem"><a class="el" href="dir_20e768baa5d01a8ee51c7c9b68e644ce.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">LoopFusion.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Dialect_2Affine_2Passes_8h_source.html">mlir/Dialect/Affine/Passes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineStructures_8h_source.html">mlir/Dialect/Affine/Analysis/AffineStructures.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopAnalysis_8h_source.html">mlir/Dialect/Affine/Analysis/LoopAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">mlir/Dialect/Affine/Analysis/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopFusionUtils_8h_source.html">mlir/Dialect/Affine/LoopFusionUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopUtils_8h_source.html">mlir/Dialect/Affine/LoopUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Affine_2Utils_8h_source.html">mlir/Dialect/Affine/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2MemRef_2IR_2MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">mlir/IR/AffineExpr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineMap_8h_source.html">mlir/IR/AffineMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Builders_8h_source.html">mlir/IR/Builders.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/DenseMap.h&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/Support/CommandLine.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
<code>#include &quot;llvm/Support/raw_ostream.h&quot;</code><br />
<code>#include &lt;iomanip&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &quot;mlir/Dialect/Affine/Passes.h.inc&quot;</code><br />
</div>
<p><a href="LoopFusion_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1affine"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html">mlir::affine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a5625d45190429949682e481ca9e71fa3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#a5625d45190429949682e481ca9e71fa3">GEN_PASS_DEF_AFFINELOOPFUSION</a></td></tr>
<tr class="separator:a5625d45190429949682e481ca9e71fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;affine-fusion&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad080a47dc9767a288da575eddd2482d7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#ad080a47dc9767a288da575eddd2482d7">canRemoveSrcNodeAfterFusion</a> (unsigned srcId, unsigned dstId, const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;fusionSlice, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *fusedLoopInsPoint, const <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;escapingMemRefs, const <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;mdg)</td></tr>
<tr class="memdesc:ad080a47dc9767a288da575eddd2482d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if node 'srcId' can be removed after fusing it with node 'dstId'.  <a href="LoopFusion_8cpp.html#ad080a47dc9767a288da575eddd2482d7">More...</a><br /></td></tr>
<tr class="separator:ad080a47dc9767a288da575eddd2482d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780e9cd601e0939ffe078229d4da4897"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#a780e9cd601e0939ffe078229d4da4897">getProducerCandidates</a> (unsigned dstId, const <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;mdg, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; &amp;srcIdCandidates)</td></tr>
<tr class="memdesc:a780e9cd601e0939ffe078229d4da4897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'srcIdCandidates' the producer fusion candidates for consumer 'dstId'.  <a href="LoopFusion_8cpp.html#a780e9cd601e0939ffe078229d4da4897">More...</a><br /></td></tr>
<tr class="separator:a780e9cd601e0939ffe078229d4da4897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8734b91aa5f22990be85d662b70cc7b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#ae8734b91aa5f22990be85d662b70cc7b">gatherProducerConsumerMemrefs</a> (unsigned srcId, unsigned dstId, const <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;mdg, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;producerConsumerMemrefs)</td></tr>
<tr class="memdesc:ae8734b91aa5f22990be85d662b70cc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'producerConsumerMemrefs' the memrefs involved in a producer-consumer dependence between 'srcId' and 'dstId'.  <a href="LoopFusion_8cpp.html#ae8734b91aa5f22990be85d662b70cc7b">More...</a><br /></td></tr>
<tr class="separator:ae8734b91aa5f22990be85d662b70cc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dcdb4f38b90b6d61e0a4e56d754d0a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#aa6dcdb4f38b90b6d61e0a4e56d754d0a">isEscapingMemref</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> memref, <a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:aa6dcdb4f38b90b6d61e0a4e56d754d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memref escapes in the context of the fusion pass if either:  <a href="LoopFusion_8cpp.html#aa6dcdb4f38b90b6d61e0a4e56d754d0a">More...</a><br /></td></tr>
<tr class="separator:aa6dcdb4f38b90b6d61e0a4e56d754d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae124344b5ba3c49778b95f91c643fea0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#ae124344b5ba3c49778b95f91c643fea0">gatherEscapingMemrefs</a> (unsigned id, const <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;mdg, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;escapingMemRefs)</td></tr>
<tr class="memdesc:ae124344b5ba3c49778b95f91c643fea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'escapingMemRefs' the memrefs from affine store ops in node 'id' that escape the block or are accessed in a non-affine way.  <a href="LoopFusion_8cpp.html#ae124344b5ba3c49778b95f91c643fea0">More...</a><br /></td></tr>
<tr class="separator:ae124344b5ba3c49778b95f91c643fea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea7018d373460b6bd2c29760b2c4390"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#aeea7018d373460b6bd2c29760b2c4390">sinkSequentialLoops</a> (<a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">MemRefDependenceGraph::Node</a> *node)</td></tr>
<tr class="separator:aeea7018d373460b6bd2c29760b2c4390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df1163cb951a363fdc20fef29e6c2ca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#a1df1163cb951a363fdc20fef29e6c2ca">getDominanceFilterForPrivateMemRefRepl</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *sliceInsertionBlock, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; producerStores)</td></tr>
<tr class="memdesc:a1df1163cb951a363fdc20fef29e6c2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the operation that should act as a dominance filter while replacing memref uses with a private memref for which <code>producerStores</code> and <code>sliceInsertionBlock</code> are provided.  <a href="LoopFusion_8cpp.html#a1df1163cb951a363fdc20fef29e6c2ca">More...</a><br /></td></tr>
<tr class="separator:a1df1163cb951a363fdc20fef29e6c2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4251d70ddd03b23343909b482b4d55"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#aee4251d70ddd03b23343909b482b4d55">getAdditionalComputeFraction</a> (AffineForOp srcForOp, AffineForOp dstForOp, unsigned depth, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &gt; depthSliceUnions, int64_t &amp;sliceCost, int64_t &amp;fusedLoopNestComputeCost)</td></tr>
<tr class="memdesc:aee4251d70ddd03b23343909b482b4d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of additional (redundant) computation that will be done as a fraction of the total computation if <code>srcForOp</code> is fused into <code>dstForOp</code> at depth <code>depth</code>.  <a href="LoopFusion_8cpp.html#aee4251d70ddd03b23343909b482b4d55">More...</a><br /></td></tr>
<tr class="separator:aee4251d70ddd03b23343909b482b4d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48914db7d780253b07ba8fe5257b977"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#ad48914db7d780253b07ba8fe5257b977">createPrivateMemRef</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; storeOps, unsigned dstLoopDepth, std::optional&lt; unsigned &gt; fastMemorySpace, <a class="el" href="classmlir_1_1Block.html">Block</a> *sliceInsertionBlock, uint64_t localBufSizeThreshold)</td></tr>
<tr class="separator:ad48914db7d780253b07ba8fe5257b977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e7f1676d78b5805b24689f77174dcc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LoopFusion_8cpp.html#aa1e7f1676d78b5805b24689f77174dcc">isFusionProfitable</a> (AffineForOp srcForOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; producerStores, AffineForOp dstForOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &gt; depthSliceUnions, unsigned maxLegalFusionDepth, unsigned *dstLoopDepth, double computeToleranceThreshold)</td></tr>
<tr class="separator:aa1e7f1676d78b5805b24689f77174dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;affine-fusion&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00041">41</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

</div>
</div>
<a id="a5625d45190429949682e481ca9e71fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5625d45190429949682e481ca9e71fa3">&#9670;&nbsp;</a></span>GEN_PASS_DEF_AFFINELOOPFUSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEN_PASS_DEF_AFFINELOOPFUSION</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00036">36</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad080a47dc9767a288da575eddd2482d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad080a47dc9767a288da575eddd2482d7">&#9670;&nbsp;</a></span>canRemoveSrcNodeAfterFusion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool canRemoveSrcNodeAfterFusion </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>srcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;&#160;</td>
          <td class="paramname"><em>fusionSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>fusedLoopInsPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>escapingMemRefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>mdg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if node 'srcId' can be removed after fusing it with node 'dstId'. </p>
<p>The node can be removed if any of the following conditions are met:</p><ol type="1">
<li>'srcId' has no output dependences after fusion and no escaping memrefs.</li>
<li>'srcId' has no output dependences after fusion, has escaping memrefs and the fusion slice is maximal.</li>
<li>'srcId' has output dependences after fusion, the fusion slice is maximal and the fusion insertion point dominates all the dependences. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00075">75</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00356">mlir::affine::MemRefDependenceGraph::getNode()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00385">mlir::Operation::isBeforeInBlock()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01011">mlir::affine::ComputationSliceState::isMaximal()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00071">mlir::affine::MemRefDependenceGraph::Node::op</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00147">mlir::affine::MemRefDependenceGraph::outEdges</a>.</p>

</div>
</div>
<a id="ad48914db7d780253b07ba8fe5257b977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48914db7d780253b07ba8fe5257b977">&#9670;&nbsp;</a></span>createPrivateMemRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> createPrivateMemRef </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>storeOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>fastMemorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>sliceInsertionBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>localBufSizeThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00332">332</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01162">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00619">mlir::getAffineDimExpr()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01065">mlir::affine::MemRefRegion::getConstantBoundingSizeAndShape()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00527">mlir::affine::MemRefRegion::getConstraints()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00243">getDominanceFilterForPrivateMemRefRepl()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01326">mlir::affine::getMemRefIntOrFloatEltSizeInBytes()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00217">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00238">mlir::Operation::getParentOfType()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00364">mlir::FlatLinearValueConstraints::getValues()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01306">mlir::affine::replaceAllMemRefUsesWith()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01612">mlir::simplifyAffineExpr()</a>.</p>

</div>
</div>
<a id="ae124344b5ba3c49778b95f91c643fea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae124344b5ba3c49778b95f91c643fea0">&#9670;&nbsp;</a></span>gatherEscapingMemrefs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gatherEscapingMemrefs </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>mdg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>escapingMemRefs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns in 'escapingMemRefs' the memrefs from affine store ops in node 'id' that escape the block or are accessed in a non-affine way. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00215">215</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00262">mlir::affine::MemRefDependenceGraph::block</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00356">mlir::affine::MemRefDependenceGraph::getNode()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l00185">isEscapingMemref()</a>.</p>

</div>
</div>
<a id="ae8734b91aa5f22990be85d662b70cc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8734b91aa5f22990be85d662b70cc7b">&#9670;&nbsp;</a></span>gatherProducerConsumerMemrefs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gatherProducerConsumerMemrefs </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>srcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>mdg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>producerConsumerMemrefs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns in 'producerConsumerMemrefs' the memrefs involved in a producer-consumer dependence between 'srcId' and 'dstId'. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00169">169</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopFusionUtils_8cpp_source.html#l00638">mlir::affine::gatherProducerConsumerMemrefs()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00356">mlir::affine::MemRefDependenceGraph::getNode()</a>.</p>

</div>
</div>
<a id="aee4251d70ddd03b23343909b482b4d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4251d70ddd03b23343909b482b4d55">&#9670;&nbsp;</a></span>getAdditionalComputeFraction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;double&gt; getAdditionalComputeFraction </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>srcForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>dstForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &gt;&#160;</td>
          <td class="paramname"><em>depthSliceUnions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>sliceCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>fusedLoopNestComputeCost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the amount of additional (redundant) computation that will be done as a fraction of the total computation if <code>srcForOp</code> is fused into <code>dstForOp</code> at depth <code>depth</code>. </p>
<p>The method returns the compute cost of the slice and the fused nest's compute cost in the trailing output arguments. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00278">278</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopFusionUtils_8cpp_source.html#l00562">mlir::affine::getComputeCost()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00573">mlir::affine::getFusionComputeCost()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00473">mlir::affine::getLoopNestStats()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00342">mlir::affine::ComputationSliceState::isEmpty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00501">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a1df1163cb951a363fdc20fef29e6c2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df1163cb951a363fdc20fef29e6c2ca">&#9670;&nbsp;</a></span>getDominanceFilterForPrivateMemRefRepl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Operation.html">Operation</a>* getDominanceFilterForPrivateMemRefRepl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>sliceInsertionBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>producerStores</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the operation that should act as a dominance filter while replacing memref uses with a private memref for which <code>producerStores</code> and <code>sliceInsertionBlock</code> are provided. </p>
<p>This effectively determines in what part of the IR we should be performing the replacement. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00243">243</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00143">mlir::Block::begin()</a>, <a class="el" href="Block_8cpp_source.html#l00074">mlir::Block::findAncestorOpInBlock()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02299">mlir::affine::findInnermostCommonBlockInScope()</a>, and <a class="el" href="IR_2Operation_8cpp_source.html#l00385">mlir::Operation::isBeforeInBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00332">createPrivateMemRef()</a>.</p>

</div>
</div>
<a id="a780e9cd601e0939ffe078229d4da4897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780e9cd601e0939ffe078229d4da4897">&#9670;&nbsp;</a></span>getProducerCandidates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void getProducerCandidates </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>mdg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcIdCandidates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns in 'srcIdCandidates' the producer fusion candidates for consumer 'dstId'. </p>
<p>Candidates are sorted by node id order. This order corresponds to the program order when the 'mdg' is created. However, program order is not guaranteed and must not be required by the client. Program order won't be held if the 'mdg' is reused from a previous fusion step or if the node creation order changes in the future to support more advance cases. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00134">134</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00356">mlir::affine::MemRefDependenceGraph::getNode()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00144">mlir::affine::MemRefDependenceGraph::inEdges</a>.</p>

</div>
</div>
<a id="aa6dcdb4f38b90b6d61e0a4e56d754d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6dcdb4f38b90b6d61e0a4e56d754d0a">&#9670;&nbsp;</a></span>isEscapingMemref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isEscapingMemref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A memref escapes in the context of the fusion pass if either: </p>
<ol type="1">
<li>it (or its alias) is a block argument, or</li>
<li>created by an op not known to guarantee alias freedom,</li>
<li>it (or its alias) are used by ops other than affine dereferencing ops (e.g., by call op, memref load/store ops, alias creating ops, unknown ops, terminator ops, etc.); such ops do not deference the memref in an affine way. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00185">185</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, and <a class="el" href="Value_8h_source.html#l00218">mlir::Value::getUsers()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00215">gatherEscapingMemrefs()</a>.</p>

</div>
</div>
<a id="aa1e7f1676d78b5805b24689f77174dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e7f1676d78b5805b24689f77174dcc">&#9670;&nbsp;</a></span>isFusionProfitable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isFusionProfitable </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>srcForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>producerStores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>dstForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &gt;&#160;</td>
          <td class="paramname"><em>depthSliceUnions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxLegalFusionDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>dstLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>computeToleranceThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00501">501</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01162">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00278">getAdditionalComputeFraction()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00562">mlir::affine::getComputeCost()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00473">mlir::affine::getLoopNestStats()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02081">mlir::affine::getMemoryFootprintBytes()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01345">mlir::affine::MemRefRegion::getRegionSize()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00342">mlir::affine::ComputationSliceState::isEmpty()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00212">max()</a>.</p>

</div>
</div>
<a id="aeea7018d373460b6bd2c29760b2c4390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea7018d373460b6bd2c29760b2c4390">&#9670;&nbsp;</a></span>sinkSequentialLoops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sinkSequentialLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">MemRefDependenceGraph::Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00232">232</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00071">mlir::affine::MemRefDependenceGraph::Node::op</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01444">mlir::affine::sinkSequentialLoops()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:28 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
