<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Vector/Transforms/VectorTransferSplitRewritePatterns.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_84ad971b6ccc87b19bc57b4cf8f3f79f.html">Vector</a></li><li class="navelem"><a class="el" href="dir_7b47e7ae615a7c9f8246c22d2b9965e5.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">VectorTransferSplitRewritePatterns.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;optional&gt;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Arith_2IR_2Arith_8h_source.html">mlir/Dialect/Arith/IR/Arith.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Linalg_2IR_2Linalg_8h_source.html">mlir/Dialect/Linalg/IR/Linalg.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2MemRef_2IR_2MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html">mlir/Dialect/SCF/IR/SCF.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StructuredOpsUtils_8h_source.html">mlir/Dialect/Utils/StructuredOpsUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VectorTransforms_8h_source.html">mlir/Dialect/Vector/Transforms/VectorTransforms.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VectorInterfaces_8h_source.html">mlir/Interfaces/VectorInterfaces.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
</div>
<p><a href="VectorTransferSplitRewritePatterns_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="VectorTransferSplitRewritePatterns_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;vector-transfer-split&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7942a579f487abc1c7bab0442f5766da"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="VectorTransferSplitRewritePatterns_8cpp.html#a7942a579f487abc1c7bab0442f5766da">createInBoundsCond</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, VectorTransferOpInterface xferOp)</td></tr>
<tr class="memdesc:a7942a579f487abc1c7bab0442f5766da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the condition to ensure that a particular VectorTransferOpInterface is in-bounds.  <a href="VectorTransferSplitRewritePatterns_8cpp.html#a7942a579f487abc1c7bab0442f5766da">More...</a><br /></td></tr>
<tr class="separator:a7942a579f487abc1c7bab0442f5766da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608b76c3eed0b6350a875901243f748f"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="VectorTransferSplitRewritePatterns_8cpp.html#a608b76c3eed0b6350a875901243f748f">splitFullAndPartialTransferPrecondition</a> (VectorTransferOpInterface xferOp)</td></tr>
<tr class="memdesc:a608b76c3eed0b6350a875901243f748f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a vector.transfer operation into an in-bounds (i.e., no out-of-bounds masking) fast path and a slow path.  <a href="VectorTransferSplitRewritePatterns_8cpp.html#a608b76c3eed0b6350a875901243f748f">More...</a><br /></td></tr>
<tr class="separator:a608b76c3eed0b6350a875901243f748f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7613eea26c6ae61621bf8140ce5e24c0"><td class="memItemLeft" align="right" valign="top">static MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="VectorTransferSplitRewritePatterns_8cpp.html#a7613eea26c6ae61621bf8140ce5e24c0">getCastCompatibleMemRefType</a> (MemRefType aT, MemRefType bT)</td></tr>
<tr class="memdesc:a7613eea26c6ae61621bf8140ce5e24c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two MemRefTypes <code>aT</code> and <code>bT</code>, return a MemRefType to which both can be cast.  <a href="VectorTransferSplitRewritePatterns_8cpp.html#a7613eea26c6ae61621bf8140ce5e24c0">More...</a><br /></td></tr>
<tr class="separator:a7613eea26c6ae61621bf8140ce5e24c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31820a96698023964635f78624b6e8a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="VectorTransferSplitRewritePatterns_8cpp.html#ac31820a96698023964635f78624b6e8a">castToCompatibleMemRefType</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> memref, MemRefType compatibleMemRefType)</td></tr>
<tr class="memdesc:ac31820a96698023964635f78624b6e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the given memref to a compatible memref type.  <a href="VectorTransferSplitRewritePatterns_8cpp.html#ac31820a96698023964635f78624b6e8a">More...</a><br /></td></tr>
<tr class="separator:ac31820a96698023964635f78624b6e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d5348db926142ee393c8a5f6d51169"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="VectorTransferSplitRewritePatterns_8cpp.html#a71d5348db926142ee393c8a5f6d51169">createSubViewIntersection</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, VectorTransferOpInterface xferOp, <a class="el" href="classmlir_1_1Value.html">Value</a> alloc)</td></tr>
<tr class="memdesc:a71d5348db926142ee393c8a5f6d51169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operates under a scoped context to build the intersection between the view <code>xferOp.getbase()</code> @ <code><a class="el" href="namespacemlir_1_1nvgpu.html#ad59722c33205a25c3184235b9519c8bc" title="Get the indices that the given load/store operation is operating on.">xferOp.getIndices()</a></code> and the view <code>alloc</code>.  <a href="VectorTransferSplitRewritePatterns_8cpp.html#a71d5348db926142ee393c8a5f6d51169">More...</a><br /></td></tr>
<tr class="separator:a71d5348db926142ee393c8a5f6d51169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171e94fa064e85ff68e26bb003e10c60"><td class="memItemLeft" align="right" valign="top">static scf::IfOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="VectorTransferSplitRewritePatterns_8cpp.html#a171e94fa064e85ff68e26bb003e10c60">createFullPartialLinalgCopy</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, vector::TransferReadOp xferOp, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> returnTypes, <a class="el" href="classmlir_1_1Value.html">Value</a> inBoundsCond, MemRefType compatibleMemRefType, <a class="el" href="classmlir_1_1Value.html">Value</a> alloc)</td></tr>
<tr class="memdesc:a171e94fa064e85ff68e26bb003e10c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <code>xferOp</code> for which:  <a href="VectorTransferSplitRewritePatterns_8cpp.html#a171e94fa064e85ff68e26bb003e10c60">More...</a><br /></td></tr>
<tr class="separator:a171e94fa064e85ff68e26bb003e10c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6ff4dc1bfcc2fba804057f99bbd632"><td class="memItemLeft" align="right" valign="top">static scf::IfOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="VectorTransferSplitRewritePatterns_8cpp.html#a5e6ff4dc1bfcc2fba804057f99bbd632">createFullPartialVectorTransferRead</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, vector::TransferReadOp xferOp, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> returnTypes, <a class="el" href="classmlir_1_1Value.html">Value</a> inBoundsCond, MemRefType compatibleMemRefType, <a class="el" href="classmlir_1_1Value.html">Value</a> alloc)</td></tr>
<tr class="memdesc:a5e6ff4dc1bfcc2fba804057f99bbd632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <code>xferOp</code> for which:  <a href="VectorTransferSplitRewritePatterns_8cpp.html#a5e6ff4dc1bfcc2fba804057f99bbd632">More...</a><br /></td></tr>
<tr class="separator:a5e6ff4dc1bfcc2fba804057f99bbd632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c340c144e195bcb1f542b16a9293f27"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="VectorTransferSplitRewritePatterns_8cpp.html#a4c340c144e195bcb1f542b16a9293f27">getLocationToWriteFullVec</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, vector::TransferWriteOp xferOp, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> returnTypes, <a class="el" href="classmlir_1_1Value.html">Value</a> inBoundsCond, MemRefType compatibleMemRefType, <a class="el" href="classmlir_1_1Value.html">Value</a> alloc)</td></tr>
<tr class="memdesc:a4c340c144e195bcb1f542b16a9293f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <code>xferOp</code> for which:  <a href="VectorTransferSplitRewritePatterns_8cpp.html#a4c340c144e195bcb1f542b16a9293f27">More...</a><br /></td></tr>
<tr class="separator:a4c340c144e195bcb1f542b16a9293f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbd261290254f9ad7c6f4f69e8e02aa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="VectorTransferSplitRewritePatterns_8cpp.html#a1cbd261290254f9ad7c6f4f69e8e02aa">createFullPartialLinalgCopy</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, vector::TransferWriteOp xferOp, <a class="el" href="classmlir_1_1Value.html">Value</a> inBoundsCond, <a class="el" href="classmlir_1_1Value.html">Value</a> alloc)</td></tr>
<tr class="memdesc:a1cbd261290254f9ad7c6f4f69e8e02aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <code>xferOp</code> for which:  <a href="VectorTransferSplitRewritePatterns_8cpp.html#a1cbd261290254f9ad7c6f4f69e8e02aa">More...</a><br /></td></tr>
<tr class="separator:a1cbd261290254f9ad7c6f4f69e8e02aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c61af9a1c44ec8b2edef25d638bcc1d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="VectorTransferSplitRewritePatterns_8cpp.html#a2c61af9a1c44ec8b2edef25d638bcc1d">createFullPartialVectorTransferWrite</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, vector::TransferWriteOp xferOp, <a class="el" href="classmlir_1_1Value.html">Value</a> inBoundsCond, <a class="el" href="classmlir_1_1Value.html">Value</a> alloc)</td></tr>
<tr class="memdesc:a2c61af9a1c44ec8b2edef25d638bcc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <code>xferOp</code> for which:  <a href="VectorTransferSplitRewritePatterns_8cpp.html#a2c61af9a1c44ec8b2edef25d638bcc1d">More...</a><br /></td></tr>
<tr class="separator:a2c61af9a1c44ec8b2edef25d638bcc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac105ba9f4710accd616d09c98f320a3e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="VectorTransferSplitRewritePatterns_8cpp.html#ac105ba9f4710accd616d09c98f320a3e">getAutomaticAllocationScope</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="separator:ac105ba9f4710accd616d09c98f320a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;vector-transfer-split&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00029">29</a> of file <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html">VectorTransferSplitRewritePatterns.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac31820a96698023964635f78624b6e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31820a96698023964635f78624b6e8a">&#9670;&nbsp;</a></span>castToCompatibleMemRefType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> castToCompatibleMemRefType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>compatibleMemRefType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the given memref to a compatible memref type. </p>
<p>If the source memref has a different address space than the target type, a <code>memref.memory_space_cast</code> is first inserted, followed by a <code>memref.cast</code>. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00165">165</a> of file <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html">VectorTransferSplitRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Value_8cpp_source.html#l00024">mlir::Value::getLoc()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00245">createFullPartialLinalgCopy()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00297">createFullPartialVectorTransferRead()</a>, and <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00345">getLocationToWriteFullVec()</a>.</p>

</div>
</div>
<a id="a171e94fa064e85ff68e26bb003e10c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171e94fa064e85ff68e26bb003e10c60">&#9670;&nbsp;</a></span>createFullPartialLinalgCopy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static scf::IfOp createFullPartialLinalgCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector::TransferReadOp&#160;</td>
          <td class="paramname"><em>xferOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>returnTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>inBoundsCond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>compatibleMemRefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an <code>xferOp</code> for which: </p>
<ol type="1">
<li><code>inBoundsCond</code> and a <code>compatibleMemRefType</code> have been computed.</li>
<li>a memref of single vector <code>alloc</code> has been allocated. Produce IR resembling: <div class="fragment"><div class="line"> %1:3 = scf.if (%inBounds) {</div>
<div class="line">   (memref.memory_space_cast %<a class="code" href="namespacemlir_1_1nvgpu.html#ae4c82fd5e3500e2d345d723829e09efea7fc56270e7a70fa81a5935b72eacbe29">A</a>: memref&lt;<a class="code" href="namespacemlir_1_1nvgpu.html#ae4c82fd5e3500e2d345d723829e09efea7fc56270e7a70fa81a5935b72eacbe29">A</a>..., addr_space&gt; to memref&lt;<a class="code" href="namespacemlir_1_1nvgpu.html#ae4c82fd5e3500e2d345d723829e09efea7fc56270e7a70fa81a5935b72eacbe29">A</a>...&gt;)</div>
<div class="line">   %view = memref.cast %A: memref&lt;A...&gt; to compatibleMemRefType</div>
<div class="line">   scf.yield %view, ... : compatibleMemRefType, index, index</div>
<div class="line"> } <span class="keywordflow">else</span> {</div>
<div class="line">   %2 = linalg.fill(%pad, %alloc)</div>
<div class="line">   %3 = subview %view [...][...][...]</div>
<div class="line">   %4 = subview %alloc [0, 0] [...] [...]</div>
<div class="line">   linalg.copy(%3, %4)</div>
<div class="line">   %5 = memref.cast %alloc: memref&lt;<a class="code" href="namespacemlir_1_1nvgpu.html#ae4c82fd5e3500e2d345d723829e09efea9d5ed678fe57bcca610140957afab571">B</a>...&gt; to compatibleMemRefType</div>
<div class="line">   scf.yield %5, ... : compatibleMemRefType, index, index</div>
<div class="line">}</div>
<div class="ttc" id="anamespacemlir_1_1nvgpu_html_ae4c82fd5e3500e2d345d723829e09efea7fc56270e7a70fa81a5935b72eacbe29"><div class="ttname"><a href="namespacemlir_1_1nvgpu.html#ae4c82fd5e3500e2d345d723829e09efea7fc56270e7a70fa81a5935b72eacbe29">mlir::nvgpu::MatMulOperandRole::A</a></div><div class="ttdeci">@ A</div></div>
<div class="ttc" id="anamespacemlir_1_1nvgpu_html_ae4c82fd5e3500e2d345d723829e09efea9d5ed678fe57bcca610140957afab571"><div class="ttname"><a href="namespacemlir_1_1nvgpu.html#ae4c82fd5e3500e2d345d723829e09efea9d5ed678fe57bcca610140957afab571">mlir::nvgpu::MatMulOperandRole::B</a></div><div class="ttdeci">@ B</div></div>
</div><!-- fragment --> Return the produced scf::IfOp. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00245">245</a> of file <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html">VectorTransferSplitRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00165">castToCompatibleMemRefType()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, and <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00185">createSubViewIntersection()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00509">mlir::vector::splitFullAndPartialTransfer()</a>.</p>

</div>
</div>
<a id="a1cbd261290254f9ad7c6f4f69e8e02aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbd261290254f9ad7c6f4f69e8e02aa">&#9670;&nbsp;</a></span>createFullPartialLinalgCopy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void createFullPartialLinalgCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector::TransferWriteOp&#160;</td>
          <td class="paramname"><em>xferOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>inBoundsCond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an <code>xferOp</code> for which: </p>
<ol type="1">
<li><code>inBoundsCond</code> has been computed.</li>
<li>a memref of single vector <code>alloc</code> has been allocated.</li>
<li>it originally wrote to view Produce IR resembling: <div class="fragment"><div class="line"> %notInBounds = arith.xori %inBounds, %<span class="keyword">true</span></div>
<div class="line"> scf.if (%notInBounds) {</div>
<div class="line">   %3 = subview %alloc [...][...][...]</div>
<div class="line">   %4 = subview %view [0, 0][...][...]</div>
<div class="line">   linalg.copy(%3, %4)</div>
<div class="line">}</div>
</div><!-- fragment --> </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00384">384</a> of file <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html">VectorTransferSplitRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00258">mlir::arith::ConstantIntOp::create()</a>, and <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00185">createSubViewIntersection()</a>.</p>

</div>
</div>
<a id="a5e6ff4dc1bfcc2fba804057f99bbd632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6ff4dc1bfcc2fba804057f99bbd632">&#9670;&nbsp;</a></span>createFullPartialVectorTransferRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static scf::IfOp createFullPartialVectorTransferRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector::TransferReadOp&#160;</td>
          <td class="paramname"><em>xferOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>returnTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>inBoundsCond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>compatibleMemRefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an <code>xferOp</code> for which: </p>
<ol type="1">
<li><code>inBoundsCond</code> and a <code>compatibleMemRefType</code> have been computed.</li>
<li>a memref of single vector <code>alloc</code> has been allocated. Produce IR resembling: <div class="fragment"><div class="line"> %1:3 = scf.if (%inBounds) {</div>
<div class="line">   (memref.memory_space_cast %<a class="code" href="namespacemlir_1_1nvgpu.html#ae4c82fd5e3500e2d345d723829e09efea7fc56270e7a70fa81a5935b72eacbe29">A</a>: memref&lt;<a class="code" href="namespacemlir_1_1nvgpu.html#ae4c82fd5e3500e2d345d723829e09efea7fc56270e7a70fa81a5935b72eacbe29">A</a>..., addr_space&gt; to memref&lt;<a class="code" href="namespacemlir_1_1nvgpu.html#ae4c82fd5e3500e2d345d723829e09efea7fc56270e7a70fa81a5935b72eacbe29">A</a>...&gt;)</div>
<div class="line">   memref.cast %A: memref&lt;A...&gt; to compatibleMemRefType</div>
<div class="line">   scf.yield %view, ... : compatibleMemRefType, index, index</div>
<div class="line"> } <span class="keywordflow">else</span> {</div>
<div class="line">   %2 = vector.transfer_read %view[...], %pad : memref&lt;<a class="code" href="namespacemlir_1_1nvgpu.html#ae4c82fd5e3500e2d345d723829e09efea7fc56270e7a70fa81a5935b72eacbe29">A</a>...&gt;, vector&lt;...&gt;</div>
<div class="line">   %3 = vector.type_cast %extra_alloc :</div>
<div class="line">     memref&lt;...&gt; to memref&lt;vector&lt;...&gt;&gt;</div>
<div class="line">   store %2, %3[] : memref&lt;vector&lt;...&gt;&gt;</div>
<div class="line">   %4 = memref.cast %alloc: memref&lt;<a class="code" href="namespacemlir_1_1nvgpu.html#ae4c82fd5e3500e2d345d723829e09efea9d5ed678fe57bcca610140957afab571">B</a>...&gt; to compatibleMemRefType</div>
<div class="line">   scf.yield %4, ... : compatibleMemRefType, index, index</div>
<div class="line">}</div>
</div><!-- fragment --> Return the produced scf::IfOp. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00297">297</a> of file <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html">VectorTransferSplitRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00165">castToCompatibleMemRefType()</a>, <a class="el" href="Builders_8cpp_source.html#l00548">mlir::OpBuilder::clone()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00509">mlir::vector::splitFullAndPartialTransfer()</a>.</p>

</div>
</div>
<a id="a2c61af9a1c44ec8b2edef25d638bcc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c61af9a1c44ec8b2edef25d638bcc1d">&#9670;&nbsp;</a></span>createFullPartialVectorTransferWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void createFullPartialVectorTransferWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector::TransferWriteOp&#160;</td>
          <td class="paramname"><em>xferOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>inBoundsCond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an <code>xferOp</code> for which: </p>
<ol type="1">
<li><code>inBoundsCond</code> has been computed.</li>
<li>a memref of single vector <code>alloc</code> has been allocated.</li>
<li>it originally wrote to view Produce IR resembling: <div class="fragment"><div class="line"> %notInBounds = arith.xori %inBounds, %<span class="keyword">true</span></div>
<div class="line"> scf.if (%notInBounds) {</div>
<div class="line">   %2 = load %alloc : memref&lt;vector&lt;...&gt;&gt;</div>
<div class="line">   vector.transfer_write %2, %view[...] : memref&lt;<a class="code" href="namespacemlir_1_1nvgpu.html#ae4c82fd5e3500e2d345d723829e09efea7fc56270e7a70fa81a5935b72eacbe29">A</a>...&gt;, vector&lt;...&gt;</div>
<div class="line">}</div>
</div><!-- fragment --> </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00412">412</a> of file <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html">VectorTransferSplitRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00548">mlir::OpBuilder::clone()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00258">mlir::arith::ConstantIntOp::create()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>, and <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00509">mlir::vector::splitFullAndPartialTransfer()</a>.</p>

</div>
</div>
<a id="a7942a579f487abc1c7bab0442f5766da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7942a579f487abc1c7bab0442f5766da">&#9670;&nbsp;</a></span>createInBoundsCond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> createInBoundsCond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorTransferOpInterface&#160;</td>
          <td class="paramname"><em>xferOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the condition to ensure that a particular VectorTransferOpInterface is in-bounds. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00036">36</a> of file <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html">VectorTransferSplitRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00367">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00359">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00068">mlir::memref::getMixedSize()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00509">mlir::vector::splitFullAndPartialTransfer()</a>.</p>

</div>
</div>
<a id="a71d5348db926142ee393c8a5f6d51169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d5348db926142ee393c8a5f6d51169">&#9670;&nbsp;</a></span>createSubViewIntersection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>&gt; createSubViewIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorTransferOpInterface&#160;</td>
          <td class="paramname"><em>xferOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operates under a scoped context to build the intersection between the view <code>xferOp.getbase()</code> @ <code><a class="el" href="namespacemlir_1_1nvgpu.html#ad59722c33205a25c3184235b9519c8bc" title="Get the indices that the given load/store operation is operating on.">xferOp.getIndices()</a></code> and the view <code>alloc</code>. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00185">185</a> of file <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html">VectorTransferSplitRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">mlir::AffineMap::inferFromExprList()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00245">createFullPartialLinalgCopy()</a>.</p>

</div>
</div>
<a id="ac105ba9f4710accd616d09c98f320a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac105ba9f4710accd616d09c98f320a3e">&#9670;&nbsp;</a></span>getAutomaticAllocationScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Operation.html">Operation</a>* getAutomaticAllocationScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00433">433</a> of file <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html">VectorTransferSplitRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00509">mlir::vector::splitFullAndPartialTransfer()</a>.</p>

</div>
</div>
<a id="a7613eea26c6ae61621bf8140ce5e24c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7613eea26c6ae61621bf8140ce5e24c0">&#9670;&nbsp;</a></span>getCastCompatibleMemRefType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MemRefType getCastCompatibleMemRefType </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>aT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>bT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given two MemRefTypes <code>aT</code> and <code>bT</code>, return a MemRefType to which both can be cast. </p>
<p>If the MemRefTypes don't have the same rank or are not strided, return null; otherwise:</p><ol type="1">
<li>if <code>aT</code> and <code>bT</code> are cast-compatible, return <code>aT</code>.</li>
<li>else return a new MemRefType obtained by iterating over the shape and strides and: a. keeping the ones that are static and equal across <code>aT</code> and <code>bT</code>. b. using a dynamic shape and/or stride for the dimensions that don't agree. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00134">134</a> of file <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html">VectorTransferSplitRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00509">mlir::vector::splitFullAndPartialTransfer()</a>.</p>

</div>
</div>
<a id="a4c340c144e195bcb1f542b16a9293f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c340c144e195bcb1f542b16a9293f27">&#9670;&nbsp;</a></span>getLocationToWriteFullVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> getLocationToWriteFullVec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector::TransferWriteOp&#160;</td>
          <td class="paramname"><em>xferOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>returnTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>inBoundsCond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>compatibleMemRefType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an <code>xferOp</code> for which: </p>
<ol type="1">
<li><code>inBoundsCond</code> and a <code>compatibleMemRefType</code> have been computed.</li>
<li>a memref of single vector <code>alloc</code> has been allocated. Produce IR resembling: <div class="fragment"><div class="line"> %1:3 = scf.if (%inBounds) {</div>
<div class="line">   memref.cast %<a class="code" href="namespacemlir_1_1nvgpu.html#ae4c82fd5e3500e2d345d723829e09efea7fc56270e7a70fa81a5935b72eacbe29">A</a>: memref&lt;<a class="code" href="namespacemlir_1_1nvgpu.html#ae4c82fd5e3500e2d345d723829e09efea7fc56270e7a70fa81a5935b72eacbe29">A</a>...&gt; to compatibleMemRefType</div>
<div class="line">   scf.yield %view, ... : compatibleMemRefType, index, index</div>
<div class="line"> } <span class="keywordflow">else</span> {</div>
<div class="line">   %3 = vector.type_cast %extra_alloc :</div>
<div class="line">     memref&lt;...&gt; to memref&lt;vector&lt;...&gt;&gt;</div>
<div class="line">   %4 = memref.cast %alloc: memref&lt;<a class="code" href="namespacemlir_1_1nvgpu.html#ae4c82fd5e3500e2d345d723829e09efea9d5ed678fe57bcca610140957afab571">B</a>...&gt; to compatibleMemRefType</div>
<div class="line">   scf.yield %4, ... : compatibleMemRefType, index, index</div>
<div class="line">}</div>
</div><!-- fragment --> </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00345">345</a> of file <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html">VectorTransferSplitRewritePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00165">castToCompatibleMemRefType()</a>, and <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00509">mlir::vector::splitFullAndPartialTransfer()</a>.</p>

</div>
</div>
<a id="a608b76c3eed0b6350a875901243f748f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608b76c3eed0b6350a875901243f748f">&#9670;&nbsp;</a></span>splitFullAndPartialTransferPrecondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult splitFullAndPartialTransferPrecondition </td>
          <td>(</td>
          <td class="paramtype">VectorTransferOpInterface&#160;</td>
          <td class="paramname"><em>xferOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a vector.transfer operation into an in-bounds (i.e., no out-of-bounds masking) fast path and a slow path. </p>
<p>If <code>ifOp</code> is not null and the result is <code>success, the</code>ifOp` points to the newly created conditional upon function return. To accommodate for the fact that the original vector.transfer indexing may be arbitrary and the slow path indexes @[0...0] in the temporary buffer, the scf.if op returns a view and values of type index. At this time, only vector.transfer_read case is implemented.</p>
<p>Example (a 2-D vector.transfer_read): ``` %1 = vector.transfer_read %0[...], pad : memref&lt;A...&gt;, vector&lt;...&gt; ``` is transformed into: ``` %1:3 = scf.if (inBounds) { // fast path, direct cast memref.cast A: memref&lt;A...&gt; to compatibleMemRefType scf.yield view : compatibleMemRefType, index, index } else { // slow path, not in-bounds vector.transfer or linalg.copy. memref.cast alloc: memref&lt;B...&gt; to compatibleMemRefType scf.yield %4 : compatibleMemRefType, index, index */ // } /** %0 = vector.transfer_read %1#0[%1#1, %1#2] {in_bounds = [true ... true]} ``<code> where</code>alloc` is a top of the function alloca'ed buffer of one vector.</p>
<p>Preconditions:</p><ol type="1">
<li><code>xferOp.getPermutationMap()</code> must be a minor identity map</li>
<li>the rank of the <code>xferOp.memref()</code> and the rank of the <code>xferOp.getVector()</code> must be equal. This will be relaxed in the future but requires rank-reducing subviews. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00106">106</a> of file <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html">VectorTransferSplitRewritePatterns.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00509">mlir::vector::splitFullAndPartialTransfer()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:28 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
