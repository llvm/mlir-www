<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/SCF/Transforms/TileUsingInterface.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a href="dir_d7bf56b426f340e7a9442bd07d045545.html">SCF</a></li><li class="navelem"><a href="dir_c5fb1dbd194462dcd31045c7634a832a.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">TileUsingInterface.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="TileUsingInterface_8h_source.html">mlir/Dialect/SCF/Transforms/TileUsingInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SliceAnalysis_8h_source.html">mlir/Analysis/SliceAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TopologicalSortUtils_8h_source.html">mlir/Analysis/TopologicalSortUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html">mlir/Dialect/Arith/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html">mlir/Dialect/SCF/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Tensor_2IR_2Tensor_8h_source.html">mlir/Dialect/Tensor/IR/Tensor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IndexingUtils_8h_source.html">mlir/Dialect/Utils/IndexingUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dominance_8h_source.html">mlir/IR/Dominance.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DestinationStyleOpInterface_8h_source.html">mlir/Interfaces/DestinationStyleOpInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TilingInterface_8h_source.html">mlir/Interfaces/TilingInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="FrozenRewritePatternSet_8h_source.html">mlir/Rewrite/FrozenRewritePatternSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GreedyPatternRewriteDriver_8h_source.html">mlir/Transforms/GreedyPatternRewriteDriver.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/ScopeExit.h&quot;</code><br />
<code>#include &quot;llvm/ADT/TypeSwitch.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
</div>
<p><a href="TileUsingInterface_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d" id="r_ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;tile-using-interface&quot;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a84cb389e736acc0eacc571ba2b913251" id="r_a84cb389e736acc0eacc571ba2b913251"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84cb389e736acc0eacc571ba2b913251">YieldTiledValuesFn</a></td></tr>
<tr class="memdesc:a84cb389e736acc0eacc571ba2b913251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for function that allows returning additional yielded values during <span class="tt">yieldTiledValuesAndReplace</span>.  <br /></td></tr>
<tr class="memitem:a337541ada5c97c0ede6b61433e696a36" id="r_a337541ada5c97c0ede6b61433e696a36"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a337541ada5c97c0ede6b61433e696a36">GenerateTiledBodyFn</a></td></tr>
<tr class="memdesc:a337541ada5c97c0ede6b61433e696a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for function that implements the body of a tiled loop.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6076656dee568a8ebb437bc014f5ab1a" id="r_a6076656dee568a8ebb437bc014f5ab1a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6076656dee568a8ebb437bc014f5ab1a">fillInterchangeVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; interchangeVector, size_t iterationDomainSize)</td></tr>
<tr class="memdesc:a6076656dee568a8ebb437bc014f5ab1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to adjust the interchange vector to match the iteration domain.  <br /></td></tr>
<tr class="memitem:ae7dfa05fb201f99ec63ba9a32aec6299" id="r_ae7dfa05fb201f99ec63ba9a32aec6299"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7dfa05fb201f99ec63ba9a32aec6299">verifyOptions</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, const scf::SCFTilingOptions &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:ae7dfa05fb201f99ec63ba9a32aec6299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the tile size options are set in a consistent manner.  <br /></td></tr>
<tr class="memitem:ae6f48eb394ba79ea53f4bb9c56a70b49" id="r_ae6f48eb394ba79ea53f4bb9c56a70b49"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6f48eb394ba79ea53f4bb9c56a70b49">getUserTileSizesAndNumThreads</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; iterationDomain, const scf::SCFTilingOptions &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:ae6f48eb394ba79ea53f4bb9c56a70b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to instantiate the tile sizes and/or number of threads specified by the user.  <br /></td></tr>
<tr class="memitem:a355737c46864cfd2ee697fd8bb16c7e6" id="r_a355737c46864cfd2ee697fd8bb16c7e6"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a355737c46864cfd2ee697fd8bb16c7e6">checkTileSizes</a> (TilingInterface op, scf::SCFTilingOptions::LoopType loopType, <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a> reductionStrategy, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; givenTileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads)</td></tr>
<tr class="memdesc:a355737c46864cfd2ee697fd8bb16c7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any of the tiled loops are not parallel.  <br /></td></tr>
<tr class="memitem:ac3b7c533b86d674139e275da577ef977" id="r_ac3b7c533b86d674139e275da577ef977"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3b7c533b86d674139e275da577ef977">getSanitizedReductionDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; givenTileSizes, const scf::SCFTilingOptions &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:ac3b7c533b86d674139e275da577ef977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reduction dims that are tiled.  <br /></td></tr>
<tr class="memitem:abb6dd85d4816fccaea1880b659d13c74" id="r_abb6dd85d4816fccaea1880b659d13c74"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb6dd85d4816fccaea1880b659d13c74">tileDividesIterationDomain</a> (<a class="el" href="structmlir_1_1Range.html">Range</a> loopRange)</td></tr>
<tr class="memdesc:abb6dd85d4816fccaea1880b659d13c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <span class="tt">stride</span> evenly divides the trip count <span class="tt">size - offset</span>.  <br /></td></tr>
<tr class="memitem:aa1bde1ec01167e7e3dfcb6a7ea8586c0" id="r_aa1bde1ec01167e7e3dfcb6a7ea8586c0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1bde1ec01167e7e3dfcb6a7ea8586c0">getBoundedTileSize</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="structmlir_1_1Range.html">Range</a> loopRange, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> offset, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> givenTileSize)</td></tr>
<tr class="memdesc:aa1bde1ec01167e7e3dfcb6a7ea8586c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bounded tile size given the current <span class="tt">offset</span>, <span class="tt">loopRange</span> and <span class="tt">tileSize</span>, i.e., <span class="tt">min(tileSize, range.end() - offset)</span>.  <br /></td></tr>
<tr class="memitem:a01610701cd6c907f601b3a9a2d356b75" id="r_a01610701cd6c907f601b3a9a2d356b75"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01610701cd6c907f601b3a9a2d356b75">canOmitTileOffsetInBoundsCheck</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> givenTileSize, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> numThreads, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> iterationSize)</td></tr>
<tr class="memdesc:a01610701cd6c907f601b3a9a2d356b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the maximum tile offset <span class="tt">tileSize * numThreads-1</span> is less than <span class="tt">iterationSize</span>.  <br /></td></tr>
<tr class="memitem:a8d982a928f07cccfab12c01249748e4f" id="r_a8d982a928f07cccfab12c01249748e4f"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d982a928f07cccfab12c01249748e4f">getTileOffsetAndSizes</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; iterationDomain, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; givenTileSizes)</td></tr>
<tr class="memdesc:a8d982a928f07cccfab12c01249748e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the <span class="tt"><a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a></span>s that represents the multi-dimensional <span class="tt">offset</span>s and <span class="tt">size</span>s of the tile of the iteration space that the innermost loop body of the generated tiled loops corresponds to.  <br /></td></tr>
<tr class="memitem:a958b7e81641b8db66350bc40ffeed752" id="r_a958b7e81641b8db66350bc40ffeed752"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a958b7e81641b8db66350bc40ffeed752">getLoopBounds</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; loopRanges, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; givenTileSizes)</td></tr>
<tr class="memdesc:a958b7e81641b8db66350bc40ffeed752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to return the bounds of the loops to be generated.  <br /></td></tr>
<tr class="memitem:a83a0e3547e0bb0c54d1e26c2774ba964" id="r_a83a0e3547e0bb0c54d1e26c2774ba964"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83a0e3547e0bb0c54d1e26c2774ba964">cloneOpAndUpdateDestinationArgs</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newDestArgs)</td></tr>
<tr class="memdesc:a83a0e3547e0bb0c54d1e26c2774ba964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones the operation and updates the destination if the operation implements the <span class="tt">DestinationStyleOpInterface</span>.  <br /></td></tr>
<tr class="memitem:a56e1a42cf7605daa2821dc1429afcaee" id="r_a56e1a42cf7605daa2821dc1429afcaee"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56e1a42cf7605daa2821dc1429afcaee">generateLoopNestUsingForOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; loopRanges, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; givenTileSizes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> outerDestinationTensors, <a class="el" href="#a337541ada5c97c0ede6b61433e696a36">GenerateTiledBodyFn</a> tiledBodyFn)</td></tr>
<tr class="memdesc:a56e1a42cf7605daa2821dc1429afcaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the tile-loop nest using <span class="tt">scf.for</span> operation.  <br /></td></tr>
<tr class="memitem:a9e9117718aa1ede278f942b023b7aab2" id="r_a9e9117718aa1ede278f942b023b7aab2"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e9117718aa1ede278f942b023b7aab2">getTileOffsetAndSizesWithForAllOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; iterationDomain, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; givenTileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads)</td></tr>
<tr class="memdesc:a9e9117718aa1ede278f942b023b7aab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the <span class="tt"><a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a></span>s that represents the multi-dimensional <span class="tt">offset</span>s and <span class="tt">size</span>s of the tile of the iteration space that the innermost loop body of the generated tiled loops corresponds to when tiling using <span class="tt">forall</span> op.  <br /></td></tr>
<tr class="memitem:acfc6693517610619b8732dd8dcf69571" id="r_acfc6693517610619b8732dd8dcf69571"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfc6693517610619b8732dd8dcf69571">generateLoopNestUsingForallOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; loopRanges, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; givenTileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; mappingVector, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> outerDestinationTensors, <a class="el" href="#a337541ada5c97c0ede6b61433e696a36">GenerateTiledBodyFn</a> tiledBodyFn)</td></tr>
<tr class="memdesc:acfc6693517610619b8732dd8dcf69571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the tile-loop nest using <span class="tt">scf.forall</span> operation.  <br /></td></tr>
<tr class="memitem:a498011feca5bf46c4e1a3c9265efa3c4" id="r_a498011feca5bf46c4e1a3c9265efa3c4"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a498011feca5bf46c4e1a3c9265efa3c4">generateLoopNestUsingCustomOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; loopRanges, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; givenTileSizes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> outerDestinationTensors, const scf::SCFTilingOptions::GenerateLoopHeaderFn &amp;generateLoopHeaderFn, const scf::SCFTilingOptions::GenerateLoopTerminatorFn &amp;generateLoopTerminatorFn, <a class="el" href="#a337541ada5c97c0ede6b61433e696a36">GenerateTiledBodyFn</a> tiledBodyFn)</td></tr>
<tr class="memdesc:a498011feca5bf46c4e1a3c9265efa3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the tile-loop nest using custom loop operation.  <br /></td></tr>
<tr class="memitem:a49fe9ed4928d93836c78064f40756611" id="r_a49fe9ed4928d93836c78064f40756611"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49fe9ed4928d93836c78064f40756611">generateLoopNest</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, const scf::SCFTilingOptions &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; loopRanges, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; givenTileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> destinationTensors, <a class="el" href="#a337541ada5c97c0ede6b61433e696a36">GenerateTiledBodyFn</a> tiledBodyFn)</td></tr>
<tr class="memdesc:a49fe9ed4928d93836c78064f40756611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the tile-loop nest using the loop construct specifed in <span class="tt">options</span>.  <br /></td></tr>
<tr class="memitem:add9e7656aee85c0f4a1714fbced5edc2" id="r_add9e7656aee85c0f4a1714fbced5edc2"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add9e7656aee85c0f4a1714fbced5edc2">createInitialTensorsForTiling</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a> reductionStrategy, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; iterationDomain, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; givenTileSizes, const <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;reductionDims)</td></tr>
<tr class="memitem:adde84869f994649ffe0419e13487d88a" id="r_adde84869f994649ffe0419e13487d88a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adde84869f994649ffe0419e13487d88a">getSplitReductionIvs</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a> reductionStrategy, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; givenTileSizes, const <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;reductionDims)</td></tr>
<tr class="memdesc:adde84869f994649ffe0419e13487d88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the case of <span class="tt">ReductionTilingStrategy::PartialReductionOuterParallel</span> the <span class="tt">PartialReductionOpInterface</span> methods need the index of the parallel split reduction being executed.  <br /></td></tr>
<tr class="memitem:add70536479a7c799d338021db3fd3b5d" id="r_add70536479a7c799d338021db3fd3b5d"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add70536479a7c799d338021db3fd3b5d">getTiledImplementation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a> reductionStrategy, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> regionIterArg, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; givenTileSizes, const <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;reductionDims)</td></tr>
<tr class="memitem:a0513b7cf9ed5f6dcad5e277bede08c63" id="r_a0513b7cf9ed5f6dcad5e277bede08c63"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0513b7cf9ed5f6dcad5e277bede08c63">getResultTilePosition</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a> reductionStrategy, <a class="el" href="classint64__t.html">int64_t</a> index, <a class="el" href="classmlir_1_1Value.html">Value</a> tiledResult, TilingInterface op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; givenTileSizes, const <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;reductionDims, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;resultOffset, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;resultSize)</td></tr>
<tr class="memitem:a07241199d7f7bdfecfb4fe0d854fe48f" id="r_a07241199d7f7bdfecfb4fe0d854fe48f"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="structmlir_1_1MergeResult.html">MergeResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07241199d7f7bdfecfb4fe0d854fe48f">mergeTilingResults</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a> reductionStrategy, const <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;reductionDims, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> partialResults)</td></tr>
<tr class="memitem:ae8b92b35dc194d537e026baef725d246" id="r_ae8b92b35dc194d537e026baef725d246"><td class="memTemplParams" colspan="2">template&lt;typename LoopType&gt; </td></tr>
<tr class="memitem:ae8b92b35dc194d537e026baef725d246 template"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LoopLikeOpInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8b92b35dc194d537e026baef725d246">yieldTiledValuesAndReplaceLoop</a> (LoopType loopOp, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newInitOperands, <a class="el" href="#a84cb389e736acc0eacc571ba2b913251">YieldTiledValuesFn</a> yieldTiledValuesFn)</td></tr>
<tr class="memdesc:ae8b92b35dc194d537e026baef725d246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the specified additional <span class="tt">newInitOperands</span> operands to the loops existing <span class="tt">init</span> operands (or similar), and replace <span class="tt">loopOp</span> with the new loop that has the additional init operands.  <br /></td></tr>
<tr class="memitem:ab38437a5237764e11d29b329a03cd4ed" id="r_ab38437a5237764e11d29b329a03cd4ed"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab38437a5237764e11d29b329a03cd4ed template"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LoopLikeOpInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab38437a5237764e11d29b329a03cd4ed">yieldTiledValuesAndReplaceLoop&lt; scf::ForOp &gt;</a> (scf::ForOp loopOp, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newInitOperands, <a class="el" href="#a84cb389e736acc0eacc571ba2b913251">YieldTiledValuesFn</a> yieldTiledValuesFn)</td></tr>
<tr class="memdesc:ab38437a5237764e11d29b329a03cd4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <span class="tt">yieldTiledValuesAndReplaceLoop</span> for <span class="tt">scf.for</span>.  <br /></td></tr>
<tr class="memitem:a20a39c74db3a8fdba231adbc0b6ed767" id="r_a20a39c74db3a8fdba231adbc0b6ed767"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a20a39c74db3a8fdba231adbc0b6ed767 template"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LoopLikeOpInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20a39c74db3a8fdba231adbc0b6ed767">yieldTiledValuesAndReplaceLoop&lt; scf::ForallOp &gt;</a> (scf::ForallOp loopOp, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newInitOperands, <a class="el" href="#a84cb389e736acc0eacc571ba2b913251">YieldTiledValuesFn</a> yieldTiledValuesFn)</td></tr>
<tr class="memdesc:a20a39c74db3a8fdba231adbc0b6ed767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <span class="tt">yieldTiledValuesAndReplaceLoop</span> for <span class="tt">scf.forall</span>  <br /></td></tr>
<tr class="memitem:abdbc9cbe5517396c1feada1fadefc3df" id="r_abdbc9cbe5517396c1feada1fadefc3df"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LoopLikeOpInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdbc9cbe5517396c1feada1fadefc3df">yieldTiledValuesAndReplaceLoop</a> (LoopLikeOpInterface loopLikeOp, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newInitOperands, <a class="el" href="#a84cb389e736acc0eacc571ba2b913251">YieldTiledValuesFn</a> yieldTiledValuesFn)</td></tr>
<tr class="memdesc:abdbc9cbe5517396c1feada1fadefc3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <span class="tt">yieldTiledValuesAndReplaceLoop</span> for <span class="tt">LoopLikeOpInterface</span>, that just dispatches to the implementation for each supported loop type.  <br /></td></tr>
<tr class="memitem:acba6980331e472f54032c57818013e68" id="r_acba6980331e472f54032c57818013e68"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acba6980331e472f54032c57818013e68">addInitOperandsToLoopNest</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt; loops, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newInitValues, <a class="el" href="#a84cb389e736acc0eacc571ba2b913251">YieldTiledValuesFn</a> getNewTiledYieldsFn)</td></tr>
<tr class="memdesc:acba6980331e472f54032c57818013e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to add new init values to a loop nest.  <br /></td></tr>
<tr class="memitem:a14f051b3bcd74a768026486e54398210" id="r_a14f051b3bcd74a768026486e54398210"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; <a class="el" href="classmlir_1_1OpResult.html">OpResult</a>, std::optional&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14f051b3bcd74a768026486e54398210">getUntiledProducerFromSliceSource</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *source, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LoopLikeOpInterface &gt; loops)</td></tr>
<tr class="memdesc:a14f051b3bcd74a768026486e54398210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the untiled producer whose slice is used in a tiled consumer.  <br /></td></tr>
<tr class="memitem:a2c60be984a912b6e26bba0f55834ebba" id="r_a2c60be984a912b6e26bba0f55834ebba"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c60be984a912b6e26bba0f55834ebba">checkAssumptionForFusingConsumer</a> (tensor::InsertSliceOp candidateSliceOp)</td></tr>
<tr class="memdesc:a2c60be984a912b6e26bba0f55834ebba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function that checks whether the only use of the result of a tensor.insert_slice op is in a scf.yield op.  <br /></td></tr>
<tr class="memitem:a7f3819b9258f4b29d1f75af5de0f80ba" id="r_a7f3819b9258f4b29d1f75af5de0f80ba"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f3819b9258f4b29d1f75af5de0f80ba">getFirstUserOfLoop</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *loopOp)</td></tr>
<tr class="memdesc:a7f3819b9258f4b29d1f75af5de0f80ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">An utility to get the first user of the given loopOp.  <br /></td></tr>
<tr class="memitem:a8476ae91189971134cbf07d3da7cbc6e" id="r_a8476ae91189971134cbf07d3da7cbc6e"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classllvm_1_1SetVector.html">llvm::SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8476ae91189971134cbf07d3da7cbc6e">checkAssumptionForLoop</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *loopOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *consumerOp, <a class="el" href="classbool.html">bool</a> reorderOperations)</td></tr>
<tr class="memdesc:a8476ae91189971134cbf07d3da7cbc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility currently checks whether the first userOp of loop is NOT before the last defineOp of consumer operand.  <br /></td></tr>
<tr class="memitem:a24289d9d672bcd51d4fe800b0dc22d25" id="r_a24289d9d672bcd51d4fe800b0dc22d25"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24289d9d672bcd51d4fe800b0dc22d25">getConsumerFromLoopUses</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *loopOp, <a class="el" href="classunsigned.html">unsigned</a> resultNumber)</td></tr>
<tr class="memdesc:a24289d9d672bcd51d4fe800b0dc22d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> of the first valid user (and use) of the value <span class="tt">val</span> which implements <span class="tt">TilingInterface</span> and <span class="tt">DestinationStyleOpInterface</span>.  <br /></td></tr>
<tr class="memitem:a66472b68e266e685090a73c5d217e559" id="r_a66472b68e266e685090a73c5d217e559"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66472b68e266e685090a73c5d217e559">getUntiledConsumerFromSlice</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::InsertSliceOp candidateSliceOp, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt; loops)</td></tr>
<tr class="memdesc:a66472b68e266e685090a73c5d217e559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the untiled consumer of the outermost scf.for's result which is yielded by a tensor.insert_slice from the innermost scf.for.  <br /></td></tr>
<tr class="memitem:a5ad1ffd875c090c64222aa6ee765efbf" id="r_a5ad1ffd875c090c64222aa6ee765efbf"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ad1ffd875c090c64222aa6ee765efbf">getUntiledConsumerFromSlice</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::ParallelInsertSliceOp candidateSliceOp, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt; loops)</td></tr>
<tr class="memdesc:a5ad1ffd875c090c64222aa6ee765efbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the first untiled consumer of a scf.forall's result which is yielded by a tensor.parallel_insert_slice.  <br /></td></tr>
<tr class="memitem:a6d94c1bf365f0554b258899dd8baad4f" id="r_a6d94c1bf365f0554b258899dd8baad4f"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d94c1bf365f0554b258899dd8baad4f">getUntiledConsumerOperandsFromSlices</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; sliceOps, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt; loops)</td></tr>
<tr class="memdesc:a6d94c1bf365f0554b258899dd8baad4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility to fetch an untiled consumer of tensor.insert_slice/tensor.parallel_insert_slice.  <br /></td></tr>
<tr class="memitem:ad97be6b3297bf26326b111ca2fa97da1" id="r_ad97be6b3297bf26326b111ca2fa97da1"><td class="memTemplParams" colspan="2">template&lt;typename InsertSliceOpTy&gt; </td></tr>
<tr class="memitem:ad97be6b3297bf26326b111ca2fa97da1 template"><td class="memItemLeft" align="right" valign="top">static tensor::InsertSliceOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad97be6b3297bf26326b111ca2fa97da1">cloneAsInsertSlice</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, InsertSliceOpTy sliceOp)</td></tr>
<tr class="memitem:a89438f1b74db0575ec5f079a61d8ec40" id="r_a89438f1b74db0575ec5f079a61d8ec40"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a89438f1b74db0575ec5f079a61d8ec40 template"><td class="memItemLeft" align="right" valign="top">tensor::InsertSliceOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89438f1b74db0575ec5f079a61d8ec40">cloneAsInsertSlice&lt; tensor::InsertSliceOp &gt;</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::InsertSliceOp insertSliceOp)</td></tr>
<tr class="memitem:a7a2198fa360b947c9e90735288f93fda" id="r_a7a2198fa360b947c9e90735288f93fda"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7a2198fa360b947c9e90735288f93fda template"><td class="memItemLeft" align="right" valign="top">tensor::InsertSliceOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a2198fa360b947c9e90735288f93fda">cloneAsInsertSlice&lt; tensor::ParallelInsertSliceOp &gt;</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::ParallelInsertSliceOp insertSliceOp)</td></tr>
<tr class="memitem:a698841736e9ab595756c934bf3d533f4" id="r_a698841736e9ab595756c934bf3d533f4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; tensor::InsertSliceOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a698841736e9ab595756c934bf3d533f4">cloneAsInsertSlices</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; candidateSlices)</td></tr>
<tr class="memitem:a40a73f0ba8021c393b365dd47d789454" id="r_a40a73f0ba8021c393b365dd47d789454"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; scf::SCFFuseConsumerOfSliceResult &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40a73f0ba8021c393b365dd47d789454">tileAndFuseConsumerOfSlicesImpl</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *consumerOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt; consumerOpOperands, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; candidateSlices, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt; loops)</td></tr>
<tr class="memitem:ad8ed5a4c842484d5f162e7b22cd686f8" id="r_ad8ed5a4c842484d5f162e7b22cd686f8"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8ed5a4c842484d5f162e7b22cd686f8">getProducingParallelInsertSlice</a> (scf::ForallOp forallOp, <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> <a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memdesc:ad8ed5a4c842484d5f162e7b22cd686f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given <span class="tt">result</span> of a <span class="tt">forallOp</span> return the <span class="tt">tensor.parallel_insert_slice</span> op (or combining op) that is used to construct this result.  <br /></td></tr>
<tr class="memitem:a1263ed5b692468d7d77553acdc5431ba" id="r_a1263ed5b692468d7d77553acdc5431ba"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1263ed5b692468d7d77553acdc5431ba">getProducingInsertSliceLikeOp</a> (<a class="el" href="classmlir_1_1OpResult.html">OpResult</a> <a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LoopLikeOpInterface &gt; loops)</td></tr>
<tr class="memdesc:a1263ed5b692468d7d77553acdc5431ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given result of the loop nest that is a tiled loop nest, return the insert slice-like op that is used for consumer fusion.  <br /></td></tr>
</table>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&#160;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;tile-using-interface&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00033">33</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a337541ada5c97c0ede6b61433e696a36" name="a337541ada5c97c0ede6b61433e696a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337541ada5c97c0ede6b61433e696a36">&#9670;&#160;</a></span>GenerateTiledBodyFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a337541ada5c97c0ede6b61433e696a36">GenerateTiledBodyFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;LogicalResult(</div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="code hl_class" href="classmlir_1_1Location.html">Location</a> Loc, <a class="code hl_class" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs,</div>
<div class="line">    <a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;OpFoldResult&gt;</a> tileOffsets, <a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;OpFoldResult&gt;</a> tileSizes,</div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1ValueRange.html">ValueRange</a> outerDestinationTensors, <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value&gt;</a> &amp;tiledResults,</div>
<div class="line">    <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;OpFoldResult&gt;</a>&gt; &amp;resultOffsets,</div>
<div class="line">    <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;OpFoldResult&gt;</a>&gt; &amp;resultSizes)&gt;</div>
<div class="ttc" id="aclassllvm_1_1ArrayRef_html"><div class="ttname"><a href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a></div><div class="ttdef"><b>Definition</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00048">LLVM.h:48</a></div></div>
<div class="ttc" id="aclassllvm_1_1SmallVector_html"><div class="ttname"><a href="classllvm_1_1SmallVector.html">llvm::SmallVector</a></div><div class="ttdef"><b>Definition</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00072">LLVM.h:72</a></div></div>
<div class="ttc" id="aclassmlir_1_1Location_html"><div class="ttname"><a href="classmlir_1_1Location.html">mlir::Location</a></div><div class="ttdoc">This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...</div><div class="ttdef"><b>Definition</b> <a href="Location_8h_source.html#l00076">Location.h:76</a></div></div>
<div class="ttc" id="aclassmlir_1_1RewriterBase_html"><div class="ttname"><a href="classmlir_1_1RewriterBase.html">mlir::RewriterBase</a></div><div class="ttdoc">This class coordinates the application of a rewrite on a set of IR, providing a way for clients to tr...</div><div class="ttdef"><b>Definition</b> <a href="PatternMatch_8h_source.html#l00368">PatternMatch.h:368</a></div></div>
<div class="ttc" id="aclassmlir_1_1ValueRange_html"><div class="ttname"><a href="classmlir_1_1ValueRange.html">mlir::ValueRange</a></div><div class="ttdoc">This class provides an abstraction over the different types of ranges over Values.</div><div class="ttdef"><b>Definition</b> <a href="ValueRange_8h_source.html#l00383">ValueRange.h:387</a></div></div>
</div><!-- fragment -->
<p>Typedef for function that implements the body of a tiled loop. </p>
<ul>
<li><span class="tt">ivs</span> induction variable for the loop.</li>
<li><span class="tt">tileOffsets</span> represents offsets for the tiled iteration space.</li>
<li><span class="tt">tileSizes</span> represents the sizes for the tiled iteraiton space.</li>
<li><span class="tt">outerDestinationTensors</span> tensor that holds the result. Is same size as the destination operands of the original operations.</li>
<li><span class="tt">tiledResults</span> results of the tiled computation, corresponds to tiles of the original operation computed by the loop body. Should be same size as the <span class="tt">destinationTensors</span></li>
<li><span class="tt">resultOffsets</span> is of the same size as <span class="tt">tiledResults</span> and represents the offset to use when writing the corresponding element from <span class="tt">tiledResults</span> into <span class="tt">destinationTensors</span>.</li>
<li><span class="tt">resultOffsets</span> is of the same size as <span class="tt">tiledResults</span> and represents the size to use when writing the corresponding element from <span class="tt">tiledResults</span> into <span class="tt">destinationTensors</span>. In case the method needs to return <span class="tt">failure()</span> the method is expected to clean up any inserted operations. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00359">359</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<a id="a84cb389e736acc0eacc571ba2b913251" name="a84cb389e736acc0eacc571ba2b913251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84cb389e736acc0eacc571ba2b913251">&#9670;&#160;</a></span>YieldTiledValuesFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a84cb389e736acc0eacc571ba2b913251">YieldTiledValuesFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;LogicalResult(</div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="code hl_class" href="classmlir_1_1Location.html">Location</a> loc, <a class="code hl_class" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="code hl_class" href="classmlir_1_1ValueRange.html">ValueRange</a> newBbArgs,</div>
<div class="line">    <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value&gt;</a> &amp;tiledValues,</div>
<div class="line">    <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;OpFoldResult&gt;</a>&gt; &amp;resultOffsets,</div>
<div class="line">    <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;OpFoldResult&gt;</a>&gt; &amp;resultSizes)&gt;</div>
</div><!-- fragment -->
<p>Typedef for function that allows returning additional yielded values during <span class="tt">yieldTiledValuesAndReplace</span>. </p>
<ul>
<li><span class="tt">ivs</span> induction variable for the loop.</li>
<li><span class="tt">newBbArgs</span> basic block arguments corresponding to newly added iter_args.</li>
<li><span class="tt">tiledValues</span> the tiled values to return. Must be of same size as <span class="tt">newbbArgs</span>, each element of this array is inserted into the corresponding element in <span class="tt">newbbArgs</span>.</li>
<li><span class="tt">resultOffsets</span> is of the same size as <span class="tt">tiledValues</span> and represents the offsets to use when inserting corresponding element from <span class="tt">tiledValues</span> into the element from <span class="tt">newBbArgs</span>.</li>
<li><span class="tt">resultSizes</span> is of the same size as <span class="tt">tiledValues</span> and represents the size of the corresponding element from <span class="tt">tiledValues</span> inserted into the element from <span class="tt">newBbArgs</span>. In case the method needs to return <span class="tt">failure()</span> the method is expected to clean up any inserted operations. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00336">336</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="acba6980331e472f54032c57818013e68" name="acba6980331e472f54032c57818013e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba6980331e472f54032c57818013e68">&#9670;&#160;</a></span>addInitOperandsToLoopNest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult addInitOperandsToLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>newInitValues</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a84cb389e736acc0eacc571ba2b913251">YieldTiledValuesFn</a></td>          <td class="paramname"><span class="paramname"><em>getNewTiledYieldsFn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to add new init values to a loop nest. </p>
<p>Updates <span class="tt">loops</span> in-place with new loops that use the <span class="tt">newInitValues</span>. The outer-loops are updated to yield the new result values of the inner loop. For the innermost loop, the call back <span class="tt">getNewYields</span> is invoked to get the additional values to yield form the innermost loop. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01041">1041</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00343">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00529">mlir::RewriterBase::replaceOpWithNewOp()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00904">yieldTiledValuesAndReplaceLoop()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l02188">tileAndFuseConsumerOfSlicesImpl()</a>.</p>

</div>
</div>
<a id="a01610701cd6c907f601b3a9a2d356b75" name="a01610701cd6c907f601b3a9a2d356b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01610701cd6c907f601b3a9a2d356b75">&#9670;&#160;</a></span>canOmitTileOffsetInBoundsCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> canOmitTileOffsetInBoundsCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>givenTileSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>numThreads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>iterationSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the maximum tile offset <span class="tt">tileSize * numThreads-1</span> is less than <span class="tt">iterationSize</span>. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00262">262</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00474">getTileOffsetAndSizesWithForAllOp()</a>.</p>

</div>
</div>
<a id="a2c60be984a912b6e26bba0f55834ebba" name="a2c60be984a912b6e26bba0f55834ebba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c60be984a912b6e26bba0f55834ebba">&#9670;&#160;</a></span>checkAssumptionForFusingConsumer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult checkAssumptionForFusingConsumer </td>
          <td>(</td>
          <td class="paramtype">tensor::InsertSliceOp</td>          <td class="paramname"><span class="paramname"><em>candidateSliceOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A utility function that checks whether the only use of the result of a tensor.insert_slice op is in a scf.yield op. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01856">1856</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l02050">getUntiledConsumerFromSlice()</a>.</p>

</div>
</div>
<a id="a8476ae91189971134cbf07d3da7cbc6e" name="a8476ae91189971134cbf07d3da7cbc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8476ae91189971134cbf07d3da7cbc6e">&#9670;&#160;</a></span>checkAssumptionForLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllvm_1_1SetVector.html">llvm::SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt; checkAssumptionForLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>loopOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>consumerOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>reorderOperations</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility currently checks whether the first userOp of loop is NOT before the last defineOp of consumer operand. </p>
<p>Because that we need to move the whole loop structure right before the <span class="tt">firstUserOfLoop</span>. This utility thus helps ensuring that no invalid IR is formed, i.e. no backward slice of consumerOp is dominated by the <span class="tt">firstUserOfLoop</span>. Saying that:</p>
<div class="fragment"><div class="line">%0 = <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for() {</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">%1 = firstUserOfLoop(%0)</div>
<div class="line">...</div>
<div class="line">%2 = lastDefOfConsumerOperand</div>
<div class="line">...</div>
<div class="line">%3 = consumerOp(%2)</div>
<div class="ttc" id="anamespacemlir_1_1scf_html"><div class="ttname"><a href="namespacemlir_1_1scf.html">mlir::scf</a></div><div class="ttdef"><b>Definition</b> <a href="SCFToGPU_8h_source.html#l00024">SCFToGPU.h:24</a></div></div>
</div><!-- fragment --><p>If the <span class="tt">firstUserOfLoop</span> is before <span class="tt">lastDefOfConsumerOperand</span>, then it would be invalid to move the <span class="tt">loopOp</span> right before the <span class="tt">firstUserOfLoop</span>, a.k.a. use-def chain violation:</p>
<div class="fragment"><div class="line">%0:2 = <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for() {</div>
<div class="line">   <span class="comment">// use before define error</span></div>
<div class="line">   %3 = tiledConsumerOp(%2)</div>
<div class="line">}</div>
<div class="line">%1 = firstUserOfLoop(%0)</div>
<div class="line">...</div>
<div class="line">%2 = lastDefOfConsumerOperand</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loopOp</td><td>loop operation </td></tr>
    <tr><td class="paramname">consumerOp</td><td>consumer operation </td></tr>
    <tr><td class="paramname">reorderOperations</td><td>the flag controls whether to reorder the backward slice w.r.t. the defineOp of <span class="tt">consumerOp</span> operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: computed backward slice of consumerOp, but excluding those already dominates <span class="tt">firstUserOfLoop</span>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01952">1952</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00179">mlir::getBackwardSlice()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01881">getFirstUserOfLoop()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="Dominance_8cpp_source.html#l00323">mlir::DominanceInfo::properlyDominates()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01999">getConsumerFromLoopUses()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l02188">tileAndFuseConsumerOfSlicesImpl()</a>.</p>

</div>
</div>
<a id="a355737c46864cfd2ee697fd8bb16c7e6" name="a355737c46864cfd2ee697fd8bb16c7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355737c46864cfd2ee697fd8bb16c7e6">&#9670;&#160;</a></span>checkTileSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult checkTileSizes </td>
          <td>(</td>
          <td class="paramtype">TilingInterface</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::SCFTilingOptions::LoopType</td>          <td class="paramname"><span class="paramname"><em>loopType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a></td>          <td class="paramname"><span class="paramname"><em>reductionStrategy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>givenTileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>numThreads</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if any of the tiled loops are not parallel. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00155">155</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TilingInterface_8h_source.html#l00051">mlir::FullReduction</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00155">mlir::isConstantIntValue()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="ad97be6b3297bf26326b111ca2fa97da1" name="ad97be6b3297bf26326b111ca2fa97da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97be6b3297bf26326b111ca2fa97da1">&#9670;&#160;</a></span>cloneAsInsertSlice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InsertSliceOpTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tensor::InsertSliceOp cloneAsInsertSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InsertSliceOpTy</td>          <td class="paramname"><span class="paramname"><em>sliceOp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l02168">cloneAsInsertSlices()</a>.</p>

</div>
</div>
<a id="a89438f1b74db0575ec5f079a61d8ec40" name="a89438f1b74db0575ec5f079a61d8ec40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89438f1b74db0575ec5f079a61d8ec40">&#9670;&#160;</a></span>cloneAsInsertSlice&lt; tensor::InsertSliceOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tensor::InsertSliceOp <a class="el" href="#ad97be6b3297bf26326b111ca2fa97da1">cloneAsInsertSlice</a>&lt; tensor::InsertSliceOp &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::InsertSliceOp</td>          <td class="paramname"><span class="paramname"><em>insertSliceOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l02151">2151</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00562">mlir::OpBuilder::clone()</a>.</p>

</div>
</div>
<a id="a7a2198fa360b947c9e90735288f93fda" name="a7a2198fa360b947c9e90735288f93fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2198fa360b947c9e90735288f93fda">&#9670;&#160;</a></span>cloneAsInsertSlice&lt; tensor::ParallelInsertSliceOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tensor::InsertSliceOp <a class="el" href="#ad97be6b3297bf26326b111ca2fa97da1">cloneAsInsertSlice</a>&lt; tensor::ParallelInsertSliceOp &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ParallelInsertSliceOp</td>          <td class="paramname"><span class="paramname"><em>insertSliceOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l02159">2159</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<a id="a698841736e9ab595756c934bf3d533f4" name="a698841736e9ab595756c934bf3d533f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698841736e9ab595756c934bf3d533f4">&#9670;&#160;</a></span>cloneAsInsertSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; tensor::InsertSliceOp &gt; cloneAsInsertSlices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>candidateSlices</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l02168">2168</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="#ad97be6b3297bf26326b111ca2fa97da1">cloneAsInsertSlice()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l02188">tileAndFuseConsumerOfSlicesImpl()</a>.</p>

</div>
</div>
<a id="a83a0e3547e0bb0c54d1e26c2774ba964" name="a83a0e3547e0bb0c54d1e26c2774ba964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a0e3547e0bb0c54d1e26c2774ba964">&#9670;&#160;</a></span>cloneOpAndUpdateDestinationArgs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * cloneOpAndUpdateDestinationArgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>newDestArgs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones the operation and updates the destination if the operation implements the <span class="tt">DestinationStyleOpInterface</span>. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00368">368</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00562">mlir::OpBuilder::clone()</a>.</p>

</div>
</div>
<a id="add9e7656aee85c0f4a1714fbced5edc2" name="add9e7656aee85c0f4a1714fbced5edc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9e7656aee85c0f4a1714fbced5edc2">&#9670;&#160;</a></span>createInitialTensorsForTiling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; createInitialTensorsForTiling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a></td>          <td class="paramname"><span class="paramname"><em>reductionStrategy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>iterationDomain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>numThreads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>givenTileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reductionDims</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00726">726</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01006">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="TilingInterface_8h_source.html#l00051">mlir::FullReduction</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00110">mlir::tensor::getOrCreateDestinations()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00155">mlir::isConstantIntValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="TilingInterface_8h_source.html#l00057">mlir::PartialReductionOuterParallel</a>, and <a class="el" href="TilingInterface_8h_source.html#l00054">mlir::PartialReductionOuterReduction</a>.</p>

</div>
</div>
<a id="a6076656dee568a8ebb437bc014f5ab1a" name="a6076656dee568a8ebb437bc014f5ab1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6076656dee568a8ebb437bc014f5ab1a">&#9670;&#160;</a></span>fillInterchangeVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; fillInterchangeVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>interchangeVector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>iterationDomainSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method to adjust the interchange vector to match the iteration domain. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00060">60</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<a id="a49fe9ed4928d93836c78064f40756611" name="a49fe9ed4928d93836c78064f40756611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fe9ed4928d93836c78064f40756611">&#9670;&#160;</a></span>generateLoopNest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &gt; generateLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scf::SCFTilingOptions &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>loopRanges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>givenTileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>numThreads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>destinationTensors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a337541ada5c97c0ede6b61433e696a36">GenerateTiledBodyFn</a></td>          <td class="paramname"><span class="paramname"><em>tiledBodyFn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the tile-loop nest using the loop construct specifed in <span class="tt">options</span>. </p>
<ul>
<li><span class="tt">options</span>: Tiling options specified.</li>
<li><span class="tt">loopRanges</span> specifies the lb, ub and step of the untiled iteration space.</li>
<li><span class="tt">tileSizes</span> is the tile sizes to use. Zero represent untiled loops.</li>
<li><span class="tt">outerDestinationTensors</span> are the init values to use for the outer most loop.</li>
<li><span class="tt">yieldTiledValuesFn</span> is called to generated the loop body of the inner most loop. Returns the generated loops on success. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00687">687</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TileUsingInterface_8cpp_source.html#l00637">generateLoopNestUsingCustomOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00557">generateLoopNestUsingForallOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00388">generateLoopNestUsingForOp()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">mlir::isZeroInteger()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00036">mlir::Range::offset</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00037">mlir::Range::size</a>.</p>

</div>
</div>
<a id="a498011feca5bf46c4e1a3c9265efa3c4" name="a498011feca5bf46c4e1a3c9265efa3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498011feca5bf46c4e1a3c9265efa3c4">&#9670;&#160;</a></span>generateLoopNestUsingCustomOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &gt; generateLoopNestUsingCustomOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>loopRanges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>givenTileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>outerDestinationTensors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scf::SCFTilingOptions::GenerateLoopHeaderFn &amp;</td>          <td class="paramname"><span class="paramname"><em>generateLoopHeaderFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scf::SCFTilingOptions::GenerateLoopTerminatorFn &amp;</td>          <td class="paramname"><span class="paramname"><em>generateLoopTerminatorFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a337541ada5c97c0ede6b61433e696a36">GenerateTiledBodyFn</a></td>          <td class="paramname"><span class="paramname"><em>tiledBodyFn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the tile-loop nest using custom loop operation. </p>
<ul>
<li><span class="tt">loopRanges</span> specifies the lb, ub and step of the untiled iteration space.</li>
<li><span class="tt">tileSizes</span> is the tile sizes to use. Zero represent untiled loops.</li>
<li><span class="tt">destinationTensors</span> are the init values to use for the outer most loop.</li>
<li><span class="tt">mappingVector</span> is the mapping attributes to use for loop construction. Can be empty.</li>
<li><span class="tt">tiledBodyFn</span> is called to generated the loop body of the inner most loop. Returns the generated <span class="tt">scf.forall</span> loop on success. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00637">637</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00687">generateLoopNest()</a>.</p>

</div>
</div>
<a id="acfc6693517610619b8732dd8dcf69571" name="acfc6693517610619b8732dd8dcf69571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc6693517610619b8732dd8dcf69571">&#9670;&#160;</a></span>generateLoopNestUsingForallOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &gt; generateLoopNestUsingForallOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>loopRanges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>givenTileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>numThreads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mappingVector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>outerDestinationTensors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a337541ada5c97c0ede6b61433e696a36">GenerateTiledBodyFn</a></td>          <td class="paramname"><span class="paramname"><em>tiledBodyFn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the tile-loop nest using <span class="tt">scf.forall</span> operation. </p>
<ul>
<li><span class="tt">loopRanges</span> specifies the lb, ub and step of the untiled iteration space.</li>
<li><span class="tt">giventileSizes</span> is the tile sizes to use. Zero represent untiled loops.</li>
<li><span class="tt">outerDestinationTensors</span> are the init values to use for the loop.</li>
<li><span class="tt">mappingVector</span> is the mapping attributes to use for loop construction. Can be empty.</li>
<li><span class="tt">tiledBodyFn</span> is called to generated the loop body of the inner most loop. Returns the generated <span class="tt">scf.forall</span> loop on success. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00557">557</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00266">mlir::Builder::getArrayAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00306">getLoopBounds()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00474">getTileOffsetAndSizesWithForAllOp()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">mlir::isZeroInteger()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="Builders_8h_source.html#l00436">mlir::OpBuilder::setInsertionPointToEnd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00687">generateLoopNest()</a>.</p>

</div>
</div>
<a id="a56e1a42cf7605daa2821dc1429afcaee" name="a56e1a42cf7605daa2821dc1429afcaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e1a42cf7605daa2821dc1429afcaee">&#9670;&#160;</a></span>generateLoopNestUsingForOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &gt; generateLoopNestUsingForOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>loopRanges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>givenTileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>outerDestinationTensors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a337541ada5c97c0ede6b61433e696a36">GenerateTiledBodyFn</a></td>          <td class="paramname"><span class="paramname"><em>tiledBodyFn</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the tile-loop nest using <span class="tt">scf.for</span> operation. </p>
<ul>
<li><span class="tt">loopRanges</span> specifies the lb, ub and step of the untiled iteration space.</li>
<li><span class="tt">givenTileSizes</span> is the tile sizes to use. Zero represent untiled loops.</li>
<li><span class="tt">outerDestinationTensors</span> are the init values to use for the outer most loop.</li>
<li><span class="tt">tiledBodyFn</span> is called to generated the loop body of the inner most loop. Returns the generated <span class="tt">scf.for</span> loops on success. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00388">388</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00306">getLoopBounds()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00277">getTileOffsetAndSizes()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="Builders_8h_source.html#l00436">mlir::OpBuilder::setInsertionPointToEnd()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00687">generateLoopNest()</a>.</p>

</div>
</div>
<a id="aa1bde1ec01167e7e3dfcb6a7ea8586c0" name="aa1bde1ec01167e7e3dfcb6a7ea8586c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1bde1ec01167e7e3dfcb6a7ea8586c0">&#9670;&#160;</a></span>getBoundedTileSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> getBoundedTileSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Range.html">Range</a></td>          <td class="paramname"><span class="paramname"><em>loopRange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>givenTileSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bounded tile size given the current <span class="tt">offset</span>, <span class="tt">loopRange</span> and <span class="tt">tileSize</span>, i.e., <span class="tt">min(tileSize, range.end() - offset)</span>. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00237">237</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01572">mlir::affine::makeComposedFoldedAffineMin()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00036">mlir::Range::offset</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00037">mlir::Range::size</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00222">tileDividesIterationDomain()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00277">getTileOffsetAndSizes()</a>.</p>

</div>
</div>
<a id="a24289d9d672bcd51d4fe800b0dc22d25" name="a24289d9d672bcd51d4fe800b0dc22d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24289d9d672bcd51d4fe800b0dc22d25">&#9670;&#160;</a></span>getConsumerFromLoopUses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt; getConsumerFromLoopUses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>loopOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>resultNumber</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetches the <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> of the first valid user (and use) of the value <span class="tt">val</span> which implements <span class="tt">TilingInterface</span> and <span class="tt">DestinationStyleOpInterface</span>. </p>
<p>Returns failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01999">1999</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TileUsingInterface_8cpp_source.html#l01952">checkAssumptionForLoop()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01881">getFirstUserOfLoop()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="Value_8h_source.html#l00188">mlir::Value::getUses()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00407">mlir::RewriterBase::moveOpBefore()</a>, <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00275">mlir::topologicalSort()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00852">mlir::Operation::use_empty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l02050">getUntiledConsumerFromSlice()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l02084">getUntiledConsumerFromSlice()</a>.</p>

</div>
</div>
<a id="a7f3819b9258f4b29d1f75af5de0f80ba" name="a7f3819b9258f4b29d1f75af5de0f80ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3819b9258f4b29d1f75af5de0f80ba">&#9670;&#160;</a></span>getFirstUserOfLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; getFirstUserOfLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>loopOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An utility to get the first user of the given loopOp. </p>
<p>If any of user stay in different block of loopOp, return failure. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01881">1881</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00873">mlir::Operation::getUsers()</a>, and <a class="el" href="IR_2Operation_8cpp_source.html#l00383">mlir::Operation::isBeforeInBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01952">checkAssumptionForLoop()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01999">getConsumerFromLoopUses()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l02188">tileAndFuseConsumerOfSlicesImpl()</a>.</p>

</div>
</div>
<a id="a958b7e81641b8db66350bc40ffeed752" name="a958b7e81641b8db66350bc40ffeed752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958b7e81641b8db66350bc40ffeed752">&#9670;&#160;</a></span>getLoopBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; getLoopBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>loopRanges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>givenTileSizes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to return the bounds of the loops to be generated. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00306">306</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">mlir::isZeroInteger()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00557">generateLoopNestUsingForallOp()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00388">generateLoopNestUsingForOp()</a>.</p>

</div>
</div>
<a id="a1263ed5b692468d7d77553acdc5431ba" name="a1263ed5b692468d7d77553acdc5431ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1263ed5b692468d7d77553acdc5431ba">&#9670;&#160;</a></span>getProducingInsertSliceLikeOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; getProducingInsertSliceLikeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a></td>          <td class="paramname"><span class="paramname"><em>result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LoopLikeOpInterface &gt;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a given result of the loop nest that is a tiled loop nest, return the insert slice-like op that is used for consumer fusion. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l02462">2462</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TileUsingInterface_8cpp_source.html#l02447">getProducingParallelInsertSlice()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="ad8ed5a4c842484d5f162e7b22cd686f8" name="ad8ed5a4c842484d5f162e7b22cd686f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ed5a4c842484d5f162e7b22cd686f8">&#9670;&#160;</a></span>getProducingParallelInsertSlice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; getProducingParallelInsertSlice </td>
          <td>(</td>
          <td class="paramtype">scf::ForallOp</td>          <td class="paramname"><span class="paramname"><em>forallOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a></td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a given <span class="tt">result</span> of a <span class="tt">forallOp</span> return the <span class="tt">tensor.parallel_insert_slice</span> op (or combining op) that is used to construct this result. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l02447">2447</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l02462">getProducingInsertSliceLikeOp()</a>.</p>

</div>
</div>
<a id="a0513b7cf9ed5f6dcad5e277bede08c63" name="a0513b7cf9ed5f6dcad5e277bede08c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0513b7cf9ed5f6dcad5e277bede08c63">&#9670;&#160;</a></span>getResultTilePosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult getResultTilePosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a></td>          <td class="paramname"><span class="paramname"><em>reductionStrategy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>tiledResult</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>ivs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>numThreads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>givenTileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reductionDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>resultOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>resultSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00848">848</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TilingInterface_8h_source.html#l00051">mlir::FullReduction</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00794">getSplitReductionIvs()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

</div>
</div>
<a id="ac3b7c533b86d674139e275da577ef977" name="ac3b7c533b86d674139e275da577ef977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b7c533b86d674139e275da577ef977">&#9670;&#160;</a></span>getSanitizedReductionDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; getSanitizedReductionDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>givenTileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scf::SCFTilingOptions &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the reduction dims that are tiled. </p>
<p>This accounts for reduction dims that are specified as tiled, but the tile size is 0. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00210">210</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00155">mlir::isConstantIntValue()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="adde84869f994649ffe0419e13487d88a" name="adde84869f994649ffe0419e13487d88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde84869f994649ffe0419e13487d88a">&#9670;&#160;</a></span>getSplitReductionIvs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; getSplitReductionIvs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a></td>          <td class="paramname"><span class="paramname"><em>reductionStrategy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>ivs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>numThreads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>givenTileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reductionDims</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For the case of <span class="tt">ReductionTilingStrategy::PartialReductionOuterParallel</span> the <span class="tt">PartialReductionOpInterface</span> methods need the index of the parallel split reduction being executed. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00794">794</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00959">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, and <a class="el" href="TilingInterface_8h_source.html#l00057">mlir::PartialReductionOuterParallel</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00848">getResultTilePosition()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00821">getTiledImplementation()</a>.</p>

</div>
</div>
<a id="add70536479a7c799d338021db3fd3b5d" name="add70536479a7c799d338021db3fd3b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add70536479a7c799d338021db3fd3b5d">&#9670;&#160;</a></span>getTiledImplementation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a> &gt; getTiledImplementation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a></td>          <td class="paramname"><span class="paramname"><em>reductionStrategy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>regionIterArg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>ivs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>numThreads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>givenTileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reductionDims</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00821">821</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TilingInterface_8h_source.html#l00051">mlir::FullReduction</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00794">getSplitReductionIvs()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

</div>
</div>
<a id="a8d982a928f07cccfab12c01249748e4f" name="a8d982a928f07cccfab12c01249748e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d982a928f07cccfab12c01249748e4f">&#9670;&#160;</a></span>getTileOffsetAndSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; getTileOffsetAndSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>ivs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>iterationDomain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>givenTileSizes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the <span class="tt"><a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a></span>s that represents the multi-dimensional <span class="tt">offset</span>s and <span class="tt">size</span>s of the tile of the iteration space that the innermost loop body of the generated tiled loops corresponds to. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00277">277</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00081">mlir::getAsOpFoldResult()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00237">getBoundedTileSize()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">mlir::isZeroInteger()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00388">generateLoopNestUsingForOp()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00474">getTileOffsetAndSizesWithForAllOp()</a>.</p>

</div>
</div>
<a id="a9e9117718aa1ede278f942b023b7aab2" name="a9e9117718aa1ede278f942b023b7aab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9117718aa1ede278f942b023b7aab2">&#9670;&#160;</a></span>getTileOffsetAndSizesWithForAllOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; getTileOffsetAndSizesWithForAllOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>ivs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>iterationDomain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>givenTileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>numThreads</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the <span class="tt"><a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a></span>s that represents the multi-dimensional <span class="tt">offset</span>s and <span class="tt">size</span>s of the tile of the iteration space that the innermost loop body of the generated tiled loops corresponds to when tiling using <span class="tt">forall</span> op. </p>
<p>This is handle separately due to the special case handling needed for when the tiling is done by specifying number of threads. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00474">474</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00262">canOmitTileOffsetInBoundsCheck()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00277">getTileOffsetAndSizes()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">mlir::isZeroInteger()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01579">mlir::affine::makeComposedFoldedAffineMax()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01572">mlir::affine::makeComposedFoldedAffineMin()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00557">generateLoopNestUsingForallOp()</a>.</p>

</div>
</div>
<a id="a66472b68e266e685090a73c5d217e559" name="a66472b68e266e685090a73c5d217e559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66472b68e266e685090a73c5d217e559">&#9670;&#160;</a></span>getUntiledConsumerFromSlice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt; getUntiledConsumerFromSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::InsertSliceOp</td>          <td class="paramname"><span class="paramname"><em>candidateSliceOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the untiled consumer of the outermost scf.for's result which is yielded by a tensor.insert_slice from the innermost scf.for. </p>
<p>This function makes the following assumptions :</p><ol type="1">
<li>tensor.insert_slice has scf.yield as its only user.</li>
<li>scf.for's corresponding result has only one use.</li>
<li>The <span class="tt">loops</span> passed in are perfectly nested <span class="tt">scf.for</span> operations. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l02050">2050</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TileUsingInterface_8cpp_source.html#l01856">checkAssumptionForFusingConsumer()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01999">getConsumerFromLoopUses()</a>, <a class="el" href="Value_8cpp_source.html#l00226">mlir::OpOperand::getOperandNumber()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, <a class="el" href="Value_8h_source.html#l00188">mlir::Value::getUses()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01524">mlir::isPerfectlyNestedForLoops()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l02116">getUntiledConsumerOperandsFromSlices()</a>.</p>

</div>
</div>
<a id="a5ad1ffd875c090c64222aa6ee765efbf" name="a5ad1ffd875c090c64222aa6ee765efbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad1ffd875c090c64222aa6ee765efbf">&#9670;&#160;</a></span>getUntiledConsumerFromSlice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt; getUntiledConsumerFromSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ParallelInsertSliceOp</td>          <td class="paramname"><span class="paramname"><em>candidateSliceOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the first untiled consumer of a scf.forall's result which is yielded by a tensor.parallel_insert_slice. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l02084">2084</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TileUsingInterface_8cpp_source.html#l01999">getConsumerFromLoopUses()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

</div>
</div>
<a id="a6d94c1bf365f0554b258899dd8baad4f" name="a6d94c1bf365f0554b258899dd8baad4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d94c1bf365f0554b258899dd8baad4f">&#9670;&#160;</a></span>getUntiledConsumerOperandsFromSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt; &gt; getUntiledConsumerOperandsFromSlices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>sliceOps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A utility to fetch an untiled consumer of tensor.insert_slice/tensor.parallel_insert_slice. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l02116">2116</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TileUsingInterface_8cpp_source.html#l02050">getUntiledConsumerFromSlice()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

</div>
</div>
<a id="a14f051b3bcd74a768026486e54398210" name="a14f051b3bcd74a768026486e54398210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f051b3bcd74a768026486e54398210">&#9670;&#160;</a></span>getUntiledProducerFromSliceSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classmlir_1_1OpResult.html">OpResult</a>, std::optional&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt; &gt; getUntiledProducerFromSliceSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LoopLikeOpInterface &gt;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the untiled producer whose slice is used in a tiled consumer. </p>
<p>The method traverses the tile loop nest (<span class="tt">loops</span>) if needed, and returns the <span class="tt">iter_args</span> of the outer most that is encountered. Traversing the iter_args indicates that this is a destination operand of the consumer. If there was no loop traversal needed, the second value of the returned tuple is empty. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01315">1315</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>.</p>

</div>
</div>
<a id="ae6f48eb394ba79ea53f4bb9c56a70b49" name="ae6f48eb394ba79ea53f4bb9c56a70b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f48eb394ba79ea53f4bb9c56a70b49">&#9670;&#160;</a></span>getUserTileSizesAndNumThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; getUserTileSizesAndNumThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>iterationDomain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scf::SCFTilingOptions &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to instantiate the tile sizes and/or number of threads specified by the user. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00101">101</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01006">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">mlir::isZeroInteger()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a07241199d7f7bdfecfb4fe0d854fe48f" name="a07241199d7f7bdfecfb4fe0d854fe48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07241199d7f7bdfecfb4fe0d854fe48f">&#9670;&#160;</a></span>mergeTilingResults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1MergeResult.html">MergeResult</a> &gt; mergeTilingResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a></td>          <td class="paramname"><span class="paramname"><em>reductionStrategy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reductionDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>partialResults</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00877">877</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TilingInterface_8h_source.html#l00051">mlir::FullReduction</a>, and <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

</div>
</div>
<a id="a40a73f0ba8021c393b365dd47d789454" name="a40a73f0ba8021c393b365dd47d789454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a73f0ba8021c393b365dd47d789454">&#9670;&#160;</a></span>tileAndFuseConsumerOfSlicesImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; scf::SCFFuseConsumerOfSliceResult &gt; tileAndFuseConsumerOfSlicesImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>consumerOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>consumerOpOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>candidateSlices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l02188">2188</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TileUsingInterface_8cpp_source.html#l01041">addInitOperandsToLoopNest()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01952">checkAssumptionForLoop()</a>, <a class="el" href="Builders_8cpp_source.html#l00562">mlir::OpBuilder::clone()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l02168">cloneAsInsertSlices()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01881">getFirstUserOfLoop()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Builders_8h_source.html#l00445">mlir::OpBuilder::getInsertionPoint()</a>, <a class="el" href="Value_8cpp_source.html#l00226">mlir::OpOperand::getOperandNumber()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="Block_8cpp_source.html#l00244">mlir::Block::getTerminator()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00022">mlir::isOneInteger()</a>, <a class="el" href="PatternMatch_8h_source.html#l00638">mlir::RewriterBase::modifyOpInPlace()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00407">mlir::RewriterBase::moveOpBefore()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PatternMatch_8h_source.html#l00646">mlir::RewriterBase::replaceAllUsesWith()</a>, <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html#l00061">mlir::tensor::replaceInsertSlicesWithTiledConsumer()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="abb6dd85d4816fccaea1880b659d13c74" name="abb6dd85d4816fccaea1880b659d13c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6dd85d4816fccaea1880b659d13c74">&#9670;&#160;</a></span>tileDividesIterationDomain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> tileDividesIterationDomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Range.html">Range</a></td>          <td class="paramname"><span class="paramname"><em>loopRange</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <span class="tt">stride</span> evenly divides the trip count <span class="tt">size - offset</span>. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00222">222</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00036">mlir::Range::offset</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00037">mlir::Range::size</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00038">mlir::Range::stride</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00237">getBoundedTileSize()</a>.</p>

</div>
</div>
<a id="ae7dfa05fb201f99ec63ba9a32aec6299" name="ae7dfa05fb201f99ec63ba9a32aec6299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7dfa05fb201f99ec63ba9a32aec6299">&#9670;&#160;</a></span>verifyOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult verifyOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scf::SCFTilingOptions &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify the tile size options are set in a consistent manner. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00077">77</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00204">mlir::isPermutationVector()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="abdbc9cbe5517396c1feada1fadefc3df" name="abdbc9cbe5517396c1feada1fadefc3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbc9cbe5517396c1feada1fadefc3df">&#9670;&#160;</a></span>yieldTiledValuesAndReplaceLoop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; LoopLikeOpInterface &gt; yieldTiledValuesAndReplaceLoop </td>
          <td>(</td>
          <td class="paramtype">LoopLikeOpInterface</td>          <td class="paramname"><span class="paramname"><em>loopLikeOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>newInitOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a84cb389e736acc0eacc571ba2b913251">YieldTiledValuesFn</a></td>          <td class="paramname"><span class="paramname"><em>yieldTiledValuesFn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <span class="tt">yieldTiledValuesAndReplaceLoop</span> for <span class="tt">LoopLikeOpInterface</span>, that just dispatches to the implementation for each supported loop type. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01021">1021</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00904">yieldTiledValuesAndReplaceLoop()</a>.</p>

</div>
</div>
<a id="ae8b92b35dc194d537e026baef725d246" name="ae8b92b35dc194d537e026baef725d246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b92b35dc194d537e026baef725d246">&#9670;&#160;</a></span>yieldTiledValuesAndReplaceLoop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoopType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; LoopLikeOpInterface &gt; yieldTiledValuesAndReplaceLoop </td>
          <td>(</td>
          <td class="paramtype">LoopType</td>          <td class="paramname"><span class="paramname"><em>loopOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>newInitOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a84cb389e736acc0eacc571ba2b913251">YieldTiledValuesFn</a></td>          <td class="paramname"><span class="paramname"><em>yieldTiledValuesFn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the specified additional <span class="tt">newInitOperands</span> operands to the loops existing <span class="tt">init</span> operands (or similar), and replace <span class="tt">loopOp</span> with the new loop that has the additional init operands. </p>
<p>The loop body of this loop is moved over to the new loop. <span class="tt">yieldTiledValuesFn</span> is called to get the new tiled values returned, and the offset and sizes at which the tiled value is inserted into the new region iter_args that correspond to the newly added init operands. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00904">904</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01041">addInitOperandsToLoopNest()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l01021">yieldTiledValuesAndReplaceLoop()</a>.</p>

</div>
</div>
<a id="a20a39c74db3a8fdba231adbc0b6ed767" name="a20a39c74db3a8fdba231adbc0b6ed767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a39c74db3a8fdba231adbc0b6ed767">&#9670;&#160;</a></span>yieldTiledValuesAndReplaceLoop&lt; scf::ForallOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; LoopLikeOpInterface &gt; <a class="el" href="#ae8b92b35dc194d537e026baef725d246">yieldTiledValuesAndReplaceLoop</a>&lt; scf::ForallOp &gt; </td>
          <td>(</td>
          <td class="paramtype">scf::ForallOp</td>          <td class="paramname"><span class="paramname"><em>loopOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>newInitOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a84cb389e736acc0eacc571ba2b913251">YieldTiledValuesFn</a></td>          <td class="paramname"><span class="paramname"><em>yieldTiledValuesFn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <span class="tt">yieldTiledValuesAndReplaceLoop</span> for <span class="tt">scf.forall</span> </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00904">904</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<a id="ab38437a5237764e11d29b329a03cd4ed" name="ab38437a5237764e11d29b329a03cd4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38437a5237764e11d29b329a03cd4ed">&#9670;&#160;</a></span>yieldTiledValuesAndReplaceLoop&lt; scf::ForOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; LoopLikeOpInterface &gt; <a class="el" href="#ae8b92b35dc194d537e026baef725d246">yieldTiledValuesAndReplaceLoop</a>&lt; scf::ForOp &gt; </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp</td>          <td class="paramname"><span class="paramname"><em>loopOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>newInitOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a84cb389e736acc0eacc571ba2b913251">YieldTiledValuesFn</a></td>          <td class="paramname"><span class="paramname"><em>yieldTiledValuesFn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <span class="tt">yieldTiledValuesAndReplaceLoop</span> for <span class="tt">scf.for</span>. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00904">904</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
