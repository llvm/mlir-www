<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/SCF/Transforms/TileUsingInterface.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_d7bf56b426f340e7a9442bd07d045545.html">SCF</a></li><li class="navelem"><a class="el" href="dir_c5fb1dbd194462dcd31045c7634a832a.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TileUsingInterface.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="TileUsingInterface_8h_source.html">mlir/Dialect/SCF/Transforms/TileUsingInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SliceAnalysis_8h_source.html">mlir/Analysis/SliceAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TopologicalSortUtils_8h_source.html">mlir/Analysis/TopologicalSortUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html">mlir/Dialect/Arith/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html">mlir/Dialect/SCF/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Tensor_2IR_2Tensor_8h_source.html">mlir/Dialect/Tensor/IR/Tensor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IndexingUtils_8h_source.html">mlir/Dialect/Utils/IndexingUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dominance_8h_source.html">mlir/IR/Dominance.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DestinationStyleOpInterface_8h_source.html">mlir/Interfaces/DestinationStyleOpInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TilingInterface_8h_source.html">mlir/Interfaces/TilingInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="FrozenRewritePatternSet_8h_source.html">mlir/Rewrite/FrozenRewritePatternSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GreedyPatternRewriteDriver_8h_source.html">mlir/Transforms/GreedyPatternRewriteDriver.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/ScopeExit.h&quot;</code><br />
<code>#include &quot;llvm/ADT/TypeSwitch.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
</div>
<p><a href="TileUsingInterface_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;tile-using-interface&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a505d4f42e1beb901ab163d108b0c8db9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> = std::function&lt; LogicalResult(<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newBbArgs, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;tiledValues, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; &amp;resultOffsets, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt; &amp;resultSizes)&gt;</td></tr>
<tr class="memdesc:a505d4f42e1beb901ab163d108b0c8db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that allows returning additional yielded values during <code>yieldTiledValuesAndReplace</code>.  <a href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">More...</a><br /></td></tr>
<tr class="separator:a505d4f42e1beb901ab163d108b0c8db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0b0f1d605335ebbc8fafee8571e85d7f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a0b0f1d605335ebbc8fafee8571e85d7f">fillInterchangeVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; interchangeVector, size_t iterationDomainSize)</td></tr>
<tr class="memdesc:a0b0f1d605335ebbc8fafee8571e85d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to adjust the interchange vector to match the iteration domain.  <a href="TileUsingInterface_8cpp.html#a0b0f1d605335ebbc8fafee8571e85d7f">More...</a><br /></td></tr>
<tr class="separator:a0b0f1d605335ebbc8fafee8571e85d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dfa05fb201f99ec63ba9a32aec6299"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#ae7dfa05fb201f99ec63ba9a32aec6299">verifyOptions</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, const <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">scf::SCFTilingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:ae7dfa05fb201f99ec63ba9a32aec6299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the tile size options are set in a consistent manner.  <a href="TileUsingInterface_8cpp.html#ae7dfa05fb201f99ec63ba9a32aec6299">More...</a><br /></td></tr>
<tr class="separator:ae7dfa05fb201f99ec63ba9a32aec6299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad85bf3fd0f4e53a5ad346ef48397438"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#aad85bf3fd0f4e53a5ad346ef48397438">getUserTileSizesAndNumThreads</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; iterationDomain, const <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">scf::SCFTilingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:aad85bf3fd0f4e53a5ad346ef48397438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to instantiate the tile sizes and/or number of threads specified by the user.  <a href="TileUsingInterface_8cpp.html#aad85bf3fd0f4e53a5ad346ef48397438">More...</a><br /></td></tr>
<tr class="separator:aad85bf3fd0f4e53a5ad346ef48397438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76ca043bdd336677f45e89c92093f8e"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#ad76ca043bdd336677f45e89c92093f8e">checkTileSizes</a> (TilingInterface op, <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html#ac0de119f731019cc6d8acb08187198cd">scf::SCFTilingOptions::LoopType</a> loopType, <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a> reductionStrategy, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads)</td></tr>
<tr class="memdesc:ad76ca043bdd336677f45e89c92093f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any of the tiled loops are not parallel.  <a href="TileUsingInterface_8cpp.html#ad76ca043bdd336677f45e89c92093f8e">More...</a><br /></td></tr>
<tr class="separator:ad76ca043bdd336677f45e89c92093f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e185e1dc37c135678df091feb277d1d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a0e185e1dc37c135678df091feb277d1d">getSanitizedReductionDims</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, const <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">scf::SCFTilingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a0e185e1dc37c135678df091feb277d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reduction dims that are tiled.  <a href="TileUsingInterface_8cpp.html#a0e185e1dc37c135678df091feb277d1d">More...</a><br /></td></tr>
<tr class="separator:a0e185e1dc37c135678df091feb277d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6dd85d4816fccaea1880b659d13c74"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#abb6dd85d4816fccaea1880b659d13c74">tileDividesIterationDomain</a> (<a class="el" href="structmlir_1_1Range.html">Range</a> loopRange)</td></tr>
<tr class="memdesc:abb6dd85d4816fccaea1880b659d13c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>stride</code> evenly divides the trip count <code>size - offset</code>.  <a href="TileUsingInterface_8cpp.html#abb6dd85d4816fccaea1880b659d13c74">More...</a><br /></td></tr>
<tr class="separator:abb6dd85d4816fccaea1880b659d13c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880e291006bd7a102432578ee0957069"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a880e291006bd7a102432578ee0957069">getBoundedTileSize</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="structmlir_1_1Range.html">Range</a> loopRange, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> offset, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> tileSize)</td></tr>
<tr class="memdesc:a880e291006bd7a102432578ee0957069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bounded tile size given the current <code>offset</code>, <code>loopRange</code> and <code>tileSize</code>, i.e., <code>min(tileSize, range.end() - offset)</code>.  <a href="TileUsingInterface_8cpp.html#a880e291006bd7a102432578ee0957069">More...</a><br /></td></tr>
<tr class="separator:a880e291006bd7a102432578ee0957069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5414ba15ec7505cbe18cda75476c7082"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a5414ba15ec7505cbe18cda75476c7082">canOmitTileOffsetInBoundsCheck</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> tileSize, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> numThreads, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> iterationSize)</td></tr>
<tr class="memdesc:a5414ba15ec7505cbe18cda75476c7082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the maximum tile offset <code>tileSize * numThreads-1</code> is less than <code>iterationSize</code>.  <a href="TileUsingInterface_8cpp.html#a5414ba15ec7505cbe18cda75476c7082">More...</a><br /></td></tr>
<tr class="separator:a5414ba15ec7505cbe18cda75476c7082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98c08537bc6e37e75f40114e8480424"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#ae98c08537bc6e37e75f40114e8480424">getTileOffsetAndSizes</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a> strategy, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; iterationDomain, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, const <a class="el" href="classllvm_1_1SetVector.html">llvm::SetVector</a>&lt; unsigned &gt; &amp;reductionDims)</td></tr>
<tr class="memdesc:ae98c08537bc6e37e75f40114e8480424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the <code>OpFoldResult</code>s that represents the multi-dimensional <code>offset</code>s and <code>size</code>s of the tile of the iteration space that the innermost loop body of the generated tiled loops corresponds to.  <a href="TileUsingInterface_8cpp.html#ae98c08537bc6e37e75f40114e8480424">More...</a><br /></td></tr>
<tr class="separator:ae98c08537bc6e37e75f40114e8480424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda80cd33074b6273520daf966406fa8"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#abda80cd33074b6273520daf966406fa8">getLoopBounds</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; loopRanges, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes)</td></tr>
<tr class="memdesc:abda80cd33074b6273520daf966406fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to return the bounds of the loops to be generated.  <a href="TileUsingInterface_8cpp.html#abda80cd33074b6273520daf966406fa8">More...</a><br /></td></tr>
<tr class="separator:abda80cd33074b6273520daf966406fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac306562a8fbc59e01746c58da2cdd7ed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#ac306562a8fbc59e01746c58da2cdd7ed">cloneOpAndUpdateDestinationArgs</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newDestArgs)</td></tr>
<tr class="memdesc:ac306562a8fbc59e01746c58da2cdd7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones the operation and updates the destination if the operation implements the <code>DestinationStyleOpInterface</code>.  <a href="TileUsingInterface_8cpp.html#ac306562a8fbc59e01746c58da2cdd7ed">More...</a><br /></td></tr>
<tr class="separator:ac306562a8fbc59e01746c58da2cdd7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2945e64b5676eb54ff016a7ba1eee5"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a8b2945e64b5676eb54ff016a7ba1eee5">generateLoopNestUsingForOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; loopRanges, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> destinationTensors, <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> yieldTiledValuesFn, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &amp;loops)</td></tr>
<tr class="memdesc:a8b2945e64b5676eb54ff016a7ba1eee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the tile-loop nest using <code>scf.for</code> operation.  <a href="TileUsingInterface_8cpp.html#a8b2945e64b5676eb54ff016a7ba1eee5">More...</a><br /></td></tr>
<tr class="separator:a8b2945e64b5676eb54ff016a7ba1eee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68c84503ecbbb94571d6f8f72d636a2"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#af68c84503ecbbb94571d6f8f72d636a2">generateLoopNestUsingForallOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; loopRanges, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; mappingVector, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> destinationTensors, <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> tiledBodyFn, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &amp;loops)</td></tr>
<tr class="memdesc:af68c84503ecbbb94571d6f8f72d636a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the tile-loop nest using <code>scf.forall</code> operation.  <a href="TileUsingInterface_8cpp.html#af68c84503ecbbb94571d6f8f72d636a2">More...</a><br /></td></tr>
<tr class="separator:af68c84503ecbbb94571d6f8f72d636a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9d108ae7fb281d7f1b3745d25ba328"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a5f9d108ae7fb281d7f1b3745d25ba328">generateLoopNest</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html#ac0de119f731019cc6d8acb08187198cd">scf::SCFTilingOptions::LoopType</a> loopType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; loopRanges, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> destinationTensors, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; mappingVector, <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> tiledBodyFn, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &amp;loops)</td></tr>
<tr class="memdesc:a5f9d108ae7fb281d7f1b3745d25ba328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the tile-loop nest using the loop construct specifed in <code>options</code>.  <a href="TileUsingInterface_8cpp.html#a5f9d108ae7fb281d7f1b3745d25ba328">More...</a><br /></td></tr>
<tr class="separator:a5f9d108ae7fb281d7f1b3745d25ba328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdae225de99e59e237f6534509cd47a4"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#acdae225de99e59e237f6534509cd47a4">createInitialTensorsForTiling</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a> reductionStrategy, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; iterationDomain, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, const <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; unsigned &gt; &amp;reductionDims)</td></tr>
<tr class="separator:acdae225de99e59e237f6534509cd47a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fe57f329b2d5a3ce05b27f02644751"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#af4fe57f329b2d5a3ce05b27f02644751">getSplitReductionIvs</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a> reductionStrategy, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, const <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; unsigned &gt; &amp;reductionDims)</td></tr>
<tr class="memdesc:af4fe57f329b2d5a3ce05b27f02644751"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the case of <code>ReductionTilingStrategy::PartialReductionOuterParallel</code> the <code>PartialReductionOpInterface</code> methods need the index of the parallel split reduction being executed.  <a href="TileUsingInterface_8cpp.html#af4fe57f329b2d5a3ce05b27f02644751">More...</a><br /></td></tr>
<tr class="separator:af4fe57f329b2d5a3ce05b27f02644751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af010091f0bba5b7ea8a65459f138df82"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#af010091f0bba5b7ea8a65459f138df82">getTiledImplementation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a> reductionStrategy, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> regionIterArg, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, const <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; unsigned &gt; &amp;reductionDims)</td></tr>
<tr class="separator:af010091f0bba5b7ea8a65459f138df82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a71c9d8bdc136ff107a8f9d25e17e8b"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a4a71c9d8bdc136ff107a8f9d25e17e8b">getResultTilePosition</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a> reductionStrategy, int64_t index, <a class="el" href="classmlir_1_1Value.html">Value</a> tiledResult, TilingInterface op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes, const <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; unsigned &gt; &amp;reductionDims, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;resultOffset, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;resultSize)</td></tr>
<tr class="separator:a4a71c9d8bdc136ff107a8f9d25e17e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2aa0c56fc844522f387b564baa54f0"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="structmlir_1_1MergeResult.html">MergeResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a8f2aa0c56fc844522f387b564baa54f0">mergeTilingResults</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a> reductionStrategy, const <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; unsigned &gt; &amp;reductionDims, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> partialResults)</td></tr>
<tr class="separator:a8f2aa0c56fc844522f387b564baa54f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88598dd179a90f26e657f7f024a6f332"><td class="memTemplParams" colspan="2">template&lt;typename LoopType &gt; </td></tr>
<tr class="memitem:a88598dd179a90f26e657f7f024a6f332"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; LoopLikeOpInterface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a88598dd179a90f26e657f7f024a6f332">yieldTiledValuesAndReplaceLoop</a> (LoopType loopOp, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newInitOperands, <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> yieldTiledValuesFn)</td></tr>
<tr class="memdesc:a88598dd179a90f26e657f7f024a6f332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the specified additional <code>newInitOperands</code> operands to the loops existing <code>init</code> operands (or similar), and replace <code>loopOp</code> with the new loop that has the additional init operands.  <a href="TileUsingInterface_8cpp.html#a88598dd179a90f26e657f7f024a6f332">More...</a><br /></td></tr>
<tr class="separator:a88598dd179a90f26e657f7f024a6f332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5901df24969e8438ea1ce98c323a52"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aaf5901df24969e8438ea1ce98c323a52"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; LoopLikeOpInterface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#aaf5901df24969e8438ea1ce98c323a52">yieldTiledValuesAndReplaceLoop&lt; scf::ForOp &gt;</a> (scf::ForOp loopOp, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newInitOperands, <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> yieldTiledValuesFn)</td></tr>
<tr class="memdesc:aaf5901df24969e8438ea1ce98c323a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <code>yieldTiledValuesAndReplaceLoop</code> for <code>scf.for</code>.  <a href="TileUsingInterface_8cpp.html#aaf5901df24969e8438ea1ce98c323a52">More...</a><br /></td></tr>
<tr class="separator:aaf5901df24969e8438ea1ce98c323a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b85791a9ab89de7ca013a1c7b88653"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a34b85791a9ab89de7ca013a1c7b88653"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; LoopLikeOpInterface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a34b85791a9ab89de7ca013a1c7b88653">yieldTiledValuesAndReplaceLoop&lt; scf::ForallOp &gt;</a> (scf::ForallOp loopOp, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newInitOperands, <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> yieldTiledValuesFn)</td></tr>
<tr class="memdesc:a34b85791a9ab89de7ca013a1c7b88653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <code>yieldTiledValuesAndReplaceLoop</code> for <code>scf.forall</code>  <a href="TileUsingInterface_8cpp.html#a34b85791a9ab89de7ca013a1c7b88653">More...</a><br /></td></tr>
<tr class="separator:a34b85791a9ab89de7ca013a1c7b88653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8891f33aac7261d1c7916cf144c991"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LoopLikeOpInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a4f8891f33aac7261d1c7916cf144c991">yieldTiledValuesAndReplaceLoop</a> (LoopLikeOpInterface loopLikeOp, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newInitOperands, <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> yieldTiledValuesFn)</td></tr>
<tr class="memdesc:a4f8891f33aac7261d1c7916cf144c991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <code>yieldTiledValuesAndReplaceLoop</code> for <code>LoopLikeOpInterface</code>, that just dispatches to the implementation for each supported loop type.  <a href="TileUsingInterface_8cpp.html#a4f8891f33aac7261d1c7916cf144c991">More...</a><br /></td></tr>
<tr class="separator:a4f8891f33aac7261d1c7916cf144c991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba6980331e472f54032c57818013e68"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#acba6980331e472f54032c57818013e68">addInitOperandsToLoopNest</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt; loops, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newInitValues, <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> getNewTiledYieldsFn)</td></tr>
<tr class="memdesc:acba6980331e472f54032c57818013e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to add new init values to a loop nest.  <a href="TileUsingInterface_8cpp.html#acba6980331e472f54032c57818013e68">More...</a><br /></td></tr>
<tr class="separator:acba6980331e472f54032c57818013e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c50f9432b1225386223125ae77df4d"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; <a class="el" href="classmlir_1_1OpResult.html">OpResult</a>, std::optional&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#ab4c50f9432b1225386223125ae77df4d">getUntiledProducerFromSliceSource</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *source, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LoopLikeOpInterface &gt; loops)</td></tr>
<tr class="memdesc:ab4c50f9432b1225386223125ae77df4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the untiled producer whose slice is used in a tiled consumer.  <a href="TileUsingInterface_8cpp.html#ab4c50f9432b1225386223125ae77df4d">More...</a><br /></td></tr>
<tr class="separator:ab4c50f9432b1225386223125ae77df4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c60be984a912b6e26bba0f55834ebba"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a2c60be984a912b6e26bba0f55834ebba">checkAssumptionForFusingConsumer</a> (tensor::InsertSliceOp candidateSliceOp)</td></tr>
<tr class="memdesc:a2c60be984a912b6e26bba0f55834ebba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function that checks whether the only use of the result of a tensor.insert_slice op is in a scf.yield op.  <a href="TileUsingInterface_8cpp.html#a2c60be984a912b6e26bba0f55834ebba">More...</a><br /></td></tr>
<tr class="separator:a2c60be984a912b6e26bba0f55834ebba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac906306ad6a49c6c5d40ec06cd8b948e"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#ac906306ad6a49c6c5d40ec06cd8b948e">getFirstUserOfLoop</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *loopOp)</td></tr>
<tr class="memdesc:ac906306ad6a49c6c5d40ec06cd8b948e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An utility to get the first user of the given loopOp.  <a href="TileUsingInterface_8cpp.html#ac906306ad6a49c6c5d40ec06cd8b948e">More...</a><br /></td></tr>
<tr class="separator:ac906306ad6a49c6c5d40ec06cd8b948e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e9fe707ad0a8068826d2d4425e90f4"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classllvm_1_1SetVector.html">llvm::SetVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a74e9fe707ad0a8068826d2d4425e90f4">checkAssumptionForLoop</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *loopOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *consumerOp, bool reorderOperations)</td></tr>
<tr class="memdesc:a74e9fe707ad0a8068826d2d4425e90f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility currently checks whether the first userOp of loop is NOT before the last defineOp of consumer operand.  <a href="TileUsingInterface_8cpp.html#a74e9fe707ad0a8068826d2d4425e90f4">More...</a><br /></td></tr>
<tr class="separator:a74e9fe707ad0a8068826d2d4425e90f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c26828f07f44e434b7f4b0a2d18d216"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a8c26828f07f44e434b7f4b0a2d18d216">getConsumerFromLoopUses</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *loopOp, unsigned resultNumber)</td></tr>
<tr class="memdesc:a8c26828f07f44e434b7f4b0a2d18d216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the OpOperand of the first valid user (and use) of the value <code>val</code> which implements <code>TilingInterface</code> and <code>DestinationStyleOpInterface</code>.  <a href="TileUsingInterface_8cpp.html#a8c26828f07f44e434b7f4b0a2d18d216">More...</a><br /></td></tr>
<tr class="separator:a8c26828f07f44e434b7f4b0a2d18d216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e14523733646f1383837dbae6c00656"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a3e14523733646f1383837dbae6c00656">isPerfectlyNestedForLoops</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt; loops)</td></tr>
<tr class="memdesc:a3e14523733646f1383837dbae6c00656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the loop is perfectly nested.  <a href="TileUsingInterface_8cpp.html#a3e14523733646f1383837dbae6c00656">More...</a><br /></td></tr>
<tr class="separator:a3e14523733646f1383837dbae6c00656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada33ff82be3e635c19f686ffa32bff28"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#ada33ff82be3e635c19f686ffa32bff28">getUntiledConsumerFromSlice</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::InsertSliceOp candidateSliceOp, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt; loops)</td></tr>
<tr class="memdesc:ada33ff82be3e635c19f686ffa32bff28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the untiled consumer of the outermost scf.for's result which is yielded by a tensor.insert_slice from the innermost scf.for.  <a href="TileUsingInterface_8cpp.html#ada33ff82be3e635c19f686ffa32bff28">More...</a><br /></td></tr>
<tr class="separator:ada33ff82be3e635c19f686ffa32bff28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544d7ec894df4e8e1c4a1462f46af76b"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a544d7ec894df4e8e1c4a1462f46af76b">getUntiledConsumerFromSlice</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::ParallelInsertSliceOp candidateSliceOp, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt; loops)</td></tr>
<tr class="memdesc:a544d7ec894df4e8e1c4a1462f46af76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the first untiled consumer of a scf.forall's result which is yielded by a tensor.parallel_insert_slice.  <a href="TileUsingInterface_8cpp.html#a544d7ec894df4e8e1c4a1462f46af76b">More...</a><br /></td></tr>
<tr class="separator:a544d7ec894df4e8e1c4a1462f46af76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc929b3dbf9f620b1762e695014ac1a5"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#acc929b3dbf9f620b1762e695014ac1a5">getUntiledConsumerOperandsFromSlices</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; sliceOps, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt; loops)</td></tr>
<tr class="memdesc:acc929b3dbf9f620b1762e695014ac1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility to fetch an untiled consumer of tensor.insert_slice/tensor.parallel_insert_slice.  <a href="TileUsingInterface_8cpp.html#acc929b3dbf9f620b1762e695014ac1a5">More...</a><br /></td></tr>
<tr class="separator:acc929b3dbf9f620b1762e695014ac1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97be6b3297bf26326b111ca2fa97da1"><td class="memTemplParams" colspan="2">template&lt;typename InsertSliceOpTy &gt; </td></tr>
<tr class="memitem:ad97be6b3297bf26326b111ca2fa97da1"><td class="memTemplItemLeft" align="right" valign="top">static tensor::InsertSliceOp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#ad97be6b3297bf26326b111ca2fa97da1">cloneAsInsertSlice</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, InsertSliceOpTy sliceOp)</td></tr>
<tr class="separator:ad97be6b3297bf26326b111ca2fa97da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89438f1b74db0575ec5f079a61d8ec40"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a89438f1b74db0575ec5f079a61d8ec40"><td class="memTemplItemLeft" align="right" valign="top">tensor::InsertSliceOp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a89438f1b74db0575ec5f079a61d8ec40">cloneAsInsertSlice&lt; tensor::InsertSliceOp &gt;</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::InsertSliceOp insertSliceOp)</td></tr>
<tr class="separator:a89438f1b74db0575ec5f079a61d8ec40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2198fa360b947c9e90735288f93fda"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7a2198fa360b947c9e90735288f93fda"><td class="memTemplItemLeft" align="right" valign="top">tensor::InsertSliceOp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#a7a2198fa360b947c9e90735288f93fda">cloneAsInsertSlice&lt; tensor::ParallelInsertSliceOp &gt;</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::ParallelInsertSliceOp insertSliceOp)</td></tr>
<tr class="separator:a7a2198fa360b947c9e90735288f93fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18b8a78d8fedeafa508e3f7130df329"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; tensor::InsertSliceOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="TileUsingInterface_8cpp.html#ad18b8a78d8fedeafa508e3f7130df329">cloneAsInsertSlices</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; candidateSlices)</td></tr>
<tr class="separator:ad18b8a78d8fedeafa508e3f7130df329"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;tile-using-interface&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00033">33</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a505d4f42e1beb901ab163d108b0c8db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505d4f42e1beb901ab163d108b0c8db9">&#9670;&nbsp;</a></span>YieldTiledValuesFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a> =  std::function&lt;LogicalResult( <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> newBbArgs, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &amp;tiledValues, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; &gt; &amp;resultOffsets, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; &gt; &amp;resultSizes)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that allows returning additional yielded values during <code>yieldTiledValuesAndReplace</code>. </p>
<ul>
<li><code>ivs</code> induction variable for the loop.</li>
<li><code>newBbArgs</code> basic block arguments corresponding to newly added iter_args.</li>
<li><code>tiledValues</code> the tiled values to return. Must be of same size as <code>newbbArgs</code>, each element of this array is inserted into the corresponding element in <code>newbbArgs</code>.</li>
<li><code>resultOffsets</code> is of the same size as <code>tiledValues</code> and represents the offsets to use when inserting corresponding element from <code>tiledValues</code> into the element from <code>newBbArgs</code>.</li>
<li><code>resultSizes</code> is of the same size as <code>tiledValues</code> and represents the size of the corresponding element from <code>tiledValues</code> inserted into the element from <code>newBbArgs</code>. In case the method needs to return <code>failure()</code> the method is expected to clean up any inserted operations. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00399">399</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acba6980331e472f54032c57818013e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba6980331e472f54032c57818013e68">&#9670;&nbsp;</a></span>addInitOperandsToLoopNest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult addInitOperandsToLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newInitValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a>&#160;</td>
          <td class="paramname"><em>getNewTiledYieldsFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to add new init values to a loop nest. </p>
<p>Updates <code>loops</code> in-place with new loops that use the <code>newInitValues</code>. The outer-loops are updated to yield the new result values of the inner loop. For the innermost loop, the call back <code>getNewYields</code> is invoked to get the additional values to yield form the innermost loop. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00917">917</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00343">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00519">mlir::RewriterBase::replaceOpWithNewOp()</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00781">yieldTiledValuesAndReplaceLoop()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l02122">mlir::scf::tileAndFuseConsumerOfSlices()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l01325">mlir::scf::yieldReplacementForFusedProducer()</a>.</p>

</div>
</div>
<a id="a5414ba15ec7505cbe18cda75476c7082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5414ba15ec7505cbe18cda75476c7082">&#9670;&nbsp;</a></span>canOmitTileOffsetInBoundsCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool canOmitTileOffsetInBoundsCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>tileSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>iterationSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the maximum tile offset <code>tileSize * numThreads-1</code> is less than <code>iterationSize</code>. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00262">262</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00277">getTileOffsetAndSizes()</a>.</p>

</div>
</div>
<a id="a2c60be984a912b6e26bba0f55834ebba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c60be984a912b6e26bba0f55834ebba">&#9670;&nbsp;</a></span>checkAssumptionForFusingConsumer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult checkAssumptionForFusingConsumer </td>
          <td>(</td>
          <td class="paramtype">tensor::InsertSliceOp&#160;</td>
          <td class="paramname"><em>candidateSliceOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A utility function that checks whether the only use of the result of a tensor.insert_slice op is in a scf.yield op. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01730">1730</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, and <a class="el" href="Value_8h_source.html#l00188">mlir::Value::getUses()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01981">getUntiledConsumerFromSlice()</a>.</p>

</div>
</div>
<a id="a74e9fe707ad0a8068826d2d4425e90f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e9fe707ad0a8068826d2d4425e90f4">&#9670;&nbsp;</a></span>checkAssumptionForLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;<a class="el" href="classllvm_1_1SetVector.html">llvm::SetVector</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &gt; checkAssumptionForLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>loopOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>consumerOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reorderOperations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility currently checks whether the first userOp of loop is NOT before the last defineOp of consumer operand. </p>
<p>Because that we need to move the whole loop structure right before the <code>firstUserOfLoop</code>. This utility thus helps ensuring that no invalid IR is formed, i.e. no backward slice of consumerOp is dominated by the <code>firstUserOfLoop</code>. Saying that:</p>
<div class="fragment"><div class="line">%0 = scf.for() {</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">%1 = firstUserOfLoop(%0)</div>
<div class="line">...</div>
<div class="line">%2 = lastDefOfConsumerOperand</div>
<div class="line">...</div>
<div class="line">%3 = consumerOp(%2)</div>
</div><!-- fragment --><p>If the <code>firstUserOfLoop</code> is before <code>lastDefOfConsumerOperand</code>, then it would be invalid to move the <code>loopOp</code> right before the <code>firstUserOfLoop</code>, a.k.a. use-def chain violation:</p>
<div class="fragment"><div class="line">%0:2 = scf.for() {</div>
<div class="line">   <span class="comment">// use before define error</span></div>
<div class="line">   %3 = tiledConsumerOp(%2)</div>
<div class="line">}</div>
<div class="line">%1 = firstUserOfLoop(%0)</div>
<div class="line">...</div>
<div class="line">%2 = lastDefOfConsumerOperand</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loopOp</td><td>loop operation </td></tr>
    <tr><td class="paramname">consumerOp</td><td>consumer operation </td></tr>
    <tr><td class="paramname">reorderOperations</td><td>the flag controls whether to reorder the backward slice w.r.t. the defineOp of <code>consumerOp</code> operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: computed backward slice of consumerOp, but excluding those already dominates <code>firstUserOfLoop</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01826">1826</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="SliceAnalysis_8cpp_source.html#l00177">mlir::getBackwardSlice()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01755">getFirstUserOfLoop()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="Dominance_8cpp_source.html#l00323">mlir::DominanceInfo::properlyDominates()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01873">getConsumerFromLoopUses()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l02122">mlir::scf::tileAndFuseConsumerOfSlices()</a>.</p>

</div>
</div>
<a id="ad76ca043bdd336677f45e89c92093f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76ca043bdd336677f45e89c92093f8e">&#9670;&nbsp;</a></span>checkTileSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult checkTileSizes </td>
          <td>(</td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html#ac0de119f731019cc6d8acb08187198cd">scf::SCFTilingOptions::LoopType</a>&#160;</td>
          <td class="paramname"><em>loopType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a>&#160;</td>
          <td class="paramname"><em>reductionStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>numThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if any of the tiled loops are not parallel. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00155">155</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html#ac0de119f731019cc6d8acb08187198cda5c060ed3dfd4303086b9d03f1930d71d">mlir::scf::SCFTilingOptions::ForallOp</a>, <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9abe3b9ba476420bd7d98de1a4560c2e3d">mlir::FullReduction</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00144">mlir::isConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00987">mlir::scf::tileUsingSCF()</a>.</p>

</div>
</div>
<a id="ad97be6b3297bf26326b111ca2fa97da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97be6b3297bf26326b111ca2fa97da1">&#9670;&nbsp;</a></span>cloneAsInsertSlice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InsertSliceOpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static tensor::InsertSliceOp cloneAsInsertSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InsertSliceOpTy&#160;</td>
          <td class="paramname"><em>sliceOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l02099">cloneAsInsertSlices()</a>.</p>

</div>
</div>
<a id="a89438f1b74db0575ec5f079a61d8ec40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89438f1b74db0575ec5f079a61d8ec40">&#9670;&nbsp;</a></span>cloneAsInsertSlice&lt; tensor::InsertSliceOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tensor::InsertSliceOp <a class="el" href="TileUsingInterface_8cpp.html#ad97be6b3297bf26326b111ca2fa97da1">cloneAsInsertSlice</a>&lt; tensor::InsertSliceOp &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::InsertSliceOp&#160;</td>
          <td class="paramname"><em>insertSliceOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l02082">2082</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00548">mlir::OpBuilder::clone()</a>.</p>

</div>
</div>
<a id="a7a2198fa360b947c9e90735288f93fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2198fa360b947c9e90735288f93fda">&#9670;&nbsp;</a></span>cloneAsInsertSlice&lt; tensor::ParallelInsertSliceOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tensor::InsertSliceOp <a class="el" href="TileUsingInterface_8cpp.html#ad97be6b3297bf26326b111ca2fa97da1">cloneAsInsertSlice</a>&lt; tensor::ParallelInsertSliceOp &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ParallelInsertSliceOp&#160;</td>
          <td class="paramname"><em>insertSliceOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l02090">2090</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<a id="ad18b8a78d8fedeafa508e3f7130df329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18b8a78d8fedeafa508e3f7130df329">&#9670;&nbsp;</a></span>cloneAsInsertSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;tensor::InsertSliceOp&gt; cloneAsInsertSlices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>candidateSlices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l02099">2099</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TileUsingInterface_8cpp.html#ad97be6b3297bf26326b111ca2fa97da1">cloneAsInsertSlice()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l02122">mlir::scf::tileAndFuseConsumerOfSlices()</a>.</p>

</div>
</div>
<a id="ac306562a8fbc59e01746c58da2cdd7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac306562a8fbc59e01746c58da2cdd7ed">&#9670;&nbsp;</a></span>cloneOpAndUpdateDestinationArgs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Operation.html">Operation</a>* cloneOpAndUpdateDestinationArgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newDestArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones the operation and updates the destination if the operation implements the <code>DestinationStyleOpInterface</code>. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00407">407</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00548">mlir::OpBuilder::clone()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01210">mlir::scf::tileAndFuseProducerOfSlice()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00987">mlir::scf::tileUsingSCF()</a>.</p>

</div>
</div>
<a id="acdae225de99e59e237f6534509cd47a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdae225de99e59e237f6534509cd47a4">&#9670;&nbsp;</a></span>createInitialTensorsForTiling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; createInitialTensorsForTiling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a>&#160;</td>
          <td class="paramname"><em>reductionStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>iterationDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>reductionDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00604">604</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01006">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9abe3b9ba476420bd7d98de1a4560c2e3d">mlir::FullReduction</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00114">mlir::tensor::getOrCreateDestinations()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00144">mlir::isConstantIntValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9af8276115b49533f51a75db6c8e920131">mlir::PartialReductionOuterParallel</a>, and <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9ad958073d66382f63955875a66feb4d79">mlir::PartialReductionOuterReduction</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00987">mlir::scf::tileUsingSCF()</a>.</p>

</div>
</div>
<a id="a0b0f1d605335ebbc8fafee8571e85d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0f1d605335ebbc8fafee8571e85d7f">&#9670;&nbsp;</a></span>fillInterchangeVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; fillInterchangeVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>interchangeVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iterationDomainSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method to adjust the interchange vector to match the iteration domain. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00060">60</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00987">mlir::scf::tileUsingSCF()</a>.</p>

</div>
</div>
<a id="a5f9d108ae7fb281d7f1b3745d25ba328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9d108ae7fb281d7f1b3745d25ba328">&#9670;&nbsp;</a></span>generateLoopNest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult generateLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html#ac0de119f731019cc6d8acb08187198cd">scf::SCFTilingOptions::LoopType</a>&#160;</td>
          <td class="paramname"><em>loopType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>loopRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>destinationTensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>mappingVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a>&#160;</td>
          <td class="paramname"><em>tiledBodyFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &amp;&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the tile-loop nest using the loop construct specifed in <code>options</code>. </p>
<ul>
<li><code>options</code>: Tiling options specified.</li>
<li><code>loopRanges</code> specifies the lb, ub and step of the untiled iteration space.</li>
<li><code>tileSizes</code> is the tile sizes to use. Zero represent untiled loops.</li>
<li><code>destinationTensors</code> are the init values to use for the outer most loop.</li>
<li><code>yieldTiledValuesFn</code> is called to generated the loop body of the inner most loop.</li>
<li><code>loops</code> is an in-out parameter into which the generated loops are populated. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00578">578</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html#ac0de119f731019cc6d8acb08187198cda5c060ed3dfd4303086b9d03f1930d71d">mlir::scf::SCFTilingOptions::ForallOp</a>, <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html#ac0de119f731019cc6d8acb08187198cda8f94688c23f91c9149d977e0fe921524">mlir::scf::SCFTilingOptions::ForOp</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00508">generateLoopNestUsingForallOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00427">generateLoopNestUsingForOp()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00018">mlir::isZeroInteger()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00987">mlir::scf::tileUsingSCF()</a>.</p>

</div>
</div>
<a id="af68c84503ecbbb94571d6f8f72d636a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68c84503ecbbb94571d6f8f72d636a2">&#9670;&nbsp;</a></span>generateLoopNestUsingForallOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult generateLoopNestUsingForallOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>loopRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>mappingVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>destinationTensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a>&#160;</td>
          <td class="paramname"><em>tiledBodyFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &amp;&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the tile-loop nest using <code>scf.forall</code> operation. </p>
<ul>
<li><code>loopRanges</code> specifies the lb, ub and step of the untiled iteration space.</li>
<li><code>tileSizes</code> is the tile sizes to use. Zero represent untiled loops.</li>
<li><code>destinationTensors</code> are the init values to use for the outer most loop.</li>
<li><code>mappingVector</code> is the mapping attributes to use for loop construction. Can be empty.</li>
<li><code>yieldTiledValuesFn</code> is called to generated the loop body of the inner most loop.</li>
<li><code>loops</code> is an in-out parameter into which the generated loops are populated. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00508">508</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00261">mlir::Builder::getArrayAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00370">getLoopBounds()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00018">mlir::isZeroInteger()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="Builders_8h_source.html#l00434">mlir::OpBuilder::setInsertionPointToEnd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00578">generateLoopNest()</a>.</p>

</div>
</div>
<a id="a8b2945e64b5676eb54ff016a7ba1eee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2945e64b5676eb54ff016a7ba1eee5">&#9670;&nbsp;</a></span>generateLoopNestUsingForOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult generateLoopNestUsingForOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>loopRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>destinationTensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a>&#160;</td>
          <td class="paramname"><em>yieldTiledValuesFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LoopLikeOpInterface &gt; &amp;&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the tile-loop nest using <code>scf.for</code> operation. </p>
<ul>
<li><code>loopRanges</code> specifies the lb, ub and step of the untiled iteration space.</li>
<li><code>tileSizes</code> is the tile sizes to use. Zero represent untiled loops.</li>
<li><code>destinationTensors</code> are the init values to use for the outer most loop.</li>
<li><code>yieldTiledValuesFn</code> is called to generated the loop body of the inner most loop.</li>
<li><code>loops</code> is an in-out parameter into which the generated loops are populated. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00427">427</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00370">getLoopBounds()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="Builders_8h_source.html#l00434">mlir::OpBuilder::setInsertionPointToEnd()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00578">generateLoopNest()</a>.</p>

</div>
</div>
<a id="a880e291006bd7a102432578ee0957069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880e291006bd7a102432578ee0957069">&#9670;&nbsp;</a></span>getBoundedTileSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> getBoundedTileSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Range.html">Range</a>&#160;</td>
          <td class="paramname"><em>loopRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>tileSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bounded tile size given the current <code>offset</code>, <code>loopRange</code> and <code>tileSize</code>, i.e., <code>min(tileSize, range.end() - offset)</code>. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00237">237</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01430">mlir::affine::makeComposedFoldedAffineMin()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00036">mlir::Range::offset</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00037">mlir::Range::size</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00222">tileDividesIterationDomain()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00277">getTileOffsetAndSizes()</a>.</p>

</div>
</div>
<a id="a8c26828f07f44e434b7f4b0a2d18d216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c26828f07f44e434b7f4b0a2d18d216">&#9670;&nbsp;</a></span>getConsumerFromLoopUses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&gt; getConsumerFromLoopUses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>loopOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>resultNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetches the OpOperand of the first valid user (and use) of the value <code>val</code> which implements <code>TilingInterface</code> and <code>DestinationStyleOpInterface</code>. </p>
<p>Returns failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01873">1873</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TileUsingInterface_8cpp_source.html#l01826">checkAssumptionForLoop()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01755">getFirstUserOfLoop()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="Value_8h_source.html#l00188">mlir::Value::getUses()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00407">mlir::RewriterBase::moveOpBefore()</a>, <a class="el" href="TopologicalSortUtils_8cpp_source.html#l00280">mlir::topologicalSort()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00852">mlir::Operation::use_empty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01981">getUntiledConsumerFromSlice()</a>.</p>

</div>
</div>
<a id="ac906306ad6a49c6c5d40ec06cd8b948e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac906306ad6a49c6c5d40ec06cd8b948e">&#9670;&nbsp;</a></span>getFirstUserOfLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; getFirstUserOfLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>loopOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An utility to get the first user of the given loopOp. </p>
<p>If any of user stay in different block of loopOp, return failure. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01755">1755</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00238">mlir::Operation::getParentOfType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00873">mlir::Operation::getUsers()</a>, and <a class="el" href="IR_2Operation_8cpp_source.html#l00385">mlir::Operation::isBeforeInBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01826">checkAssumptionForLoop()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01873">getConsumerFromLoopUses()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l02122">mlir::scf::tileAndFuseConsumerOfSlices()</a>.</p>

</div>
</div>
<a id="abda80cd33074b6273520daf966406fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda80cd33074b6273520daf966406fa8">&#9670;&nbsp;</a></span>getLoopBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; &gt; getLoopBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>loopRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to return the bounds of the loops to be generated. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00370">370</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00018">mlir::isZeroInteger()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00508">generateLoopNestUsingForallOp()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00427">generateLoopNestUsingForOp()</a>.</p>

</div>
</div>
<a id="a4a71c9d8bdc136ff107a8f9d25e17e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a71c9d8bdc136ff107a8f9d25e17e8b">&#9670;&nbsp;</a></span>getResultTilePosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult getResultTilePosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a>&#160;</td>
          <td class="paramname"><em>reductionStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>tiledResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>reductionDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00726">726</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9abe3b9ba476420bd7d98de1a4560c2e3d">mlir::FullReduction</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00672">getSplitReductionIvs()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00987">mlir::scf::tileUsingSCF()</a>.</p>

</div>
</div>
<a id="a0e185e1dc37c135678df091feb277d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e185e1dc37c135678df091feb277d1d">&#9670;&nbsp;</a></span>getSanitizedReductionDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt;unsigned&gt; getSanitizedReductionDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">scf::SCFTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the reduction dims that are tiled. </p>
<p>This accounts for reduction dims that are specified as tiled, but the tile size is 0. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00210">210</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00144">mlir::isConstantIntValue()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00987">mlir::scf::tileUsingSCF()</a>.</p>

</div>
</div>
<a id="af4fe57f329b2d5a3ce05b27f02644751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4fe57f329b2d5a3ce05b27f02644751">&#9670;&nbsp;</a></span>getSplitReductionIvs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; getSplitReductionIvs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a>&#160;</td>
          <td class="paramname"><em>reductionStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>reductionDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For the case of <code>ReductionTilingStrategy::PartialReductionOuterParallel</code> the <code>PartialReductionOpInterface</code> methods need the index of the parallel split reduction being executed. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00672">672</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00959">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>, and <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9af8276115b49533f51a75db6c8e920131">mlir::PartialReductionOuterParallel</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00726">getResultTilePosition()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00699">getTiledImplementation()</a>.</p>

</div>
</div>
<a id="af010091f0bba5b7ea8a65459f138df82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af010091f0bba5b7ea8a65459f138df82">&#9670;&nbsp;</a></span>getTiledImplementation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;<a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a>&gt; getTiledImplementation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a>&#160;</td>
          <td class="paramname"><em>reductionStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>regionIterArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>reductionDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00699">699</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9abe3b9ba476420bd7d98de1a4560c2e3d">mlir::FullReduction</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00672">getSplitReductionIvs()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00987">mlir::scf::tileUsingSCF()</a>.</p>

</div>
</div>
<a id="ae98c08537bc6e37e75f40114e8480424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98c08537bc6e37e75f40114e8480424">&#9670;&nbsp;</a></span>getTileOffsetAndSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; &gt; getTileOffsetAndSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>iterationDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SetVector.html">llvm::SetVector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>reductionDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the <code>OpFoldResult</code>s that represents the multi-dimensional <code>offset</code>s and <code>size</code>s of the tile of the iteration space that the innermost loop body of the generated tiled loops corresponds to. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00277">277</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00262">canOmitTileOffsetInBoundsCheck()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00079">mlir::getAsOpFoldResult()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00237">getBoundedTileSize()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00018">mlir::isZeroInteger()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01437">mlir::affine::makeComposedFoldedAffineMax()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01430">mlir::affine::makeComposedFoldedAffineMin()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00987">mlir::scf::tileUsingSCF()</a>.</p>

</div>
</div>
<a id="ada33ff82be3e635c19f686ffa32bff28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada33ff82be3e635c19f686ffa32bff28">&#9670;&nbsp;</a></span>getUntiledConsumerFromSlice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&gt; getUntiledConsumerFromSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::InsertSliceOp&#160;</td>
          <td class="paramname"><em>candidateSliceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt;&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the untiled consumer of the outermost scf.for's result which is yielded by a tensor.insert_slice from the innermost scf.for. </p>
<p>This function makes the following assumptions :</p><ol type="1">
<li>tensor.insert_slice has scf.yield as its only user.</li>
<li>scf.for's corresponding result has only one use.</li>
<li>The <code>loops</code> passed in are perfectly nested <code>scf.for</code> operations. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01981">1981</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TileUsingInterface_8cpp_source.html#l01730">checkAssumptionForFusingConsumer()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01873">getConsumerFromLoopUses()</a>, <a class="el" href="Value_8cpp_source.html#l00226">mlir::OpOperand::getOperandNumber()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, <a class="el" href="Value_8h_source.html#l00188">mlir::Value::getUses()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01931">isPerfectlyNestedForLoops()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l02047">getUntiledConsumerOperandsFromSlices()</a>.</p>

</div>
</div>
<a id="a544d7ec894df4e8e1c4a1462f46af76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544d7ec894df4e8e1c4a1462f46af76b">&#9670;&nbsp;</a></span>getUntiledConsumerFromSlice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&gt; getUntiledConsumerFromSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ParallelInsertSliceOp&#160;</td>
          <td class="paramname"><em>candidateSliceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt;&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the first untiled consumer of a scf.forall's result which is yielded by a tensor.parallel_insert_slice. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l02015">2015</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TileUsingInterface_8cpp_source.html#l01873">getConsumerFromLoopUses()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

</div>
</div>
<a id="acc929b3dbf9f620b1762e695014ac1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc929b3dbf9f620b1762e695014ac1a5">&#9670;&nbsp;</a></span>getUntiledConsumerOperandsFromSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&gt; &gt; getUntiledConsumerOperandsFromSlices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>sliceOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt;&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A utility to fetch an untiled consumer of tensor.insert_slice/tensor.parallel_insert_slice. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l02047">2047</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="TileUsingInterface_8cpp_source.html#l01981">getUntiledConsumerFromSlice()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l02122">mlir::scf::tileAndFuseConsumerOfSlices()</a>.</p>

</div>
</div>
<a id="ab4c50f9432b1225386223125ae77df4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c50f9432b1225386223125ae77df4d">&#9670;&nbsp;</a></span>getUntiledProducerFromSliceSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple&lt;<a class="el" href="classmlir_1_1OpResult.html">OpResult</a>, std::optional&lt;<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&gt; &gt; getUntiledProducerFromSliceSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LoopLikeOpInterface &gt;&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the untiled producer whose slice is used in a tiled consumer. </p>
<p>The method traverses the tile loop nest (<code>loops</code>) if needed, and returns the <code>iter_args</code> of the outer most that is encountered. Traversing the iter_args indicates that this is a destination operand of the consumer. If there was no loop traversal needed, the second value of the returned tuple is empty. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01189">1189</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01210">mlir::scf::tileAndFuseProducerOfSlice()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l01594">mlir::scf::tileConsumerAndFuseProducersUsingSCF()</a>.</p>

</div>
</div>
<a id="aad85bf3fd0f4e53a5ad346ef48397438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad85bf3fd0f4e53a5ad346ef48397438">&#9670;&nbsp;</a></span>getUserTileSizesAndNumThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; &gt; getUserTileSizesAndNumThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>iterationDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">scf::SCFTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to instantiate the tile sizes and/or number of threads specified by the user. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00101">101</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01006">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00018">mlir::isZeroInteger()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00987">mlir::scf::tileUsingSCF()</a>.</p>

</div>
</div>
<a id="a3e14523733646f1383837dbae6c00656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e14523733646f1383837dbae6c00656">&#9670;&nbsp;</a></span>isPerfectlyNestedForLoops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isPerfectlyNestedForLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt;&#160;</td>
          <td class="paramname"><em>loops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that the loop is perfectly nested. </p>
<p>The loops are expected to be ordered from outer most to inner most. For example: </p><div class="fragment"><div class="line">%0 = scf.for()</div>
<div class="line">  %1 = scf.for()</div>
<div class="line">    %2 = scf.for()</div>
<div class="line">       %3 = ...</div>
<div class="line">       yield %3</div>
<div class="line">    yield %2</div>
<div class="line">  yield %1</div>
</div><!-- fragment --><p> Here loops should be [%0, %1]. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l01931">1931</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01981">getUntiledConsumerFromSlice()</a>.</p>

</div>
</div>
<a id="a8f2aa0c56fc844522f387b564baa54f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2aa0c56fc844522f387b564baa54f0">&#9670;&nbsp;</a></span>mergeTilingResults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FailureOr&lt;<a class="el" href="structmlir_1_1MergeResult.html">MergeResult</a>&gt; mergeTilingResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TilingInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9">ReductionTilingStrategy</a>&#160;</td>
          <td class="paramname"><em>reductionStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a1ee6ce60684197b50504a1df1f9214f2">SetVector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>reductionDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>partialResults</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00754">754</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a0bb57d9710216d3da4406e58e4cbdfd9abe3b9ba476420bd7d98de1a4560c2e3d">mlir::FullReduction</a>, and <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00987">mlir::scf::tileUsingSCF()</a>.</p>

</div>
</div>
<a id="abb6dd85d4816fccaea1880b659d13c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6dd85d4816fccaea1880b659d13c74">&#9670;&nbsp;</a></span>tileDividesIterationDomain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool tileDividesIterationDomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Range.html">Range</a>&#160;</td>
          <td class="paramname"><em>loopRange</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>stride</code> evenly divides the trip count <code>size - offset</code>. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00222">222</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00036">mlir::Range::offset</a>, <a class="el" href="StaticValueUtils_8h_source.html#l00037">mlir::Range::size</a>, and <a class="el" href="StaticValueUtils_8h_source.html#l00038">mlir::Range::stride</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00237">getBoundedTileSize()</a>.</p>

</div>
</div>
<a id="ae7dfa05fb201f99ec63ba9a32aec6299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7dfa05fb201f99ec63ba9a32aec6299">&#9670;&nbsp;</a></span>verifyOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult verifyOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">scf::SCFTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify the tile size options are set in a consistent manner. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00077">77</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html#ac0de119f731019cc6d8acb08187198cda5c060ed3dfd4303086b9d03f1930d71d">mlir::scf::SCFTilingOptions::ForallOp</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00223">mlir::isPermutationVector()</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00987">mlir::scf::tileUsingSCF()</a>.</p>

</div>
</div>
<a id="a4f8891f33aac7261d1c7916cf144c991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8891f33aac7261d1c7916cf144c991">&#9670;&nbsp;</a></span>yieldTiledValuesAndReplaceLoop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;LoopLikeOpInterface&gt; yieldTiledValuesAndReplaceLoop </td>
          <td>(</td>
          <td class="paramtype">LoopLikeOpInterface&#160;</td>
          <td class="paramname"><em>loopLikeOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newInitOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a>&#160;</td>
          <td class="paramname"><em>yieldTiledValuesFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <code>yieldTiledValuesAndReplaceLoop</code> for <code>LoopLikeOpInterface</code>, that just dispatches to the implementation for each supported loop type. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00897">897</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00781">yieldTiledValuesAndReplaceLoop()</a>.</p>

</div>
</div>
<a id="a88598dd179a90f26e657f7f024a6f332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88598dd179a90f26e657f7f024a6f332">&#9670;&nbsp;</a></span>yieldTiledValuesAndReplaceLoop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoopType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;LoopLikeOpInterface&gt; yieldTiledValuesAndReplaceLoop </td>
          <td>(</td>
          <td class="paramtype">LoopType&#160;</td>
          <td class="paramname"><em>loopOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newInitOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a>&#160;</td>
          <td class="paramname"><em>yieldTiledValuesFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the specified additional <code>newInitOperands</code> operands to the loops existing <code>init</code> operands (or similar), and replace <code>loopOp</code> with the new loop that has the additional init operands. </p>
<p>The loop body of this loop is moved over to the new loop. <code>yieldTiledValuesFn</code> is called to get the new tiled values returned, and the offset and sizes at which the tiled value is inserted into the new region iter_args that correspond to the newly added init operands. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00781">781</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00917">addInitOperandsToLoopNest()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l00897">yieldTiledValuesAndReplaceLoop()</a>.</p>

</div>
</div>
<a id="a34b85791a9ab89de7ca013a1c7b88653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b85791a9ab89de7ca013a1c7b88653">&#9670;&nbsp;</a></span>yieldTiledValuesAndReplaceLoop&lt; scf::ForallOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;LoopLikeOpInterface&gt; <a class="el" href="TileUsingInterface_8cpp.html#a4f8891f33aac7261d1c7916cf144c991">yieldTiledValuesAndReplaceLoop</a>&lt; scf::ForallOp &gt; </td>
          <td>(</td>
          <td class="paramtype">scf::ForallOp&#160;</td>
          <td class="paramname"><em>loopOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newInitOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a>&#160;</td>
          <td class="paramname"><em>yieldTiledValuesFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <code>yieldTiledValuesAndReplaceLoop</code> for <code>scf.forall</code> </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00781">781</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
<a id="aaf5901df24969e8438ea1ce98c323a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5901df24969e8438ea1ce98c323a52">&#9670;&nbsp;</a></span>yieldTiledValuesAndReplaceLoop&lt; scf::ForOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;LoopLikeOpInterface&gt; <a class="el" href="TileUsingInterface_8cpp.html#a4f8891f33aac7261d1c7916cf144c991">yieldTiledValuesAndReplaceLoop</a>&lt; scf::ForOp &gt; </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>loopOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>newInitOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="TileUsingInterface_8cpp.html#a505d4f42e1beb901ab163d108b0c8db9">YieldTiledValuesFn</a>&#160;</td>
          <td class="paramname"><em>yieldTiledValuesFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <code>yieldTiledValuesAndReplaceLoop</code> for <code>scf.for</code>. </p>

<p class="definition">Definition at line <a class="el" href="TileUsingInterface_8cpp_source.html#l00781">781</a> of file <a class="el" href="TileUsingInterface_8cpp_source.html">TileUsingInterface.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:28 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
