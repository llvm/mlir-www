<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: include/mlir/Dialect/Affine/Analysis/Utils.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_5654f77406fb9ceec87e68ef828ceea2.html">mlir</a></li><li class="navelem"><a class="el" href="dir_d07a6fac82475a065a3b2953573f00a0.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_166398e1f0020b3d916a929c669bf538.html">Affine</a></li><li class="navelem"><a class="el" href="dir_740c1a08dd185e22adde3d54ecb6f2ad.html">Analysis</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Utils.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="Dialect_2Affine_2Analysis_2Utils_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//===- Utils.h - General analysis utilities ---------------------*- C++ -*-===//</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">// See https://llvm.org/LICENSE.txt for license information.</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// This header file defines prototypes for various transformation utilities for</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">// memref&#39;s and non-loop IR structures. These are not passes by themselves but</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">// are used either by passes, optimization sequences, or in turn by other</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">// transformation utilities.</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160; </div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#ifndef MLIR_DIALECT_AFFINE_ANALYSIS_UTILS_H</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="preprocessor">#define MLIR_DIALECT_AFFINE_ANALYSIS_UTILS_H</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="AffineStructures_8h.html">mlir/Dialect/Affine/Analysis/AffineStructures.h</a>&quot;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="AffineOps_8h.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &lt;optional&gt;</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160; </div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacemlir.html">mlir</a> {</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="keyword">class </span><a class="code" href="namespacemlir.html#a6e07796c43d9bdf22c519ff44150daafae1e4c8c9ccd9fc39c391da4bcd093fb2">Block</a>;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="keyword">class </span>Location;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="keyword">class </span>Operation;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="keyword">class </span><a class="code" href="namespacemlir_1_1lsp.html#ad6c31c7b93eb99ad1d173f9b2b97ff7fa689202409e48743b914713f96d93947c">Value</a>;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160; </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="keyword">namespace </span>affine {</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="keyword">class </span>AffineForOp;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="keyword">class </span>AffineValueMap;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="keyword">struct </span>MemRefAccess;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160; </div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment">// LoopNestStateCollector walks loop nests and collects load and store</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment">// operations, and whether or not a region holding op other than ForOp and IfOp</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment">// was encountered in the loop nest.</span></div>
<div class="line"><a name="l00038"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1LoopNestStateCollector.html">   38</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structmlir_1_1affine_1_1LoopNestStateCollector.html">LoopNestStateCollector</a> {</div>
<div class="line"><a name="l00039"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a6a9d08cfcdff91c3cb2818daa79b3fbb">   39</a></span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;AffineForOp, 4&gt;</a> <a class="code" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a6a9d08cfcdff91c3cb2818daa79b3fbb">forOps</a>;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="comment">// Affine loads.</span></div>
<div class="line"><a name="l00041"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a95f517b1a80923351ab5bd34fefd312c">   41</a></span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a95f517b1a80923351ab5bd34fefd312c">loadOpInsts</a>;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  <span class="comment">// Affine stores.</span></div>
<div class="line"><a name="l00043"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#ae23767154d778088beab9572db13ddfb">   43</a></span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#ae23767154d778088beab9572db13ddfb">storeOpInsts</a>;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  <span class="comment">// Non-affine loads.</span></div>
<div class="line"><a name="l00045"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#adf2391f4ce1e52ffc08a51add68a9b4e">   45</a></span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#adf2391f4ce1e52ffc08a51add68a9b4e">memrefLoads</a>;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  <span class="comment">// Non-affine stores.</span></div>
<div class="line"><a name="l00047"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#ab1b990940ad78278dd989884d2021cff">   47</a></span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#ab1b990940ad78278dd989884d2021cff">memrefStores</a>;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  <span class="comment">// Free operations.</span></div>
<div class="line"><a name="l00049"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a4c5255085d6cfdb16bff277d77176bab">   49</a></span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a4c5255085d6cfdb16bff277d77176bab">memrefFrees</a>;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160; </div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  <span class="comment">// Collects load and store operations, and whether or not a region holding op</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  <span class="comment">// other than ForOp and IfOp was encountered in the loop nest.</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#ac7e518efde98002ff3fdf5b576205883">collect</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> *opToWalk);</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;};</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160; </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment">// MemRefDependenceGraph is a graph data structure where graph nodes are</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">// top-level operations in a `Block` and edges are memref dependences or SSA</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment">// dependences (on memrefs) between the nodes. Nodes are created for all</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment">// top-level operations except in certain cases (see `init` method). Edges are</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment">// created between nodes with a dependence (see `Edge` documentation). Edges</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment">// aren&#39;t created from/to nodes that have no memory effects.</span></div>
<div class="line"><a name="l00062"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">   62</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> {</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  <span class="comment">// Node represents a node in the graph. A Node is either an entire loop nest</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  <span class="comment">// rooted at the top level which contains loads/stores, or a top level</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  <span class="comment">// load/store.</span></div>
<div class="line"><a name="l00067"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">   67</a></span>&#160;  <span class="keyword">struct </span><a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">Node</a> {</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="comment">// The unique identifier of this node in the graph.</span></div>
<div class="line"><a name="l00069"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a830ea36bccf2332f1a9aea7e09bef2f0">   69</a></span>&#160;    <span class="keywordtype">unsigned</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a830ea36bccf2332f1a9aea7e09bef2f0">id</a>;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="comment">// The top-level statement which is (or contains) a load/store.</span></div>
<div class="line"><a name="l00071"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#ab79054c161b7323e14e56f00d1d38fa0">   71</a></span>&#160;    <a class="code" href="classmlir_1_1Operation.html">Operation</a> *<a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#ab79054c161b7323e14e56f00d1d38fa0">op</a>;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="comment">// List of affine loads.</span></div>
<div class="line"><a name="l00073"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a1443947aa4f1a5ba044f9bfbc364e353">   73</a></span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a1443947aa4f1a5ba044f9bfbc364e353">loads</a>;</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <span class="comment">// List of non-affine loads.</span></div>
<div class="line"><a name="l00075"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a5ab56168ea32478165badb63843a0839">   75</a></span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a5ab56168ea32478165badb63843a0839">memrefLoads</a>;</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <span class="comment">// List of affine store ops.</span></div>
<div class="line"><a name="l00077"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a1d9d97fe37cf42792d796beeffb182db">   77</a></span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a1d9d97fe37cf42792d796beeffb182db">stores</a>;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="comment">// List of non-affine stores.</span></div>
<div class="line"><a name="l00079"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a678f66b993583d391ec12d1eaca5c168">   79</a></span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a678f66b993583d391ec12d1eaca5c168">memrefStores</a>;</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="comment">// List of free operations.</span></div>
<div class="line"><a name="l00081"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#afe5e17bd9cb80f70609ec127e9ce6d43">   81</a></span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#afe5e17bd9cb80f70609ec127e9ce6d43">memrefFrees</a>;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="comment">// Set of private memrefs used in this node.</span></div>
<div class="line"><a name="l00083"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a73ec40eb1f5ef361ab49dbdcca2126f1">   83</a></span>&#160;    <a class="code" href="classllvm_1_1DenseSet.html">DenseSet&lt;Value&gt;</a> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a73ec40eb1f5ef361ab49dbdcca2126f1">privateMemrefs</a>;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160; </div>
<div class="line"><a name="l00085"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a43784c742baf090c45dbf791c4194425">   85</a></span>&#160;    <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a43784c742baf090c45dbf791c4194425">Node</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>, <a class="code" href="classmlir_1_1Operation.html">Operation</a> *<a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#ab79054c161b7323e14e56f00d1d38fa0">op</a>) : <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a830ea36bccf2332f1a9aea7e09bef2f0">id</a>(<a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a830ea36bccf2332f1a9aea7e09bef2f0">id</a>), <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#ab79054c161b7323e14e56f00d1d38fa0">op</a>(<a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#ab79054c161b7323e14e56f00d1d38fa0">op</a>) {}</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160; </div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="comment">// Returns the load op count for &#39;memref&#39;.</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keywordtype">unsigned</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a77267e6959542952eb88324ac501186a">getLoadOpCount</a>(<a class="code" href="classmlir_1_1Value.html">Value</a> memref) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160; </div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="comment">// Returns the store op count for &#39;memref&#39;.</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="keywordtype">unsigned</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a7dcff2c5bf014d3ae42f78780ce15786">getStoreOpCount</a>(<a class="code" href="classmlir_1_1Value.html">Value</a> memref) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment">    /// Returns true if there exists an operation with a write memory effect to</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment">    /// `memref` in this node.</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment"></span>    <span class="keywordtype">unsigned</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a866114f24f1c3e927c47c87a38843a53">hasStore</a>(<a class="code" href="classmlir_1_1Value.html">Value</a> memref) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160; </div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="comment">// Returns true if the node has a free op on `memref`.</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <span class="keywordtype">unsigned</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a49e4fae512d8dd3f049672634d5edd80">hasFree</a>(<a class="code" href="classmlir_1_1Value.html">Value</a> memref) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160; </div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="comment">// Returns all store ops in &#39;storeOps&#39; which access &#39;memref&#39;.</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a0d3aa9a9ed278fe81689d73d07033b29">getStoreOpsForMemref</a>(<a class="code" href="classmlir_1_1Value.html">Value</a> memref,</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                              <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Operation *&gt;</a> *storeOps) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160; </div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <span class="comment">// Returns all load ops in &#39;loadOps&#39; which access &#39;memref&#39;.</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#ac9d40b81f36159a323d3a56d60b6bbea">getLoadOpsForMemref</a>(<a class="code" href="classmlir_1_1Value.html">Value</a> memref,</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;                             <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Operation *&gt;</a> *loadOps) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160; </div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="comment">// Returns all memrefs in &#39;loadAndStoreMemrefSet&#39; for which this node</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="comment">// has at least one load and store operation.</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a3b5c1cad1b7c6f2b8091bb7f12d29162">getLoadAndStoreMemrefSet</a>(<a class="code" href="classllvm_1_1DenseSet.html">DenseSet&lt;Value&gt;</a> *loadAndStoreMemrefSet) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  };</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160; </div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="comment">// Edge represents a data dependence between nodes in the graph. It can either</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  <span class="comment">// be a memory dependence or an SSA dependence. In the former case, it</span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  <span class="comment">// corresponds to a pair of memory accesses to the same memref or aliasing</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <span class="comment">// memrefs where at least one of them has a write or free memory effect. The</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  <span class="comment">// memory accesses need not be affine load/store operations. Operations are</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  <span class="comment">// checked for read/write effects and edges may be added conservatively. Edges</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  <span class="comment">// are not created to/from nodes that have no memory effect. An exception to</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  <span class="comment">// this are SSA dependences between operations that define memrefs (like</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  <span class="comment">// alloc&#39;s, view-like ops) and their memory-effecting users that are enclosed</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  <span class="comment">// in loops.</span></div>
<div class="line"><a name="l00123"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html">  123</a></span>&#160;  <span class="keyword">struct </span><a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html">Edge</a> {</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    <span class="comment">// The id of the node at the other end of the edge.</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="comment">// If this edge is stored in Edge = Node.inEdges[i], then</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="comment">// &#39;Node.inEdges[i].id&#39; is the identifier of the source node of the edge.</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="comment">// If this edge is stored in Edge = Node.outEdges[i], then</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    <span class="comment">// &#39;Node.outEdges[i].id&#39; is the identifier of the dest node of the edge.</span></div>
<div class="line"><a name="l00129"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html#ace11f0021945bfc712786e04e2f1101d">  129</a></span>&#160;    <span class="keywordtype">unsigned</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html#ace11f0021945bfc712786e04e2f1101d">id</a>;</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    <span class="comment">// The SSA value on which this edge represents a dependence.</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <span class="comment">// If the value is a memref, then the dependence is between graph nodes</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <span class="comment">// which contain accesses to the same memref &#39;value&#39;. If the value is a</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    <span class="comment">// non-memref value, then the dependence is between a graph node which</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    <span class="comment">// defines an SSA value and another graph node which uses the SSA value</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    <span class="comment">// (e.g. a constant or load operation defining a value which is used inside</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="comment">// a loop nest).</span></div>
<div class="line"><a name="l00137"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html#aa2928d335ef67abb4dd9f225fbe7eca5">  137</a></span>&#160;    <a class="code" href="classmlir_1_1Value.html">Value</a> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html#aa2928d335ef67abb4dd9f225fbe7eca5">value</a>;</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  };</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160; </div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  <span class="comment">// Map from node id to Node.</span></div>
<div class="line"><a name="l00141"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3df572ea465683f6b1f0e4dcd9f9b42f">  141</a></span>&#160;  <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;unsigned, Node&gt;</a> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3df572ea465683f6b1f0e4dcd9f9b42f">nodes</a>;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  <span class="comment">// Map from node id to list of input edges. The absence of an entry for a key</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  <span class="comment">// is also equivalent to the absence of any edges.</span></div>
<div class="line"><a name="l00144"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a6c0fadb723818174fe2e60709e761918">  144</a></span>&#160;  <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;unsigned, SmallVector&lt;Edge, 2&gt;</a>&gt; <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a6c0fadb723818174fe2e60709e761918">inEdges</a>;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  <span class="comment">// Map from node id to list of output edges. The absence of an entry for a</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  <span class="comment">// node is also equivalent to the absence of any edges.</span></div>
<div class="line"><a name="l00147"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a01d186fd0b75b108fce1ad9dd27e3630">  147</a></span>&#160;  <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;unsigned, SmallVector&lt;Edge, 2&gt;</a>&gt; <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a01d186fd0b75b108fce1ad9dd27e3630">outEdges</a>;</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  <span class="comment">// Map from memref to a count on the dependence edges associated with that</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  <span class="comment">// memref.</span></div>
<div class="line"><a name="l00150"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#afb1cdc99d9633c920e02a9a8975fdd41">  150</a></span>&#160;  <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;Value, unsigned&gt;</a> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#afb1cdc99d9633c920e02a9a8975fdd41">memrefEdgeCount</a>;</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  <span class="comment">// The next unique identifier to use for newly created graph nodes.</span></div>
<div class="line"><a name="l00152"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a345e759cabd082ca094c6315f1104a8b">  152</a></span>&#160;  <span class="keywordtype">unsigned</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a345e759cabd082ca094c6315f1104a8b">nextNodeId</a> = 0;</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160; </div>
<div class="line"><a name="l00154"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3c63e623ce037ff8c4bce83cf5d214a9">  154</a></span>&#160;  <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3c63e623ce037ff8c4bce83cf5d214a9">MemRefDependenceGraph</a>(<a class="code" href="classmlir_1_1Block.html">Block</a> &amp;<a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a033d58b8880a8b8bf188abaa803275f0">block</a>) : <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a033d58b8880a8b8bf188abaa803275f0">block</a>(<a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a033d58b8880a8b8bf188abaa803275f0">block</a>) {}</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160; </div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;  <span class="comment">// Initializes the dependence graph based on operations in `block&#39;.</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  <span class="comment">// Returns true on success, false otherwise.</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a0db37460f490e2adeca97211fb608c2a">init</a>();</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160; </div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  <span class="comment">// Returns the graph node for &#39;id&#39;.</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;  <span class="keyword">const</span> <a class="code" href="Dialect_2Affine_2Analysis_2Utils_8cpp.html#ab7365fa1c3a77e6dbf089404d9d07984">Node</a> *<a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a9ecf883f82ba5105ab012804d98994f5">getNode</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00162"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#ade2784d9395e6a3fbe3acb55a90c55cd">  162</a></span>&#160;  <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">Node</a> *<a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#ade2784d9395e6a3fbe3acb55a90c55cd">getNode</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>) {</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">Node</a> *<span class="keyword">&gt;</span>(</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;<a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a9ecf883f82ba5105ab012804d98994f5">getNode</a>(<span class="keywordtype">id</span>));</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  }</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160; </div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;  <span class="comment">// Returns true if the graph has node with ID `id`.</span></div>
<div class="line"><a name="l00168"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a657659a854921a4dd67b0657556f0a7c">  168</a></span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a657659a854921a4dd67b0657556f0a7c">hasNode</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3df572ea465683f6b1f0e4dcd9f9b42f">nodes</a>.contains(<span class="keywordtype">id</span>); }</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160; </div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  <span class="comment">// Returns the graph node for &#39;forOp&#39;.</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;  <span class="keyword">const</span> <a class="code" href="Dialect_2Affine_2Analysis_2Utils_8cpp.html#ab7365fa1c3a77e6dbf089404d9d07984">Node</a> *<a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a60e1b52dd56f3d099d5899568293b218">getForOpNode</a>(AffineForOp forOp) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00172"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a14b6004ed00cac7dc114366cef2cc252">  172</a></span>&#160;  <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">Node</a> *<a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a14b6004ed00cac7dc114366cef2cc252">getForOpNode</a>(AffineForOp forOp) {</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">Node</a> *<span class="keyword">&gt;</span>(</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;<a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a60e1b52dd56f3d099d5899568293b218">getForOpNode</a>(forOp));</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  }</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160; </div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  <span class="comment">// Adds a node with &#39;op&#39; to the graph and returns its unique identifier.</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  <span class="keywordtype">unsigned</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a09cdaeb6db292ca36bfa6a57c2a1bf27">addNode</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> *op);</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160; </div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  <span class="comment">// Remove node &#39;id&#39; (and its associated edges) from graph.</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aa65f5209124219ebb4a86fcedb629850">removeNode</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>);</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160; </div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  <span class="comment">// Returns true if node &#39;id&#39; writes to any memref which escapes (or is an</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  <span class="comment">// argument to) the block. Returns false otherwise.</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a0ed9f30da3f99f63db2d0a18b23a7562">writesToLiveInOrEscapingMemrefs</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160; </div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;  <span class="comment">// Returns true iff there is an edge from node &#39;srcId&#39; to node &#39;dstId&#39; which</span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  <span class="comment">// is for &#39;value&#39; if non-null, or for any value otherwise. Returns false</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;  <span class="comment">// otherwise.</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#ae3bdae51f114698511aa7be4b3133880">hasEdge</a>(<span class="keywordtype">unsigned</span> srcId, <span class="keywordtype">unsigned</span> dstId, <a class="code" href="classmlir_1_1Value.html">Value</a> value = <span class="keyword">nullptr</span>) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160; </div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  <span class="comment">// Adds an edge from node &#39;srcId&#39; to node &#39;dstId&#39; for &#39;value&#39;.</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a2426d1416444660e2a965499b9558f2e">addEdge</a>(<span class="keywordtype">unsigned</span> srcId, <span class="keywordtype">unsigned</span> dstId, <a class="code" href="classmlir_1_1Value.html">Value</a> value);</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160; </div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  <span class="comment">// Removes an edge from node &#39;srcId&#39; to node &#39;dstId&#39; for &#39;value&#39;.</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a19787b209c503c45e6dff3d8a975d123">removeEdge</a>(<span class="keywordtype">unsigned</span> srcId, <span class="keywordtype">unsigned</span> dstId, <a class="code" href="classmlir_1_1Value.html">Value</a> value);</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160; </div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  <span class="comment">// Returns true if there is a path in the dependence graph from node &#39;srcId&#39;</span></div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  <span class="comment">// to node &#39;dstId&#39;. Returns false otherwise. `srcId`, `dstId`, and the</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  <span class="comment">// operations that the edges connected are expected to be from the same block.</span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a45510d99234261290bf188a3108387cd">hasDependencePath</a>(<span class="keywordtype">unsigned</span> srcId, <span class="keywordtype">unsigned</span> dstId) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160; </div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;  <span class="comment">// Returns the input edge count for node &#39;id&#39; and &#39;memref&#39; from src nodes</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;  <span class="comment">// which access &#39;memref&#39; with a store operation.</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;  <span class="keywordtype">unsigned</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aded491cadebd6d0969d23f80cb0ef475">getIncomingMemRefAccesses</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>, <a class="code" href="classmlir_1_1Value.html">Value</a> memref) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160; </div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;  <span class="comment">// Returns the output edge count for node &#39;id&#39; and &#39;memref&#39; (if non-null),</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  <span class="comment">// otherwise returns the total output edge count from node &#39;id&#39;.</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;  <span class="keywordtype">unsigned</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a996bade25457fbc32567f4b47ae18f3f">getOutEdgeCount</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>, <a class="code" href="classmlir_1_1Value.html">Value</a> memref = <span class="keyword">nullptr</span>) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment">  /// Return all nodes which define SSA values used in node &#39;id&#39;.</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a437652354edafa39b0546fe0a60e9071">gatherDefiningNodes</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>,</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                           <a class="code" href="classllvm_1_1DenseSet.html">DenseSet&lt;unsigned&gt;</a> &amp;definingNodes) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160; </div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  <span class="comment">// Computes and returns an insertion point operation, before which the</span></div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  <span class="comment">// the fused &lt;srcId, dstId&gt; loop nest can be inserted while preserving</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;  <span class="comment">// dependences. Returns nullptr if no such insertion point is found.</span></div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;  <a class="code" href="classmlir_1_1Operation.html">Operation</a> *<a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a61ca2d2048e49f64711b86f5746f0081">getFusedLoopNestInsertionPoint</a>(<span class="keywordtype">unsigned</span> srcId,</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                                            <span class="keywordtype">unsigned</span> dstId) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160; </div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;  <span class="comment">// Updates edge mappings from node &#39;srcId&#39; to node &#39;dstId&#39; after fusing them,</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  <span class="comment">// taking into account that:</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  <span class="comment">//   *) if &#39;removeSrcId&#39; is true, &#39;srcId&#39; will be removed after fusion,</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  <span class="comment">//   *) memrefs in &#39;privateMemRefs&#39; has been replaced in node at &#39;dstId&#39; by a</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;  <span class="comment">//      private memref.</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a650542cbe4a3a8ed5cef0ad22bf2f39a">updateEdges</a>(<span class="keywordtype">unsigned</span> srcId, <span class="keywordtype">unsigned</span> dstId,</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                   <span class="keyword">const</span> <a class="code" href="classllvm_1_1DenseSet.html">DenseSet&lt;Value&gt;</a> &amp;privateMemRefs, <span class="keywordtype">bool</span> removeSrcId);</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160; </div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  <span class="comment">// Update edge mappings for nodes &#39;sibId&#39; and &#39;dstId&#39; to reflect fusion</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  <span class="comment">// of sibling node &#39;sibId&#39; into node &#39;dstId&#39;.</span></div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a650542cbe4a3a8ed5cef0ad22bf2f39a">updateEdges</a>(<span class="keywordtype">unsigned</span> sibId, <span class="keywordtype">unsigned</span> dstId);</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160; </div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;  <span class="comment">// Adds the specified ops to lists of node at &#39;id&#39;.</span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#abe5db0c6c3108f9e233ad68ee134e496">addToNode</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>, <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Operation *&gt;</a> loads,</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                 <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Operation *&gt;</a> stores,</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;                 <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Operation *&gt;</a> memrefLoads,</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                 <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Operation *&gt;</a> memrefStores,</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                 <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Operation *&gt;</a> memrefFrees);</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160; </div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a55a81e7e71f3511a8babe8c8535393f1">clearNodeLoadAndStores</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>);</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160; </div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;  <span class="comment">// Calls &#39;callback&#39; for each input edge incident to node &#39;id&#39; which carries a</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;  <span class="comment">// memref dependence.</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a83ce0d42a3715e3d152f87ec4437c56e">forEachMemRefInputEdge</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>,</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                              <span class="keyword">const</span> std::function&lt;<span class="keywordtype">void</span>(Edge)&gt; &amp;callback);</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160; </div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;  <span class="comment">// Calls &#39;callback&#39; for each output edge from node &#39;id&#39; which carries a</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;  <span class="comment">// memref dependence.</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aaeb96e8d972edf0793f628b700743c52">forEachMemRefOutputEdge</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>,</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                               <span class="keyword">const</span> std::function&lt;<span class="keywordtype">void</span>(Edge)&gt; &amp;callback);</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160; </div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  <span class="comment">// Calls &#39;callback&#39; for each edge in &#39;edges&#39; which carries a memref</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;  <span class="comment">// dependence.</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#ab8c546bd37ebde1870dfd51b66080974">forEachMemRefEdge</a>(<a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Edge&gt;</a> edges,</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                         <span class="keyword">const</span> std::function&lt;<span class="keywordtype">void</span>(Edge)&gt; &amp;callback);</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160; </div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#af0240c7ff60660612bd78f98bff995e4">print</a>(raw_ostream &amp;os) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160; </div>
<div class="line"><a name="l00259"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aee33c4c116b0fceb1dc3ec2114d0916b">  259</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aee33c4c116b0fceb1dc3ec2114d0916b">dump</a>()<span class="keyword"> const </span>{ <a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#af0240c7ff60660612bd78f98bff995e4">print</a>(llvm::errs()); }</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment">  /// The block for which this graph is created to perform fusion.</span></div>
<div class="line"><a name="l00262"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a033d58b8880a8b8bf188abaa803275f0">  262</a></span>&#160;<span class="comment"></span>  <a class="code" href="classmlir_1_1Block.html">Block</a> &amp;<a class="code" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a033d58b8880a8b8bf188abaa803275f0">block</a>;</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;};</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="comment">/// Populates &#39;loops&#39; with IVs of the affine.for ops surrounding &#39;op&#39; ordered</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment">/// from the outermost &#39;affine.for&#39; operation to the innermost one while not</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment">/// traversing outside of the surrounding affine scope.</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="namespacemlir_1_1affine.html#a9085efe05b8bc0b7c3b4f643d70eb1e7">getAffineForIVs</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;AffineForOp&gt;</a> *loops);</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="comment">/// Populates &#39;ivs&#39; with IVs of the surrounding affine.for and affine.parallel</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="comment">/// ops ordered from the outermost one to the innermost while not traversing</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="comment">/// outside of the surrounding affine scope.</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="namespacemlir_1_1affine.html#a50b5b72a6baee24bfab9faebd198fe9b">getAffineIVs</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Value&gt;</a> &amp;ivs);</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment">/// Populates &#39;ops&#39; with affine operations enclosing `op` ordered from outermost</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="comment">/// to innermost while stopping at the boundary of the affine scope. affine.for,</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="comment">/// affine.if, or affine.parallel ops comprise such surrounding affine ops.</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment">/// `ops` is guaranteed by design to have a successive chain of affine parent</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="comment">/// ops.</span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="namespacemlir_1_1affine.html#a1f8e59ec9faff34b64ebb0411a383c3a">getEnclosingAffineOps</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Operation *&gt;</a> *ops);</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="comment">/// Returns the nesting depth of this operation, i.e., the number of loops</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="comment">/// surrounding this operation.</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="comment"></span><span class="keywordtype">unsigned</span> <a class="code" href="namespacemlir_1_1affine.html#ac82ec61d5cae9ebb4489d2ab9ad6e8f8">getNestingDepth</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> *op);</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="comment">/// Returns whether a loop is a parallel loop and contains a reduction loop.</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="comment"></span><span class="keywordtype">bool</span> <a class="code" href="namespacemlir_1_1affine.html#a34c1ca39d435d06366058d16b5fe4225">isLoopParallelAndContainsReduction</a>(AffineForOp forOp);</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="comment">/// Returns in &#39;sequentialLoops&#39; all sequential loops in loop nest rooted</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="comment">/// at &#39;forOp&#39;.</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="namespacemlir_1_1affine.html#a5ad383995f97dc30a0d6891e33fd499a">getSequentialLoops</a>(AffineForOp forOp,</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                        llvm::SmallDenseSet&lt;Value, 8&gt; *sequentialLoops);</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="comment">/// Enumerates different result statuses of slice computation by</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="comment">/// `computeSliceUnion`</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="comment"></span><span class="comment">// TODO: Identify and add different kinds of failures during slice computation.</span></div>
<div class="line"><a name="l00297"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1SliceComputationResult.html">  297</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structmlir_1_1affine_1_1SliceComputationResult.html">SliceComputationResult</a> {</div>
<div class="line"><a name="l00298"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9">  298</a></span>&#160;  <span class="keyword">enum</span> <a class="code" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9">ResultEnum</a> {</div>
<div class="line"><a name="l00299"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9aa85f3aac90ad660d5de9933c03cd26ef">  299</a></span>&#160;    <a class="code" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9aa85f3aac90ad660d5de9933c03cd26ef">Success</a>,</div>
<div class="line"><a name="l00300"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9aa56e19629619cf1e69cb9f4ec40dcb7c">  300</a></span>&#160;    <a class="code" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9aa56e19629619cf1e69cb9f4ec40dcb7c">IncorrectSliceFailure</a>, <span class="comment">// Slice is computed, but it is incorrect.</span></div>
<div class="line"><a name="l00301"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9a4386b2e4cd401f45247b3ff587a5e4d6">  301</a></span>&#160;    <a class="code" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9a4386b2e4cd401f45247b3ff587a5e4d6">GenericFailure</a>,        <span class="comment">// Unable to compute src loop computation slice.</span></div>
<div class="line"><a name="l00302"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1SliceComputationResult.html#ae1bf161ba038ce8ed38567be7adba786">  302</a></span>&#160;  } <a class="code" href="structmlir_1_1affine_1_1SliceComputationResult.html#ae1bf161ba038ce8ed38567be7adba786">value</a>;</div>
<div class="line"><a name="l00303"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1SliceComputationResult.html#a37a45916fce7b4d2989ae128c037d3ef">  303</a></span>&#160;  <a class="code" href="structmlir_1_1affine_1_1SliceComputationResult.html#a37a45916fce7b4d2989ae128c037d3ef">SliceComputationResult</a>(<a class="code" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9">ResultEnum</a> v) : <a class="code" href="structmlir_1_1affine_1_1SliceComputationResult.html#ae1bf161ba038ce8ed38567be7adba786">value</a>(v) {}</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;};</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="comment">/// ComputationSliceState aggregates loop IVs, loop bound AffineMaps and their</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="comment">/// associated operands for a set of loops within a loop nest (typically the</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="comment">/// set of loops surrounding a store operation). Loop bound AffineMaps which</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="comment">/// are non-null represent slices of that loop&#39;s iteration space.</span></div>
<div class="line"><a name="l00310"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1ComputationSliceState.html">  310</a></span>&#160;<span class="comment"></span><span class="keyword">struct </span><a class="code" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> {</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;  <span class="comment">// List of sliced loop IVs (ordered from outermost to innermost).</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;  <span class="comment">// EX: &#39;ivs[i]&#39; has lower bound &#39;lbs[i]&#39; and upper bound &#39;ubs[i]&#39;.</span></div>
<div class="line"><a name="l00313"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1ComputationSliceState.html#a140bf9ff4200613fb5822bed2f1bfc18">  313</a></span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value, 4&gt;</a> <a class="code" href="structmlir_1_1affine_1_1ComputationSliceState.html#a140bf9ff4200613fb5822bed2f1bfc18">ivs</a>;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;  <span class="comment">// List of lower bound AffineMaps.</span></div>
<div class="line"><a name="l00315"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1ComputationSliceState.html#ade6c510051faa671f7758989e38b491d">  315</a></span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;AffineMap, 4&gt;</a> <a class="code" href="structmlir_1_1affine_1_1ComputationSliceState.html#ade6c510051faa671f7758989e38b491d">lbs</a>;</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;  <span class="comment">// List of upper bound AffineMaps.</span></div>
<div class="line"><a name="l00317"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1ComputationSliceState.html#ab0148e60f0d8d38822992cf91eb87b5b">  317</a></span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;AffineMap, 4&gt;</a> <a class="code" href="structmlir_1_1affine_1_1ComputationSliceState.html#ab0148e60f0d8d38822992cf91eb87b5b">ubs</a>;</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;  <span class="comment">// List of lower bound operands (lbOperands[i] are used by &#39;lbs[i]&#39;).</span></div>
<div class="line"><a name="l00319"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1ComputationSliceState.html#afd8aa32fa351614ef5060a1e079dec0b">  319</a></span>&#160;  std::vector&lt;SmallVector&lt;Value, 4&gt;&gt; <a class="code" href="structmlir_1_1affine_1_1ComputationSliceState.html#afd8aa32fa351614ef5060a1e079dec0b">lbOperands</a>;</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;  <span class="comment">// List of upper bound operands (ubOperands[i] are used by &#39;ubs[i]&#39;).</span></div>
<div class="line"><a name="l00321"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1ComputationSliceState.html#aa3215ff59c18264fa4e846d9a2d5615f">  321</a></span>&#160;  std::vector&lt;SmallVector&lt;Value, 4&gt;&gt; <a class="code" href="structmlir_1_1affine_1_1ComputationSliceState.html#aa3215ff59c18264fa4e846d9a2d5615f">ubOperands</a>;</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;  <span class="comment">// Slice loop nest insertion point in target loop nest.</span></div>
<div class="line"><a name="l00323"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1ComputationSliceState.html#afc69fcff6c39da7525bb1c61b91c4492">  323</a></span>&#160;  <a class="code" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> <a class="code" href="structmlir_1_1affine_1_1ComputationSliceState.html#afc69fcff6c39da7525bb1c61b91c4492">insertPoint</a>;</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;  <span class="comment">// Adds to &#39;cst&#39; with constraints which represent the slice bounds on &#39;ivs&#39;</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;  <span class="comment">// in &#39;this&#39;. Specifically, the values in &#39;ivs&#39; are added to &#39;cst&#39; as dim</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;  <span class="comment">// variables and the values in &#39;lb/ubOperands&#39; are added as symbols.</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;  <span class="comment">// Constraints are added for all loop IV bounds (dim or symbol), and</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;  <span class="comment">// constraints are added for slice bounds in &#39;lbs&#39;/&#39;ubs&#39;.</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;  <span class="comment">// Returns failure if we cannot add loop bounds because of unsupported cases.</span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;  LogicalResult <a class="code" href="structmlir_1_1affine_1_1ComputationSliceState.html#a2a55ff23adbc2491f154ec4074c665d6">getAsConstraints</a>(<a class="code" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *cst) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="comment">  /// Adds to &#39;cst&#39; constraints which represent the original loop bounds on</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="comment">  /// &#39;ivs&#39; in &#39;this&#39;. This corresponds to the original domain of the loop nest</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="comment">  /// from which the slice is being computed. Returns failure if we cannot add</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="comment">  /// loop bounds because of unsupported cases.</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="comment"></span>  LogicalResult <a class="code" href="structmlir_1_1affine_1_1ComputationSliceState.html#a9b06d992ca662858732225827937c1f7">getSourceAsConstraints</a>(<a class="code" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;cst) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160; </div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;  <span class="comment">// Clears all bounds and operands in slice state.</span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1ComputationSliceState.html#ae01fc5e4aa59b1624613835b69c219a6">clearBounds</a>();</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="comment">  /// Returns true if the computation slice is empty.</span></div>
<div class="line"><a name="l00342"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1ComputationSliceState.html#a6662e2d7b1582bfe4ff4f64eea403432">  342</a></span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code" href="structmlir_1_1affine_1_1ComputationSliceState.html#a6662e2d7b1582bfe4ff4f64eea403432">isEmpty</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="structmlir_1_1affine_1_1ComputationSliceState.html#a140bf9ff4200613fb5822bed2f1bfc18">ivs</a>.empty(); }</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="comment">  /// Returns true if the computation slice encloses all the iterations of the</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="comment">  /// sliced loop nest. Returns false if it does not. Returns std::nullopt if it</span></div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="comment">  /// cannot determine if the slice is maximal or not.</span></div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="comment"></span>  <span class="comment">// TODO: Cache &#39;isMaximal&#39; so that we don&#39;t recompute it when the slice</span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;  <span class="comment">// information hasn&#39;t changed.</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;  std::optional&lt;bool&gt; <a class="code" href="structmlir_1_1affine_1_1ComputationSliceState.html#abc7052b611c0772f9c551ee0d4b33d92">isMaximal</a>() <span class="keyword">const</span>;</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="comment">  /// Checks the validity of the slice computed. This is done using the</span></div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="comment">  /// following steps:</span></div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="comment">  /// 1. Get the new domain of the slice that would be created if fusion</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="comment">  /// succeeds. This domain gets constructed with source loop IVS and</span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="comment">  /// destination loop IVS as dimensions.</span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;<span class="comment">  /// 2. Project out the dimensions of the destination loop from the domain</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="comment">  /// above calculated in step(1) to express it purely in terms of the source</span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="comment">  /// loop IVs.</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="comment">  /// 3. Calculate a set difference between the iterations of the new domain and</span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<span class="comment">  /// the original domain of the source loop.</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;<span class="comment">  /// If this difference is empty, the slice is declared to be valid. Otherwise,</span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="comment">  /// return false as it implies that the effective fusion results in at least</span></div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="comment">  /// one iteration of the slice that was not originally in the source&#39;s domain.</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="comment">  /// If the validity cannot be determined, returns std::nullopt.</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="comment"></span>  std::optional&lt;bool&gt; <a class="code" href="structmlir_1_1affine_1_1ComputationSliceState.html#a09a810c2f49cc44e2c5de12c6caf2727">isSliceValid</a>() <span class="keyword">const</span>;</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160; </div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1ComputationSliceState.html#a23715baf2fcbb66e2acd9db32956f40e">dump</a>() <span class="keyword">const</span>;</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160; </div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;<span class="keyword">private</span>:<span class="comment"></span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="comment">  /// Fast check to determine if the computation slice is maximal. Returns true</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;<span class="comment">  /// if each slice dimension maps to an existing dst dimension and both the src</span></div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;<span class="comment">  /// and the dst loops for those dimensions have the same bounds. Returns false</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;<span class="comment">  /// if both the src and the dst loops don&#39;t have the same bounds. Returns</span></div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;<span class="comment">  /// std::nullopt if none of the above can be proven.</span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;<span class="comment"></span>  std::optional&lt;bool&gt; isSliceMaximalFastCheck() <span class="keyword">const</span>;</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;};</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="comment">/// Computes the computation slice loop bounds for one loop nest as affine maps</span></div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;<span class="comment">/// of the other loop nest&#39;s IVs and symbols, using &#39;dependenceConstraints&#39;</span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;<span class="comment">/// computed between &#39;depSourceAccess&#39; and &#39;depSinkAccess&#39;.</span></div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;<span class="comment">/// If &#39;isBackwardSlice&#39; is true, a backwards slice is computed in which the</span></div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<span class="comment">/// slice bounds of loop nest surrounding &#39;depSourceAccess&#39; are computed in</span></div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;<span class="comment">/// terms of loop IVs and symbols of the loop nest surrounding &#39;depSinkAccess&#39;</span></div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;<span class="comment">/// at &#39;loopDepth&#39;.</span></div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;<span class="comment">/// If &#39;isBackwardSlice&#39; is false, a forward slice is computed in which the</span></div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;<span class="comment">/// slice bounds of loop nest surrounding &#39;depSinkAccess&#39; are computed in terms</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="comment">/// of loop IVs and symbols of the loop nest surrounding &#39;depSourceAccess&#39; at</span></div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;<span class="comment">/// &#39;loopDepth&#39;.</span></div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;<span class="comment">/// The slice loop bounds and associated operands are returned in &#39;sliceState&#39;.</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;<span class="comment"></span><span class="comment">//</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;<span class="comment">//  Backward slice example:</span></div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;<span class="comment">//    affine.for %i0 = 0 to 10 {</span></div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;<span class="comment">//      affine.store %cst, %0[%i0] : memref&lt;100xf32&gt;  // &#39;depSourceAccess&#39;</span></div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;<span class="comment">//    affine.for %i1 = 0 to 10 {</span></div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;<span class="comment">//      %v = affine.load %0[%i1] : memref&lt;100xf32&gt;    // &#39;depSinkAccess&#39;</span></div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;<span class="comment">//    // Backward computation slice of loop nest &#39;%i0&#39;.</span></div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;<span class="comment">//    affine.for %i0 = (d0) -&gt; (d0)(%i1) to (d0) -&gt; (d0 + 1)(%i1) {</span></div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;<span class="comment">//      affine.store %cst, %0[%i0] : memref&lt;100xf32&gt;  // &#39;depSourceAccess&#39;</span></div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;<span class="comment">//  Forward slice example:</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="comment">//    affine.for %i0 = 0 to 10 {</span></div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="comment">//      affine.store %cst, %0[%i0] : memref&lt;100xf32&gt;  // &#39;depSourceAccess&#39;</span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="comment">//    affine.for %i1 = 0 to 10 {</span></div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="comment">//      %v = affine.load %0[%i1] : memref&lt;100xf32&gt;    // &#39;depSinkAccess&#39;</span></div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="comment">//    // Forward computation slice of loop nest &#39;%i1&#39;.</span></div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="comment">//    affine.for %i1 = (d0) -&gt; (d0)(%i0) to (d0) -&gt; (d0 + 1)(%i0) {</span></div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="comment">//      %v = affine.load %0[%i1] : memref&lt;100xf32&gt;    // &#39;depSinkAccess&#39;</span></div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacemlir_1_1affine.html#ab6cceed0c6debb9af0d3bd76c9ed52f4">getComputationSliceState</a>(</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <a class="code" href="classmlir_1_1Operation.html">Operation</a> *depSourceOp, <a class="code" href="classmlir_1_1Operation.html">Operation</a> *depSinkOp,</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    <span class="keyword">const</span> FlatAffineValueConstraints &amp;dependenceConstraints, <span class="keywordtype">unsigned</span> loopDepth,</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    <span class="keywordtype">bool</span> isBackwardSlice, ComputationSliceState *sliceState);</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;<span class="comment">/// Return the number of iterations for the `slicetripCountMap` provided.</span></div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;<span class="comment"></span>uint64_t <a class="code" href="namespacemlir_1_1affine.html#acfb5cde2210f8126b02cd84843a0c43b">getSliceIterationCount</a>(</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <span class="keyword">const</span> llvm::SmallDenseMap&lt;Operation *, uint64_t, 8&gt; &amp;sliceTripCountMap);</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="comment">/// Builds a map &#39;tripCountMap&#39; from AffineForOp to constant trip count for</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="comment">/// loop nest surrounding represented by slice loop bounds in &#39;slice&#39;. Returns</span></div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="comment">/// true on success, false otherwise (if a non-constant trip count was</span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="comment">/// encountered).</span></div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;<span class="comment"></span><span class="keywordtype">bool</span> <a class="code" href="namespacemlir_1_1affine.html#af1b7ee261b2662fe2f0c257c9e04f3b6">buildSliceTripCountMap</a>(</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    <span class="keyword">const</span> ComputationSliceState &amp;slice,</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    llvm::SmallDenseMap&lt;Operation *, uint64_t, 8&gt; *tripCountMap);</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;<span class="comment">/// Computes in &#39;sliceUnion&#39; the union of all slice bounds computed at</span></div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;<span class="comment">/// &#39;loopDepth&#39; between all dependent pairs of ops in &#39;opsA&#39; and &#39;opsB&#39;, and</span></div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;<span class="comment">/// then verifies if it is valid. The parameter &#39;numCommonLoops&#39; is the number</span></div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;<span class="comment">/// of loops common to the operations in &#39;opsA&#39; and &#39;opsB&#39;. If &#39;isBackwardSlice&#39;</span></div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;<span class="comment">/// is true, computes slice bounds for loop nest surrounding ops in &#39;opsA&#39;, as a</span></div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;<span class="comment">/// function of IVs and symbols of loop nest surrounding ops in &#39;opsB&#39; at</span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;<span class="comment">/// &#39;loopDepth&#39;. If &#39;isBackwardSlice&#39; is false, computes slice bounds for loop</span></div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="comment">/// nest surrounding ops in &#39;opsB&#39;, as a function of IVs and symbols of loop</span></div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;<span class="comment">/// nest surrounding ops in &#39;opsA&#39; at &#39;loopDepth&#39;. Returns</span></div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<span class="comment">/// &#39;SliceComputationResult::Success&#39; if union was computed correctly, an</span></div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;<span class="comment">/// appropriate &#39;failure&#39; otherwise.</span></div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;<span class="comment"></span>SliceComputationResult</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;<a class="code" href="namespacemlir_1_1affine.html#a29213ed6d6cdad5cdd69bb66c6df863f">computeSliceUnion</a>(<a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Operation *&gt;</a> opsA, <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Operation *&gt;</a> opsB,</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;                  <span class="keywordtype">unsigned</span> loopDepth, <span class="keywordtype">unsigned</span> numCommonLoops,</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;                  <span class="keywordtype">bool</span> isBackwardSlice, ComputationSliceState *sliceUnion);</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="comment">/// Creates a clone of the computation contained in the loop nest surrounding</span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="comment">/// &#39;srcOpInst&#39;, slices the iteration space of src loop based on slice bounds</span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="comment">/// in &#39;sliceState&#39;, and inserts the computation slice at the beginning of the</span></div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="comment">/// operation block of the loop at &#39;dstLoopDepth&#39; in the loop nest surrounding</span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="comment">/// &#39;dstOpInst&#39;. Returns the top-level loop of the computation slice on</span></div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="comment">/// success, returns nullptr otherwise.</span></div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="comment"></span><span class="comment">// Loop depth is a crucial optimization choice that determines where to</span></div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="comment">// materialize the results of the backward slice - presenting a trade-off b/w</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="comment">// storage and redundant computation in several cases.</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="comment">// TODO: Support computation slices with common surrounding loops.</span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;AffineForOp <a class="code" href="namespacemlir_1_1affine.html#af32168fb86ad493527c61d139acee48a">insertBackwardComputationSlice</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> *srcOpInst,</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;                                           <a class="code" href="classmlir_1_1Operation.html">Operation</a> *dstOpInst,</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;                                           <span class="keywordtype">unsigned</span> dstLoopDepth,</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;                                           ComputationSliceState *sliceState);</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="comment">/// A region of a memref&#39;s data space; this is typically constructed by</span></div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;<span class="comment">/// analyzing load/store op&#39;s on this memref and the index space of loops</span></div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;<span class="comment">/// surrounding such op&#39;s.</span></div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;<span class="comment"></span><span class="comment">// For example, the memref region for a load operation at loop depth = 1:</span></div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;<span class="comment">//    affine.for %i = 0 to 32 {</span></div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="comment">//      affine.for %ii = %i to (d0) -&gt; (d0 + 8) (%i) {</span></div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;<span class="comment">//        affine.load %A[%ii]</span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;<span class="comment">//      }</span></div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;<span class="comment">// Region:  {memref = %A, write = false, {%i &lt;= m0 &lt;= %i + 7} }</span></div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="comment">// The last field is a 2-d FlatAffineValueConstraints symbolic in %i.</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00481"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html">  481</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> {</div>
<div class="line"><a name="l00482"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#ac6d5022fc3e167d5e4f2c9e9c116ae39">  482</a></span>&#160;  <span class="keyword">explicit</span> <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#ac6d5022fc3e167d5e4f2c9e9c116ae39">MemRefRegion</a>(<a class="code" href="classmlir_1_1Location.html">Location</a> <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">loc</a>) : <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">loc</a>(<a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">loc</a>) {}</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;<span class="comment">  /// Computes the memory region accessed by this memref with the region</span></div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;<span class="comment">  /// represented as constraints symbolic/parametric in &#39;loopDepth&#39; loops</span></div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;<span class="comment">  /// surrounding opInst. The computed region&#39;s &#39;cst&#39; field has exactly as many</span></div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="comment">  /// dimensional variables as the rank of the memref, and *potentially*</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;<span class="comment">  /// additional symbolic variables which could include any of the loop IVs</span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="comment">  /// surrounding opInst up until &#39;loopDepth&#39; and another additional Function</span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;<span class="comment">  /// symbols involved with the access (for eg., those appear in affine.apply&#39;s,</span></div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;<span class="comment">  /// loop bounds, etc.). If &#39;sliceState&#39; is non-null, operands from</span></div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;<span class="comment">  /// &#39;sliceState&#39; are added as symbols, and the following constraints are added</span></div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;<span class="comment">  /// to the system:</span></div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;<span class="comment">  /// *) Inequality constraints which represent loop bounds for &#39;sliceState&#39;</span></div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;<span class="comment">  ///    operands which are loop IVS (these represent the destination loop IVs</span></div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;<span class="comment">  ///    of the slice, and are added as symbols to MemRefRegion&#39;s constraint</span></div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;<span class="comment">  ///    system).</span></div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;<span class="comment">  /// *) Inequality constraints for the slice bounds in &#39;sliceState&#39;, which</span></div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;<span class="comment">  ///    represent the bounds on the loop IVs in this constraint system w.r.t</span></div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;<span class="comment">  ///    to slice operands (which correspond to symbols).</span></div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;<span class="comment">  /// If &#39;addMemRefDimBounds&#39; is true, constant upper/lower bounds</span></div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;<span class="comment">  /// [0, memref.getDimSize(i)) are added for each MemRef dimension &#39;i&#39;.</span></div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;<span class="comment">  /// If `dropLocalVars` is true, all local variables in `cst` are projected</span></div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;<span class="comment">  /// out.</span></div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;<span class="comment">  ///</span></div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;<span class="comment">  ///  For example, the memref region for this operation at loopDepth = 1 will</span></div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;<span class="comment">  ///  be:</span></div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;<span class="comment">  ///</span></div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;<span class="comment">  ///    affine.for %i = 0 to 32 {</span></div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;<span class="comment">  ///      affine.for %ii = %i to (d0) -&gt; (d0 + 8) (%i) {</span></div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;<span class="comment">  ///        load %A[%ii]</span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="comment">  ///      }</span></div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;<span class="comment">  ///    }</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="comment">  ///</span></div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;<span class="comment">  ///   {memref = %A, write = false, {%i &lt;= m0 &lt;= %i + 7} }</span></div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;<span class="comment">  /// The last field is a 2-d FlatAffineValueConstraints symbolic in %i.</span></div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;<span class="comment">  ///</span></div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;<span class="comment">  /// If `dropOuterIVs` is true, project out any IVs other than those among</span></div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;<span class="comment">  /// `loopDepth` surrounding IVs, which would be symbols. If `dropOuterIVs`</span></div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;<span class="comment">  /// is false, the IVs would be turned into local variables instead of being</span></div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;<span class="comment">  /// projected out.</span></div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;<span class="comment"></span>  LogicalResult <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#a60e67b614605337ccb83b83bdaace70c">compute</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> *op, <span class="keywordtype">unsigned</span> loopDepth,</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;                        <span class="keyword">const</span> <a class="code" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState = <span class="keyword">nullptr</span>,</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;                        <span class="keywordtype">bool</span> addMemRefDimBounds = <span class="keyword">true</span>,</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;                        <span class="keywordtype">bool</span> dropLocalVars = <span class="keyword">true</span>, <span class="keywordtype">bool</span> dropOuterIVs = <span class="keyword">true</span>);</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160; </div>
<div class="line"><a name="l00527"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#a183baa082e4b25b1204cc5f9fa712d5b">  527</a></span>&#160;  <a class="code" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *<a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#a183baa082e4b25b1204cc5f9fa712d5b">getConstraints</a>() { <span class="keywordflow">return</span> &amp;<a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#a3d0ae2cb9072efe63434e12545d10486">cst</a>; }</div>
<div class="line"><a name="l00528"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#aafb1611afca2ff34d88c1c89a08c3497">  528</a></span>&#160;  <span class="keyword">const</span> <a class="code" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *<a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#aafb1611afca2ff34d88c1c89a08c3497">getConstraints</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;<a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#a3d0ae2cb9072efe63434e12545d10486">cst</a>; }</div>
<div class="line"><a name="l00529"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#a4255fd434f5d6dc27bebe8ffe3198dc7">  529</a></span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#a4255fd434f5d6dc27bebe8ffe3198dc7">isWrite</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#aaa0de038280a27f97e36f354690dbe15">write</a>; }</div>
<div class="line"><a name="l00530"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#ab0382cfe83a9301c5cc63f73a1a1e8d3">  530</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#ab0382cfe83a9301c5cc63f73a1a1e8d3">setWrite</a>(<span class="keywordtype">bool</span> flag) { <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#aaa0de038280a27f97e36f354690dbe15">write</a> = flag; }</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;<span class="comment">  /// Returns a constant upper bound on the number of elements in this region if</span></div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;<span class="comment">  /// bounded by a known constant (always possible for static shapes),</span></div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;<span class="comment">  /// std::nullopt otherwise. Note that the symbols of the region are treated</span></div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;<span class="comment">  /// specially, i.e., the returned bounding constant holds for *any given*</span></div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;<span class="comment">  /// value of the symbol variables. The &#39;shape&#39; vector is set to the</span></div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;<span class="comment">  /// corresponding dimension-wise bounds major to minor. The number of elements</span></div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;<span class="comment">  /// and all the dimension-wise bounds are guaranteed to be non-negative. We</span></div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;<span class="comment">  /// use int64_t instead of uint64_t since index types can be at most</span></div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;<span class="comment">  /// int64_t. `lbs` are set to the lower bound maps for each of the rank</span></div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;<span class="comment">  /// dimensions where each of these maps is purely symbolic in the constraints</span></div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;<span class="comment">  /// set&#39;s symbols.</span></div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;<span class="comment"></span>  std::optional&lt;int64_t&gt; <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#a02e6b8cc86992af6bcd29f0357072ca6">getConstantBoundingSizeAndShape</a>(</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;      <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;int64_t&gt;</a> *shape = <span class="keyword">nullptr</span>,</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;      <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;AffineMap&gt;</a> *lbs = <span class="keyword">nullptr</span>) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;<span class="comment">  /// Gets the lower and upper bound map for the dimensional variable at</span></div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;<span class="comment">  /// `pos`.</span></div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#a772a10d9c01365d3d3a697f8679e1afc">getLowerAndUpperBound</a>(<span class="keywordtype">unsigned</span> pos, <a class="code" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;lbMap,</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                             <a class="code" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;ubMap) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;<span class="comment">  /// Returns the size of this MemRefRegion in bytes.</span></div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;<span class="comment"></span>  std::optional&lt;int64_t&gt; <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#a8fb53fa6d699f6834738fa2f220ac783">getRegionSize</a>();</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160; </div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;  <span class="comment">// Wrapper around FlatAffineValueConstraints::unionBoundingBox.</span></div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;  LogicalResult <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#aa2761578967822bb7853e072a1a29bac">unionBoundingBox</a>(<span class="keyword">const</span> <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> &amp;other);</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;<span class="comment">  /// Returns the rank of the memref that this region corresponds to.</span></div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="comment"></span>  <span class="keywordtype">unsigned</span> <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#a22317444c57ececdfd0b3f5497d1971c">getRank</a>() <span class="keyword">const</span>;</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="comment">  /// Memref that this region corresponds to.</span></div>
<div class="line"><a name="l00562"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#ac097fcae970f4cd44eb14f9484deaf43">  562</a></span>&#160;<span class="comment"></span>  <a class="code" href="classmlir_1_1Value.html">Value</a> <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#ac097fcae970f4cd44eb14f9484deaf43">memref</a>;</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;<span class="comment">  /// Read or write.</span></div>
<div class="line"><a name="l00565"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#aaa0de038280a27f97e36f354690dbe15">  565</a></span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#aaa0de038280a27f97e36f354690dbe15">write</a> = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;<span class="comment">  /// If there is more than one load/store op associated with the region, the</span></div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;<span class="comment">  /// location information would correspond to one of those op&#39;s.</span></div>
<div class="line"><a name="l00569"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">  569</a></span>&#160;<span class="comment"></span>  <a class="code" href="classmlir_1_1Location.html">Location</a> <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">loc</a>;</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;<span class="comment">  /// Region (data space) of the memref accessed. This set will thus have at</span></div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;<span class="comment">  /// least as many dimensional variables as the shape dimensionality of the</span></div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;<span class="comment">  /// memref, and these are the leading dimensions of the set appearing in that</span></div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="comment">  /// order (major to minor / outermost to innermost). There may be additional</span></div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="comment">  /// variables since getMemRefRegion() is called with a specific loop depth,</span></div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;<span class="comment">  /// and thus the region is symbolic in the outer surrounding loops at that</span></div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;<span class="comment">  /// depth.</span></div>
<div class="line"><a name="l00578"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#a3d0ae2cb9072efe63434e12545d10486">  578</a></span>&#160;<span class="comment"></span>  <a class="code" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> <a class="code" href="structmlir_1_1affine_1_1MemRefRegion.html#a3d0ae2cb9072efe63434e12545d10486">cst</a>;</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;};</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="comment">/// Returns the size of a memref with element type int or float in bytes if it&#39;s</span></div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;<span class="comment">/// statically shaped, std::nullopt otherwise.</span></div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="comment"></span>std::optional&lt;uint64_t&gt; <a class="code" href="namespacemlir_1_1affine.html#ac5e109cfdab6f0859fbbc3e0bf08ebac">getIntOrFloatMemRefSizeInBytes</a>(MemRefType memRefType);</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;<span class="comment">/// Checks a load or store op for an out of bound access; returns failure if the</span></div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;<span class="comment">/// access is out of bounds along any of the dimensions, success otherwise.</span></div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;<span class="comment">/// Emits a diagnostic error (with location information) if emitError is true.</span></div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;<span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> LoadOrStoreOpPo<span class="keywordtype">int</span>er&gt;</div>
<div class="line"><a name="l00589"></a><span class="lineno"><a class="line" href="namespacemlir_1_1affine.html#addef193d35d8d7990addced6bcb731c1">  589</a></span>&#160;LogicalResult <a class="code" href="namespacemlir_1_1affine.html#addef193d35d8d7990addced6bcb731c1">boundCheckLoadOrStoreOp</a>(LoadOrStoreOpPointer loadOrStoreOp,</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;                                      <span class="keywordtype">bool</span> <a class="code" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a> = <span class="keyword">true</span>);</div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;<span class="comment">/// Returns the number of surrounding loops common to both A and B.</span></div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;<span class="comment"></span><span class="keywordtype">unsigned</span> <a class="code" href="namespacemlir_1_1affine.html#a3a39bbf8628440572cdd76a10d58dc53">getNumCommonSurroundingLoops</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;a, <a class="code" href="classmlir_1_1Operation.html">Operation</a> &amp;b);</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;<span class="comment">/// Gets the memory footprint of all data touched in the specified memory space</span></div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;<span class="comment">/// in bytes; if the memory space is unspecified, considers all memory spaces.</span></div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;<span class="comment"></span>std::optional&lt;int64_t&gt; <a class="code" href="namespacemlir_1_1affine.html#a93666d2fb7a3b0598ecf69542f1a5ab7">getMemoryFootprintBytes</a>(AffineForOp forOp,</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;                                               <span class="keywordtype">int</span> memorySpace = -1);</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;<span class="comment">/// Returns the memref&#39;s element type&#39;s size in bytes where the elemental type</span></div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;<span class="comment">/// is an int or float or a vector of such types.</span></div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;<span class="comment"></span>std::optional&lt;int64_t&gt; <a class="code" href="namespacemlir_1_1affine.html#afd9e0f536b1471778961ba51c2227f07">getMemRefIntOrFloatEltSizeInBytes</a>(MemRefType memRefType);</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;<span class="comment">/// Simplify the integer set by simplifying the underlying affine expressions by</span></div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="comment">/// flattening and some simple inference. Also, drop any duplicate constraints.</span></div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;<span class="comment">/// Returns the simplified integer set. This method runs in time linear in the</span></div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="comment">/// number of constraints.</span></div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;<span class="comment"></span><a class="code" href="classmlir_1_1IntegerSet.html">IntegerSet</a> <a class="code" href="namespacemlir_1_1affine.html#a1f2e85e904cf88ca63479dad00941e87">simplifyIntegerSet</a>(<a class="code" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set);</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;<span class="comment">/// Returns the innermost common loop depth for the set of operations in &#39;ops&#39;.</span></div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;<span class="comment"></span><span class="keywordtype">unsigned</span> <a class="code" href="namespacemlir_1_1affine.html#a9cc3df9a0cea6ad3bf48958ad2d54128">getInnermostCommonLoopDepth</a>(</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;    <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Operation *&gt;</a> ops,</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;    <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;AffineForOp&gt;</a> *surroundingLoops = <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;<span class="comment">/// Try to simplify the given affine.min or affine.max op to an affine map with</span></div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="comment">/// a single result and operands, taking into account the specified constraint</span></div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;<span class="comment">/// set. Return failure if no simplified version could be found.</span></div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;<span class="comment"></span>FailureOr&lt;AffineValueMap&gt;</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;<a class="code" href="namespacemlir_1_1affine.html#af4c9fec2934b9a14a5883e9fabbe3f49">simplifyConstrainedMinMaxOp</a>(<a class="code" href="classmlir_1_1Operation.html">Operation</a> *op,</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;                            <a class="code" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> constraints);</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;<span class="comment">/// Find the innermost common `Block` of `a` and `b` in the affine scope</span></div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;<span class="comment">/// that `a` and `b` are part of. Return nullptr if they belong to different</span></div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;<span class="comment">/// affine scopes. Also, return nullptr if they do not have a common `Block`</span></div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;<span class="comment">/// ancestor (for eg., when they are part of the `then` and `else` regions</span></div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;<span class="comment">/// of an op that itself starts an affine scope.</span></div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;<span class="comment"></span><a class="code" href="classmlir_1_1Block.html">mlir::Block</a> *<a class="code" href="namespacemlir_1_1affine.html#ae33ee1431de2b7e6802c9270b1ff60d1">findInnermostCommonBlockInScope</a>(<a class="code" href="classmlir_1_1Operation.html">mlir::Operation</a> *a,</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;                                             <a class="code" href="classmlir_1_1Operation.html">mlir::Operation</a> *b);</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160; </div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;} <span class="comment">// namespace affine</span></div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;} <span class="comment">// namespace mlir</span></div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160; </div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;<span class="preprocessor">#endif </span><span class="comment">// MLIR_DIALECT_AFFINE_ANALYSIS_UTILS_H</span></div>
<div class="ttc" id="aAffineOps_8h_html"><div class="ttname"><a href="AffineOps_8h.html">AffineOps.h</a></div></div>
<div class="ttc" id="aAffineStructures_8h_html"><div class="ttname"><a href="AffineStructures_8h.html">AffineStructures.h</a></div></div>
<div class="ttc" id="aDialect_2Affine_2Analysis_2Utils_8cpp_html_ab7365fa1c3a77e6dbf089404d9d07984"><div class="ttname"><a href="Dialect_2Affine_2Analysis_2Utils_8cpp.html#ab7365fa1c3a77e6dbf089404d9d07984">Node</a></div><div class="ttdeci">MemRefDependenceGraph::Node Node</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00036">Utils.cpp:36</a></div></div>
<div class="ttc" id="aclassllvm_1_1ArrayRef_html"><div class="ttname"><a href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a></div><div class="ttdef"><b>Definition:</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00048">LLVM.h:48</a></div></div>
<div class="ttc" id="aclassllvm_1_1DenseMap_html"><div class="ttname"><a href="classllvm_1_1DenseMap.html">llvm::DenseMap</a></div><div class="ttdef"><b>Definition:</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00055">LLVM.h:55</a></div></div>
<div class="ttc" id="aclassllvm_1_1DenseSet_html"><div class="ttname"><a href="classllvm_1_1DenseSet.html">llvm::DenseSet</a></div><div class="ttdef"><b>Definition:</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00059">LLVM.h:59</a></div></div>
<div class="ttc" id="aclassllvm_1_1SmallVectorImpl_html"><div class="ttname"><a href="classllvm_1_1SmallVectorImpl.html">llvm::SmallVectorImpl</a></div><div class="ttdef"><b>Definition:</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00074">LLVM.h:74</a></div></div>
<div class="ttc" id="aclassllvm_1_1SmallVector_html"><div class="ttname"><a href="classllvm_1_1SmallVector.html">llvm::SmallVector</a></div><div class="ttdef"><b>Definition:</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00072">LLVM.h:72</a></div></div>
<div class="ttc" id="aclassmlir_1_1AffineMap_html"><div class="ttname"><a href="classmlir_1_1AffineMap.html">mlir::AffineMap</a></div><div class="ttdoc">A multi-dimensional affine map Affine map's are immutable like Type's, and they are uniqued.</div><div class="ttdef"><b>Definition:</b> <a href="mlir_2IR_2AffineMap_8h_source.html#l00046">AffineMap.h:46</a></div></div>
<div class="ttc" id="aclassmlir_1_1Block_html"><div class="ttname"><a href="classmlir_1_1Block.html">mlir::Block</a></div><div class="ttdoc">Block represents an ordered list of Operations.</div><div class="ttdef"><b>Definition:</b> <a href="Block_8h_source.html#l00032">Block.h:33</a></div></div>
<div class="ttc" id="aclassmlir_1_1Block_html_a0ea87a88ccca470d216809e2a162d909"><div class="ttname"><a href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">mlir::Block::iterator</a></div><div class="ttdeci">OpListType::iterator iterator</div><div class="ttdef"><b>Definition:</b> <a href="Block_8h_source.html#l00140">Block.h:140</a></div></div>
<div class="ttc" id="aclassmlir_1_1IntegerSet_html"><div class="ttname"><a href="classmlir_1_1IntegerSet.html">mlir::IntegerSet</a></div><div class="ttdoc">An integer set representing a conjunction of one or more affine equalities and inequalities.</div><div class="ttdef"><b>Definition:</b> <a href="mlir_2IR_2IntegerSet_8h_source.html#l00044">IntegerSet.h:44</a></div></div>
<div class="ttc" id="aclassmlir_1_1Location_html"><div class="ttname"><a href="classmlir_1_1Location.html">mlir::Location</a></div><div class="ttdoc">This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...</div><div class="ttdef"><b>Definition:</b> <a href="Location_8h_source.html#l00076">Location.h:76</a></div></div>
<div class="ttc" id="aclassmlir_1_1Operation_html"><div class="ttname"><a href="classmlir_1_1Operation.html">mlir::Operation</a></div><div class="ttdoc">Operation is the basic unit of execution within MLIR.</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Operation_8h_source.html#l00084">Operation.h:88</a></div></div>
<div class="ttc" id="aclassmlir_1_1Value_html"><div class="ttname"><a href="classmlir_1_1Value.html">mlir::Value</a></div><div class="ttdoc">This class represents an instance of an SSA value in the MLIR system, representing a computable value...</div><div class="ttdef"><b>Definition:</b> <a href="Value_8h_source.html#l00096">Value.h:96</a></div></div>
<div class="ttc" id="aclassmlir_1_1affine_1_1FlatAffineValueConstraints_html"><div class="ttname"><a href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">mlir::affine::FlatAffineValueConstraints</a></div><div class="ttdoc">FlatAffineValueConstraints is an extension of FlatLinearValueConstraints with helper functions for Af...</div><div class="ttdef"><b>Definition:</b> <a href="AffineStructures_8h_source.html#l00044">AffineStructures.h:44</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a1f2e85e904cf88ca63479dad00941e87"><div class="ttname"><a href="namespacemlir_1_1affine.html#a1f2e85e904cf88ca63479dad00941e87">mlir::affine::simplifyIntegerSet</a></div><div class="ttdeci">IntegerSet simplifyIntegerSet(IntegerSet set)</div><div class="ttdoc">Simplify the integer set by simplifying the underlying affine expressions by flattening and some simp...</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02108">Utils.cpp:2108</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a1f8e59ec9faff34b64ebb0411a383c3a"><div class="ttname"><a href="namespacemlir_1_1affine.html#a1f8e59ec9faff34b64ebb0411a383c3a">mlir::affine::getEnclosingAffineOps</a></div><div class="ttdeci">void getEnclosingAffineOps(Operation &amp;op, SmallVectorImpl&lt; Operation * &gt; *ops)</div><div class="ttdoc">Populates 'ops' with affine operations enclosing op ordered from outermost to innermost while stoppin...</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00770">Utils.cpp:770</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a29213ed6d6cdad5cdd69bb66c6df863f"><div class="ttname"><a href="namespacemlir_1_1affine.html#a29213ed6d6cdad5cdd69bb66c6df863f">mlir::affine::computeSliceUnion</a></div><div class="ttdeci">SliceComputationResult computeSliceUnion(ArrayRef&lt; Operation * &gt; opsA, ArrayRef&lt; Operation * &gt; opsB, unsigned loopDepth, unsigned numCommonLoops, bool isBackwardSlice, ComputationSliceState *sliceUnion)</div><div class="ttdoc">Computes in 'sliceUnion' the union of all slice bounds computed at 'loopDepth' between all dependent ...</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01541">Utils.cpp:1541</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a34c1ca39d435d06366058d16b5fe4225"><div class="ttname"><a href="namespacemlir_1_1affine.html#a34c1ca39d435d06366058d16b5fe4225">mlir::affine::isLoopParallelAndContainsReduction</a></div><div class="ttdeci">bool isLoopParallelAndContainsReduction(AffineForOp forOp)</div><div class="ttdoc">Returns whether a loop is a parallel loop and contains a reduction loop.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02090">Utils.cpp:2090</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a3a39bbf8628440572cdd76a10d58dc53"><div class="ttname"><a href="namespacemlir_1_1affine.html#a3a39bbf8628440572cdd76a10d58dc53">mlir::affine::getNumCommonSurroundingLoops</a></div><div class="ttdeci">unsigned getNumCommonSurroundingLoops(Operation &amp;a, Operation &amp;b)</div><div class="ttdoc">Returns the number of surrounding loops common to both A and B.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02019">Utils.cpp:2019</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a50b5b72a6baee24bfab9faebd198fe9b"><div class="ttname"><a href="namespacemlir_1_1affine.html#a50b5b72a6baee24bfab9faebd198fe9b">mlir::affine::getAffineIVs</a></div><div class="ttdeci">void getAffineIVs(Operation &amp;op, SmallVectorImpl&lt; Value &gt; &amp;ivs)</div><div class="ttdoc">Populates 'ivs' with IVs of the surrounding affine.for and affine.parallel ops ordered from the outer...</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02002">Utils.cpp:2002</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a5ad383995f97dc30a0d6891e33fd499a"><div class="ttname"><a href="namespacemlir_1_1affine.html#a5ad383995f97dc30a0d6891e33fd499a">mlir::affine::getSequentialLoops</a></div><div class="ttdeci">void getSequentialLoops(AffineForOp forOp, llvm::SmallDenseSet&lt; Value, 8 &gt; *sequentialLoops)</div><div class="ttdoc">Returns in 'sequentialLoops' all sequential loops in loop nest rooted at 'forOp'.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02099">Utils.cpp:2099</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a9085efe05b8bc0b7c3b4f643d70eb1e7"><div class="ttname"><a href="namespacemlir_1_1affine.html#a9085efe05b8bc0b7c3b4f643d70eb1e7">mlir::affine::getAffineForIVs</a></div><div class="ttdeci">void getAffineForIVs(Operation &amp;op, SmallVectorImpl&lt; AffineForOp &gt; *loops)</div><div class="ttdoc">Populates 'loops' with IVs of the affine.for ops surrounding 'op' ordered from the outermost 'affine....</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00756">Utils.cpp:756</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a93666d2fb7a3b0598ecf69542f1a5ab7"><div class="ttname"><a href="namespacemlir_1_1affine.html#a93666d2fb7a3b0598ecf69542f1a5ab7">mlir::affine::getMemoryFootprintBytes</a></div><div class="ttdeci">std::optional&lt; int64_t &gt; getMemoryFootprintBytes(AffineForOp forOp, int memorySpace=-1)</div><div class="ttdoc">Gets the memory footprint of all data touched in the specified memory space in bytes; if the memory s...</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02081">Utils.cpp:2081</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a9cc3df9a0cea6ad3bf48958ad2d54128"><div class="ttname"><a href="namespacemlir_1_1affine.html#a9cc3df9a0cea6ad3bf48958ad2d54128">mlir::affine::getInnermostCommonLoopDepth</a></div><div class="ttdeci">unsigned getInnermostCommonLoopDepth(ArrayRef&lt; Operation * &gt; ops, SmallVectorImpl&lt; AffineForOp &gt; *surroundingLoops=nullptr)</div><div class="ttdoc">Returns the innermost common loop depth for the set of operations in 'ops'.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01509">Utils.cpp:1509</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_ab6cceed0c6debb9af0d3bd76c9ed52f4"><div class="ttname"><a href="namespacemlir_1_1affine.html#ab6cceed0c6debb9af0d3bd76c9ed52f4">mlir::affine::getComputationSliceState</a></div><div class="ttdeci">void getComputationSliceState(Operation *depSourceOp, Operation *depSinkOp, const FlatAffineValueConstraints &amp;dependenceConstraints, unsigned loopDepth, bool isBackwardSlice, ComputationSliceState *sliceState)</div><div class="ttdoc">Computes the computation slice loop bounds for one loop nest as affine maps of the other loop nest's ...</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01781">Utils.cpp:1781</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_ac5e109cfdab6f0859fbbc3e0bf08ebac"><div class="ttname"><a href="namespacemlir_1_1affine.html#ac5e109cfdab6f0859fbbc3e0bf08ebac">mlir::affine::getIntOrFloatMemRefSizeInBytes</a></div><div class="ttdeci">std::optional&lt; uint64_t &gt; getIntOrFloatMemRefSizeInBytes(MemRefType memRefType)</div><div class="ttdoc">Returns the size of a memref with element type int or float in bytes if it's statically shaped,...</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01370">Utils.cpp:1370</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_ac82ec61d5cae9ebb4489d2ab9ad6e8f8"><div class="ttname"><a href="namespacemlir_1_1affine.html#ac82ec61d5cae9ebb4489d2ab9ad6e8f8">mlir::affine::getNestingDepth</a></div><div class="ttdeci">unsigned getNestingDepth(Operation *op)</div><div class="ttdoc">Returns the nesting depth of this operation, i.e., the number of loops surrounding this operation.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01974">Utils.cpp:1974</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_acfb5cde2210f8126b02cd84843a0c43b"><div class="ttname"><a href="namespacemlir_1_1affine.html#acfb5cde2210f8126b02cd84843a0c43b">mlir::affine::getSliceIterationCount</a></div><div class="ttdeci">uint64_t getSliceIterationCount(const llvm::SmallDenseMap&lt; Operation *, uint64_t, 8 &gt; &amp;sliceTripCountMap)</div><div class="ttdoc">Return the number of iterations for the slicetripCountMap provided.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01767">Utils.cpp:1767</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_addef193d35d8d7990addced6bcb731c1"><div class="ttname"><a href="namespacemlir_1_1affine.html#addef193d35d8d7990addced6bcb731c1">mlir::affine::boundCheckLoadOrStoreOp</a></div><div class="ttdeci">LogicalResult boundCheckLoadOrStoreOp(LoadOrStoreOpPointer loadOrStoreOp, bool emitError=true)</div><div class="ttdoc">Checks a load or store op for an out of bound access; returns failure if the access is out of bounds ...</div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_ae33ee1431de2b7e6802c9270b1ff60d1"><div class="ttname"><a href="namespacemlir_1_1affine.html#ae33ee1431de2b7e6802c9270b1ff60d1">mlir::affine::findInnermostCommonBlockInScope</a></div><div class="ttdeci">mlir::Block * findInnermostCommonBlockInScope(mlir::Operation *a, mlir::Operation *b)</div><div class="ttdoc">Find the innermost common Block of a and b in the affine scope that a and b are part of.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02299">Utils.cpp:2299</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_af1b7ee261b2662fe2f0c257c9e04f3b6"><div class="ttname"><a href="namespacemlir_1_1affine.html#af1b7ee261b2662fe2f0c257c9e04f3b6">mlir::affine::buildSliceTripCountMap</a></div><div class="ttdeci">bool buildSliceTripCountMap(const ComputationSliceState &amp;slice, llvm::SmallDenseMap&lt; Operation *, uint64_t, 8 &gt; *tripCountMap)</div><div class="ttdoc">Builds a map 'tripCountMap' from AffineForOp to constant trip count for loop nest surrounding represe...</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01729">Utils.cpp:1729</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_af32168fb86ad493527c61d139acee48a"><div class="ttname"><a href="namespacemlir_1_1affine.html#af32168fb86ad493527c61d139acee48a">mlir::affine::insertBackwardComputationSlice</a></div><div class="ttdeci">AffineForOp insertBackwardComputationSlice(Operation *srcOpInst, Operation *dstOpInst, unsigned dstLoopDepth, ComputationSliceState *sliceState)</div><div class="ttdoc">Creates a clone of the computation contained in the loop nest surrounding 'srcOpInst',...</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01893">Utils.cpp:1893</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_af4c9fec2934b9a14a5883e9fabbe3f49"><div class="ttname"><a href="namespacemlir_1_1affine.html#af4c9fec2934b9a14a5883e9fabbe3f49">mlir::affine::simplifyConstrainedMinMaxOp</a></div><div class="ttdeci">FailureOr&lt; AffineValueMap &gt; simplifyConstrainedMinMaxOp(Operation *op, FlatAffineValueConstraints constraints)</div><div class="ttdoc">Try to simplify the given affine.min or affine.max op to an affine map with a single result and opera...</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02194">Utils.cpp:2194</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_afd9e0f536b1471778961ba51c2227f07"><div class="ttname"><a href="namespacemlir_1_1affine.html#afd9e0f536b1471778961ba51c2227f07">mlir::affine::getMemRefIntOrFloatEltSizeInBytes</a></div><div class="ttdeci">std::optional&lt; int64_t &gt; getMemRefIntOrFloatEltSizeInBytes(MemRefType memRefType)</div><div class="ttdoc">Returns the memref's element type's size in bytes where the elemental type is an int or float or a ve...</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01326">Utils.cpp:1326</a></div></div>
<div class="ttc" id="anamespacemlir_1_1lsp_html_ad6c31c7b93eb99ad1d173f9b2b97ff7fa689202409e48743b914713f96d93947c"><div class="ttname"><a href="namespacemlir_1_1lsp.html#ad6c31c7b93eb99ad1d173f9b2b97ff7fa689202409e48743b914713f96d93947c">mlir::lsp::CompletionItemKind::Value</a></div><div class="ttdeci">@ Value</div></div>
<div class="ttc" id="anamespacemlir_html"><div class="ttname"><a href="namespacemlir.html">mlir</a></div><div class="ttdoc">Include the generated interface declarations.</div><div class="ttdef"><b>Definition:</b> <a href="LocalAliasAnalysis_8h_source.html#l00020">LocalAliasAnalysis.h:20</a></div></div>
<div class="ttc" id="anamespacemlir_html_a4e96b0c437652eb5a4890734bb6bcee7"><div class="ttname"><a href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">mlir::emitError</a></div><div class="ttdeci">InFlightDiagnostic emitError(Location loc)</div><div class="ttdoc">Utility method to emit an error message using this location.</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Diagnostics_8cpp_source.html#l00328">Diagnostics.cpp:328</a></div></div>
<div class="ttc" id="anamespacemlir_html_a6e07796c43d9bdf22c519ff44150daafae1e4c8c9ccd9fc39c391da4bcd093fb2"><div class="ttname"><a href="namespacemlir.html#a6e07796c43d9bdf22c519ff44150daafae1e4c8c9ccd9fc39c391da4bcd093fb2">mlir::HoistingKind::Block</a></div><div class="ttdeci">@ Block</div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html">mlir::affine::ComputationSliceState</a></div><div class="ttdoc">ComputationSliceState aggregates loop IVs, loop bound AffineMaps and their associated operands for a ...</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00310">Utils.h:310</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_a09a810c2f49cc44e2c5de12c6caf2727"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#a09a810c2f49cc44e2c5de12c6caf2727">mlir::affine::ComputationSliceState::isSliceValid</a></div><div class="ttdeci">std::optional&lt; bool &gt; isSliceValid() const</div><div class="ttdoc">Checks the validity of the slice computed.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00941">Utils.cpp:941</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_a140bf9ff4200613fb5822bed2f1bfc18"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#a140bf9ff4200613fb5822bed2f1bfc18">mlir::affine::ComputationSliceState::ivs</a></div><div class="ttdeci">SmallVector&lt; Value, 4 &gt; ivs</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00313">Utils.h:313</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_a23715baf2fcbb66e2acd9db32956f40e"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#a23715baf2fcbb66e2acd9db32956f40e">mlir::affine::ComputationSliceState::dump</a></div><div class="ttdeci">void dump() const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00846">Utils.cpp:846</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_a2a55ff23adbc2491f154ec4074c665d6"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#a2a55ff23adbc2491f154ec4074c665d6">mlir::affine::ComputationSliceState::getAsConstraints</a></div><div class="ttdeci">LogicalResult getAsConstraints(FlatAffineValueConstraints *cst) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00803">Utils.cpp:803</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_a6662e2d7b1582bfe4ff4f64eea403432"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#a6662e2d7b1582bfe4ff4f64eea403432">mlir::affine::ComputationSliceState::isEmpty</a></div><div class="ttdeci">bool isEmpty() const</div><div class="ttdoc">Returns true if the computation slice is empty.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00342">Utils.h:342</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_a9b06d992ca662858732225827937c1f7"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#a9b06d992ca662858732225827937c1f7">mlir::affine::ComputationSliceState::getSourceAsConstraints</a></div><div class="ttdeci">LogicalResult getSourceAsConstraints(FlatAffineValueConstraints &amp;cst) const</div><div class="ttdoc">Adds to 'cst' constraints which represent the original loop bounds on 'ivs' in 'this'.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00787">Utils.cpp:787</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_aa3215ff59c18264fa4e846d9a2d5615f"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#aa3215ff59c18264fa4e846d9a2d5615f">mlir::affine::ComputationSliceState::ubOperands</a></div><div class="ttdeci">std::vector&lt; SmallVector&lt; Value, 4 &gt; &gt; ubOperands</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00321">Utils.h:321</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_ab0148e60f0d8d38822992cf91eb87b5b"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#ab0148e60f0d8d38822992cf91eb87b5b">mlir::affine::ComputationSliceState::ubs</a></div><div class="ttdeci">SmallVector&lt; AffineMap, 4 &gt; ubs</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00317">Utils.h:317</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_abc7052b611c0772f9c551ee0d4b33d92"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#abc7052b611c0772f9c551ee0d4b33d92">mlir::affine::ComputationSliceState::isMaximal</a></div><div class="ttdeci">std::optional&lt; bool &gt; isMaximal() const</div><div class="ttdoc">Returns true if the computation slice encloses all the iterations of the sliced loop nest.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01011">Utils.cpp:1011</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_ade6c510051faa671f7758989e38b491d"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#ade6c510051faa671f7758989e38b491d">mlir::affine::ComputationSliceState::lbs</a></div><div class="ttdeci">SmallVector&lt; AffineMap, 4 &gt; lbs</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00315">Utils.h:315</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_ae01fc5e4aa59b1624613835b69c219a6"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#ae01fc5e4aa59b1624613835b69c219a6">mlir::affine::ComputationSliceState::clearBounds</a></div><div class="ttdeci">void clearBounds()</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00839">Utils.cpp:839</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_afc69fcff6c39da7525bb1c61b91c4492"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#afc69fcff6c39da7525bb1c61b91c4492">mlir::affine::ComputationSliceState::insertPoint</a></div><div class="ttdeci">Block::iterator insertPoint</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00323">Utils.h:323</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_afd8aa32fa351614ef5060a1e079dec0b"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#afd8aa32fa351614ef5060a1e079dec0b">mlir::affine::ComputationSliceState::lbOperands</a></div><div class="ttdeci">std::vector&lt; SmallVector&lt; Value, 4 &gt; &gt; lbOperands</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00319">Utils.h:319</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1LoopNestStateCollector_html"><div class="ttname"><a href="structmlir_1_1affine_1_1LoopNestStateCollector.html">mlir::affine::LoopNestStateCollector</a></div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00038">Utils.h:38</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1LoopNestStateCollector_html_a4c5255085d6cfdb16bff277d77176bab"><div class="ttname"><a href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a4c5255085d6cfdb16bff277d77176bab">mlir::affine::LoopNestStateCollector::memrefFrees</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; memrefFrees</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00049">Utils.h:49</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1LoopNestStateCollector_html_a6a9d08cfcdff91c3cb2818daa79b3fbb"><div class="ttname"><a href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a6a9d08cfcdff91c3cb2818daa79b3fbb">mlir::affine::LoopNestStateCollector::forOps</a></div><div class="ttdeci">SmallVector&lt; AffineForOp, 4 &gt; forOps</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00039">Utils.h:39</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1LoopNestStateCollector_html_a95f517b1a80923351ab5bd34fefd312c"><div class="ttname"><a href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a95f517b1a80923351ab5bd34fefd312c">mlir::affine::LoopNestStateCollector::loadOpInsts</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; loadOpInsts</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00041">Utils.h:41</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1LoopNestStateCollector_html_ab1b990940ad78278dd989884d2021cff"><div class="ttname"><a href="structmlir_1_1affine_1_1LoopNestStateCollector.html#ab1b990940ad78278dd989884d2021cff">mlir::affine::LoopNestStateCollector::memrefStores</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; memrefStores</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00047">Utils.h:47</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1LoopNestStateCollector_html_ac7e518efde98002ff3fdf5b576205883"><div class="ttname"><a href="structmlir_1_1affine_1_1LoopNestStateCollector.html#ac7e518efde98002ff3fdf5b576205883">mlir::affine::LoopNestStateCollector::collect</a></div><div class="ttdeci">void collect(Operation *opToWalk)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00041">Utils.cpp:41</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1LoopNestStateCollector_html_adf2391f4ce1e52ffc08a51add68a9b4e"><div class="ttname"><a href="structmlir_1_1affine_1_1LoopNestStateCollector.html#adf2391f4ce1e52ffc08a51add68a9b4e">mlir::affine::LoopNestStateCollector::memrefLoads</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; memrefLoads</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00045">Utils.h:45</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1LoopNestStateCollector_html_ae23767154d778088beab9572db13ddfb"><div class="ttname"><a href="structmlir_1_1affine_1_1LoopNestStateCollector.html#ae23767154d778088beab9572db13ddfb">mlir::affine::LoopNestStateCollector::storeOpInsts</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; storeOpInsts</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00043">Utils.h:43</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge_html"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html">mlir::affine::MemRefDependenceGraph::Edge</a></div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00123">Utils.h:123</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge_html_aa2928d335ef67abb4dd9f225fbe7eca5"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html#aa2928d335ef67abb4dd9f225fbe7eca5">mlir::affine::MemRefDependenceGraph::Edge::value</a></div><div class="ttdeci">Value value</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00137">Utils.h:137</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge_html_ace11f0021945bfc712786e04e2f1101d"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html#ace11f0021945bfc712786e04e2f1101d">mlir::affine::MemRefDependenceGraph::Edge::id</a></div><div class="ttdeci">unsigned id</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00129">Utils.h:129</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">mlir::affine::MemRefDependenceGraph::Node</a></div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00067">Utils.h:67</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a0d3aa9a9ed278fe81689d73d07033b29"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a0d3aa9a9ed278fe81689d73d07033b29">mlir::affine::MemRefDependenceGraph::Node::getStoreOpsForMemref</a></div><div class="ttdeci">void getStoreOpsForMemref(Value memref, SmallVectorImpl&lt; Operation * &gt; *storeOps) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00128">Utils.cpp:128</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a1443947aa4f1a5ba044f9bfbc364e353"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a1443947aa4f1a5ba044f9bfbc364e353">mlir::affine::MemRefDependenceGraph::Node::loads</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; loads</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00073">Utils.h:73</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a1d9d97fe37cf42792d796beeffb182db"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a1d9d97fe37cf42792d796beeffb182db">mlir::affine::MemRefDependenceGraph::Node::stores</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; stores</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00077">Utils.h:77</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a3b5c1cad1b7c6f2b8091bb7f12d29162"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a3b5c1cad1b7c6f2b8091bb7f12d29162">mlir::affine::MemRefDependenceGraph::Node::getLoadAndStoreMemrefSet</a></div><div class="ttdeci">void getLoadAndStoreMemrefSet(DenseSet&lt; Value &gt; *loadAndStoreMemrefSet) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00147">Utils.cpp:147</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a43784c742baf090c45dbf791c4194425"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a43784c742baf090c45dbf791c4194425">mlir::affine::MemRefDependenceGraph::Node::Node</a></div><div class="ttdeci">Node(unsigned id, Operation *op)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00085">Utils.h:85</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a49e4fae512d8dd3f049672634d5edd80"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a49e4fae512d8dd3f049672634d5edd80">mlir::affine::MemRefDependenceGraph::Node::hasFree</a></div><div class="ttdeci">unsigned hasFree(Value memref) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00121">Utils.cpp:121</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a5ab56168ea32478165badb63843a0839"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a5ab56168ea32478165badb63843a0839">mlir::affine::MemRefDependenceGraph::Node::memrefLoads</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; memrefLoads</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00075">Utils.h:75</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a678f66b993583d391ec12d1eaca5c168"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a678f66b993583d391ec12d1eaca5c168">mlir::affine::MemRefDependenceGraph::Node::memrefStores</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; memrefStores</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00079">Utils.h:79</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a73ec40eb1f5ef361ab49dbdcca2126f1"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a73ec40eb1f5ef361ab49dbdcca2126f1">mlir::affine::MemRefDependenceGraph::Node::privateMemrefs</a></div><div class="ttdeci">DenseSet&lt; Value &gt; privateMemrefs</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00083">Utils.h:83</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a77267e6959542952eb88324ac501186a"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a77267e6959542952eb88324ac501186a">mlir::affine::MemRefDependenceGraph::Node::getLoadOpCount</a></div><div class="ttdeci">unsigned getLoadOpCount(Value memref) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00076">Utils.cpp:76</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a7dcff2c5bf014d3ae42f78780ce15786"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a7dcff2c5bf014d3ae42f78780ce15786">mlir::affine::MemRefDependenceGraph::Node::getStoreOpCount</a></div><div class="ttdeci">unsigned getStoreOpCount(Value memref) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00091">Utils.cpp:91</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a830ea36bccf2332f1a9aea7e09bef2f0"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a830ea36bccf2332f1a9aea7e09bef2f0">mlir::affine::MemRefDependenceGraph::Node::id</a></div><div class="ttdeci">unsigned id</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00069">Utils.h:69</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a866114f24f1c3e927c47c87a38843a53"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a866114f24f1c3e927c47c87a38843a53">mlir::affine::MemRefDependenceGraph::Node::hasStore</a></div><div class="ttdeci">unsigned hasStore(Value memref) const</div><div class="ttdoc">Returns true if there exists an operation with a write memory effect to memref in this node.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00107">Utils.cpp:107</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_ab79054c161b7323e14e56f00d1d38fa0"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#ab79054c161b7323e14e56f00d1d38fa0">mlir::affine::MemRefDependenceGraph::Node::op</a></div><div class="ttdeci">Operation * op</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00071">Utils.h:71</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_ac9d40b81f36159a323d3a56d60b6bbea"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#ac9d40b81f36159a323d3a56d60b6bbea">mlir::affine::MemRefDependenceGraph::Node::getLoadOpsForMemref</a></div><div class="ttdeci">void getLoadOpsForMemref(Value memref, SmallVectorImpl&lt; Operation * &gt; *loadOps) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00137">Utils.cpp:137</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_afe5e17bd9cb80f70609ec127e9ce6d43"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#afe5e17bd9cb80f70609ec127e9ce6d43">mlir::affine::MemRefDependenceGraph::Node::memrefFrees</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; memrefFrees</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00081">Utils.h:81</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">mlir::affine::MemRefDependenceGraph</a></div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00062">Utils.h:62</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a01d186fd0b75b108fce1ad9dd27e3630"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a01d186fd0b75b108fce1ad9dd27e3630">mlir::affine::MemRefDependenceGraph::outEdges</a></div><div class="ttdeci">DenseMap&lt; unsigned, SmallVector&lt; Edge, 2 &gt; &gt; outEdges</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00147">Utils.h:147</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a033d58b8880a8b8bf188abaa803275f0"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a033d58b8880a8b8bf188abaa803275f0">mlir::affine::MemRefDependenceGraph::block</a></div><div class="ttdeci">Block &amp; block</div><div class="ttdoc">The block for which this graph is created to perform fusion.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00262">Utils.h:262</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a09cdaeb6db292ca36bfa6a57c2a1bf27"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a09cdaeb6db292ca36bfa6a57c2a1bf27">mlir::affine::MemRefDependenceGraph::addNode</a></div><div class="ttdeci">unsigned addNode(Operation *op)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00371">Utils.cpp:371</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a0db37460f490e2adeca97211fb608c2a"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a0db37460f490e2adeca97211fb608c2a">mlir::affine::MemRefDependenceGraph::init</a></div><div class="ttdeci">bool init()</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00243">Utils.cpp:243</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a0ed9f30da3f99f63db2d0a18b23a7562"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a0ed9f30da3f99f63db2d0a18b23a7562">mlir::affine::MemRefDependenceGraph::writesToLiveInOrEscapingMemrefs</a></div><div class="ttdeci">bool writesToLiveInOrEscapingMemrefs(unsigned id) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00401">Utils.cpp:401</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a14b6004ed00cac7dc114366cef2cc252"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a14b6004ed00cac7dc114366cef2cc252">mlir::affine::MemRefDependenceGraph::getForOpNode</a></div><div class="ttdeci">Node * getForOpNode(AffineForOp forOp)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00172">Utils.h:172</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a19787b209c503c45e6dff3d8a975d123"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a19787b209c503c45e6dff3d8a975d123">mlir::affine::MemRefDependenceGraph::removeEdge</a></div><div class="ttdeci">void removeEdge(unsigned srcId, unsigned dstId, Value value)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00447">Utils.cpp:447</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a2426d1416444660e2a965499b9558f2e"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a2426d1416444660e2a965499b9558f2e">mlir::affine::MemRefDependenceGraph::addEdge</a></div><div class="ttdeci">void addEdge(unsigned srcId, unsigned dstId, Value value)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00436">Utils.cpp:436</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a345e759cabd082ca094c6315f1104a8b"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a345e759cabd082ca094c6315f1104a8b">mlir::affine::MemRefDependenceGraph::nextNodeId</a></div><div class="ttdeci">unsigned nextNodeId</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00152">Utils.h:152</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a3c63e623ce037ff8c4bce83cf5d214a9"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3c63e623ce037ff8c4bce83cf5d214a9">mlir::affine::MemRefDependenceGraph::MemRefDependenceGraph</a></div><div class="ttdeci">MemRefDependenceGraph(Block &amp;block)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00154">Utils.h:154</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a3df572ea465683f6b1f0e4dcd9f9b42f"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3df572ea465683f6b1f0e4dcd9f9b42f">mlir::affine::MemRefDependenceGraph::nodes</a></div><div class="ttdeci">DenseMap&lt; unsigned, Node &gt; nodes</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00141">Utils.h:141</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a437652354edafa39b0546fe0a60e9071"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a437652354edafa39b0546fe0a60e9071">mlir::affine::MemRefDependenceGraph::gatherDefiningNodes</a></div><div class="ttdeci">void gatherDefiningNodes(unsigned id, DenseSet&lt; unsigned &gt; &amp;definingNodes) const</div><div class="ttdoc">Return all nodes which define SSA values used in node 'id'.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00535">Utils.cpp:535</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a45510d99234261290bf188a3108387cd"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a45510d99234261290bf188a3108387cd">mlir::affine::MemRefDependenceGraph::hasDependencePath</a></div><div class="ttdeci">bool hasDependencePath(unsigned srcId, unsigned dstId) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00474">Utils.cpp:474</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a55a81e7e71f3511a8babe8c8535393f1"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a55a81e7e71f3511a8babe8c8535393f1">mlir::affine::MemRefDependenceGraph::clearNodeLoadAndStores</a></div><div class="ttdeci">void clearNodeLoadAndStores(unsigned id)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00702">Utils.cpp:702</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a60e1b52dd56f3d099d5899568293b218"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a60e1b52dd56f3d099d5899568293b218">mlir::affine::MemRefDependenceGraph::getForOpNode</a></div><div class="ttdeci">const Node * getForOpNode(AffineForOp forOp) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00363">Utils.cpp:363</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a61ca2d2048e49f64711b86f5746f0081"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a61ca2d2048e49f64711b86f5746f0081">mlir::affine::MemRefDependenceGraph::getFusedLoopNestInsertionPoint</a></div><div class="ttdeci">Operation * getFusedLoopNestInsertionPoint(unsigned srcId, unsigned dstId) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00549">Utils.cpp:549</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a650542cbe4a3a8ed5cef0ad22bf2f39a"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a650542cbe4a3a8ed5cef0ad22bf2f39a">mlir::affine::MemRefDependenceGraph::updateEdges</a></div><div class="ttdeci">void updateEdges(unsigned srcId, unsigned dstId, const DenseSet&lt; Value &gt; &amp;privateMemRefs, bool removeSrcId)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00625">Utils.cpp:625</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a657659a854921a4dd67b0657556f0a7c"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a657659a854921a4dd67b0657556f0a7c">mlir::affine::MemRefDependenceGraph::hasNode</a></div><div class="ttdeci">bool hasNode(unsigned id) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00168">Utils.h:168</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a6c0fadb723818174fe2e60709e761918"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a6c0fadb723818174fe2e60709e761918">mlir::affine::MemRefDependenceGraph::inEdges</a></div><div class="ttdeci">DenseMap&lt; unsigned, SmallVector&lt; Edge, 2 &gt; &gt; inEdges</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00144">Utils.h:144</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a83ce0d42a3715e3d152f87ec4437c56e"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a83ce0d42a3715e3d152f87ec4437c56e">mlir::affine::MemRefDependenceGraph::forEachMemRefInputEdge</a></div><div class="ttdeci">void forEachMemRefInputEdge(unsigned id, const std::function&lt; void(Edge)&gt; &amp;callback)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00710">Utils.cpp:710</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a996bade25457fbc32567f4b47ae18f3f"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a996bade25457fbc32567f4b47ae18f3f">mlir::affine::MemRefDependenceGraph::getOutEdgeCount</a></div><div class="ttdeci">unsigned getOutEdgeCount(unsigned id, Value memref=nullptr) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00525">Utils.cpp:525</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a9ecf883f82ba5105ab012804d98994f5"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a9ecf883f82ba5105ab012804d98994f5">mlir::affine::MemRefDependenceGraph::getNode</a></div><div class="ttdeci">const Node * getNode(unsigned id) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00356">Utils.cpp:356</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_aa65f5209124219ebb4a86fcedb629850"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aa65f5209124219ebb4a86fcedb629850">mlir::affine::MemRefDependenceGraph::removeNode</a></div><div class="ttdeci">void removeNode(unsigned id)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00378">Utils.cpp:378</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_aaeb96e8d972edf0793f628b700743c52"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aaeb96e8d972edf0793f628b700743c52">mlir::affine::MemRefDependenceGraph::forEachMemRefOutputEdge</a></div><div class="ttdeci">void forEachMemRefOutputEdge(unsigned id, const std::function&lt; void(Edge)&gt; &amp;callback)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00718">Utils.cpp:718</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_ab8c546bd37ebde1870dfd51b66080974"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#ab8c546bd37ebde1870dfd51b66080974">mlir::affine::MemRefDependenceGraph::forEachMemRefEdge</a></div><div class="ttdeci">void forEachMemRefEdge(ArrayRef&lt; Edge &gt; edges, const std::function&lt; void(Edge)&gt; &amp;callback)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00726">Utils.cpp:726</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_abe5db0c6c3108f9e233ad68ee134e496"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#abe5db0c6c3108f9e233ad68ee134e496">mlir::affine::MemRefDependenceGraph::addToNode</a></div><div class="ttdeci">void addToNode(unsigned id, ArrayRef&lt; Operation * &gt; loads, ArrayRef&lt; Operation * &gt; stores, ArrayRef&lt; Operation * &gt; memrefLoads, ArrayRef&lt; Operation * &gt; memrefStores, ArrayRef&lt; Operation * &gt; memrefFrees)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00689">Utils.cpp:689</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_ade2784d9395e6a3fbe3acb55a90c55cd"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#ade2784d9395e6a3fbe3acb55a90c55cd">mlir::affine::MemRefDependenceGraph::getNode</a></div><div class="ttdeci">Node * getNode(unsigned id)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00162">Utils.h:162</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_aded491cadebd6d0969d23f80cb0ef475"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aded491cadebd6d0969d23f80cb0ef475">mlir::affine::MemRefDependenceGraph::getIncomingMemRefAccesses</a></div><div class="ttdeci">unsigned getIncomingMemRefAccesses(unsigned id, Value memref) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00509">Utils.cpp:509</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_ae3bdae51f114698511aa7be4b3133880"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#ae3bdae51f114698511aa7be4b3133880">mlir::affine::MemRefDependenceGraph::hasEdge</a></div><div class="ttdeci">bool hasEdge(unsigned srcId, unsigned dstId, Value value=nullptr) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00421">Utils.cpp:421</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_aee33c4c116b0fceb1dc3ec2114d0916b"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aee33c4c116b0fceb1dc3ec2114d0916b">mlir::affine::MemRefDependenceGraph::dump</a></div><div class="ttdeci">void dump() const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00259">Utils.h:259</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_af0240c7ff60660612bd78f98bff995e4"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#af0240c7ff60660612bd78f98bff995e4">mlir::affine::MemRefDependenceGraph::print</a></div><div class="ttdeci">void print(raw_ostream &amp;os) const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00738">Utils.cpp:738</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_afb1cdc99d9633c920e02a9a8975fdd41"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#afb1cdc99d9633c920e02a9a8975fdd41">mlir::affine::MemRefDependenceGraph::memrefEdgeCount</a></div><div class="ttdeci">DenseMap&lt; Value, unsigned &gt; memrefEdgeCount</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00150">Utils.h:150</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html">mlir::affine::MemRefRegion</a></div><div class="ttdoc">A region of a memref's data space; this is typically constructed by analyzing load/store op's on this...</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00481">Utils.h:481</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_a02e6b8cc86992af6bcd29f0357072ca6"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#a02e6b8cc86992af6bcd29f0357072ca6">mlir::affine::MemRefRegion::getConstantBoundingSizeAndShape</a></div><div class="ttdeci">std::optional&lt; int64_t &gt; getConstantBoundingSizeAndShape(SmallVectorImpl&lt; int64_t &gt; *shape=nullptr, SmallVectorImpl&lt; AffineMap &gt; *lbs=nullptr) const</div><div class="ttdoc">Returns a constant upper bound on the number of elements in this region if bounded by a known constan...</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01065">Utils.cpp:1065</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_a183baa082e4b25b1204cc5f9fa712d5b"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#a183baa082e4b25b1204cc5f9fa712d5b">mlir::affine::MemRefRegion::getConstraints</a></div><div class="ttdeci">FlatAffineValueConstraints * getConstraints()</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00527">Utils.h:527</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_a22317444c57ececdfd0b3f5497d1971c"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#a22317444c57ececdfd0b3f5497d1971c">mlir::affine::MemRefRegion::getRank</a></div><div class="ttdeci">unsigned getRank() const</div><div class="ttdoc">Returns the rank of the memref that this region corresponds to.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01061">Utils.cpp:1061</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_a3d0ae2cb9072efe63434e12545d10486"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#a3d0ae2cb9072efe63434e12545d10486">mlir::affine::MemRefRegion::cst</a></div><div class="ttdeci">FlatAffineValueConstraints cst</div><div class="ttdoc">Region (data space) of the memref accessed.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00578">Utils.h:578</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_a4255fd434f5d6dc27bebe8ffe3198dc7"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#a4255fd434f5d6dc27bebe8ffe3198dc7">mlir::affine::MemRefRegion::isWrite</a></div><div class="ttdeci">bool isWrite() const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00529">Utils.h:529</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_a60e67b614605337ccb83b83bdaace70c"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#a60e67b614605337ccb83b83bdaace70c">mlir::affine::MemRefRegion::compute</a></div><div class="ttdeci">LogicalResult compute(Operation *op, unsigned loopDepth, const ComputationSliceState *sliceState=nullptr, bool addMemRefDimBounds=true, bool dropLocalVars=true, bool dropOuterIVs=true)</div><div class="ttdoc">Computes the memory region accessed by this memref with the region represented as constraints symboli...</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01162">Utils.cpp:1162</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_a772a10d9c01365d3d3a697f8679e1afc"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#a772a10d9c01365d3d3a697f8679e1afc">mlir::affine::MemRefRegion::getLowerAndUpperBound</a></div><div class="ttdeci">void getLowerAndUpperBound(unsigned pos, AffineMap &amp;lbMap, AffineMap &amp;ubMap) const</div><div class="ttdoc">Gets the lower and upper bound map for the dimensional variable at pos.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01121">Utils.cpp:1121</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_a8fb53fa6d699f6834738fa2f220ac783"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#a8fb53fa6d699f6834738fa2f220ac783">mlir::affine::MemRefRegion::getRegionSize</a></div><div class="ttdeci">std::optional&lt; int64_t &gt; getRegionSize()</div><div class="ttdoc">Returns the size of this MemRefRegion in bytes.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01345">Utils.cpp:1345</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_aa2761578967822bb7853e072a1a29bac"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#aa2761578967822bb7853e072a1a29bac">mlir::affine::MemRefRegion::unionBoundingBox</a></div><div class="ttdeci">LogicalResult unionBoundingBox(const MemRefRegion &amp;other)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01140">Utils.cpp:1140</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_aaa0de038280a27f97e36f354690dbe15"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#aaa0de038280a27f97e36f354690dbe15">mlir::affine::MemRefRegion::write</a></div><div class="ttdeci">bool write</div><div class="ttdoc">Read or write.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00565">Utils.h:565</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_aafb1611afca2ff34d88c1c89a08c3497"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#aafb1611afca2ff34d88c1c89a08c3497">mlir::affine::MemRefRegion::getConstraints</a></div><div class="ttdeci">const FlatAffineValueConstraints * getConstraints() const</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00528">Utils.h:528</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_ab0382cfe83a9301c5cc63f73a1a1e8d3"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#ab0382cfe83a9301c5cc63f73a1a1e8d3">mlir::affine::MemRefRegion::setWrite</a></div><div class="ttdeci">void setWrite(bool flag)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00530">Utils.h:530</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_ac097fcae970f4cd44eb14f9484deaf43"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#ac097fcae970f4cd44eb14f9484deaf43">mlir::affine::MemRefRegion::memref</a></div><div class="ttdeci">Value memref</div><div class="ttdoc">Memref that this region corresponds to.</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00562">Utils.h:562</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_ac6d5022fc3e167d5e4f2c9e9c116ae39"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#ac6d5022fc3e167d5e4f2c9e9c116ae39">mlir::affine::MemRefRegion::MemRefRegion</a></div><div class="ttdeci">MemRefRegion(Location loc)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00482">Utils.h:482</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_aff8b1c63008105dbed4b81d798babf92"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">mlir::affine::MemRefRegion::loc</a></div><div class="ttdeci">Location loc</div><div class="ttdoc">If there is more than one load/store op associated with the region, the location information would co...</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00569">Utils.h:569</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1SliceComputationResult_html"><div class="ttname"><a href="structmlir_1_1affine_1_1SliceComputationResult.html">mlir::affine::SliceComputationResult</a></div><div class="ttdoc">Enumerates different result statuses of slice computation by computeSliceUnion</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00297">Utils.h:297</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1SliceComputationResult_html_a37a45916fce7b4d2989ae128c037d3ef"><div class="ttname"><a href="structmlir_1_1affine_1_1SliceComputationResult.html#a37a45916fce7b4d2989ae128c037d3ef">mlir::affine::SliceComputationResult::SliceComputationResult</a></div><div class="ttdeci">SliceComputationResult(ResultEnum v)</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00303">Utils.h:303</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1SliceComputationResult_html_a4ee39b3fde28b841ed203728087810e9"><div class="ttname"><a href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9">mlir::affine::SliceComputationResult::ResultEnum</a></div><div class="ttdeci">ResultEnum</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00298">Utils.h:298</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1SliceComputationResult_html_a4ee39b3fde28b841ed203728087810e9a4386b2e4cd401f45247b3ff587a5e4d6"><div class="ttname"><a href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9a4386b2e4cd401f45247b3ff587a5e4d6">mlir::affine::SliceComputationResult::GenericFailure</a></div><div class="ttdeci">@ GenericFailure</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00301">Utils.h:301</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1SliceComputationResult_html_a4ee39b3fde28b841ed203728087810e9aa56e19629619cf1e69cb9f4ec40dcb7c"><div class="ttname"><a href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9aa56e19629619cf1e69cb9f4ec40dcb7c">mlir::affine::SliceComputationResult::IncorrectSliceFailure</a></div><div class="ttdeci">@ IncorrectSliceFailure</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00300">Utils.h:300</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1SliceComputationResult_html_a4ee39b3fde28b841ed203728087810e9aa85f3aac90ad660d5de9933c03cd26ef"><div class="ttname"><a href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9aa85f3aac90ad660d5de9933c03cd26ef">mlir::affine::SliceComputationResult::Success</a></div><div class="ttdeci">@ Success</div><div class="ttdef"><b>Definition:</b> <a href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00299">Utils.h:299</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1SliceComputationResult_html_ae1bf161ba038ce8ed38567be7adba786"><div class="ttname"><a href="structmlir_1_1affine_1_1SliceComputationResult.html#ae1bf161ba038ce8ed38567be7adba786">mlir::affine::SliceComputationResult::value</a></div><div class="ttdeci">enum mlir::affine::SliceComputationResult::ResultEnum value</div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:08 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
