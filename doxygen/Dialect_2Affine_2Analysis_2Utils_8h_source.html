<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: include/mlir/Dialect/Affine/Analysis/Utils.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a href="dir_5654f77406fb9ceec87e68ef828ceea2.html">mlir</a></li><li class="navelem"><a href="dir_d07a6fac82475a065a3b2953573f00a0.html">Dialect</a></li><li class="navelem"><a href="dir_166398e1f0020b3d916a929c669bf538.html">Affine</a></li><li class="navelem"><a href="dir_740c1a08dd185e22adde3d54ecb6f2ad.html">Analysis</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="headertitle"><div class="title">Utils.h</div></div>
</div><!--header-->
<div class="contents">
<a href="Dialect_2Affine_2Analysis_2Utils_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span><span class="comment">//===- Utils.h - General analysis utilities ---------------------*- C++ -*-===//</span></div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="comment">//</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span><span class="comment">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span></div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="comment">// See https://llvm.org/LICENSE.txt for license information.</span></div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span></div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="comment">//</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="comment">//===----------------------------------------------------------------------===//</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span><span class="comment">//</span></div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span><span class="comment">// This header file defines prototypes for various transformation utilities for</span></div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span><span class="comment">// memref&#39;s and non-loop IR structures. These are not passes by themselves but</span></div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span><span class="comment">// are used either by passes, optimization sequences, or in turn by other</span></div>
<div class="line"><a id="l00012" name="l00012"></a><span class="lineno">   12</span><span class="comment">// transformation utilities.</span></div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span><span class="comment">//</span></div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno">   14</span><span class="comment">//===----------------------------------------------------------------------===//</span></div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span> </div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span><span class="preprocessor">#ifndef MLIR_DIALECT_AFFINE_ANALYSIS_UTILS_H</span></div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span><span class="preprocessor">#define MLIR_DIALECT_AFFINE_ANALYSIS_UTILS_H</span></div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span> </div>
<div class="line"><a id="l00019" name="l00019"></a><span class="lineno">   19</span><span class="preprocessor">#include &quot;<a class="code" href="AffineStructures_8h.html">mlir/Dialect/Affine/Analysis/AffineStructures.h</a>&quot;</span></div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span><span class="preprocessor">#include &quot;<a class="code" href="AffineOps_8h.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</span></div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span><span class="preprocessor">#include &lt;optional&gt;</span></div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span> </div>
<div class="line"><a id="l00024" name="l00024"></a><span class="lineno">   24</span><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacemlir.html">mlir</a> {</div>
<div class="line"><a id="l00025" name="l00025"></a><span class="lineno">   25</span><span class="keyword">class </span><a class="code hl_class" href="classmlir_1_1Block.html">Block</a>;</div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span><span class="keyword">class </span><a class="code hl_class" href="classmlir_1_1Location.html">Location</a>;</div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno">   27</span><span class="keyword">class </span><a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a>;</div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span><span class="keyword">class </span><a class="code hl_class" href="classmlir_1_1Value.html">Value</a>;</div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span> </div>
<div class="line"><a id="l00030" name="l00030"></a><span class="lineno">   30</span><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacemlir_1_1affine.html">affine</a> {</div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span><span class="keyword">class </span>AffineForOp;</div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span><span class="keyword">class </span><a class="code hl_class" href="classmlir_1_1affine_1_1AffineValueMap.html">AffineValueMap</a>;</div>
<div class="line"><a id="l00033" name="l00033"></a><span class="lineno">   33</span><span class="keyword">struct </span><a class="code hl_struct" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a>;</div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span> </div>
<div class="line"><a id="l00035" name="l00035"></a><span class="lineno">   35</span><span class="comment">// LoopNestStateCollector walks loop nests and collects load and store</span></div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span><span class="comment">// operations, and whether or not a region holding op other than ForOp and IfOp</span></div>
<div class="line"><a id="l00037" name="l00037"></a><span class="lineno">   37</span><span class="comment">// was encountered in the loop nest.</span></div>
<div class="foldopen" id="foldopen00038" data-start="{" data-end="};">
<div class="line"><a id="l00038" name="l00038"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1LoopNestStateCollector.html">   38</a></span><span class="keyword">struct </span><a class="code hl_struct" href="structmlir_1_1affine_1_1LoopNestStateCollector.html">LoopNestStateCollector</a> {</div>
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a6a9d08cfcdff91c3cb2818daa79b3fbb">   39</a></span>  <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;AffineForOp, 4&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a6a9d08cfcdff91c3cb2818daa79b3fbb">forOps</a>;</div>
<div class="line"><a id="l00040" name="l00040"></a><span class="lineno">   40</span>  <span class="comment">// Affine loads.</span></div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a95f517b1a80923351ab5bd34fefd312c">   41</a></span>  <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a95f517b1a80923351ab5bd34fefd312c">loadOpInsts</a>;</div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span>  <span class="comment">// Affine stores.</span></div>
<div class="line"><a id="l00043" name="l00043"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#ae23767154d778088beab9572db13ddfb">   43</a></span>  <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#ae23767154d778088beab9572db13ddfb">storeOpInsts</a>;</div>
<div class="line"><a id="l00044" name="l00044"></a><span class="lineno">   44</span>  <span class="comment">// Non-affine loads.</span></div>
<div class="line"><a id="l00045" name="l00045"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#adf2391f4ce1e52ffc08a51add68a9b4e">   45</a></span>  <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#adf2391f4ce1e52ffc08a51add68a9b4e">memrefLoads</a>;</div>
<div class="line"><a id="l00046" name="l00046"></a><span class="lineno">   46</span>  <span class="comment">// Non-affine stores.</span></div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#ab1b990940ad78278dd989884d2021cff">   47</a></span>  <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#ab1b990940ad78278dd989884d2021cff">memrefStores</a>;</div>
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno">   48</span>  <span class="comment">// Free operations.</span></div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a4c5255085d6cfdb16bff277d77176bab">   49</a></span>  <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a4c5255085d6cfdb16bff277d77176bab">memrefFrees</a>;</div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span> </div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span>  <span class="comment">// Collects load and store operations, and whether or not a region holding op</span></div>
<div class="line"><a id="l00052" name="l00052"></a><span class="lineno">   52</span>  <span class="comment">// other than ForOp and IfOp was encountered in the loop nest.</span></div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno">   53</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1LoopNestStateCollector.html#ac7e518efde98002ff3fdf5b576205883">collect</a>(<a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *opToWalk);</div>
<div class="line"><a id="l00054" name="l00054"></a><span class="lineno">   54</span>};</div>
</div>
<div class="line"><a id="l00055" name="l00055"></a><span class="lineno">   55</span> </div>
<div class="line"><a id="l00056" name="l00056"></a><span class="lineno">   56</span><span class="comment">// MemRefDependenceGraph is a graph data structure where graph nodes are</span></div>
<div class="line"><a id="l00057" name="l00057"></a><span class="lineno">   57</span><span class="comment">// top-level operations in a `Block` and edges are memref dependences or SSA</span></div>
<div class="line"><a id="l00058" name="l00058"></a><span class="lineno">   58</span><span class="comment">// dependences (on memrefs) between the nodes. Nodes are created for all</span></div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno">   59</span><span class="comment">// top-level operations except in certain cases (see `init` method). Edges are</span></div>
<div class="line"><a id="l00060" name="l00060"></a><span class="lineno">   60</span><span class="comment">// created between nodes with a dependence (see `Edge` documentation). Edges</span></div>
<div class="line"><a id="l00061" name="l00061"></a><span class="lineno">   61</span><span class="comment">// aren&#39;t created from/to nodes that have no memory effects.</span></div>
<div class="foldopen" id="foldopen00062" data-start="{" data-end="};">
<div class="line"><a id="l00062" name="l00062"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">   62</a></span><span class="keyword">struct </span><a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3c63e623ce037ff8c4bce83cf5d214a9">MemRefDependenceGraph</a> {</div>
<div class="line"><a id="l00063" name="l00063"></a><span class="lineno">   63</span><span class="keyword">public</span>:</div>
<div class="line"><a id="l00064" name="l00064"></a><span class="lineno">   64</span>  <span class="comment">// Node represents a node in the graph. A Node is either an entire loop nest</span></div>
<div class="line"><a id="l00065" name="l00065"></a><span class="lineno">   65</span>  <span class="comment">// rooted at the top level which contains loads/stores, or a top level</span></div>
<div class="line"><a id="l00066" name="l00066"></a><span class="lineno">   66</span>  <span class="comment">// load/store.</span></div>
<div class="foldopen" id="foldopen00067" data-start="{" data-end="};">
<div class="line"><a id="l00067" name="l00067"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">   67</a></span>  <span class="keyword">struct </span><a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a43784c742baf090c45dbf791c4194425">Node</a> {</div>
<div class="line"><a id="l00068" name="l00068"></a><span class="lineno">   68</span>    <span class="comment">// The unique identifier of this node in the graph.</span></div>
<div class="line"><a id="l00069" name="l00069"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a830ea36bccf2332f1a9aea7e09bef2f0">   69</a></span>    <span class="keywordtype">unsigned</span> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a830ea36bccf2332f1a9aea7e09bef2f0">id</a>;</div>
<div class="line"><a id="l00070" name="l00070"></a><span class="lineno">   70</span>    <span class="comment">// The top-level statement which is (or contains) a load/store.</span></div>
<div class="line"><a id="l00071" name="l00071"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#ab79054c161b7323e14e56f00d1d38fa0">   71</a></span>    <a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *<a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#ab79054c161b7323e14e56f00d1d38fa0">op</a>;</div>
<div class="line"><a id="l00072" name="l00072"></a><span class="lineno">   72</span>    <span class="comment">// List of affine loads.</span></div>
<div class="line"><a id="l00073" name="l00073"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a1443947aa4f1a5ba044f9bfbc364e353">   73</a></span>    <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a1443947aa4f1a5ba044f9bfbc364e353">loads</a>;</div>
<div class="line"><a id="l00074" name="l00074"></a><span class="lineno">   74</span>    <span class="comment">// List of non-affine loads.</span></div>
<div class="line"><a id="l00075" name="l00075"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a5ab56168ea32478165badb63843a0839">   75</a></span>    <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a5ab56168ea32478165badb63843a0839">memrefLoads</a>;</div>
<div class="line"><a id="l00076" name="l00076"></a><span class="lineno">   76</span>    <span class="comment">// List of affine store ops.</span></div>
<div class="line"><a id="l00077" name="l00077"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a1d9d97fe37cf42792d796beeffb182db">   77</a></span>    <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a1d9d97fe37cf42792d796beeffb182db">stores</a>;</div>
<div class="line"><a id="l00078" name="l00078"></a><span class="lineno">   78</span>    <span class="comment">// List of non-affine stores.</span></div>
<div class="line"><a id="l00079" name="l00079"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a678f66b993583d391ec12d1eaca5c168">   79</a></span>    <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a678f66b993583d391ec12d1eaca5c168">memrefStores</a>;</div>
<div class="line"><a id="l00080" name="l00080"></a><span class="lineno">   80</span>    <span class="comment">// List of free operations.</span></div>
<div class="line"><a id="l00081" name="l00081"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#afe5e17bd9cb80f70609ec127e9ce6d43">   81</a></span>    <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;Operation *, 4&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#afe5e17bd9cb80f70609ec127e9ce6d43">memrefFrees</a>;</div>
<div class="line"><a id="l00082" name="l00082"></a><span class="lineno">   82</span>    <span class="comment">// Set of private memrefs used in this node.</span></div>
<div class="line"><a id="l00083" name="l00083"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a73ec40eb1f5ef361ab49dbdcca2126f1">   83</a></span>    <a class="code hl_typedef" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet&lt;Value&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a73ec40eb1f5ef361ab49dbdcca2126f1">privateMemrefs</a>;</div>
<div class="line"><a id="l00084" name="l00084"></a><span class="lineno">   84</span> </div>
<div class="line"><a id="l00085" name="l00085"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a43784c742baf090c45dbf791c4194425">   85</a></span>    <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a43784c742baf090c45dbf791c4194425">Node</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>, <a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *<a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#ab79054c161b7323e14e56f00d1d38fa0">op</a>) : <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a830ea36bccf2332f1a9aea7e09bef2f0">id</a>(<a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a830ea36bccf2332f1a9aea7e09bef2f0">id</a>), <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#ab79054c161b7323e14e56f00d1d38fa0">op</a>(<a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#ab79054c161b7323e14e56f00d1d38fa0">op</a>) {}</div>
<div class="line"><a id="l00086" name="l00086"></a><span class="lineno">   86</span> </div>
<div class="line"><a id="l00087" name="l00087"></a><span class="lineno">   87</span>    <span class="comment">// Returns the load op count for &#39;memref&#39;.</span></div>
<div class="line"><a id="l00088" name="l00088"></a><span class="lineno">   88</span>    <span class="keywordtype">unsigned</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a77267e6959542952eb88324ac501186a">getLoadOpCount</a>(<a class="code hl_class" href="classmlir_1_1Value.html">Value</a> <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00089" name="l00089"></a><span class="lineno">   89</span> </div>
<div class="line"><a id="l00090" name="l00090"></a><span class="lineno">   90</span>    <span class="comment">// Returns the store op count for &#39;memref&#39;.</span></div>
<div class="line"><a id="l00091" name="l00091"></a><span class="lineno">   91</span>    <span class="keywordtype">unsigned</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a7dcff2c5bf014d3ae42f78780ce15786">getStoreOpCount</a>(<a class="code hl_class" href="classmlir_1_1Value.html">Value</a> <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00092" name="l00092"></a><span class="lineno">   92</span><span class="comment"></span> </div>
<div class="line"><a id="l00093" name="l00093"></a><span class="lineno">   93</span><span class="comment">    /// Returns true if there exists an operation with a write memory effect to</span></div>
<div class="line"><a id="l00094" name="l00094"></a><span class="lineno">   94</span><span class="comment">    /// `memref` in this node.</span></div>
<div class="line"><a id="l00095" name="l00095"></a><span class="lineno">   95</span>    <span class="keywordtype">unsigned</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a866114f24f1c3e927c47c87a38843a53">hasStore</a>(<a class="code hl_class" href="classmlir_1_1Value.html">Value</a> <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00096" name="l00096"></a><span class="lineno">   96</span> </div>
<div class="line"><a id="l00097" name="l00097"></a><span class="lineno">   97</span>    <span class="comment">// Returns true if the node has a free op on `memref`.</span></div>
<div class="line"><a id="l00098" name="l00098"></a><span class="lineno">   98</span>    <span class="keywordtype">unsigned</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a49e4fae512d8dd3f049672634d5edd80">hasFree</a>(<a class="code hl_class" href="classmlir_1_1Value.html">Value</a> <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00099" name="l00099"></a><span class="lineno">   99</span> </div>
<div class="line"><a id="l00100" name="l00100"></a><span class="lineno">  100</span>    <span class="comment">// Returns all store ops in &#39;storeOps&#39; which access &#39;memref&#39;.</span></div>
<div class="line"><a id="l00101" name="l00101"></a><span class="lineno">  101</span>    <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a0d3aa9a9ed278fe81689d73d07033b29">getStoreOpsForMemref</a>(<a class="code hl_class" href="classmlir_1_1Value.html">Value</a> <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>,</div>
<div class="line"><a id="l00102" name="l00102"></a><span class="lineno">  102</span>                              <a class="code hl_class" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Operation *&gt;</a> *storeOps) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00103" name="l00103"></a><span class="lineno">  103</span> </div>
<div class="line"><a id="l00104" name="l00104"></a><span class="lineno">  104</span>    <span class="comment">// Returns all load ops in &#39;loadOps&#39; which access &#39;memref&#39;.</span></div>
<div class="line"><a id="l00105" name="l00105"></a><span class="lineno">  105</span>    <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#ac9d40b81f36159a323d3a56d60b6bbea">getLoadOpsForMemref</a>(<a class="code hl_class" href="classmlir_1_1Value.html">Value</a> <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>,</div>
<div class="line"><a id="l00106" name="l00106"></a><span class="lineno">  106</span>                             <a class="code hl_class" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Operation *&gt;</a> *loadOps) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00107" name="l00107"></a><span class="lineno">  107</span> </div>
<div class="line"><a id="l00108" name="l00108"></a><span class="lineno">  108</span>    <span class="comment">// Returns all memrefs in &#39;loadAndStoreMemrefSet&#39; for which this node</span></div>
<div class="line"><a id="l00109" name="l00109"></a><span class="lineno">  109</span>    <span class="comment">// has at least one load and store operation.</span></div>
<div class="line"><a id="l00110" name="l00110"></a><span class="lineno">  110</span>    <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a3b5c1cad1b7c6f2b8091bb7f12d29162">getLoadAndStoreMemrefSet</a>(<a class="code hl_typedef" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet&lt;Value&gt;</a> *loadAndStoreMemrefSet) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00111" name="l00111"></a><span class="lineno">  111</span>  };</div>
</div>
<div class="line"><a id="l00112" name="l00112"></a><span class="lineno">  112</span> </div>
<div class="line"><a id="l00113" name="l00113"></a><span class="lineno">  113</span>  <span class="comment">// Edge represents a data dependence between nodes in the graph. It can either</span></div>
<div class="line"><a id="l00114" name="l00114"></a><span class="lineno">  114</span>  <span class="comment">// be a memory dependence or an SSA dependence. In the former case, it</span></div>
<div class="line"><a id="l00115" name="l00115"></a><span class="lineno">  115</span>  <span class="comment">// corresponds to a pair of memory accesses to the same memref or aliasing</span></div>
<div class="line"><a id="l00116" name="l00116"></a><span class="lineno">  116</span>  <span class="comment">// memrefs where at least one of them has a write or free memory effect. The</span></div>
<div class="line"><a id="l00117" name="l00117"></a><span class="lineno">  117</span>  <span class="comment">// memory accesses need not be affine load/store operations. Operations are</span></div>
<div class="line"><a id="l00118" name="l00118"></a><span class="lineno">  118</span>  <span class="comment">// checked for read/write effects and edges may be added conservatively. Edges</span></div>
<div class="line"><a id="l00119" name="l00119"></a><span class="lineno">  119</span>  <span class="comment">// are not created to/from nodes that have no memory effect. An exception to</span></div>
<div class="line"><a id="l00120" name="l00120"></a><span class="lineno">  120</span>  <span class="comment">// this are SSA dependences between operations that define memrefs (like</span></div>
<div class="line"><a id="l00121" name="l00121"></a><span class="lineno">  121</span>  <span class="comment">// alloc&#39;s, view-like ops) and their memory-effecting users that are enclosed</span></div>
<div class="line"><a id="l00122" name="l00122"></a><span class="lineno">  122</span>  <span class="comment">// in loops.</span></div>
<div class="foldopen" id="foldopen00123" data-start="{" data-end="};">
<div class="line"><a id="l00123" name="l00123"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html">  123</a></span>  <span class="keyword">struct </span><a class="code hl_struct" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html">Edge</a> {</div>
<div class="line"><a id="l00124" name="l00124"></a><span class="lineno">  124</span>    <span class="comment">// The id of the node at the other end of the edge.</span></div>
<div class="line"><a id="l00125" name="l00125"></a><span class="lineno">  125</span>    <span class="comment">// If this edge is stored in Edge = Node.inEdges[i], then</span></div>
<div class="line"><a id="l00126" name="l00126"></a><span class="lineno">  126</span>    <span class="comment">// &#39;Node.inEdges[i].id&#39; is the identifier of the source node of the edge.</span></div>
<div class="line"><a id="l00127" name="l00127"></a><span class="lineno">  127</span>    <span class="comment">// If this edge is stored in Edge = Node.outEdges[i], then</span></div>
<div class="line"><a id="l00128" name="l00128"></a><span class="lineno">  128</span>    <span class="comment">// &#39;Node.outEdges[i].id&#39; is the identifier of the dest node of the edge.</span></div>
<div class="line"><a id="l00129" name="l00129"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html#ace11f0021945bfc712786e04e2f1101d">  129</a></span>    <span class="keywordtype">unsigned</span> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html#ace11f0021945bfc712786e04e2f1101d">id</a>;</div>
<div class="line"><a id="l00130" name="l00130"></a><span class="lineno">  130</span>    <span class="comment">// The SSA value on which this edge represents a dependence.</span></div>
<div class="line"><a id="l00131" name="l00131"></a><span class="lineno">  131</span>    <span class="comment">// If the value is a memref, then the dependence is between graph nodes</span></div>
<div class="line"><a id="l00132" name="l00132"></a><span class="lineno">  132</span>    <span class="comment">// which contain accesses to the same memref &#39;value&#39;. If the value is a</span></div>
<div class="line"><a id="l00133" name="l00133"></a><span class="lineno">  133</span>    <span class="comment">// non-memref value, then the dependence is between a graph node which</span></div>
<div class="line"><a id="l00134" name="l00134"></a><span class="lineno">  134</span>    <span class="comment">// defines an SSA value and another graph node which uses the SSA value</span></div>
<div class="line"><a id="l00135" name="l00135"></a><span class="lineno">  135</span>    <span class="comment">// (e.g. a constant or load operation defining a value which is used inside</span></div>
<div class="line"><a id="l00136" name="l00136"></a><span class="lineno">  136</span>    <span class="comment">// a loop nest).</span></div>
<div class="line"><a id="l00137" name="l00137"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html#aa2928d335ef67abb4dd9f225fbe7eca5">  137</a></span>    <a class="code hl_class" href="classmlir_1_1Value.html">Value</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html#aa2928d335ef67abb4dd9f225fbe7eca5">value</a>;</div>
<div class="line"><a id="l00138" name="l00138"></a><span class="lineno">  138</span>  };</div>
</div>
<div class="line"><a id="l00139" name="l00139"></a><span class="lineno">  139</span> </div>
<div class="line"><a id="l00140" name="l00140"></a><span class="lineno">  140</span>  <span class="comment">// Map from node id to Node.</span></div>
<div class="line"><a id="l00141" name="l00141"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3df572ea465683f6b1f0e4dcd9f9b42f">  141</a></span>  <a class="code hl_typedef" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap&lt;unsigned, Node&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3df572ea465683f6b1f0e4dcd9f9b42f">nodes</a>;</div>
<div class="line"><a id="l00142" name="l00142"></a><span class="lineno">  142</span>  <span class="comment">// Map from node id to list of input edges. The absence of an entry for a key</span></div>
<div class="line"><a id="l00143" name="l00143"></a><span class="lineno">  143</span>  <span class="comment">// is also equivalent to the absence of any edges.</span></div>
<div class="line"><a id="l00144" name="l00144"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a6c0fadb723818174fe2e60709e761918">  144</a></span>  <a class="code hl_typedef" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap&lt;unsigned, SmallVector&lt;Edge, 2&gt;</a>&gt; <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a6c0fadb723818174fe2e60709e761918">inEdges</a>;</div>
<div class="line"><a id="l00145" name="l00145"></a><span class="lineno">  145</span>  <span class="comment">// Map from node id to list of output edges. The absence of an entry for a</span></div>
<div class="line"><a id="l00146" name="l00146"></a><span class="lineno">  146</span>  <span class="comment">// node is also equivalent to the absence of any edges.</span></div>
<div class="line"><a id="l00147" name="l00147"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a01d186fd0b75b108fce1ad9dd27e3630">  147</a></span>  <a class="code hl_typedef" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap&lt;unsigned, SmallVector&lt;Edge, 2&gt;</a>&gt; <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a01d186fd0b75b108fce1ad9dd27e3630">outEdges</a>;</div>
<div class="line"><a id="l00148" name="l00148"></a><span class="lineno">  148</span>  <span class="comment">// Map from memref to a count on the dependence edges associated with that</span></div>
<div class="line"><a id="l00149" name="l00149"></a><span class="lineno">  149</span>  <span class="comment">// memref.</span></div>
<div class="line"><a id="l00150" name="l00150"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#afb1cdc99d9633c920e02a9a8975fdd41">  150</a></span>  <a class="code hl_typedef" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap&lt;Value, unsigned&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#afb1cdc99d9633c920e02a9a8975fdd41">memrefEdgeCount</a>;</div>
<div class="line"><a id="l00151" name="l00151"></a><span class="lineno">  151</span>  <span class="comment">// The next unique identifier to use for newly created graph nodes.</span></div>
<div class="line"><a id="l00152" name="l00152"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a345e759cabd082ca094c6315f1104a8b">  152</a></span>  <span class="keywordtype">unsigned</span> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a345e759cabd082ca094c6315f1104a8b">nextNodeId</a> = 0;</div>
<div class="line"><a id="l00153" name="l00153"></a><span class="lineno">  153</span> </div>
<div class="line"><a id="l00154" name="l00154"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3c63e623ce037ff8c4bce83cf5d214a9">  154</a></span>  <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3c63e623ce037ff8c4bce83cf5d214a9">MemRefDependenceGraph</a>(<a class="code hl_class" href="classmlir_1_1Block.html">Block</a> &amp;<a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a033d58b8880a8b8bf188abaa803275f0">block</a>) : <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a033d58b8880a8b8bf188abaa803275f0">block</a>(<a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a033d58b8880a8b8bf188abaa803275f0">block</a>) {}</div>
<div class="line"><a id="l00155" name="l00155"></a><span class="lineno">  155</span> </div>
<div class="line"><a id="l00156" name="l00156"></a><span class="lineno">  156</span>  <span class="comment">// Initializes the data dependence graph by iterating over the operations of</span></div>
<div class="line"><a id="l00157" name="l00157"></a><span class="lineno">  157</span>  <span class="comment">// the MDG&#39;s `block`. A `Node` is created for every top-level op except for</span></div>
<div class="line"><a id="l00158" name="l00158"></a><span class="lineno">  158</span>  <span class="comment">// side-effect-free operations with zero results and no regions. Assigns each</span></div>
<div class="line"><a id="l00159" name="l00159"></a><span class="lineno">  159</span>  <span class="comment">// node in the graph a node id based on the order in block. Fails if certain</span></div>
<div class="line"><a id="l00160" name="l00160"></a><span class="lineno">  160</span>  <span class="comment">// kinds of operations, for which `Node` creation isn&#39;t supported, are</span></div>
<div class="line"><a id="l00161" name="l00161"></a><span class="lineno">  161</span>  <span class="comment">// encountered (unknown region holding ops). If `fullAffineDependences` is</span></div>
<div class="line"><a id="l00162" name="l00162"></a><span class="lineno">  162</span>  <span class="comment">// set, affine memory dependence analysis is performed before concluding that</span></div>
<div class="line"><a id="l00163" name="l00163"></a><span class="lineno">  163</span>  <span class="comment">// conflicting affine memory accesses lead to a dependence check; otherwise, a</span></div>
<div class="line"><a id="l00164" name="l00164"></a><span class="lineno">  164</span>  <span class="comment">// pair of conflicting affine memory accesses (where one of them is a store</span></div>
<div class="line"><a id="l00165" name="l00165"></a><span class="lineno">  165</span>  <span class="comment">// and they are to the same memref) always leads to an edge (conservatively).</span></div>
<div class="line"><a id="l00166" name="l00166"></a><span class="lineno">  166</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a8f53c72d7d11724c7213beb168550f69">init</a>(<span class="keywordtype">bool</span> fullAffineDependences = <span class="keyword">true</span>);</div>
<div class="line"><a id="l00167" name="l00167"></a><span class="lineno">  167</span> </div>
<div class="line"><a id="l00168" name="l00168"></a><span class="lineno">  168</span>  <span class="comment">// Returns the graph node for &#39;id&#39;.</span></div>
<div class="line"><a id="l00169" name="l00169"></a><span class="lineno">  169</span>  <span class="keyword">const</span> Node *<a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a9ecf883f82ba5105ab012804d98994f5">getNode</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>) <span class="keyword">const</span>;</div>
<div class="foldopen" id="foldopen00170" data-start="{" data-end="}">
<div class="line"><a id="l00170" name="l00170"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a044e8c2c285b222c732ffe12a0ba2820">  170</a></span>  <a class="code hl_struct" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">Node</a> *<a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a044e8c2c285b222c732ffe12a0ba2820">getNode</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>) {</div>
<div class="line"><a id="l00171" name="l00171"></a><span class="lineno">  171</span>    <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><a class="code hl_struct" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">Node</a> *<span class="keyword">&gt;</span>(</div>
<div class="line"><a id="l00172" name="l00172"></a><span class="lineno">  172</span>        <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3c63e623ce037ff8c4bce83cf5d214a9">MemRefDependenceGraph</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;getNode(<span class="keywordtype">id</span>));</div>
<div class="line"><a id="l00173" name="l00173"></a><span class="lineno">  173</span>  }</div>
</div>
<div class="line"><a id="l00174" name="l00174"></a><span class="lineno">  174</span> </div>
<div class="line"><a id="l00175" name="l00175"></a><span class="lineno">  175</span>  <span class="comment">// Returns true if the graph has node with ID `id`.</span></div>
<div class="line"><a id="l00176" name="l00176"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a657659a854921a4dd67b0657556f0a7c">  176</a></span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a657659a854921a4dd67b0657556f0a7c">hasNode</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3df572ea465683f6b1f0e4dcd9f9b42f">nodes</a>.contains(<span class="keywordtype">id</span>); }</div>
<div class="line"><a id="l00177" name="l00177"></a><span class="lineno">  177</span> </div>
<div class="line"><a id="l00178" name="l00178"></a><span class="lineno">  178</span>  <span class="comment">// Returns the graph node for &#39;forOp&#39;.</span></div>
<div class="line"><a id="l00179" name="l00179"></a><span class="lineno">  179</span>  <span class="keyword">const</span> Node *<a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a60e1b52dd56f3d099d5899568293b218">getForOpNode</a>(AffineForOp forOp) <span class="keyword">const</span>;</div>
<div class="foldopen" id="foldopen00180" data-start="{" data-end="}">
<div class="line"><a id="l00180" name="l00180"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a790085bc35e36d40045748ca863ec470">  180</a></span>  <a class="code hl_struct" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">Node</a> *<a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a790085bc35e36d40045748ca863ec470">getForOpNode</a>(AffineForOp forOp) {</div>
<div class="line"><a id="l00181" name="l00181"></a><span class="lineno">  181</span>    <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><a class="code hl_struct" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">Node</a> *<span class="keyword">&gt;</span>(</div>
<div class="line"><a id="l00182" name="l00182"></a><span class="lineno">  182</span>        <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3c63e623ce037ff8c4bce83cf5d214a9">MemRefDependenceGraph</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;getForOpNode(forOp));</div>
<div class="line"><a id="l00183" name="l00183"></a><span class="lineno">  183</span>  }</div>
</div>
<div class="line"><a id="l00184" name="l00184"></a><span class="lineno">  184</span> </div>
<div class="line"><a id="l00185" name="l00185"></a><span class="lineno">  185</span>  <span class="comment">// Adds a node with &#39;op&#39; to the graph and returns its unique identifier.</span></div>
<div class="line"><a id="l00186" name="l00186"></a><span class="lineno">  186</span>  <span class="keywordtype">unsigned</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a09cdaeb6db292ca36bfa6a57c2a1bf27">addNode</a>(<a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *op);</div>
<div class="line"><a id="l00187" name="l00187"></a><span class="lineno">  187</span> </div>
<div class="line"><a id="l00188" name="l00188"></a><span class="lineno">  188</span>  <span class="comment">// Remove node &#39;id&#39; (and its associated edges) from graph.</span></div>
<div class="line"><a id="l00189" name="l00189"></a><span class="lineno">  189</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aa65f5209124219ebb4a86fcedb629850">removeNode</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>);</div>
<div class="line"><a id="l00190" name="l00190"></a><span class="lineno">  190</span> </div>
<div class="line"><a id="l00191" name="l00191"></a><span class="lineno">  191</span>  <span class="comment">// Returns true if node &#39;id&#39; writes to any memref which escapes (or is an</span></div>
<div class="line"><a id="l00192" name="l00192"></a><span class="lineno">  192</span>  <span class="comment">// argument to) the block. Returns false otherwise.</span></div>
<div class="line"><a id="l00193" name="l00193"></a><span class="lineno">  193</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a0ed9f30da3f99f63db2d0a18b23a7562">writesToLiveInOrEscapingMemrefs</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00194" name="l00194"></a><span class="lineno">  194</span> </div>
<div class="line"><a id="l00195" name="l00195"></a><span class="lineno">  195</span>  <span class="comment">// Returns true iff there is an edge from node &#39;srcId&#39; to node &#39;dstId&#39; which</span></div>
<div class="line"><a id="l00196" name="l00196"></a><span class="lineno">  196</span>  <span class="comment">// is for &#39;value&#39; if non-null, or for any value otherwise. Returns false</span></div>
<div class="line"><a id="l00197" name="l00197"></a><span class="lineno">  197</span>  <span class="comment">// otherwise.</span></div>
<div class="line"><a id="l00198" name="l00198"></a><span class="lineno">  198</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#ae3bdae51f114698511aa7be4b3133880">hasEdge</a>(<span class="keywordtype">unsigned</span> srcId, <span class="keywordtype">unsigned</span> dstId, <a class="code hl_class" href="classmlir_1_1Value.html">Value</a> value = <span class="keyword">nullptr</span>) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00199" name="l00199"></a><span class="lineno">  199</span> </div>
<div class="line"><a id="l00200" name="l00200"></a><span class="lineno">  200</span>  <span class="comment">// Adds an edge from node &#39;srcId&#39; to node &#39;dstId&#39; for &#39;value&#39;.</span></div>
<div class="line"><a id="l00201" name="l00201"></a><span class="lineno">  201</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a2426d1416444660e2a965499b9558f2e">addEdge</a>(<span class="keywordtype">unsigned</span> srcId, <span class="keywordtype">unsigned</span> dstId, <a class="code hl_class" href="classmlir_1_1Value.html">Value</a> value);</div>
<div class="line"><a id="l00202" name="l00202"></a><span class="lineno">  202</span> </div>
<div class="line"><a id="l00203" name="l00203"></a><span class="lineno">  203</span>  <span class="comment">// Removes an edge from node &#39;srcId&#39; to node &#39;dstId&#39; for &#39;value&#39;.</span></div>
<div class="line"><a id="l00204" name="l00204"></a><span class="lineno">  204</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a19787b209c503c45e6dff3d8a975d123">removeEdge</a>(<span class="keywordtype">unsigned</span> srcId, <span class="keywordtype">unsigned</span> dstId, <a class="code hl_class" href="classmlir_1_1Value.html">Value</a> value);</div>
<div class="line"><a id="l00205" name="l00205"></a><span class="lineno">  205</span> </div>
<div class="line"><a id="l00206" name="l00206"></a><span class="lineno">  206</span>  <span class="comment">// Returns true if there is a path in the dependence graph from node &#39;srcId&#39;</span></div>
<div class="line"><a id="l00207" name="l00207"></a><span class="lineno">  207</span>  <span class="comment">// to node &#39;dstId&#39;. Returns false otherwise. `srcId`, `dstId`, and the</span></div>
<div class="line"><a id="l00208" name="l00208"></a><span class="lineno">  208</span>  <span class="comment">// operations that the edges connected are expected to be from the same block.</span></div>
<div class="line"><a id="l00209" name="l00209"></a><span class="lineno">  209</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a45510d99234261290bf188a3108387cd">hasDependencePath</a>(<span class="keywordtype">unsigned</span> srcId, <span class="keywordtype">unsigned</span> dstId) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00210" name="l00210"></a><span class="lineno">  210</span> </div>
<div class="line"><a id="l00211" name="l00211"></a><span class="lineno">  211</span>  <span class="comment">// Returns the input edge count for node &#39;id&#39; and &#39;memref&#39; from src nodes</span></div>
<div class="line"><a id="l00212" name="l00212"></a><span class="lineno">  212</span>  <span class="comment">// which access &#39;memref&#39; with a store operation.</span></div>
<div class="line"><a id="l00213" name="l00213"></a><span class="lineno">  213</span>  <span class="keywordtype">unsigned</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aded491cadebd6d0969d23f80cb0ef475">getIncomingMemRefAccesses</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>, <a class="code hl_class" href="classmlir_1_1Value.html">Value</a> <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00214" name="l00214"></a><span class="lineno">  214</span> </div>
<div class="line"><a id="l00215" name="l00215"></a><span class="lineno">  215</span>  <span class="comment">// Returns the output edge count for node &#39;id&#39; and &#39;memref&#39; (if non-null),</span></div>
<div class="line"><a id="l00216" name="l00216"></a><span class="lineno">  216</span>  <span class="comment">// otherwise returns the total output edge count from node &#39;id&#39;.</span></div>
<div class="line"><a id="l00217" name="l00217"></a><span class="lineno">  217</span>  <span class="keywordtype">unsigned</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a996bade25457fbc32567f4b47ae18f3f">getOutEdgeCount</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>, <a class="code hl_class" href="classmlir_1_1Value.html">Value</a> <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a> = <span class="keyword">nullptr</span>) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00218" name="l00218"></a><span class="lineno">  218</span><span class="comment"></span> </div>
<div class="line"><a id="l00219" name="l00219"></a><span class="lineno">  219</span><span class="comment">  /// Return all nodes which define SSA values used in node &#39;id&#39;.</span></div>
<div class="line"><a id="l00220" name="l00220"></a><span class="lineno">  220</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a437652354edafa39b0546fe0a60e9071">gatherDefiningNodes</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>,</div>
<div class="line"><a id="l00221" name="l00221"></a><span class="lineno">  221</span>                           <a class="code hl_typedef" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet&lt;unsigned&gt;</a> &amp;definingNodes) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00222" name="l00222"></a><span class="lineno">  222</span> </div>
<div class="line"><a id="l00223" name="l00223"></a><span class="lineno">  223</span>  <span class="comment">// Computes and returns an insertion point operation, before which the</span></div>
<div class="line"><a id="l00224" name="l00224"></a><span class="lineno">  224</span>  <span class="comment">// the fused &lt;srcId, dstId&gt; loop nest can be inserted while preserving</span></div>
<div class="line"><a id="l00225" name="l00225"></a><span class="lineno">  225</span>  <span class="comment">// dependences. Returns nullptr if no such insertion point is found.</span></div>
<div class="line"><a id="l00226" name="l00226"></a><span class="lineno">  226</span>  <a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *<a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a61ca2d2048e49f64711b86f5746f0081">getFusedLoopNestInsertionPoint</a>(<span class="keywordtype">unsigned</span> srcId,</div>
<div class="line"><a id="l00227" name="l00227"></a><span class="lineno">  227</span>                                            <span class="keywordtype">unsigned</span> dstId) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00228" name="l00228"></a><span class="lineno">  228</span> </div>
<div class="line"><a id="l00229" name="l00229"></a><span class="lineno">  229</span>  <span class="comment">// Updates edge mappings from node &#39;srcId&#39; to node &#39;dstId&#39; after fusing them,</span></div>
<div class="line"><a id="l00230" name="l00230"></a><span class="lineno">  230</span>  <span class="comment">// taking into account that:</span></div>
<div class="line"><a id="l00231" name="l00231"></a><span class="lineno">  231</span>  <span class="comment">//   *) if &#39;removeSrcId&#39; is true, &#39;srcId&#39; will be removed after fusion,</span></div>
<div class="line"><a id="l00232" name="l00232"></a><span class="lineno">  232</span>  <span class="comment">//   *) memrefs in &#39;privateMemRefs&#39; has been replaced in node at &#39;dstId&#39; by a</span></div>
<div class="line"><a id="l00233" name="l00233"></a><span class="lineno">  233</span>  <span class="comment">//      private memref.</span></div>
<div class="line"><a id="l00234" name="l00234"></a><span class="lineno">  234</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a650542cbe4a3a8ed5cef0ad22bf2f39a">updateEdges</a>(<span class="keywordtype">unsigned</span> srcId, <span class="keywordtype">unsigned</span> dstId,</div>
<div class="line"><a id="l00235" name="l00235"></a><span class="lineno">  235</span>                   <span class="keyword">const</span> <a class="code hl_typedef" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet&lt;Value&gt;</a> &amp;privateMemRefs, <span class="keywordtype">bool</span> removeSrcId);</div>
<div class="line"><a id="l00236" name="l00236"></a><span class="lineno">  236</span> </div>
<div class="line"><a id="l00237" name="l00237"></a><span class="lineno">  237</span>  <span class="comment">// Update edge mappings for nodes &#39;sibId&#39; and &#39;dstId&#39; to reflect fusion</span></div>
<div class="line"><a id="l00238" name="l00238"></a><span class="lineno">  238</span>  <span class="comment">// of sibling node &#39;sibId&#39; into node &#39;dstId&#39;.</span></div>
<div class="line"><a id="l00239" name="l00239"></a><span class="lineno">  239</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a650542cbe4a3a8ed5cef0ad22bf2f39a">updateEdges</a>(<span class="keywordtype">unsigned</span> sibId, <span class="keywordtype">unsigned</span> dstId);</div>
<div class="line"><a id="l00240" name="l00240"></a><span class="lineno">  240</span> </div>
<div class="line"><a id="l00241" name="l00241"></a><span class="lineno">  241</span>  <span class="comment">// Adds the specified ops to lists of node at &#39;id&#39;.</span></div>
<div class="line"><a id="l00242" name="l00242"></a><span class="lineno">  242</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#abe5db0c6c3108f9e233ad68ee134e496">addToNode</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>, <a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Operation *&gt;</a> loads,</div>
<div class="line"><a id="l00243" name="l00243"></a><span class="lineno">  243</span>                 <a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Operation *&gt;</a> stores,</div>
<div class="line"><a id="l00244" name="l00244"></a><span class="lineno">  244</span>                 <a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Operation *&gt;</a> memrefLoads,</div>
<div class="line"><a id="l00245" name="l00245"></a><span class="lineno">  245</span>                 <a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Operation *&gt;</a> memrefStores,</div>
<div class="line"><a id="l00246" name="l00246"></a><span class="lineno">  246</span>                 <a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Operation *&gt;</a> memrefFrees);</div>
<div class="line"><a id="l00247" name="l00247"></a><span class="lineno">  247</span> </div>
<div class="line"><a id="l00248" name="l00248"></a><span class="lineno">  248</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a55a81e7e71f3511a8babe8c8535393f1">clearNodeLoadAndStores</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>);</div>
<div class="line"><a id="l00249" name="l00249"></a><span class="lineno">  249</span> </div>
<div class="line"><a id="l00250" name="l00250"></a><span class="lineno">  250</span>  <span class="comment">// Calls &#39;callback&#39; for each input edge incident to node &#39;id&#39; which carries a</span></div>
<div class="line"><a id="l00251" name="l00251"></a><span class="lineno">  251</span>  <span class="comment">// memref dependence.</span></div>
<div class="line"><a id="l00252" name="l00252"></a><span class="lineno">  252</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a83ce0d42a3715e3d152f87ec4437c56e">forEachMemRefInputEdge</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>,</div>
<div class="line"><a id="l00253" name="l00253"></a><span class="lineno">  253</span>                              <span class="keyword">const</span> std::function&lt;<span class="keywordtype">void</span>(Edge)&gt; &amp;callback);</div>
<div class="line"><a id="l00254" name="l00254"></a><span class="lineno">  254</span> </div>
<div class="line"><a id="l00255" name="l00255"></a><span class="lineno">  255</span>  <span class="comment">// Calls &#39;callback&#39; for each output edge from node &#39;id&#39; which carries a</span></div>
<div class="line"><a id="l00256" name="l00256"></a><span class="lineno">  256</span>  <span class="comment">// memref dependence.</span></div>
<div class="line"><a id="l00257" name="l00257"></a><span class="lineno">  257</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aaeb96e8d972edf0793f628b700743c52">forEachMemRefOutputEdge</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>,</div>
<div class="line"><a id="l00258" name="l00258"></a><span class="lineno">  258</span>                               <span class="keyword">const</span> std::function&lt;<span class="keywordtype">void</span>(Edge)&gt; &amp;callback);</div>
<div class="line"><a id="l00259" name="l00259"></a><span class="lineno">  259</span> </div>
<div class="line"><a id="l00260" name="l00260"></a><span class="lineno">  260</span>  <span class="comment">// Calls &#39;callback&#39; for each edge in &#39;edges&#39; which carries a memref</span></div>
<div class="line"><a id="l00261" name="l00261"></a><span class="lineno">  261</span>  <span class="comment">// dependence.</span></div>
<div class="line"><a id="l00262" name="l00262"></a><span class="lineno">  262</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#ab8c546bd37ebde1870dfd51b66080974">forEachMemRefEdge</a>(<a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Edge&gt;</a> edges,</div>
<div class="line"><a id="l00263" name="l00263"></a><span class="lineno">  263</span>                         <span class="keyword">const</span> std::function&lt;<span class="keywordtype">void</span>(Edge)&gt; &amp;callback);</div>
<div class="line"><a id="l00264" name="l00264"></a><span class="lineno">  264</span> </div>
<div class="line"><a id="l00265" name="l00265"></a><span class="lineno">  265</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#af0240c7ff60660612bd78f98bff995e4">print</a>(<a class="code hl_class" href="classmlir_1_1raw__ostream.html">raw_ostream</a> &amp;os) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00266" name="l00266"></a><span class="lineno">  266</span> </div>
<div class="line"><a id="l00267" name="l00267"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aee33c4c116b0fceb1dc3ec2114d0916b">  267</a></span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aee33c4c116b0fceb1dc3ec2114d0916b">dump</a>()<span class="keyword"> const </span>{ <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#af0240c7ff60660612bd78f98bff995e4">print</a>(llvm::errs()); }</div>
<div class="line"><a id="l00268" name="l00268"></a><span class="lineno">  268</span><span class="comment"></span> </div>
<div class="line"><a id="l00269" name="l00269"></a><span class="lineno">  269</span><span class="comment">  /// The block for which this graph is created to perform fusion.</span></div>
<div class="line"><a id="l00270" name="l00270"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a033d58b8880a8b8bf188abaa803275f0">  270</a></span>  <a class="code hl_class" href="classmlir_1_1Block.html">Block</a> &amp;<a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a033d58b8880a8b8bf188abaa803275f0">block</a>;</div>
<div class="line"><a id="l00271" name="l00271"></a><span class="lineno">  271</span>};</div>
</div>
<div class="line"><a id="l00272" name="l00272"></a><span class="lineno">  272</span><span class="comment"></span> </div>
<div class="line"><a id="l00273" name="l00273"></a><span class="lineno">  273</span><span class="comment">/// Populates &#39;loops&#39; with IVs of the affine.for ops surrounding &#39;op&#39; ordered</span></div>
<div class="line"><a id="l00274" name="l00274"></a><span class="lineno">  274</span><span class="comment">/// from the outermost &#39;affine.for&#39; operation to the innermost one while not</span></div>
<div class="line"><a id="l00275" name="l00275"></a><span class="lineno">  275</span><span class="comment">/// traversing outside of the surrounding affine scope.</span></div>
<div class="line"><a id="l00276" name="l00276"></a><span class="lineno">  276</span><span class="keywordtype">void</span> <a class="code hl_function" href="namespacemlir_1_1affine.html#a9085efe05b8bc0b7c3b4f643d70eb1e7">getAffineForIVs</a>(<a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="code hl_class" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;AffineForOp&gt;</a> *loops);</div>
<div class="line"><a id="l00277" name="l00277"></a><span class="lineno">  277</span><span class="comment"></span> </div>
<div class="line"><a id="l00278" name="l00278"></a><span class="lineno">  278</span><span class="comment">/// Populates &#39;ivs&#39; with IVs of the surrounding affine.for and affine.parallel</span></div>
<div class="line"><a id="l00279" name="l00279"></a><span class="lineno">  279</span><span class="comment">/// ops ordered from the outermost one to the innermost while not traversing</span></div>
<div class="line"><a id="l00280" name="l00280"></a><span class="lineno">  280</span><span class="comment">/// outside of the surrounding affine scope.</span></div>
<div class="line"><a id="l00281" name="l00281"></a><span class="lineno">  281</span><span class="keywordtype">void</span> <a class="code hl_function" href="namespacemlir_1_1affine.html#a50b5b72a6baee24bfab9faebd198fe9b">getAffineIVs</a>(<a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="code hl_class" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Value&gt;</a> &amp;ivs);</div>
<div class="line"><a id="l00282" name="l00282"></a><span class="lineno">  282</span><span class="comment"></span> </div>
<div class="line"><a id="l00283" name="l00283"></a><span class="lineno">  283</span><span class="comment">/// Populates &#39;ops&#39; with affine operations enclosing `op` ordered from outermost</span></div>
<div class="line"><a id="l00284" name="l00284"></a><span class="lineno">  284</span><span class="comment">/// to innermost while stopping at the boundary of the affine scope. affine.for,</span></div>
<div class="line"><a id="l00285" name="l00285"></a><span class="lineno">  285</span><span class="comment">/// affine.if, or affine.parallel ops comprise such surrounding affine ops.</span></div>
<div class="line"><a id="l00286" name="l00286"></a><span class="lineno">  286</span><span class="comment">/// `ops` is guaranteed by design to have a successive chain of affine parent</span></div>
<div class="line"><a id="l00287" name="l00287"></a><span class="lineno">  287</span><span class="comment">/// ops.</span></div>
<div class="line"><a id="l00288" name="l00288"></a><span class="lineno">  288</span><span class="keywordtype">void</span> <a class="code hl_function" href="namespacemlir_1_1affine.html#a1f8e59ec9faff34b64ebb0411a383c3a">getEnclosingAffineOps</a>(<a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="code hl_class" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Operation *&gt;</a> *ops);</div>
<div class="line"><a id="l00289" name="l00289"></a><span class="lineno">  289</span><span class="comment"></span> </div>
<div class="line"><a id="l00290" name="l00290"></a><span class="lineno">  290</span><span class="comment">/// Returns the nesting depth of this operation, i.e., the number of loops</span></div>
<div class="line"><a id="l00291" name="l00291"></a><span class="lineno">  291</span><span class="comment">/// surrounding this operation.</span></div>
<div class="line"><a id="l00292" name="l00292"></a><span class="lineno">  292</span><span class="keywordtype">unsigned</span> <a class="code hl_function" href="namespacemlir_1_1affine.html#ac82ec61d5cae9ebb4489d2ab9ad6e8f8">getNestingDepth</a>(<a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *op);</div>
<div class="line"><a id="l00293" name="l00293"></a><span class="lineno">  293</span><span class="comment"></span> </div>
<div class="line"><a id="l00294" name="l00294"></a><span class="lineno">  294</span><span class="comment">/// Returns whether a loop is a parallel loop and contains a reduction loop.</span></div>
<div class="line"><a id="l00295" name="l00295"></a><span class="lineno">  295</span><span class="keywordtype">bool</span> <a class="code hl_function" href="namespacemlir_1_1affine.html#a34c1ca39d435d06366058d16b5fe4225">isLoopParallelAndContainsReduction</a>(AffineForOp forOp);</div>
<div class="line"><a id="l00296" name="l00296"></a><span class="lineno">  296</span><span class="comment"></span> </div>
<div class="line"><a id="l00297" name="l00297"></a><span class="lineno">  297</span><span class="comment">/// Returns in &#39;sequentialLoops&#39; all sequential loops in loop nest rooted</span></div>
<div class="line"><a id="l00298" name="l00298"></a><span class="lineno">  298</span><span class="comment">/// at &#39;forOp&#39;.</span></div>
<div class="line"><a id="l00299" name="l00299"></a><span class="lineno">  299</span><span class="keywordtype">void</span> <a class="code hl_function" href="namespacemlir_1_1affine.html#a5ad383995f97dc30a0d6891e33fd499a">getSequentialLoops</a>(AffineForOp forOp,</div>
<div class="line"><a id="l00300" name="l00300"></a><span class="lineno">  300</span>                        llvm::SmallDenseSet&lt;Value, 8&gt; *sequentialLoops);</div>
<div class="line"><a id="l00301" name="l00301"></a><span class="lineno">  301</span><span class="comment"></span> </div>
<div class="line"><a id="l00302" name="l00302"></a><span class="lineno">  302</span><span class="comment">/// Enumerates different result statuses of slice computation by</span></div>
<div class="line"><a id="l00303" name="l00303"></a><span class="lineno">  303</span><span class="comment">/// `computeSliceUnion`</span></div>
<div class="line"><a id="l00304" name="l00304"></a><span class="lineno">  304</span><span class="comment">// TODO: Identify and add different kinds of failures during slice computation.</span></div>
<div class="foldopen" id="foldopen00305" data-start="{" data-end="};">
<div class="line"><a id="l00305" name="l00305"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1SliceComputationResult.html">  305</a></span><span class="keyword">struct </span><a class="code hl_function" href="structmlir_1_1affine_1_1SliceComputationResult.html#a37a45916fce7b4d2989ae128c037d3ef">SliceComputationResult</a> {</div>
<div class="foldopen" id="foldopen00306" data-start="{" data-end="};">
<div class="line"><a id="l00306" name="l00306"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9">  306</a></span>  <span class="keyword">enum</span> <a class="code hl_enumeration" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9">ResultEnum</a> {</div>
<div class="line"><a id="l00307" name="l00307"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9aa85f3aac90ad660d5de9933c03cd26ef">  307</a></span>    <a class="code hl_enumvalue" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9aa85f3aac90ad660d5de9933c03cd26ef">Success</a>,</div>
<div class="line"><a id="l00308" name="l00308"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9aa56e19629619cf1e69cb9f4ec40dcb7c">  308</a></span>    <a class="code hl_enumvalue" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9aa56e19629619cf1e69cb9f4ec40dcb7c">IncorrectSliceFailure</a>, <span class="comment">// Slice is computed, but it is incorrect.</span></div>
<div class="line"><a id="l00309" name="l00309"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9a4386b2e4cd401f45247b3ff587a5e4d6">  309</a></span>    <a class="code hl_enumvalue" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9a4386b2e4cd401f45247b3ff587a5e4d6">GenericFailure</a>,        <span class="comment">// Unable to compute src loop computation slice.</span></div>
<div class="line"><a id="l00310" name="l00310"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1SliceComputationResult.html#ae1bf161ba038ce8ed38567be7adba786">  310</a></span>  } <a class="code hl_variable" href="structmlir_1_1affine_1_1SliceComputationResult.html#ae1bf161ba038ce8ed38567be7adba786">value</a>;</div>
</div>
<div class="line"><a id="l00311" name="l00311"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1SliceComputationResult.html#a37a45916fce7b4d2989ae128c037d3ef">  311</a></span>  <a class="code hl_function" href="structmlir_1_1affine_1_1SliceComputationResult.html#a37a45916fce7b4d2989ae128c037d3ef">SliceComputationResult</a>(<a class="code hl_enumeration" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9">ResultEnum</a> v) : <a class="code hl_variable" href="structmlir_1_1affine_1_1SliceComputationResult.html#ae1bf161ba038ce8ed38567be7adba786">value</a>(v) {}</div>
<div class="line"><a id="l00312" name="l00312"></a><span class="lineno">  312</span>};</div>
</div>
<div class="line"><a id="l00313" name="l00313"></a><span class="lineno">  313</span><span class="comment"></span> </div>
<div class="line"><a id="l00314" name="l00314"></a><span class="lineno">  314</span><span class="comment">/// ComputationSliceState aggregates loop IVs, loop bound AffineMaps and their</span></div>
<div class="line"><a id="l00315" name="l00315"></a><span class="lineno">  315</span><span class="comment">/// associated operands for a set of loops within a loop nest (typically the</span></div>
<div class="line"><a id="l00316" name="l00316"></a><span class="lineno">  316</span><span class="comment">/// set of loops surrounding a store operation). Loop bound AffineMaps which</span></div>
<div class="line"><a id="l00317" name="l00317"></a><span class="lineno">  317</span><span class="comment">/// are non-null represent slices of that loop&#39;s iteration space.</span></div>
<div class="foldopen" id="foldopen00318" data-start="{" data-end="};">
<div class="line"><a id="l00318" name="l00318"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1ComputationSliceState.html">  318</a></span><span class="keyword">struct </span><a class="code hl_struct" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> {</div>
<div class="line"><a id="l00319" name="l00319"></a><span class="lineno">  319</span>  <span class="comment">// List of sliced loop IVs (ordered from outermost to innermost).</span></div>
<div class="line"><a id="l00320" name="l00320"></a><span class="lineno">  320</span>  <span class="comment">// EX: &#39;ivs[i]&#39; has lower bound &#39;lbs[i]&#39; and upper bound &#39;ubs[i]&#39;.</span></div>
<div class="line"><a id="l00321" name="l00321"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1ComputationSliceState.html#a140bf9ff4200613fb5822bed2f1bfc18">  321</a></span>  <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value, 4&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1ComputationSliceState.html#a140bf9ff4200613fb5822bed2f1bfc18">ivs</a>;</div>
<div class="line"><a id="l00322" name="l00322"></a><span class="lineno">  322</span>  <span class="comment">// List of lower bound AffineMaps.</span></div>
<div class="line"><a id="l00323" name="l00323"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1ComputationSliceState.html#ade6c510051faa671f7758989e38b491d">  323</a></span>  <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;AffineMap, 4&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1ComputationSliceState.html#ade6c510051faa671f7758989e38b491d">lbs</a>;</div>
<div class="line"><a id="l00324" name="l00324"></a><span class="lineno">  324</span>  <span class="comment">// List of upper bound AffineMaps.</span></div>
<div class="line"><a id="l00325" name="l00325"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1ComputationSliceState.html#ab0148e60f0d8d38822992cf91eb87b5b">  325</a></span>  <a class="code hl_class" href="classllvm_1_1SmallVector.html">SmallVector&lt;AffineMap, 4&gt;</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1ComputationSliceState.html#ab0148e60f0d8d38822992cf91eb87b5b">ubs</a>;</div>
<div class="line"><a id="l00326" name="l00326"></a><span class="lineno">  326</span>  <span class="comment">// List of lower bound operands (lbOperands[i] are used by &#39;lbs[i]&#39;).</span></div>
<div class="line"><a id="l00327" name="l00327"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1ComputationSliceState.html#afd8aa32fa351614ef5060a1e079dec0b">  327</a></span>  std::vector&lt;SmallVector&lt;Value, 4&gt;&gt; <a class="code hl_variable" href="structmlir_1_1affine_1_1ComputationSliceState.html#afd8aa32fa351614ef5060a1e079dec0b">lbOperands</a>;</div>
<div class="line"><a id="l00328" name="l00328"></a><span class="lineno">  328</span>  <span class="comment">// List of upper bound operands (ubOperands[i] are used by &#39;ubs[i]&#39;).</span></div>
<div class="line"><a id="l00329" name="l00329"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1ComputationSliceState.html#aa3215ff59c18264fa4e846d9a2d5615f">  329</a></span>  std::vector&lt;SmallVector&lt;Value, 4&gt;&gt; <a class="code hl_variable" href="structmlir_1_1affine_1_1ComputationSliceState.html#aa3215ff59c18264fa4e846d9a2d5615f">ubOperands</a>;</div>
<div class="line"><a id="l00330" name="l00330"></a><span class="lineno">  330</span>  <span class="comment">// Slice loop nest insertion point in target loop nest.</span></div>
<div class="line"><a id="l00331" name="l00331"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1ComputationSliceState.html#afc69fcff6c39da7525bb1c61b91c4492">  331</a></span>  <a class="code hl_typedef" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1ComputationSliceState.html#afc69fcff6c39da7525bb1c61b91c4492">insertPoint</a>;</div>
<div class="line"><a id="l00332" name="l00332"></a><span class="lineno">  332</span>  <span class="comment">// Adds to &#39;cst&#39; with constraints which represent the slice bounds on &#39;ivs&#39;</span></div>
<div class="line"><a id="l00333" name="l00333"></a><span class="lineno">  333</span>  <span class="comment">// in &#39;this&#39;. Specifically, the values in &#39;ivs&#39; are added to &#39;cst&#39; as dim</span></div>
<div class="line"><a id="l00334" name="l00334"></a><span class="lineno">  334</span>  <span class="comment">// variables and the values in &#39;lb/ubOperands&#39; are added as symbols.</span></div>
<div class="line"><a id="l00335" name="l00335"></a><span class="lineno">  335</span>  <span class="comment">// Constraints are added for all loop IV bounds (dim or symbol), and</span></div>
<div class="line"><a id="l00336" name="l00336"></a><span class="lineno">  336</span>  <span class="comment">// constraints are added for slice bounds in &#39;lbs&#39;/&#39;ubs&#39;.</span></div>
<div class="line"><a id="l00337" name="l00337"></a><span class="lineno">  337</span>  <span class="comment">// Returns failure if we cannot add loop bounds because of unsupported cases.</span></div>
<div class="line"><a id="l00338" name="l00338"></a><span class="lineno">  338</span>  LogicalResult <a class="code hl_function" href="structmlir_1_1affine_1_1ComputationSliceState.html#a2a55ff23adbc2491f154ec4074c665d6">getAsConstraints</a>(<a class="code hl_class" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *cst) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00339" name="l00339"></a><span class="lineno">  339</span><span class="comment"></span> </div>
<div class="line"><a id="l00340" name="l00340"></a><span class="lineno">  340</span><span class="comment">  /// Adds to &#39;cst&#39; constraints which represent the original loop bounds on</span></div>
<div class="line"><a id="l00341" name="l00341"></a><span class="lineno">  341</span><span class="comment">  /// &#39;ivs&#39; in &#39;this&#39;. This corresponds to the original domain of the loop nest</span></div>
<div class="line"><a id="l00342" name="l00342"></a><span class="lineno">  342</span><span class="comment">  /// from which the slice is being computed. Returns failure if we cannot add</span></div>
<div class="line"><a id="l00343" name="l00343"></a><span class="lineno">  343</span><span class="comment">  /// loop bounds because of unsupported cases.</span></div>
<div class="line"><a id="l00344" name="l00344"></a><span class="lineno">  344</span>  LogicalResult <a class="code hl_function" href="structmlir_1_1affine_1_1ComputationSliceState.html#a9b06d992ca662858732225827937c1f7">getSourceAsConstraints</a>(<a class="code hl_class" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;cst) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00345" name="l00345"></a><span class="lineno">  345</span> </div>
<div class="line"><a id="l00346" name="l00346"></a><span class="lineno">  346</span>  <span class="comment">// Clears all bounds and operands in slice state.</span></div>
<div class="line"><a id="l00347" name="l00347"></a><span class="lineno">  347</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1ComputationSliceState.html#ae01fc5e4aa59b1624613835b69c219a6">clearBounds</a>();</div>
<div class="line"><a id="l00348" name="l00348"></a><span class="lineno">  348</span><span class="comment"></span> </div>
<div class="line"><a id="l00349" name="l00349"></a><span class="lineno">  349</span><span class="comment">  /// Returns true if the computation slice is empty.</span></div>
<div class="line"><a id="l00350" name="l00350"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1ComputationSliceState.html#a6662e2d7b1582bfe4ff4f64eea403432">  350</a></span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="structmlir_1_1affine_1_1ComputationSliceState.html#a6662e2d7b1582bfe4ff4f64eea403432">isEmpty</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="structmlir_1_1affine_1_1ComputationSliceState.html#a140bf9ff4200613fb5822bed2f1bfc18">ivs</a>.empty(); }</div>
<div class="line"><a id="l00351" name="l00351"></a><span class="lineno">  351</span><span class="comment"></span> </div>
<div class="line"><a id="l00352" name="l00352"></a><span class="lineno">  352</span><span class="comment">  /// Returns true if the computation slice encloses all the iterations of the</span></div>
<div class="line"><a id="l00353" name="l00353"></a><span class="lineno">  353</span><span class="comment">  /// sliced loop nest. Returns false if it does not. Returns std::nullopt if it</span></div>
<div class="line"><a id="l00354" name="l00354"></a><span class="lineno">  354</span><span class="comment">  /// cannot determine if the slice is maximal or not.</span></div>
<div class="line"><a id="l00355" name="l00355"></a><span class="lineno">  355</span>  <span class="comment">// TODO: Cache &#39;isMaximal&#39; so that we don&#39;t recompute it when the slice</span></div>
<div class="line"><a id="l00356" name="l00356"></a><span class="lineno">  356</span>  <span class="comment">// information hasn&#39;t changed.</span></div>
<div class="line"><a id="l00357" name="l00357"></a><span class="lineno">  357</span>  std::optional&lt;bool&gt; <a class="code hl_function" href="structmlir_1_1affine_1_1ComputationSliceState.html#abc7052b611c0772f9c551ee0d4b33d92">isMaximal</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l00358" name="l00358"></a><span class="lineno">  358</span><span class="comment"></span> </div>
<div class="line"><a id="l00359" name="l00359"></a><span class="lineno">  359</span><span class="comment">  /// Checks the validity of the slice computed. This is done using the</span></div>
<div class="line"><a id="l00360" name="l00360"></a><span class="lineno">  360</span><span class="comment">  /// following steps:</span></div>
<div class="line"><a id="l00361" name="l00361"></a><span class="lineno">  361</span><span class="comment">  /// 1. Get the new domain of the slice that would be created if fusion</span></div>
<div class="line"><a id="l00362" name="l00362"></a><span class="lineno">  362</span><span class="comment">  /// succeeds. This domain gets constructed with source loop IVS and</span></div>
<div class="line"><a id="l00363" name="l00363"></a><span class="lineno">  363</span><span class="comment">  /// destination loop IVS as dimensions.</span></div>
<div class="line"><a id="l00364" name="l00364"></a><span class="lineno">  364</span><span class="comment">  /// 2. Project out the dimensions of the destination loop from the domain</span></div>
<div class="line"><a id="l00365" name="l00365"></a><span class="lineno">  365</span><span class="comment">  /// above calculated in step(1) to express it purely in terms of the source</span></div>
<div class="line"><a id="l00366" name="l00366"></a><span class="lineno">  366</span><span class="comment">  /// loop IVs.</span></div>
<div class="line"><a id="l00367" name="l00367"></a><span class="lineno">  367</span><span class="comment">  /// 3. Calculate a set difference between the iterations of the new domain and</span></div>
<div class="line"><a id="l00368" name="l00368"></a><span class="lineno">  368</span><span class="comment">  /// the original domain of the source loop.</span></div>
<div class="line"><a id="l00369" name="l00369"></a><span class="lineno">  369</span><span class="comment">  /// If this difference is empty, the slice is declared to be valid. Otherwise,</span></div>
<div class="line"><a id="l00370" name="l00370"></a><span class="lineno">  370</span><span class="comment">  /// return false as it implies that the effective fusion results in at least</span></div>
<div class="line"><a id="l00371" name="l00371"></a><span class="lineno">  371</span><span class="comment">  /// one iteration of the slice that was not originally in the source&#39;s domain.</span></div>
<div class="line"><a id="l00372" name="l00372"></a><span class="lineno">  372</span><span class="comment">  /// If the validity cannot be determined, returns std::nullopt.</span></div>
<div class="line"><a id="l00373" name="l00373"></a><span class="lineno">  373</span>  std::optional&lt;bool&gt; <a class="code hl_function" href="structmlir_1_1affine_1_1ComputationSliceState.html#a09a810c2f49cc44e2c5de12c6caf2727">isSliceValid</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l00374" name="l00374"></a><span class="lineno">  374</span> </div>
<div class="line"><a id="l00375" name="l00375"></a><span class="lineno">  375</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1ComputationSliceState.html#a23715baf2fcbb66e2acd9db32956f40e">dump</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l00376" name="l00376"></a><span class="lineno">  376</span> </div>
<div class="line"><a id="l00377" name="l00377"></a><span class="lineno">  377</span><span class="keyword">private</span>:<span class="comment"></span></div>
<div class="line"><a id="l00378" name="l00378"></a><span class="lineno">  378</span><span class="comment">  /// Fast check to determine if the computation slice is maximal. Returns true</span></div>
<div class="line"><a id="l00379" name="l00379"></a><span class="lineno">  379</span><span class="comment">  /// if each slice dimension maps to an existing dst dimension and both the src</span></div>
<div class="line"><a id="l00380" name="l00380"></a><span class="lineno">  380</span><span class="comment">  /// and the dst loops for those dimensions have the same bounds. Returns false</span></div>
<div class="line"><a id="l00381" name="l00381"></a><span class="lineno">  381</span><span class="comment">  /// if both the src and the dst loops don&#39;t have the same bounds. Returns</span></div>
<div class="line"><a id="l00382" name="l00382"></a><span class="lineno">  382</span><span class="comment">  /// std::nullopt if none of the above can be proven.</span></div>
<div class="line"><a id="l00383" name="l00383"></a><span class="lineno">  383</span>  std::optional&lt;bool&gt; isSliceMaximalFastCheck() <span class="keyword">const</span>;</div>
<div class="line"><a id="l00384" name="l00384"></a><span class="lineno">  384</span>};</div>
</div>
<div class="line"><a id="l00385" name="l00385"></a><span class="lineno">  385</span><span class="comment"></span> </div>
<div class="line"><a id="l00386" name="l00386"></a><span class="lineno">  386</span><span class="comment">/// Computes the computation slice loop bounds for one loop nest as affine maps</span></div>
<div class="line"><a id="l00387" name="l00387"></a><span class="lineno">  387</span><span class="comment">/// of the other loop nest&#39;s IVs and symbols, using &#39;dependenceConstraints&#39;</span></div>
<div class="line"><a id="l00388" name="l00388"></a><span class="lineno">  388</span><span class="comment">/// computed between &#39;depSourceAccess&#39; and &#39;depSinkAccess&#39;.</span></div>
<div class="line"><a id="l00389" name="l00389"></a><span class="lineno">  389</span><span class="comment">/// If &#39;isBackwardSlice&#39; is true, a backwards slice is computed in which the</span></div>
<div class="line"><a id="l00390" name="l00390"></a><span class="lineno">  390</span><span class="comment">/// slice bounds of loop nest surrounding &#39;depSourceAccess&#39; are computed in</span></div>
<div class="line"><a id="l00391" name="l00391"></a><span class="lineno">  391</span><span class="comment">/// terms of loop IVs and symbols of the loop nest surrounding &#39;depSinkAccess&#39;</span></div>
<div class="line"><a id="l00392" name="l00392"></a><span class="lineno">  392</span><span class="comment">/// at &#39;loopDepth&#39;.</span></div>
<div class="line"><a id="l00393" name="l00393"></a><span class="lineno">  393</span><span class="comment">/// If &#39;isBackwardSlice&#39; is false, a forward slice is computed in which the</span></div>
<div class="line"><a id="l00394" name="l00394"></a><span class="lineno">  394</span><span class="comment">/// slice bounds of loop nest surrounding &#39;depSinkAccess&#39; are computed in terms</span></div>
<div class="line"><a id="l00395" name="l00395"></a><span class="lineno">  395</span><span class="comment">/// of loop IVs and symbols of the loop nest surrounding &#39;depSourceAccess&#39; at</span></div>
<div class="line"><a id="l00396" name="l00396"></a><span class="lineno">  396</span><span class="comment">/// &#39;loopDepth&#39;.</span></div>
<div class="line"><a id="l00397" name="l00397"></a><span class="lineno">  397</span><span class="comment">/// The slice loop bounds and associated operands are returned in &#39;sliceState&#39;.</span></div>
<div class="line"><a id="l00398" name="l00398"></a><span class="lineno">  398</span><span class="comment">//</span></div>
<div class="line"><a id="l00399" name="l00399"></a><span class="lineno">  399</span><span class="comment">//  Backward slice example:</span></div>
<div class="line"><a id="l00400" name="l00400"></a><span class="lineno">  400</span><span class="comment">//</span></div>
<div class="line"><a id="l00401" name="l00401"></a><span class="lineno">  401</span><span class="comment">//    affine.for %i0 = 0 to 10 {</span></div>
<div class="line"><a id="l00402" name="l00402"></a><span class="lineno">  402</span><span class="comment">//      affine.store %cst, %0[%i0] : memref&lt;100xf32&gt;  // &#39;depSourceAccess&#39;</span></div>
<div class="line"><a id="l00403" name="l00403"></a><span class="lineno">  403</span><span class="comment">//    }</span></div>
<div class="line"><a id="l00404" name="l00404"></a><span class="lineno">  404</span><span class="comment">//    affine.for %i1 = 0 to 10 {</span></div>
<div class="line"><a id="l00405" name="l00405"></a><span class="lineno">  405</span><span class="comment">//      %v = affine.load %0[%i1] : memref&lt;100xf32&gt;    // &#39;depSinkAccess&#39;</span></div>
<div class="line"><a id="l00406" name="l00406"></a><span class="lineno">  406</span><span class="comment">//    }</span></div>
<div class="line"><a id="l00407" name="l00407"></a><span class="lineno">  407</span><span class="comment">//</span></div>
<div class="line"><a id="l00408" name="l00408"></a><span class="lineno">  408</span><span class="comment">//    // Backward computation slice of loop nest &#39;%i0&#39;.</span></div>
<div class="line"><a id="l00409" name="l00409"></a><span class="lineno">  409</span><span class="comment">//    affine.for %i0 = (d0) -&gt; (d0)(%i1) to (d0) -&gt; (d0 + 1)(%i1) {</span></div>
<div class="line"><a id="l00410" name="l00410"></a><span class="lineno">  410</span><span class="comment">//      affine.store %cst, %0[%i0] : memref&lt;100xf32&gt;  // &#39;depSourceAccess&#39;</span></div>
<div class="line"><a id="l00411" name="l00411"></a><span class="lineno">  411</span><span class="comment">//    }</span></div>
<div class="line"><a id="l00412" name="l00412"></a><span class="lineno">  412</span><span class="comment">//</span></div>
<div class="line"><a id="l00413" name="l00413"></a><span class="lineno">  413</span><span class="comment">//  Forward slice example:</span></div>
<div class="line"><a id="l00414" name="l00414"></a><span class="lineno">  414</span><span class="comment">//</span></div>
<div class="line"><a id="l00415" name="l00415"></a><span class="lineno">  415</span><span class="comment">//    affine.for %i0 = 0 to 10 {</span></div>
<div class="line"><a id="l00416" name="l00416"></a><span class="lineno">  416</span><span class="comment">//      affine.store %cst, %0[%i0] : memref&lt;100xf32&gt;  // &#39;depSourceAccess&#39;</span></div>
<div class="line"><a id="l00417" name="l00417"></a><span class="lineno">  417</span><span class="comment">//    }</span></div>
<div class="line"><a id="l00418" name="l00418"></a><span class="lineno">  418</span><span class="comment">//    affine.for %i1 = 0 to 10 {</span></div>
<div class="line"><a id="l00419" name="l00419"></a><span class="lineno">  419</span><span class="comment">//      %v = affine.load %0[%i1] : memref&lt;100xf32&gt;    // &#39;depSinkAccess&#39;</span></div>
<div class="line"><a id="l00420" name="l00420"></a><span class="lineno">  420</span><span class="comment">//    }</span></div>
<div class="line"><a id="l00421" name="l00421"></a><span class="lineno">  421</span><span class="comment">//</span></div>
<div class="line"><a id="l00422" name="l00422"></a><span class="lineno">  422</span><span class="comment">//    // Forward computation slice of loop nest &#39;%i1&#39;.</span></div>
<div class="line"><a id="l00423" name="l00423"></a><span class="lineno">  423</span><span class="comment">//    affine.for %i1 = (d0) -&gt; (d0)(%i0) to (d0) -&gt; (d0 + 1)(%i0) {</span></div>
<div class="line"><a id="l00424" name="l00424"></a><span class="lineno">  424</span><span class="comment">//      %v = affine.load %0[%i1] : memref&lt;100xf32&gt;    // &#39;depSinkAccess&#39;</span></div>
<div class="line"><a id="l00425" name="l00425"></a><span class="lineno">  425</span><span class="comment">//    }</span></div>
<div class="line"><a id="l00426" name="l00426"></a><span class="lineno">  426</span><span class="comment">//</span></div>
<div class="line"><a id="l00427" name="l00427"></a><span class="lineno">  427</span><span class="keywordtype">void</span> <a class="code hl_function" href="namespacemlir_1_1affine.html#ab6cceed0c6debb9af0d3bd76c9ed52f4">getComputationSliceState</a>(</div>
<div class="line"><a id="l00428" name="l00428"></a><span class="lineno">  428</span>    <a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *depSourceOp, <a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *depSinkOp,</div>
<div class="line"><a id="l00429" name="l00429"></a><span class="lineno">  429</span>    <span class="keyword">const</span> FlatAffineValueConstraints &amp;dependenceConstraints, <span class="keywordtype">unsigned</span> loopDepth,</div>
<div class="line"><a id="l00430" name="l00430"></a><span class="lineno">  430</span>    <span class="keywordtype">bool</span> isBackwardSlice, ComputationSliceState *sliceState);</div>
<div class="line"><a id="l00431" name="l00431"></a><span class="lineno">  431</span><span class="comment"></span> </div>
<div class="line"><a id="l00432" name="l00432"></a><span class="lineno">  432</span><span class="comment">/// Return the number of iterations for the `slicetripCountMap` provided.</span></div>
<div class="line"><a id="l00433" name="l00433"></a><span class="lineno">  433</span>uint64_t <a class="code hl_function" href="namespacemlir_1_1affine.html#acfb5cde2210f8126b02cd84843a0c43b">getSliceIterationCount</a>(</div>
<div class="line"><a id="l00434" name="l00434"></a><span class="lineno">  434</span>    <span class="keyword">const</span> llvm::SmallDenseMap&lt;Operation *, uint64_t, 8&gt; &amp;sliceTripCountMap);</div>
<div class="line"><a id="l00435" name="l00435"></a><span class="lineno">  435</span><span class="comment"></span> </div>
<div class="line"><a id="l00436" name="l00436"></a><span class="lineno">  436</span><span class="comment">/// Builds a map &#39;tripCountMap&#39; from AffineForOp to constant trip count for</span></div>
<div class="line"><a id="l00437" name="l00437"></a><span class="lineno">  437</span><span class="comment">/// loop nest surrounding represented by slice loop bounds in &#39;slice&#39;. Returns</span></div>
<div class="line"><a id="l00438" name="l00438"></a><span class="lineno">  438</span><span class="comment">/// true on success, false otherwise (if a non-constant trip count was</span></div>
<div class="line"><a id="l00439" name="l00439"></a><span class="lineno">  439</span><span class="comment">/// encountered).</span></div>
<div class="line"><a id="l00440" name="l00440"></a><span class="lineno">  440</span><span class="keywordtype">bool</span> <a class="code hl_function" href="namespacemlir_1_1affine.html#af1b7ee261b2662fe2f0c257c9e04f3b6">buildSliceTripCountMap</a>(</div>
<div class="line"><a id="l00441" name="l00441"></a><span class="lineno">  441</span>    <span class="keyword">const</span> ComputationSliceState &amp;slice,</div>
<div class="line"><a id="l00442" name="l00442"></a><span class="lineno">  442</span>    llvm::SmallDenseMap&lt;Operation *, uint64_t, 8&gt; *tripCountMap);</div>
<div class="line"><a id="l00443" name="l00443"></a><span class="lineno">  443</span><span class="comment"></span> </div>
<div class="line"><a id="l00444" name="l00444"></a><span class="lineno">  444</span><span class="comment">/// Computes in &#39;sliceUnion&#39; the union of all slice bounds computed at</span></div>
<div class="line"><a id="l00445" name="l00445"></a><span class="lineno">  445</span><span class="comment">/// &#39;loopDepth&#39; between all dependent pairs of ops in &#39;opsA&#39; and &#39;opsB&#39;, and</span></div>
<div class="line"><a id="l00446" name="l00446"></a><span class="lineno">  446</span><span class="comment">/// then verifies if it is valid. The parameter &#39;numCommonLoops&#39; is the number</span></div>
<div class="line"><a id="l00447" name="l00447"></a><span class="lineno">  447</span><span class="comment">/// of loops common to the operations in &#39;opsA&#39; and &#39;opsB&#39;. If &#39;isBackwardSlice&#39;</span></div>
<div class="line"><a id="l00448" name="l00448"></a><span class="lineno">  448</span><span class="comment">/// is true, computes slice bounds for loop nest surrounding ops in &#39;opsA&#39;, as a</span></div>
<div class="line"><a id="l00449" name="l00449"></a><span class="lineno">  449</span><span class="comment">/// function of IVs and symbols of loop nest surrounding ops in &#39;opsB&#39; at</span></div>
<div class="line"><a id="l00450" name="l00450"></a><span class="lineno">  450</span><span class="comment">/// &#39;loopDepth&#39;. If &#39;isBackwardSlice&#39; is false, computes slice bounds for loop</span></div>
<div class="line"><a id="l00451" name="l00451"></a><span class="lineno">  451</span><span class="comment">/// nest surrounding ops in &#39;opsB&#39;, as a function of IVs and symbols of loop</span></div>
<div class="line"><a id="l00452" name="l00452"></a><span class="lineno">  452</span><span class="comment">/// nest surrounding ops in &#39;opsA&#39; at &#39;loopDepth&#39;. Returns</span></div>
<div class="line"><a id="l00453" name="l00453"></a><span class="lineno">  453</span><span class="comment">/// &#39;SliceComputationResult::Success&#39; if union was computed correctly, an</span></div>
<div class="line"><a id="l00454" name="l00454"></a><span class="lineno">  454</span><span class="comment">/// appropriate &#39;failure&#39; otherwise.</span></div>
<div class="line"><a id="l00455" name="l00455"></a><span class="lineno">  455</span>SliceComputationResult</div>
<div class="line"><a id="l00456" name="l00456"></a><span class="lineno">  456</span><a class="code hl_function" href="namespacemlir_1_1affine.html#a29213ed6d6cdad5cdd69bb66c6df863f">computeSliceUnion</a>(<a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Operation *&gt;</a> opsA, <a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Operation *&gt;</a> opsB,</div>
<div class="line"><a id="l00457" name="l00457"></a><span class="lineno">  457</span>                  <span class="keywordtype">unsigned</span> loopDepth, <span class="keywordtype">unsigned</span> numCommonLoops,</div>
<div class="line"><a id="l00458" name="l00458"></a><span class="lineno">  458</span>                  <span class="keywordtype">bool</span> isBackwardSlice, ComputationSliceState *sliceUnion);</div>
<div class="line"><a id="l00459" name="l00459"></a><span class="lineno">  459</span><span class="comment"></span> </div>
<div class="line"><a id="l00460" name="l00460"></a><span class="lineno">  460</span><span class="comment">/// Creates a clone of the computation contained in the loop nest surrounding</span></div>
<div class="line"><a id="l00461" name="l00461"></a><span class="lineno">  461</span><span class="comment">/// &#39;srcOpInst&#39;, slices the iteration space of src loop based on slice bounds</span></div>
<div class="line"><a id="l00462" name="l00462"></a><span class="lineno">  462</span><span class="comment">/// in &#39;sliceState&#39;, and inserts the computation slice at the beginning of the</span></div>
<div class="line"><a id="l00463" name="l00463"></a><span class="lineno">  463</span><span class="comment">/// operation block of the loop at &#39;dstLoopDepth&#39; in the loop nest surrounding</span></div>
<div class="line"><a id="l00464" name="l00464"></a><span class="lineno">  464</span><span class="comment">/// &#39;dstOpInst&#39;. Returns the top-level loop of the computation slice on</span></div>
<div class="line"><a id="l00465" name="l00465"></a><span class="lineno">  465</span><span class="comment">/// success, returns nullptr otherwise.</span></div>
<div class="line"><a id="l00466" name="l00466"></a><span class="lineno">  466</span><span class="comment">// Loop depth is a crucial optimization choice that determines where to</span></div>
<div class="line"><a id="l00467" name="l00467"></a><span class="lineno">  467</span><span class="comment">// materialize the results of the backward slice - presenting a trade-off b/w</span></div>
<div class="line"><a id="l00468" name="l00468"></a><span class="lineno">  468</span><span class="comment">// storage and redundant computation in several cases.</span></div>
<div class="line"><a id="l00469" name="l00469"></a><span class="lineno">  469</span><span class="comment">// TODO: Support computation slices with common surrounding loops.</span></div>
<div class="line"><a id="l00470" name="l00470"></a><span class="lineno">  470</span>AffineForOp <a class="code hl_function" href="namespacemlir_1_1affine.html#af32168fb86ad493527c61d139acee48a">insertBackwardComputationSlice</a>(<a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *srcOpInst,</div>
<div class="line"><a id="l00471" name="l00471"></a><span class="lineno">  471</span>                                           <a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *dstOpInst,</div>
<div class="line"><a id="l00472" name="l00472"></a><span class="lineno">  472</span>                                           <span class="keywordtype">unsigned</span> dstLoopDepth,</div>
<div class="line"><a id="l00473" name="l00473"></a><span class="lineno">  473</span>                                           ComputationSliceState *sliceState);</div>
<div class="line"><a id="l00474" name="l00474"></a><span class="lineno">  474</span><span class="comment"></span> </div>
<div class="line"><a id="l00475" name="l00475"></a><span class="lineno">  475</span><span class="comment">/// A region of a memref&#39;s data space; this is typically constructed by</span></div>
<div class="line"><a id="l00476" name="l00476"></a><span class="lineno">  476</span><span class="comment">/// analyzing load/store op&#39;s on this memref and the index space of loops</span></div>
<div class="line"><a id="l00477" name="l00477"></a><span class="lineno">  477</span><span class="comment">/// surrounding such op&#39;s.</span></div>
<div class="line"><a id="l00478" name="l00478"></a><span class="lineno">  478</span><span class="comment">// For example, the memref region for a load operation at loop depth = 1:</span></div>
<div class="line"><a id="l00479" name="l00479"></a><span class="lineno">  479</span><span class="comment">//</span></div>
<div class="line"><a id="l00480" name="l00480"></a><span class="lineno">  480</span><span class="comment">//    affine.for %i = 0 to 32 {</span></div>
<div class="line"><a id="l00481" name="l00481"></a><span class="lineno">  481</span><span class="comment">//      affine.for %ii = %i to (d0) -&gt; (d0 + 8) (%i) {</span></div>
<div class="line"><a id="l00482" name="l00482"></a><span class="lineno">  482</span><span class="comment">//        affine.load %A[%ii]</span></div>
<div class="line"><a id="l00483" name="l00483"></a><span class="lineno">  483</span><span class="comment">//      }</span></div>
<div class="line"><a id="l00484" name="l00484"></a><span class="lineno">  484</span><span class="comment">//    }</span></div>
<div class="line"><a id="l00485" name="l00485"></a><span class="lineno">  485</span><span class="comment">//</span></div>
<div class="line"><a id="l00486" name="l00486"></a><span class="lineno">  486</span><span class="comment">// Region:  {memref = %A, write = false, {%i &lt;= m0 &lt;= %i + 7} }</span></div>
<div class="line"><a id="l00487" name="l00487"></a><span class="lineno">  487</span><span class="comment">// The last field is a 2-d FlatAffineValueConstraints symbolic in %i.</span></div>
<div class="line"><a id="l00488" name="l00488"></a><span class="lineno">  488</span><span class="comment">//</span></div>
<div class="foldopen" id="foldopen00489" data-start="{" data-end="};">
<div class="line"><a id="l00489" name="l00489"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html">  489</a></span><span class="keyword">struct </span><a class="code hl_function" href="structmlir_1_1affine_1_1MemRefRegion.html#ac6d5022fc3e167d5e4f2c9e9c116ae39">MemRefRegion</a> {</div>
<div class="line"><a id="l00490" name="l00490"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#ac6d5022fc3e167d5e4f2c9e9c116ae39">  490</a></span>  <span class="keyword">explicit</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefRegion.html#ac6d5022fc3e167d5e4f2c9e9c116ae39">MemRefRegion</a>(<a class="code hl_class" href="classmlir_1_1Location.html">Location</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">loc</a>) : <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">loc</a>(<a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">loc</a>) {}</div>
<div class="line"><a id="l00491" name="l00491"></a><span class="lineno">  491</span><span class="comment"></span> </div>
<div class="line"><a id="l00492" name="l00492"></a><span class="lineno">  492</span><span class="comment">  /// Computes the memory region accessed by this memref with the region</span></div>
<div class="line"><a id="l00493" name="l00493"></a><span class="lineno">  493</span><span class="comment">  /// represented as constraints symbolic/parametric in &#39;loopDepth&#39; loops</span></div>
<div class="line"><a id="l00494" name="l00494"></a><span class="lineno">  494</span><span class="comment">  /// surrounding opInst. The computed region&#39;s &#39;cst&#39; field has exactly as many</span></div>
<div class="line"><a id="l00495" name="l00495"></a><span class="lineno">  495</span><span class="comment">  /// dimensional variables as the rank of the memref, and *potentially*</span></div>
<div class="line"><a id="l00496" name="l00496"></a><span class="lineno">  496</span><span class="comment">  /// additional symbolic variables which could include any of the loop IVs</span></div>
<div class="line"><a id="l00497" name="l00497"></a><span class="lineno">  497</span><span class="comment">  /// surrounding opInst up until &#39;loopDepth&#39; and another additional Function</span></div>
<div class="line"><a id="l00498" name="l00498"></a><span class="lineno">  498</span><span class="comment">  /// symbols involved with the access (for eg., those appear in affine.apply&#39;s,</span></div>
<div class="line"><a id="l00499" name="l00499"></a><span class="lineno">  499</span><span class="comment">  /// loop bounds, etc.). If &#39;sliceState&#39; is non-null, operands from</span></div>
<div class="line"><a id="l00500" name="l00500"></a><span class="lineno">  500</span><span class="comment">  /// &#39;sliceState&#39; are added as symbols, and the following constraints are added</span></div>
<div class="line"><a id="l00501" name="l00501"></a><span class="lineno">  501</span><span class="comment">  /// to the system:</span></div>
<div class="line"><a id="l00502" name="l00502"></a><span class="lineno">  502</span><span class="comment">  /// *) Inequality constraints which represent loop bounds for &#39;sliceState&#39;</span></div>
<div class="line"><a id="l00503" name="l00503"></a><span class="lineno">  503</span><span class="comment">  ///    operands which are loop IVS (these represent the destination loop IVs</span></div>
<div class="line"><a id="l00504" name="l00504"></a><span class="lineno">  504</span><span class="comment">  ///    of the slice, and are added as symbols to MemRefRegion&#39;s constraint</span></div>
<div class="line"><a id="l00505" name="l00505"></a><span class="lineno">  505</span><span class="comment">  ///    system).</span></div>
<div class="line"><a id="l00506" name="l00506"></a><span class="lineno">  506</span><span class="comment">  /// *) Inequality constraints for the slice bounds in &#39;sliceState&#39;, which</span></div>
<div class="line"><a id="l00507" name="l00507"></a><span class="lineno">  507</span><span class="comment">  ///    represent the bounds on the loop IVs in this constraint system w.r.t</span></div>
<div class="line"><a id="l00508" name="l00508"></a><span class="lineno">  508</span><span class="comment">  ///    to slice operands (which correspond to symbols).</span></div>
<div class="line"><a id="l00509" name="l00509"></a><span class="lineno">  509</span><span class="comment">  /// If &#39;addMemRefDimBounds&#39; is true, constant upper/lower bounds</span></div>
<div class="line"><a id="l00510" name="l00510"></a><span class="lineno">  510</span><span class="comment">  /// [0, memref.getDimSize(i)) are added for each MemRef dimension &#39;i&#39;.</span></div>
<div class="line"><a id="l00511" name="l00511"></a><span class="lineno">  511</span><span class="comment">  /// If `dropLocalVars` is true, all local variables in `cst` are projected</span></div>
<div class="line"><a id="l00512" name="l00512"></a><span class="lineno">  512</span><span class="comment">  /// out.</span></div>
<div class="line"><a id="l00513" name="l00513"></a><span class="lineno">  513</span><span class="comment">  ///</span></div>
<div class="line"><a id="l00514" name="l00514"></a><span class="lineno">  514</span><span class="comment">  ///  For example, the memref region for this operation at loopDepth = 1 will</span></div>
<div class="line"><a id="l00515" name="l00515"></a><span class="lineno">  515</span><span class="comment">  ///  be:</span></div>
<div class="line"><a id="l00516" name="l00516"></a><span class="lineno">  516</span><span class="comment">  ///</span></div>
<div class="line"><a id="l00517" name="l00517"></a><span class="lineno">  517</span><span class="comment">  ///    affine.for %i = 0 to 32 {</span></div>
<div class="line"><a id="l00518" name="l00518"></a><span class="lineno">  518</span><span class="comment">  ///      affine.for %ii = %i to (d0) -&gt; (d0 + 8) (%i) {</span></div>
<div class="line"><a id="l00519" name="l00519"></a><span class="lineno">  519</span><span class="comment">  ///        load %A[%ii]</span></div>
<div class="line"><a id="l00520" name="l00520"></a><span class="lineno">  520</span><span class="comment">  ///      }</span></div>
<div class="line"><a id="l00521" name="l00521"></a><span class="lineno">  521</span><span class="comment">  ///    }</span></div>
<div class="line"><a id="l00522" name="l00522"></a><span class="lineno">  522</span><span class="comment">  ///</span></div>
<div class="line"><a id="l00523" name="l00523"></a><span class="lineno">  523</span><span class="comment">  ///   {memref = %A, write = false, {%i &lt;= m0 &lt;= %i + 7} }</span></div>
<div class="line"><a id="l00524" name="l00524"></a><span class="lineno">  524</span><span class="comment">  /// The last field is a 2-d FlatAffineValueConstraints symbolic in %i.</span></div>
<div class="line"><a id="l00525" name="l00525"></a><span class="lineno">  525</span><span class="comment">  ///</span></div>
<div class="line"><a id="l00526" name="l00526"></a><span class="lineno">  526</span><span class="comment">  /// If `dropOuterIVs` is true, project out any IVs other than those among</span></div>
<div class="line"><a id="l00527" name="l00527"></a><span class="lineno">  527</span><span class="comment">  /// `loopDepth` surrounding IVs, which would be symbols. If `dropOuterIVs`</span></div>
<div class="line"><a id="l00528" name="l00528"></a><span class="lineno">  528</span><span class="comment">  /// is false, the IVs would be turned into local variables instead of being</span></div>
<div class="line"><a id="l00529" name="l00529"></a><span class="lineno">  529</span><span class="comment">  /// projected out.</span></div>
<div class="line"><a id="l00530" name="l00530"></a><span class="lineno">  530</span>  LogicalResult <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefRegion.html#a60e67b614605337ccb83b83bdaace70c">compute</a>(<a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *op, <span class="keywordtype">unsigned</span> loopDepth,</div>
<div class="line"><a id="l00531" name="l00531"></a><span class="lineno">  531</span>                        <span class="keyword">const</span> <a class="code hl_struct" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState = <span class="keyword">nullptr</span>,</div>
<div class="line"><a id="l00532" name="l00532"></a><span class="lineno">  532</span>                        <span class="keywordtype">bool</span> addMemRefDimBounds = <span class="keyword">true</span>,</div>
<div class="line"><a id="l00533" name="l00533"></a><span class="lineno">  533</span>                        <span class="keywordtype">bool</span> dropLocalVars = <span class="keyword">true</span>, <span class="keywordtype">bool</span> dropOuterIVs = <span class="keyword">true</span>);</div>
<div class="line"><a id="l00534" name="l00534"></a><span class="lineno">  534</span> </div>
<div class="line"><a id="l00535" name="l00535"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#abd8c328086327a660e050f9d525626d5">  535</a></span>  <a class="code hl_class" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *<a class="code hl_function" href="structmlir_1_1affine_1_1MemRefRegion.html#abd8c328086327a660e050f9d525626d5">getConstraints</a>() { <span class="keywordflow">return</span> &amp;<a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefRegion.html#a3d0ae2cb9072efe63434e12545d10486">cst</a>; }</div>
<div class="line"><a id="l00536" name="l00536"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#afc423788ee75197d33435708ce67c2b9">  536</a></span>  <span class="keyword">const</span> <a class="code hl_class" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *<a class="code hl_function" href="structmlir_1_1affine_1_1MemRefRegion.html#afc423788ee75197d33435708ce67c2b9">getConstraints</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;<a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefRegion.html#a3d0ae2cb9072efe63434e12545d10486">cst</a>; }</div>
<div class="line"><a id="l00537" name="l00537"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#a4255fd434f5d6dc27bebe8ffe3198dc7">  537</a></span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefRegion.html#a4255fd434f5d6dc27bebe8ffe3198dc7">isWrite</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefRegion.html#aaa0de038280a27f97e36f354690dbe15">write</a>; }</div>
<div class="line"><a id="l00538" name="l00538"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#ab0382cfe83a9301c5cc63f73a1a1e8d3">  538</a></span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefRegion.html#ab0382cfe83a9301c5cc63f73a1a1e8d3">setWrite</a>(<span class="keywordtype">bool</span> flag) { <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefRegion.html#aaa0de038280a27f97e36f354690dbe15">write</a> = flag; }</div>
<div class="line"><a id="l00539" name="l00539"></a><span class="lineno">  539</span><span class="comment"></span> </div>
<div class="line"><a id="l00540" name="l00540"></a><span class="lineno">  540</span><span class="comment">  /// Returns a constant upper bound on the number of elements in this region if</span></div>
<div class="line"><a id="l00541" name="l00541"></a><span class="lineno">  541</span><span class="comment">  /// bounded by a known constant (always possible for static shapes),</span></div>
<div class="line"><a id="l00542" name="l00542"></a><span class="lineno">  542</span><span class="comment">  /// std::nullopt otherwise. Note that the symbols of the region are treated</span></div>
<div class="line"><a id="l00543" name="l00543"></a><span class="lineno">  543</span><span class="comment">  /// specially, i.e., the returned bounding constant holds for *any given*</span></div>
<div class="line"><a id="l00544" name="l00544"></a><span class="lineno">  544</span><span class="comment">  /// value of the symbol variables. The &#39;shape&#39; vector is set to the</span></div>
<div class="line"><a id="l00545" name="l00545"></a><span class="lineno">  545</span><span class="comment">  /// corresponding dimension-wise bounds major to minor. The number of elements</span></div>
<div class="line"><a id="l00546" name="l00546"></a><span class="lineno">  546</span><span class="comment">  /// and all the dimension-wise bounds are guaranteed to be non-negative. We</span></div>
<div class="line"><a id="l00547" name="l00547"></a><span class="lineno">  547</span><span class="comment">  /// use int64_t instead of uint64_t since index types can be at most</span></div>
<div class="line"><a id="l00548" name="l00548"></a><span class="lineno">  548</span><span class="comment">  /// int64_t. `lbs` are set to the lower bound maps for each of the rank</span></div>
<div class="line"><a id="l00549" name="l00549"></a><span class="lineno">  549</span><span class="comment">  /// dimensions where each of these maps is purely symbolic in the constraints</span></div>
<div class="line"><a id="l00550" name="l00550"></a><span class="lineno">  550</span><span class="comment">  /// set&#39;s symbols.</span></div>
<div class="line"><a id="l00551" name="l00551"></a><span class="lineno">  551</span>  std::optional&lt;int64_t&gt; <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefRegion.html#a02e6b8cc86992af6bcd29f0357072ca6">getConstantBoundingSizeAndShape</a>(</div>
<div class="line"><a id="l00552" name="l00552"></a><span class="lineno">  552</span>      <a class="code hl_class" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;int64_t&gt;</a> *<a class="code hl_namespace" href="namespacemlir_1_1shape.html">shape</a> = <span class="keyword">nullptr</span>,</div>
<div class="line"><a id="l00553" name="l00553"></a><span class="lineno">  553</span>      <a class="code hl_class" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;AffineMap&gt;</a> *lbs = <span class="keyword">nullptr</span>) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00554" name="l00554"></a><span class="lineno">  554</span><span class="comment"></span> </div>
<div class="line"><a id="l00555" name="l00555"></a><span class="lineno">  555</span><span class="comment">  /// Gets the lower and upper bound map for the dimensional variable at</span></div>
<div class="line"><a id="l00556" name="l00556"></a><span class="lineno">  556</span><span class="comment">  /// `pos`.</span></div>
<div class="line"><a id="l00557" name="l00557"></a><span class="lineno">  557</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefRegion.html#a772a10d9c01365d3d3a697f8679e1afc">getLowerAndUpperBound</a>(<span class="keywordtype">unsigned</span> pos, <a class="code hl_class" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;lbMap,</div>
<div class="line"><a id="l00558" name="l00558"></a><span class="lineno">  558</span>                             <a class="code hl_class" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;ubMap) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00559" name="l00559"></a><span class="lineno">  559</span><span class="comment"></span> </div>
<div class="line"><a id="l00560" name="l00560"></a><span class="lineno">  560</span><span class="comment">  /// Returns the size of this MemRefRegion in bytes.</span></div>
<div class="line"><a id="l00561" name="l00561"></a><span class="lineno">  561</span>  std::optional&lt;int64_t&gt; <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefRegion.html#a8fb53fa6d699f6834738fa2f220ac783">getRegionSize</a>();</div>
<div class="line"><a id="l00562" name="l00562"></a><span class="lineno">  562</span> </div>
<div class="line"><a id="l00563" name="l00563"></a><span class="lineno">  563</span>  <span class="comment">// Wrapper around FlatAffineValueConstraints::unionBoundingBox.</span></div>
<div class="line"><a id="l00564" name="l00564"></a><span class="lineno">  564</span>  LogicalResult <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefRegion.html#aa2761578967822bb7853e072a1a29bac">unionBoundingBox</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> &amp;other);</div>
<div class="line"><a id="l00565" name="l00565"></a><span class="lineno">  565</span><span class="comment"></span> </div>
<div class="line"><a id="l00566" name="l00566"></a><span class="lineno">  566</span><span class="comment">  /// Returns the rank of the memref that this region corresponds to.</span></div>
<div class="line"><a id="l00567" name="l00567"></a><span class="lineno">  567</span>  <span class="keywordtype">unsigned</span> <a class="code hl_function" href="structmlir_1_1affine_1_1MemRefRegion.html#a22317444c57ececdfd0b3f5497d1971c">getRank</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l00568" name="l00568"></a><span class="lineno">  568</span><span class="comment"></span> </div>
<div class="line"><a id="l00569" name="l00569"></a><span class="lineno">  569</span><span class="comment">  /// Memref that this region corresponds to.</span></div>
<div class="line"><a id="l00570" name="l00570"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#ac097fcae970f4cd44eb14f9484deaf43">  570</a></span>  <a class="code hl_class" href="classmlir_1_1Value.html">Value</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefRegion.html#ac097fcae970f4cd44eb14f9484deaf43">memref</a>;</div>
<div class="line"><a id="l00571" name="l00571"></a><span class="lineno">  571</span><span class="comment"></span> </div>
<div class="line"><a id="l00572" name="l00572"></a><span class="lineno">  572</span><span class="comment">  /// Read or write.</span></div>
<div class="line"><a id="l00573" name="l00573"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#aaa0de038280a27f97e36f354690dbe15">  573</a></span>  <span class="keywordtype">bool</span> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefRegion.html#aaa0de038280a27f97e36f354690dbe15">write</a> = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00574" name="l00574"></a><span class="lineno">  574</span><span class="comment"></span> </div>
<div class="line"><a id="l00575" name="l00575"></a><span class="lineno">  575</span><span class="comment">  /// If there is more than one load/store op associated with the region, the</span></div>
<div class="line"><a id="l00576" name="l00576"></a><span class="lineno">  576</span><span class="comment">  /// location information would correspond to one of those op&#39;s.</span></div>
<div class="line"><a id="l00577" name="l00577"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">  577</a></span>  <a class="code hl_class" href="classmlir_1_1Location.html">Location</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">loc</a>;</div>
<div class="line"><a id="l00578" name="l00578"></a><span class="lineno">  578</span><span class="comment"></span> </div>
<div class="line"><a id="l00579" name="l00579"></a><span class="lineno">  579</span><span class="comment">  /// Region (data space) of the memref accessed. This set will thus have at</span></div>
<div class="line"><a id="l00580" name="l00580"></a><span class="lineno">  580</span><span class="comment">  /// least as many dimensional variables as the shape dimensionality of the</span></div>
<div class="line"><a id="l00581" name="l00581"></a><span class="lineno">  581</span><span class="comment">  /// memref, and these are the leading dimensions of the set appearing in that</span></div>
<div class="line"><a id="l00582" name="l00582"></a><span class="lineno">  582</span><span class="comment">  /// order (major to minor / outermost to innermost). There may be additional</span></div>
<div class="line"><a id="l00583" name="l00583"></a><span class="lineno">  583</span><span class="comment">  /// variables since getMemRefRegion() is called with a specific loop depth,</span></div>
<div class="line"><a id="l00584" name="l00584"></a><span class="lineno">  584</span><span class="comment">  /// and thus the region is symbolic in the outer surrounding loops at that</span></div>
<div class="line"><a id="l00585" name="l00585"></a><span class="lineno">  585</span><span class="comment">  /// depth.</span></div>
<div class="line"><a id="l00586" name="l00586"></a><span class="lineno"><a class="line" href="structmlir_1_1affine_1_1MemRefRegion.html#a3d0ae2cb9072efe63434e12545d10486">  586</a></span>  <a class="code hl_class" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> <a class="code hl_variable" href="structmlir_1_1affine_1_1MemRefRegion.html#a3d0ae2cb9072efe63434e12545d10486">cst</a>;</div>
<div class="line"><a id="l00587" name="l00587"></a><span class="lineno">  587</span>};</div>
</div>
<div class="line"><a id="l00588" name="l00588"></a><span class="lineno">  588</span><span class="comment"></span> </div>
<div class="line"><a id="l00589" name="l00589"></a><span class="lineno">  589</span><span class="comment">/// Returns the size of a memref with element type int or float in bytes if it&#39;s</span></div>
<div class="line"><a id="l00590" name="l00590"></a><span class="lineno">  590</span><span class="comment">/// statically shaped, std::nullopt otherwise.</span></div>
<div class="line"><a id="l00591" name="l00591"></a><span class="lineno">  591</span>std::optional&lt;uint64_t&gt; <a class="code hl_function" href="namespacemlir_1_1affine.html#ac5e109cfdab6f0859fbbc3e0bf08ebac">getIntOrFloatMemRefSizeInBytes</a>(MemRefType memRefType);</div>
<div class="line"><a id="l00592" name="l00592"></a><span class="lineno">  592</span><span class="comment"></span> </div>
<div class="line"><a id="l00593" name="l00593"></a><span class="lineno">  593</span><span class="comment">/// Checks a load or store op for an out of bound access; returns failure if the</span></div>
<div class="line"><a id="l00594" name="l00594"></a><span class="lineno">  594</span><span class="comment">/// access is out of bounds along any of the dimensions, success otherwise.</span></div>
<div class="line"><a id="l00595" name="l00595"></a><span class="lineno">  595</span><span class="comment">/// Emits a diagnostic error (with location information) if emitError is true.</span></div>
<div class="line"><a id="l00596" name="l00596"></a><span class="lineno">  596</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> LoadOrStoreOpPo<span class="keywordtype">int</span>er&gt;</div>
<div class="line"><a id="l00597" name="l00597"></a><span class="lineno"><a class="line" href="namespacemlir_1_1affine.html#addef193d35d8d7990addced6bcb731c1">  597</a></span>LogicalResult <a class="code hl_function" href="namespacemlir_1_1affine.html#addef193d35d8d7990addced6bcb731c1">boundCheckLoadOrStoreOp</a>(LoadOrStoreOpPointer loadOrStoreOp,</div>
<div class="line"><a id="l00598" name="l00598"></a><span class="lineno">  598</span>                                      <span class="keywordtype">bool</span> <a class="code hl_function" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a> = <span class="keyword">true</span>);</div>
<div class="line"><a id="l00599" name="l00599"></a><span class="lineno">  599</span><span class="comment"></span> </div>
<div class="line"><a id="l00600" name="l00600"></a><span class="lineno">  600</span><span class="comment">/// Returns the number of surrounding loops common to both A and B.</span></div>
<div class="line"><a id="l00601" name="l00601"></a><span class="lineno">  601</span><span class="keywordtype">unsigned</span> <a class="code hl_function" href="namespacemlir_1_1affine.html#a3a39bbf8628440572cdd76a10d58dc53">getNumCommonSurroundingLoops</a>(<a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> &amp;a, <a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> &amp;<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>);</div>
<div class="line"><a id="l00602" name="l00602"></a><span class="lineno">  602</span><span class="comment"></span> </div>
<div class="line"><a id="l00603" name="l00603"></a><span class="lineno">  603</span><span class="comment">/// Gets the memory footprint of all data touched in the specified memory space</span></div>
<div class="line"><a id="l00604" name="l00604"></a><span class="lineno">  604</span><span class="comment">/// in bytes; if the memory space is unspecified, considers all memory spaces.</span></div>
<div class="line"><a id="l00605" name="l00605"></a><span class="lineno">  605</span>std::optional&lt;int64_t&gt; <a class="code hl_function" href="namespacemlir_1_1affine.html#a93666d2fb7a3b0598ecf69542f1a5ab7">getMemoryFootprintBytes</a>(AffineForOp forOp,</div>
<div class="line"><a id="l00606" name="l00606"></a><span class="lineno">  606</span>                                               <span class="keywordtype">int</span> memorySpace = -1);</div>
<div class="line"><a id="l00607" name="l00607"></a><span class="lineno">  607</span><span class="comment"></span> </div>
<div class="line"><a id="l00608" name="l00608"></a><span class="lineno">  608</span><span class="comment">/// Returns the memref&#39;s element type&#39;s size in bytes where the elemental type</span></div>
<div class="line"><a id="l00609" name="l00609"></a><span class="lineno">  609</span><span class="comment">/// is an int or float or a vector of such types.</span></div>
<div class="line"><a id="l00610" name="l00610"></a><span class="lineno">  610</span>std::optional&lt;int64_t&gt; <a class="code hl_function" href="namespacemlir_1_1affine.html#afd9e0f536b1471778961ba51c2227f07">getMemRefIntOrFloatEltSizeInBytes</a>(MemRefType memRefType);</div>
<div class="line"><a id="l00611" name="l00611"></a><span class="lineno">  611</span><span class="comment"></span> </div>
<div class="line"><a id="l00612" name="l00612"></a><span class="lineno">  612</span><span class="comment">/// Simplify the integer set by simplifying the underlying affine expressions by</span></div>
<div class="line"><a id="l00613" name="l00613"></a><span class="lineno">  613</span><span class="comment">/// flattening and some simple inference. Also, drop any duplicate constraints.</span></div>
<div class="line"><a id="l00614" name="l00614"></a><span class="lineno">  614</span><span class="comment">/// Returns the simplified integer set. This method runs in time linear in the</span></div>
<div class="line"><a id="l00615" name="l00615"></a><span class="lineno">  615</span><span class="comment">/// number of constraints.</span></div>
<div class="line"><a id="l00616" name="l00616"></a><span class="lineno">  616</span><a class="code hl_class" href="classmlir_1_1IntegerSet.html">IntegerSet</a> <a class="code hl_function" href="namespacemlir_1_1affine.html#a1f2e85e904cf88ca63479dad00941e87">simplifyIntegerSet</a>(<a class="code hl_class" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set);</div>
<div class="line"><a id="l00617" name="l00617"></a><span class="lineno">  617</span><span class="comment"></span> </div>
<div class="line"><a id="l00618" name="l00618"></a><span class="lineno">  618</span><span class="comment">/// Returns the innermost common loop depth for the set of operations in &#39;ops&#39;.</span></div>
<div class="line"><a id="l00619" name="l00619"></a><span class="lineno">  619</span><span class="keywordtype">unsigned</span> <a class="code hl_function" href="namespacemlir_1_1affine.html#a9cc3df9a0cea6ad3bf48958ad2d54128">getInnermostCommonLoopDepth</a>(</div>
<div class="line"><a id="l00620" name="l00620"></a><span class="lineno">  620</span>    <a class="code hl_class" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Operation *&gt;</a> ops,</div>
<div class="line"><a id="l00621" name="l00621"></a><span class="lineno">  621</span>    <a class="code hl_class" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;AffineForOp&gt;</a> *surroundingLoops = <span class="keyword">nullptr</span>);</div>
<div class="line"><a id="l00622" name="l00622"></a><span class="lineno">  622</span><span class="comment"></span> </div>
<div class="line"><a id="l00623" name="l00623"></a><span class="lineno">  623</span><span class="comment">/// Try to simplify the given affine.min or affine.max op to an affine map with</span></div>
<div class="line"><a id="l00624" name="l00624"></a><span class="lineno">  624</span><span class="comment">/// a single result and operands, taking into account the specified constraint</span></div>
<div class="line"><a id="l00625" name="l00625"></a><span class="lineno">  625</span><span class="comment">/// set. Return failure if no simplified version could be found.</span></div>
<div class="line"><a id="l00626" name="l00626"></a><span class="lineno">  626</span>FailureOr&lt;AffineValueMap&gt;</div>
<div class="line"><a id="l00627" name="l00627"></a><span class="lineno">  627</span><a class="code hl_function" href="namespacemlir_1_1affine.html#af4c9fec2934b9a14a5883e9fabbe3f49">simplifyConstrainedMinMaxOp</a>(<a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *op,</div>
<div class="line"><a id="l00628" name="l00628"></a><span class="lineno">  628</span>                            <a class="code hl_class" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> constraints);</div>
<div class="line"><a id="l00629" name="l00629"></a><span class="lineno">  629</span><span class="comment"></span> </div>
<div class="line"><a id="l00630" name="l00630"></a><span class="lineno">  630</span><span class="comment">/// Find the innermost common `Block` of `a` and `b` in the affine scope</span></div>
<div class="line"><a id="l00631" name="l00631"></a><span class="lineno">  631</span><span class="comment">/// that `a` and `b` are part of. Return nullptr if they belong to different</span></div>
<div class="line"><a id="l00632" name="l00632"></a><span class="lineno">  632</span><span class="comment">/// affine scopes. Also, return nullptr if they do not have a common `Block`</span></div>
<div class="line"><a id="l00633" name="l00633"></a><span class="lineno">  633</span><span class="comment">/// ancestor (for eg., when they are part of the `then` and `else` regions</span></div>
<div class="line"><a id="l00634" name="l00634"></a><span class="lineno">  634</span><span class="comment">/// of an op that itself starts an affine scope.</span></div>
<div class="line"><a id="l00635" name="l00635"></a><span class="lineno">  635</span><a class="code hl_class" href="classmlir_1_1Block.html">mlir::Block</a> *<a class="code hl_function" href="namespacemlir_1_1affine.html#ae33ee1431de2b7e6802c9270b1ff60d1">findInnermostCommonBlockInScope</a>(<a class="code hl_class" href="classmlir_1_1Operation.html">mlir::Operation</a> *a,</div>
<div class="line"><a id="l00636" name="l00636"></a><span class="lineno">  636</span>                                             <a class="code hl_class" href="classmlir_1_1Operation.html">mlir::Operation</a> *<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>);</div>
<div class="line"><a id="l00637" name="l00637"></a><span class="lineno">  637</span> </div>
<div class="line"><a id="l00638" name="l00638"></a><span class="lineno">  638</span>} <span class="comment">// namespace affine</span></div>
<div class="line"><a id="l00639" name="l00639"></a><span class="lineno">  639</span>} <span class="comment">// namespace mlir</span></div>
<div class="line"><a id="l00640" name="l00640"></a><span class="lineno">  640</span> </div>
<div class="line"><a id="l00641" name="l00641"></a><span class="lineno">  641</span><span class="preprocessor">#endif </span><span class="comment">// MLIR_DIALECT_AFFINE_ANALYSIS_UTILS_H</span></div>
<div class="ttc" id="aAffineOps_8h_html"><div class="ttname"><a href="AffineOps_8h.html">AffineOps.h</a></div></div>
<div class="ttc" id="aAffineStructures_8h_html"><div class="ttname"><a href="AffineStructures_8h.html">AffineStructures.h</a></div></div>
<div class="ttc" id="aLinalgTransformOps_8cpp_html_a21ad0bd836b90d08f4cf640b4c298e7c"><div class="ttname"><a href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a></div><div class="ttdeci">b</div><div class="ttdoc">Return true if permutation is a valid permutation of the outer_dims_perm (case OuterOrInnerPerm::Oute...</div><div class="ttdef"><b>Definition</b> <a href="LinalgTransformOps_8cpp_source.html#l02097">LinalgTransformOps.cpp:2097</a></div></div>
<div class="ttc" id="aclassllvm_1_1ArrayRef_html"><div class="ttname"><a href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a></div><div class="ttdef"><b>Definition</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00048">LLVM.h:48</a></div></div>
<div class="ttc" id="aclassllvm_1_1SmallVectorImpl_html"><div class="ttname"><a href="classllvm_1_1SmallVectorImpl.html">llvm::SmallVectorImpl</a></div><div class="ttdef"><b>Definition</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00074">LLVM.h:74</a></div></div>
<div class="ttc" id="aclassllvm_1_1SmallVector_html"><div class="ttname"><a href="classllvm_1_1SmallVector.html">llvm::SmallVector</a></div><div class="ttdef"><b>Definition</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00072">LLVM.h:72</a></div></div>
<div class="ttc" id="aclassmlir_1_1AffineMap_html"><div class="ttname"><a href="classmlir_1_1AffineMap.html">mlir::AffineMap</a></div><div class="ttdoc">A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.</div><div class="ttdef"><b>Definition</b> <a href="mlir_2IR_2AffineMap_8h_source.html#l00046">AffineMap.h:46</a></div></div>
<div class="ttc" id="aclassmlir_1_1Block_html"><div class="ttname"><a href="classmlir_1_1Block.html">mlir::Block</a></div><div class="ttdoc">Block represents an ordered list of Operations.</div><div class="ttdef"><b>Definition</b> <a href="Block_8h_source.html#l00032">Block.h:33</a></div></div>
<div class="ttc" id="aclassmlir_1_1Block_html_a0ea87a88ccca470d216809e2a162d909"><div class="ttname"><a href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">mlir::Block::iterator</a></div><div class="ttdeci">OpListType::iterator iterator</div><div class="ttdef"><b>Definition</b> <a href="Block_8h_source.html#l00140">Block.h:140</a></div></div>
<div class="ttc" id="aclassmlir_1_1IntegerSet_html"><div class="ttname"><a href="classmlir_1_1IntegerSet.html">mlir::IntegerSet</a></div><div class="ttdoc">An integer set representing a conjunction of one or more affine equalities and inequalities.</div><div class="ttdef"><b>Definition</b> <a href="mlir_2IR_2IntegerSet_8h_source.html#l00044">IntegerSet.h:44</a></div></div>
<div class="ttc" id="aclassmlir_1_1Location_html"><div class="ttname"><a href="classmlir_1_1Location.html">mlir::Location</a></div><div class="ttdoc">This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...</div><div class="ttdef"><b>Definition</b> <a href="Location_8h_source.html#l00076">Location.h:76</a></div></div>
<div class="ttc" id="aclassmlir_1_1Operation_html"><div class="ttname"><a href="classmlir_1_1Operation.html">mlir::Operation</a></div><div class="ttdoc">Operation is the basic unit of execution within MLIR.</div><div class="ttdef"><b>Definition</b> <a href="IR_2Operation_8h_source.html#l00084">Operation.h:88</a></div></div>
<div class="ttc" id="aclassmlir_1_1Value_html"><div class="ttname"><a href="classmlir_1_1Value.html">mlir::Value</a></div><div class="ttdoc">This class represents an instance of an SSA value in the MLIR system, representing a computable value...</div><div class="ttdef"><b>Definition</b> <a href="Value_8h_source.html#l00096">Value.h:96</a></div></div>
<div class="ttc" id="aclassmlir_1_1affine_1_1AffineValueMap_html"><div class="ttname"><a href="classmlir_1_1affine_1_1AffineValueMap.html">mlir::affine::AffineValueMap</a></div><div class="ttdoc">An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes.</div><div class="ttdef"><b>Definition</b> <a href="AffineValueMap_8h_source.html#l00035">AffineValueMap.h:35</a></div></div>
<div class="ttc" id="aclassmlir_1_1affine_1_1FlatAffineValueConstraints_html"><div class="ttname"><a href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">mlir::affine::FlatAffineValueConstraints</a></div><div class="ttdoc">FlatAffineValueConstraints is an extension of FlatLinearValueConstraints with helper functions for Af...</div><div class="ttdef"><b>Definition</b> <a href="AffineStructures_8h_source.html#l00044">AffineStructures.h:44</a></div></div>
<div class="ttc" id="aclassmlir_1_1raw__ostream_html"><div class="ttname"><a href="classmlir_1_1raw__ostream.html">mlir::raw_ostream</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html"><div class="ttname"><a href="namespacemlir_1_1affine.html">mlir::affine</a></div><div class="ttdef"><b>Definition</b> <a href="AffineToStandard_8h_source.html#l00023">AffineToStandard.h:23</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a1f2e85e904cf88ca63479dad00941e87"><div class="ttname"><a href="namespacemlir_1_1affine.html#a1f2e85e904cf88ca63479dad00941e87">mlir::affine::simplifyIntegerSet</a></div><div class="ttdeci">IntegerSet simplifyIntegerSet(IntegerSet set)</div><div class="ttdoc">Simplify the integer set by simplifying the underlying affine expressions by flattening and some simp...</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02200">Utils.cpp:2200</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a1f8e59ec9faff34b64ebb0411a383c3a"><div class="ttname"><a href="namespacemlir_1_1affine.html#a1f8e59ec9faff34b64ebb0411a383c3a">mlir::affine::getEnclosingAffineOps</a></div><div class="ttdeci">void getEnclosingAffineOps(Operation &amp;op, SmallVectorImpl&lt; Operation * &gt; *ops)</div><div class="ttdoc">Populates &#39;ops&#39; with affine operations enclosing op ordered from outermost to innermost while stoppin...</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00865">Utils.cpp:865</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a29213ed6d6cdad5cdd69bb66c6df863f"><div class="ttname"><a href="namespacemlir_1_1affine.html#a29213ed6d6cdad5cdd69bb66c6df863f">mlir::affine::computeSliceUnion</a></div><div class="ttdeci">SliceComputationResult computeSliceUnion(ArrayRef&lt; Operation * &gt; opsA, ArrayRef&lt; Operation * &gt; opsB, unsigned loopDepth, unsigned numCommonLoops, bool isBackwardSlice, ComputationSliceState *sliceUnion)</div><div class="ttdoc">Computes in &#39;sliceUnion&#39; the union of all slice bounds computed at &#39;loopDepth&#39; between all dependent ...</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">Utils.cpp:1633</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a34c1ca39d435d06366058d16b5fe4225"><div class="ttname"><a href="namespacemlir_1_1affine.html#a34c1ca39d435d06366058d16b5fe4225">mlir::affine::isLoopParallelAndContainsReduction</a></div><div class="ttdeci">bool isLoopParallelAndContainsReduction(AffineForOp forOp)</div><div class="ttdoc">Returns whether a loop is a parallel loop and contains a reduction loop.</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02182">Utils.cpp:2182</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a3a39bbf8628440572cdd76a10d58dc53"><div class="ttname"><a href="namespacemlir_1_1affine.html#a3a39bbf8628440572cdd76a10d58dc53">mlir::affine::getNumCommonSurroundingLoops</a></div><div class="ttdeci">unsigned getNumCommonSurroundingLoops(Operation &amp;a, Operation &amp;b)</div><div class="ttdoc">Returns the number of surrounding loops common to both A and B.</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02108">Utils.cpp:2108</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a50b5b72a6baee24bfab9faebd198fe9b"><div class="ttname"><a href="namespacemlir_1_1affine.html#a50b5b72a6baee24bfab9faebd198fe9b">mlir::affine::getAffineIVs</a></div><div class="ttdeci">void getAffineIVs(Operation &amp;op, SmallVectorImpl&lt; Value &gt; &amp;ivs)</div><div class="ttdoc">Populates &#39;ivs&#39; with IVs of the surrounding affine.for and affine.parallel ops ordered from the outer...</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02091">Utils.cpp:2091</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a5ad383995f97dc30a0d6891e33fd499a"><div class="ttname"><a href="namespacemlir_1_1affine.html#a5ad383995f97dc30a0d6891e33fd499a">mlir::affine::getSequentialLoops</a></div><div class="ttdeci">void getSequentialLoops(AffineForOp forOp, llvm::SmallDenseSet&lt; Value, 8 &gt; *sequentialLoops)</div><div class="ttdoc">Returns in &#39;sequentialLoops&#39; all sequential loops in loop nest rooted at &#39;forOp&#39;.</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02191">Utils.cpp:2191</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a9085efe05b8bc0b7c3b4f643d70eb1e7"><div class="ttname"><a href="namespacemlir_1_1affine.html#a9085efe05b8bc0b7c3b4f643d70eb1e7">mlir::affine::getAffineForIVs</a></div><div class="ttdeci">void getAffineForIVs(Operation &amp;op, SmallVectorImpl&lt; AffineForOp &gt; *loops)</div><div class="ttdoc">Populates &#39;loops&#39; with IVs of the affine.for ops surrounding &#39;op&#39; ordered from the outermost &#39;affine....</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00851">Utils.cpp:851</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a93666d2fb7a3b0598ecf69542f1a5ab7"><div class="ttname"><a href="namespacemlir_1_1affine.html#a93666d2fb7a3b0598ecf69542f1a5ab7">mlir::affine::getMemoryFootprintBytes</a></div><div class="ttdeci">std::optional&lt; int64_t &gt; getMemoryFootprintBytes(AffineForOp forOp, int memorySpace=-1)</div><div class="ttdoc">Gets the memory footprint of all data touched in the specified memory space in bytes; if the memory s...</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02173">Utils.cpp:2173</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_a9cc3df9a0cea6ad3bf48958ad2d54128"><div class="ttname"><a href="namespacemlir_1_1affine.html#a9cc3df9a0cea6ad3bf48958ad2d54128">mlir::affine::getInnermostCommonLoopDepth</a></div><div class="ttdeci">unsigned getInnermostCommonLoopDepth(ArrayRef&lt; Operation * &gt; ops, SmallVectorImpl&lt; AffineForOp &gt; *surroundingLoops=nullptr)</div><div class="ttdoc">Returns the innermost common loop depth for the set of operations in &#39;ops&#39;.</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01601">Utils.cpp:1601</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_ab6cceed0c6debb9af0d3bd76c9ed52f4"><div class="ttname"><a href="namespacemlir_1_1affine.html#ab6cceed0c6debb9af0d3bd76c9ed52f4">mlir::affine::getComputationSliceState</a></div><div class="ttdeci">void getComputationSliceState(Operation *depSourceOp, Operation *depSinkOp, const FlatAffineValueConstraints &amp;dependenceConstraints, unsigned loopDepth, bool isBackwardSlice, ComputationSliceState *sliceState)</div><div class="ttdoc">Computes the computation slice loop bounds for one loop nest as affine maps of the other loop nest&#39;s ...</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01870">Utils.cpp:1870</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_ac5e109cfdab6f0859fbbc3e0bf08ebac"><div class="ttname"><a href="namespacemlir_1_1affine.html#ac5e109cfdab6f0859fbbc3e0bf08ebac">mlir::affine::getIntOrFloatMemRefSizeInBytes</a></div><div class="ttdeci">std::optional&lt; uint64_t &gt; getIntOrFloatMemRefSizeInBytes(MemRefType memRefType)</div><div class="ttdoc">Returns the size of a memref with element type int or float in bytes if it&#39;s statically shaped,...</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01463">Utils.cpp:1463</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_ac82ec61d5cae9ebb4489d2ab9ad6e8f8"><div class="ttname"><a href="namespacemlir_1_1affine.html#ac82ec61d5cae9ebb4489d2ab9ad6e8f8">mlir::affine::getNestingDepth</a></div><div class="ttdeci">unsigned getNestingDepth(Operation *op)</div><div class="ttdoc">Returns the nesting depth of this operation, i.e., the number of loops surrounding this operation.</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02063">Utils.cpp:2063</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_acfb5cde2210f8126b02cd84843a0c43b"><div class="ttname"><a href="namespacemlir_1_1affine.html#acfb5cde2210f8126b02cd84843a0c43b">mlir::affine::getSliceIterationCount</a></div><div class="ttdeci">uint64_t getSliceIterationCount(const llvm::SmallDenseMap&lt; Operation *, uint64_t, 8 &gt; &amp;sliceTripCountMap)</div><div class="ttdoc">Return the number of iterations for the slicetripCountMap provided.</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01856">Utils.cpp:1856</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_addef193d35d8d7990addced6bcb731c1"><div class="ttname"><a href="namespacemlir_1_1affine.html#addef193d35d8d7990addced6bcb731c1">mlir::affine::boundCheckLoadOrStoreOp</a></div><div class="ttdeci">LogicalResult boundCheckLoadOrStoreOp(LoadOrStoreOpPointer loadOrStoreOp, bool emitError=true)</div><div class="ttdoc">Checks a load or store op for an out of bound access; returns failure if the access is out of bounds ...</div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_ae33ee1431de2b7e6802c9270b1ff60d1"><div class="ttname"><a href="namespacemlir_1_1affine.html#ae33ee1431de2b7e6802c9270b1ff60d1">mlir::affine::findInnermostCommonBlockInScope</a></div><div class="ttdeci">mlir::Block * findInnermostCommonBlockInScope(mlir::Operation *a, mlir::Operation *b)</div><div class="ttdoc">Find the innermost common Block of a and b in the affine scope that a and b are part of.</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02391">Utils.cpp:2391</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_af1b7ee261b2662fe2f0c257c9e04f3b6"><div class="ttname"><a href="namespacemlir_1_1affine.html#af1b7ee261b2662fe2f0c257c9e04f3b6">mlir::affine::buildSliceTripCountMap</a></div><div class="ttdeci">bool buildSliceTripCountMap(const ComputationSliceState &amp;slice, llvm::SmallDenseMap&lt; Operation *, uint64_t, 8 &gt; *tripCountMap)</div><div class="ttdoc">Builds a map &#39;tripCountMap&#39; from AffineForOp to constant trip count for loop nest surrounding represe...</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01818">Utils.cpp:1818</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_af32168fb86ad493527c61d139acee48a"><div class="ttname"><a href="namespacemlir_1_1affine.html#af32168fb86ad493527c61d139acee48a">mlir::affine::insertBackwardComputationSlice</a></div><div class="ttdeci">AffineForOp insertBackwardComputationSlice(Operation *srcOpInst, Operation *dstOpInst, unsigned dstLoopDepth, ComputationSliceState *sliceState)</div><div class="ttdoc">Creates a clone of the computation contained in the loop nest surrounding &#39;srcOpInst&#39;,...</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01982">Utils.cpp:1982</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_af4c9fec2934b9a14a5883e9fabbe3f49"><div class="ttname"><a href="namespacemlir_1_1affine.html#af4c9fec2934b9a14a5883e9fabbe3f49">mlir::affine::simplifyConstrainedMinMaxOp</a></div><div class="ttdeci">FailureOr&lt; AffineValueMap &gt; simplifyConstrainedMinMaxOp(Operation *op, FlatAffineValueConstraints constraints)</div><div class="ttdoc">Try to simplify the given affine.min or affine.max op to an affine map with a single result and opera...</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02286">Utils.cpp:2286</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html_afd9e0f536b1471778961ba51c2227f07"><div class="ttname"><a href="namespacemlir_1_1affine.html#afd9e0f536b1471778961ba51c2227f07">mlir::affine::getMemRefIntOrFloatEltSizeInBytes</a></div><div class="ttdeci">std::optional&lt; int64_t &gt; getMemRefIntOrFloatEltSizeInBytes(MemRefType memRefType)</div><div class="ttdoc">Returns the memref&#39;s element type&#39;s size in bytes where the elemental type is an int or float or a ve...</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01419">Utils.cpp:1419</a></div></div>
<div class="ttc" id="anamespacemlir_1_1memref_html"><div class="ttname"><a href="namespacemlir_1_1memref.html">mlir::memref</a></div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Passes_8h_source.html#l00026">Passes.h:26</a></div></div>
<div class="ttc" id="anamespacemlir_1_1shape_html"><div class="ttname"><a href="namespacemlir_1_1shape.html">mlir::shape</a></div><div class="ttdef"><b>Definition</b> <a href="ShapeMappingAnalysis_8h_source.html#l00020">ShapeMappingAnalysis.h:20</a></div></div>
<div class="ttc" id="anamespacemlir_html"><div class="ttname"><a href="namespacemlir.html">mlir</a></div><div class="ttdoc">Include the generated interface declarations.</div><div class="ttdef"><b>Definition</b> <a href="AliasAnalysis_8h_source.html#l00019">AliasAnalysis.h:19</a></div></div>
<div class="ttc" id="anamespacemlir_html_a4aa33aa05f4fcff8a40613b43fb06f01"><div class="ttname"><a href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">mlir::DenseSet</a></div><div class="ttdeci">llvm::DenseSet&lt; ValueT, ValueInfoT &gt; DenseSet</div><div class="ttdef"><b>Definition</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00128">LLVM.h:128</a></div></div>
<div class="ttc" id="anamespacemlir_html_a4e96b0c437652eb5a4890734bb6bcee7"><div class="ttname"><a href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">mlir::emitError</a></div><div class="ttdeci">InFlightDiagnostic emitError(Location loc)</div><div class="ttdoc">Utility method to emit an error message using this location.</div><div class="ttdef"><b>Definition</b> <a href="IR_2Diagnostics_8cpp_source.html#l00332">Diagnostics.cpp:332</a></div></div>
<div class="ttc" id="anamespacemlir_html_abde461319ad5039ddbf5b4e70f47618b"><div class="ttname"><a href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">mlir::DenseMap</a></div><div class="ttdeci">llvm::DenseMap&lt; KeyT, ValueT, KeyInfoT, BucketT &gt; DenseMap</div><div class="ttdef"><b>Definition</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00126">LLVM.h:126</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html">mlir::affine::ComputationSliceState</a></div><div class="ttdoc">ComputationSliceState aggregates loop IVs, loop bound AffineMaps and their associated operands for a ...</div><div class="ttdef"><b>Definition</b> <a href="#l00318">Utils.h:318</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_a09a810c2f49cc44e2c5de12c6caf2727"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#a09a810c2f49cc44e2c5de12c6caf2727">mlir::affine::ComputationSliceState::isSliceValid</a></div><div class="ttdeci">std::optional&lt; bool &gt; isSliceValid() const</div><div class="ttdoc">Checks the validity of the slice computed.</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01036">Utils.cpp:1036</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_a140bf9ff4200613fb5822bed2f1bfc18"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#a140bf9ff4200613fb5822bed2f1bfc18">mlir::affine::ComputationSliceState::ivs</a></div><div class="ttdeci">SmallVector&lt; Value, 4 &gt; ivs</div><div class="ttdef"><b>Definition</b> <a href="#l00321">Utils.h:321</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_a23715baf2fcbb66e2acd9db32956f40e"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#a23715baf2fcbb66e2acd9db32956f40e">mlir::affine::ComputationSliceState::dump</a></div><div class="ttdeci">void dump() const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00941">Utils.cpp:941</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_a2a55ff23adbc2491f154ec4074c665d6"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#a2a55ff23adbc2491f154ec4074c665d6">mlir::affine::ComputationSliceState::getAsConstraints</a></div><div class="ttdeci">LogicalResult getAsConstraints(FlatAffineValueConstraints *cst) const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00898">Utils.cpp:898</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_a6662e2d7b1582bfe4ff4f64eea403432"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#a6662e2d7b1582bfe4ff4f64eea403432">mlir::affine::ComputationSliceState::isEmpty</a></div><div class="ttdeci">bool isEmpty() const</div><div class="ttdoc">Returns true if the computation slice is empty.</div><div class="ttdef"><b>Definition</b> <a href="#l00350">Utils.h:350</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_a9b06d992ca662858732225827937c1f7"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#a9b06d992ca662858732225827937c1f7">mlir::affine::ComputationSliceState::getSourceAsConstraints</a></div><div class="ttdeci">LogicalResult getSourceAsConstraints(FlatAffineValueConstraints &amp;cst) const</div><div class="ttdoc">Adds to &#39;cst&#39; constraints which represent the original loop bounds on &#39;ivs&#39; in &#39;this&#39;.</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00882">Utils.cpp:882</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_aa3215ff59c18264fa4e846d9a2d5615f"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#aa3215ff59c18264fa4e846d9a2d5615f">mlir::affine::ComputationSliceState::ubOperands</a></div><div class="ttdeci">std::vector&lt; SmallVector&lt; Value, 4 &gt; &gt; ubOperands</div><div class="ttdef"><b>Definition</b> <a href="#l00329">Utils.h:329</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_ab0148e60f0d8d38822992cf91eb87b5b"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#ab0148e60f0d8d38822992cf91eb87b5b">mlir::affine::ComputationSliceState::ubs</a></div><div class="ttdeci">SmallVector&lt; AffineMap, 4 &gt; ubs</div><div class="ttdef"><b>Definition</b> <a href="#l00325">Utils.h:325</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_abc7052b611c0772f9c551ee0d4b33d92"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#abc7052b611c0772f9c551ee0d4b33d92">mlir::affine::ComputationSliceState::isMaximal</a></div><div class="ttdeci">std::optional&lt; bool &gt; isMaximal() const</div><div class="ttdoc">Returns true if the computation slice encloses all the iterations of the sliced loop nest.</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01106">Utils.cpp:1106</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_ade6c510051faa671f7758989e38b491d"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#ade6c510051faa671f7758989e38b491d">mlir::affine::ComputationSliceState::lbs</a></div><div class="ttdeci">SmallVector&lt; AffineMap, 4 &gt; lbs</div><div class="ttdef"><b>Definition</b> <a href="#l00323">Utils.h:323</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_ae01fc5e4aa59b1624613835b69c219a6"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#ae01fc5e4aa59b1624613835b69c219a6">mlir::affine::ComputationSliceState::clearBounds</a></div><div class="ttdeci">void clearBounds()</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00934">Utils.cpp:934</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_afc69fcff6c39da7525bb1c61b91c4492"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#afc69fcff6c39da7525bb1c61b91c4492">mlir::affine::ComputationSliceState::insertPoint</a></div><div class="ttdeci">Block::iterator insertPoint</div><div class="ttdef"><b>Definition</b> <a href="#l00331">Utils.h:331</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1ComputationSliceState_html_afd8aa32fa351614ef5060a1e079dec0b"><div class="ttname"><a href="structmlir_1_1affine_1_1ComputationSliceState.html#afd8aa32fa351614ef5060a1e079dec0b">mlir::affine::ComputationSliceState::lbOperands</a></div><div class="ttdeci">std::vector&lt; SmallVector&lt; Value, 4 &gt; &gt; lbOperands</div><div class="ttdef"><b>Definition</b> <a href="#l00327">Utils.h:327</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1LoopNestStateCollector_html"><div class="ttname"><a href="structmlir_1_1affine_1_1LoopNestStateCollector.html">mlir::affine::LoopNestStateCollector</a></div><div class="ttdef"><b>Definition</b> <a href="#l00038">Utils.h:38</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1LoopNestStateCollector_html_a4c5255085d6cfdb16bff277d77176bab"><div class="ttname"><a href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a4c5255085d6cfdb16bff277d77176bab">mlir::affine::LoopNestStateCollector::memrefFrees</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; memrefFrees</div><div class="ttdef"><b>Definition</b> <a href="#l00049">Utils.h:49</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1LoopNestStateCollector_html_a6a9d08cfcdff91c3cb2818daa79b3fbb"><div class="ttname"><a href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a6a9d08cfcdff91c3cb2818daa79b3fbb">mlir::affine::LoopNestStateCollector::forOps</a></div><div class="ttdeci">SmallVector&lt; AffineForOp, 4 &gt; forOps</div><div class="ttdef"><b>Definition</b> <a href="#l00039">Utils.h:39</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1LoopNestStateCollector_html_a95f517b1a80923351ab5bd34fefd312c"><div class="ttname"><a href="structmlir_1_1affine_1_1LoopNestStateCollector.html#a95f517b1a80923351ab5bd34fefd312c">mlir::affine::LoopNestStateCollector::loadOpInsts</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; loadOpInsts</div><div class="ttdef"><b>Definition</b> <a href="#l00041">Utils.h:41</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1LoopNestStateCollector_html_ab1b990940ad78278dd989884d2021cff"><div class="ttname"><a href="structmlir_1_1affine_1_1LoopNestStateCollector.html#ab1b990940ad78278dd989884d2021cff">mlir::affine::LoopNestStateCollector::memrefStores</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; memrefStores</div><div class="ttdef"><b>Definition</b> <a href="#l00047">Utils.h:47</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1LoopNestStateCollector_html_ac7e518efde98002ff3fdf5b576205883"><div class="ttname"><a href="structmlir_1_1affine_1_1LoopNestStateCollector.html#ac7e518efde98002ff3fdf5b576205883">mlir::affine::LoopNestStateCollector::collect</a></div><div class="ttdeci">void collect(Operation *opToWalk)</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00043">Utils.cpp:43</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1LoopNestStateCollector_html_adf2391f4ce1e52ffc08a51add68a9b4e"><div class="ttname"><a href="structmlir_1_1affine_1_1LoopNestStateCollector.html#adf2391f4ce1e52ffc08a51add68a9b4e">mlir::affine::LoopNestStateCollector::memrefLoads</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; memrefLoads</div><div class="ttdef"><b>Definition</b> <a href="#l00045">Utils.h:45</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1LoopNestStateCollector_html_ae23767154d778088beab9572db13ddfb"><div class="ttname"><a href="structmlir_1_1affine_1_1LoopNestStateCollector.html#ae23767154d778088beab9572db13ddfb">mlir::affine::LoopNestStateCollector::storeOpInsts</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; storeOpInsts</div><div class="ttdef"><b>Definition</b> <a href="#l00043">Utils.h:43</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefAccess_html"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefAccess.html">mlir::affine::MemRefAccess</a></div><div class="ttdoc">Encapsulates a memref load or store access information.</div><div class="ttdef"><b>Definition</b> <a href="AffineAnalysis_8h_source.html#l00082">AffineAnalysis.h:82</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge_html"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html">mlir::affine::MemRefDependenceGraph::Edge</a></div><div class="ttdef"><b>Definition</b> <a href="#l00123">Utils.h:123</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge_html_aa2928d335ef67abb4dd9f225fbe7eca5"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html#aa2928d335ef67abb4dd9f225fbe7eca5">mlir::affine::MemRefDependenceGraph::Edge::value</a></div><div class="ttdeci">Value value</div><div class="ttdef"><b>Definition</b> <a href="#l00137">Utils.h:137</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge_html_ace11f0021945bfc712786e04e2f1101d"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Edge.html#ace11f0021945bfc712786e04e2f1101d">mlir::affine::MemRefDependenceGraph::Edge::id</a></div><div class="ttdeci">unsigned id</div><div class="ttdef"><b>Definition</b> <a href="#l00129">Utils.h:129</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">mlir::affine::MemRefDependenceGraph::Node</a></div><div class="ttdef"><b>Definition</b> <a href="#l00067">Utils.h:67</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a0d3aa9a9ed278fe81689d73d07033b29"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a0d3aa9a9ed278fe81689d73d07033b29">mlir::affine::MemRefDependenceGraph::Node::getStoreOpsForMemref</a></div><div class="ttdeci">void getStoreOpsForMemref(Value memref, SmallVectorImpl&lt; Operation * &gt; *storeOps) const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00130">Utils.cpp:130</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a1443947aa4f1a5ba044f9bfbc364e353"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a1443947aa4f1a5ba044f9bfbc364e353">mlir::affine::MemRefDependenceGraph::Node::loads</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; loads</div><div class="ttdef"><b>Definition</b> <a href="#l00073">Utils.h:73</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a1d9d97fe37cf42792d796beeffb182db"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a1d9d97fe37cf42792d796beeffb182db">mlir::affine::MemRefDependenceGraph::Node::stores</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; stores</div><div class="ttdef"><b>Definition</b> <a href="#l00077">Utils.h:77</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a3b5c1cad1b7c6f2b8091bb7f12d29162"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a3b5c1cad1b7c6f2b8091bb7f12d29162">mlir::affine::MemRefDependenceGraph::Node::getLoadAndStoreMemrefSet</a></div><div class="ttdeci">void getLoadAndStoreMemrefSet(DenseSet&lt; Value &gt; *loadAndStoreMemrefSet) const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00149">Utils.cpp:149</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a43784c742baf090c45dbf791c4194425"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a43784c742baf090c45dbf791c4194425">mlir::affine::MemRefDependenceGraph::Node::Node</a></div><div class="ttdeci">Node(unsigned id, Operation *op)</div><div class="ttdef"><b>Definition</b> <a href="#l00085">Utils.h:85</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a49e4fae512d8dd3f049672634d5edd80"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a49e4fae512d8dd3f049672634d5edd80">mlir::affine::MemRefDependenceGraph::Node::hasFree</a></div><div class="ttdeci">unsigned hasFree(Value memref) const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00123">Utils.cpp:123</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a5ab56168ea32478165badb63843a0839"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a5ab56168ea32478165badb63843a0839">mlir::affine::MemRefDependenceGraph::Node::memrefLoads</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; memrefLoads</div><div class="ttdef"><b>Definition</b> <a href="#l00075">Utils.h:75</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a678f66b993583d391ec12d1eaca5c168"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a678f66b993583d391ec12d1eaca5c168">mlir::affine::MemRefDependenceGraph::Node::memrefStores</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; memrefStores</div><div class="ttdef"><b>Definition</b> <a href="#l00079">Utils.h:79</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a73ec40eb1f5ef361ab49dbdcca2126f1"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a73ec40eb1f5ef361ab49dbdcca2126f1">mlir::affine::MemRefDependenceGraph::Node::privateMemrefs</a></div><div class="ttdeci">DenseSet&lt; Value &gt; privateMemrefs</div><div class="ttdef"><b>Definition</b> <a href="#l00083">Utils.h:83</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a77267e6959542952eb88324ac501186a"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a77267e6959542952eb88324ac501186a">mlir::affine::MemRefDependenceGraph::Node::getLoadOpCount</a></div><div class="ttdeci">unsigned getLoadOpCount(Value memref) const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00078">Utils.cpp:78</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a7dcff2c5bf014d3ae42f78780ce15786"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a7dcff2c5bf014d3ae42f78780ce15786">mlir::affine::MemRefDependenceGraph::Node::getStoreOpCount</a></div><div class="ttdeci">unsigned getStoreOpCount(Value memref) const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00093">Utils.cpp:93</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a830ea36bccf2332f1a9aea7e09bef2f0"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a830ea36bccf2332f1a9aea7e09bef2f0">mlir::affine::MemRefDependenceGraph::Node::id</a></div><div class="ttdeci">unsigned id</div><div class="ttdef"><b>Definition</b> <a href="#l00069">Utils.h:69</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_a866114f24f1c3e927c47c87a38843a53"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#a866114f24f1c3e927c47c87a38843a53">mlir::affine::MemRefDependenceGraph::Node::hasStore</a></div><div class="ttdeci">unsigned hasStore(Value memref) const</div><div class="ttdoc">Returns true if there exists an operation with a write memory effect to memref in this node.</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00109">Utils.cpp:109</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_ab79054c161b7323e14e56f00d1d38fa0"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#ab79054c161b7323e14e56f00d1d38fa0">mlir::affine::MemRefDependenceGraph::Node::op</a></div><div class="ttdeci">Operation * op</div><div class="ttdef"><b>Definition</b> <a href="#l00071">Utils.h:71</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_ac9d40b81f36159a323d3a56d60b6bbea"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#ac9d40b81f36159a323d3a56d60b6bbea">mlir::affine::MemRefDependenceGraph::Node::getLoadOpsForMemref</a></div><div class="ttdeci">void getLoadOpsForMemref(Value memref, SmallVectorImpl&lt; Operation * &gt; *loadOps) const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00139">Utils.cpp:139</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node_html_afe5e17bd9cb80f70609ec127e9ce6d43"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html#afe5e17bd9cb80f70609ec127e9ce6d43">mlir::affine::MemRefDependenceGraph::Node::memrefFrees</a></div><div class="ttdeci">SmallVector&lt; Operation *, 4 &gt; memrefFrees</div><div class="ttdef"><b>Definition</b> <a href="#l00081">Utils.h:81</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a01d186fd0b75b108fce1ad9dd27e3630"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a01d186fd0b75b108fce1ad9dd27e3630">mlir::affine::MemRefDependenceGraph::outEdges</a></div><div class="ttdeci">DenseMap&lt; unsigned, SmallVector&lt; Edge, 2 &gt; &gt; outEdges</div><div class="ttdef"><b>Definition</b> <a href="#l00147">Utils.h:147</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a033d58b8880a8b8bf188abaa803275f0"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a033d58b8880a8b8bf188abaa803275f0">mlir::affine::MemRefDependenceGraph::block</a></div><div class="ttdeci">Block &amp; block</div><div class="ttdoc">The block for which this graph is created to perform fusion.</div><div class="ttdef"><b>Definition</b> <a href="#l00270">Utils.h:270</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a044e8c2c285b222c732ffe12a0ba2820"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a044e8c2c285b222c732ffe12a0ba2820">mlir::affine::MemRefDependenceGraph::getNode</a></div><div class="ttdeci">Node * getNode(unsigned id)</div><div class="ttdef"><b>Definition</b> <a href="#l00170">Utils.h:170</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a09cdaeb6db292ca36bfa6a57c2a1bf27"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a09cdaeb6db292ca36bfa6a57c2a1bf27">mlir::affine::MemRefDependenceGraph::addNode</a></div><div class="ttdeci">unsigned addNode(Operation *op)</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00467">Utils.cpp:467</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a0ed9f30da3f99f63db2d0a18b23a7562"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a0ed9f30da3f99f63db2d0a18b23a7562">mlir::affine::MemRefDependenceGraph::writesToLiveInOrEscapingMemrefs</a></div><div class="ttdeci">bool writesToLiveInOrEscapingMemrefs(unsigned id) const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00497">Utils.cpp:497</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a19787b209c503c45e6dff3d8a975d123"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a19787b209c503c45e6dff3d8a975d123">mlir::affine::MemRefDependenceGraph::removeEdge</a></div><div class="ttdeci">void removeEdge(unsigned srcId, unsigned dstId, Value value)</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00543">Utils.cpp:543</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a2426d1416444660e2a965499b9558f2e"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a2426d1416444660e2a965499b9558f2e">mlir::affine::MemRefDependenceGraph::addEdge</a></div><div class="ttdeci">void addEdge(unsigned srcId, unsigned dstId, Value value)</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00532">Utils.cpp:532</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a345e759cabd082ca094c6315f1104a8b"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a345e759cabd082ca094c6315f1104a8b">mlir::affine::MemRefDependenceGraph::nextNodeId</a></div><div class="ttdeci">unsigned nextNodeId</div><div class="ttdef"><b>Definition</b> <a href="#l00152">Utils.h:152</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a3c63e623ce037ff8c4bce83cf5d214a9"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3c63e623ce037ff8c4bce83cf5d214a9">mlir::affine::MemRefDependenceGraph::MemRefDependenceGraph</a></div><div class="ttdeci">MemRefDependenceGraph(Block &amp;block)</div><div class="ttdef"><b>Definition</b> <a href="#l00154">Utils.h:154</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a3df572ea465683f6b1f0e4dcd9f9b42f"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a3df572ea465683f6b1f0e4dcd9f9b42f">mlir::affine::MemRefDependenceGraph::nodes</a></div><div class="ttdeci">DenseMap&lt; unsigned, Node &gt; nodes</div><div class="ttdef"><b>Definition</b> <a href="#l00141">Utils.h:141</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a437652354edafa39b0546fe0a60e9071"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a437652354edafa39b0546fe0a60e9071">mlir::affine::MemRefDependenceGraph::gatherDefiningNodes</a></div><div class="ttdeci">void gatherDefiningNodes(unsigned id, DenseSet&lt; unsigned &gt; &amp;definingNodes) const</div><div class="ttdoc">Return all nodes which define SSA values used in node &#39;id&#39;.</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00631">Utils.cpp:631</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a45510d99234261290bf188a3108387cd"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a45510d99234261290bf188a3108387cd">mlir::affine::MemRefDependenceGraph::hasDependencePath</a></div><div class="ttdeci">bool hasDependencePath(unsigned srcId, unsigned dstId) const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00570">Utils.cpp:570</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a55a81e7e71f3511a8babe8c8535393f1"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a55a81e7e71f3511a8babe8c8535393f1">mlir::affine::MemRefDependenceGraph::clearNodeLoadAndStores</a></div><div class="ttdeci">void clearNodeLoadAndStores(unsigned id)</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00797">Utils.cpp:797</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a60e1b52dd56f3d099d5899568293b218"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a60e1b52dd56f3d099d5899568293b218">mlir::affine::MemRefDependenceGraph::getForOpNode</a></div><div class="ttdeci">const Node * getForOpNode(AffineForOp forOp) const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00459">Utils.cpp:459</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a61ca2d2048e49f64711b86f5746f0081"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a61ca2d2048e49f64711b86f5746f0081">mlir::affine::MemRefDependenceGraph::getFusedLoopNestInsertionPoint</a></div><div class="ttdeci">Operation * getFusedLoopNestInsertionPoint(unsigned srcId, unsigned dstId) const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00645">Utils.cpp:645</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a650542cbe4a3a8ed5cef0ad22bf2f39a"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a650542cbe4a3a8ed5cef0ad22bf2f39a">mlir::affine::MemRefDependenceGraph::updateEdges</a></div><div class="ttdeci">void updateEdges(unsigned srcId, unsigned dstId, const DenseSet&lt; Value &gt; &amp;privateMemRefs, bool removeSrcId)</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00720">Utils.cpp:720</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a657659a854921a4dd67b0657556f0a7c"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a657659a854921a4dd67b0657556f0a7c">mlir::affine::MemRefDependenceGraph::hasNode</a></div><div class="ttdeci">bool hasNode(unsigned id) const</div><div class="ttdef"><b>Definition</b> <a href="#l00176">Utils.h:176</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a6c0fadb723818174fe2e60709e761918"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a6c0fadb723818174fe2e60709e761918">mlir::affine::MemRefDependenceGraph::inEdges</a></div><div class="ttdeci">DenseMap&lt; unsigned, SmallVector&lt; Edge, 2 &gt; &gt; inEdges</div><div class="ttdef"><b>Definition</b> <a href="#l00144">Utils.h:144</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a790085bc35e36d40045748ca863ec470"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a790085bc35e36d40045748ca863ec470">mlir::affine::MemRefDependenceGraph::getForOpNode</a></div><div class="ttdeci">Node * getForOpNode(AffineForOp forOp)</div><div class="ttdef"><b>Definition</b> <a href="#l00180">Utils.h:180</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a83ce0d42a3715e3d152f87ec4437c56e"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a83ce0d42a3715e3d152f87ec4437c56e">mlir::affine::MemRefDependenceGraph::forEachMemRefInputEdge</a></div><div class="ttdeci">void forEachMemRefInputEdge(unsigned id, const std::function&lt; void(Edge)&gt; &amp;callback)</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00805">Utils.cpp:805</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a8f53c72d7d11724c7213beb168550f69"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a8f53c72d7d11724c7213beb168550f69">mlir::affine::MemRefDependenceGraph::init</a></div><div class="ttdeci">bool init(bool fullAffineDependences=true)</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00336">Utils.cpp:336</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a996bade25457fbc32567f4b47ae18f3f"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a996bade25457fbc32567f4b47ae18f3f">mlir::affine::MemRefDependenceGraph::getOutEdgeCount</a></div><div class="ttdeci">unsigned getOutEdgeCount(unsigned id, Value memref=nullptr) const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00621">Utils.cpp:621</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_a9ecf883f82ba5105ab012804d98994f5"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#a9ecf883f82ba5105ab012804d98994f5">mlir::affine::MemRefDependenceGraph::getNode</a></div><div class="ttdeci">const Node * getNode(unsigned id) const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00452">Utils.cpp:452</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_aa65f5209124219ebb4a86fcedb629850"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aa65f5209124219ebb4a86fcedb629850">mlir::affine::MemRefDependenceGraph::removeNode</a></div><div class="ttdeci">void removeNode(unsigned id)</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00474">Utils.cpp:474</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_aaeb96e8d972edf0793f628b700743c52"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aaeb96e8d972edf0793f628b700743c52">mlir::affine::MemRefDependenceGraph::forEachMemRefOutputEdge</a></div><div class="ttdeci">void forEachMemRefOutputEdge(unsigned id, const std::function&lt; void(Edge)&gt; &amp;callback)</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00813">Utils.cpp:813</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_ab8c546bd37ebde1870dfd51b66080974"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#ab8c546bd37ebde1870dfd51b66080974">mlir::affine::MemRefDependenceGraph::forEachMemRefEdge</a></div><div class="ttdeci">void forEachMemRefEdge(ArrayRef&lt; Edge &gt; edges, const std::function&lt; void(Edge)&gt; &amp;callback)</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00821">Utils.cpp:821</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_abe5db0c6c3108f9e233ad68ee134e496"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#abe5db0c6c3108f9e233ad68ee134e496">mlir::affine::MemRefDependenceGraph::addToNode</a></div><div class="ttdeci">void addToNode(unsigned id, ArrayRef&lt; Operation * &gt; loads, ArrayRef&lt; Operation * &gt; stores, ArrayRef&lt; Operation * &gt; memrefLoads, ArrayRef&lt; Operation * &gt; memrefStores, ArrayRef&lt; Operation * &gt; memrefFrees)</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00784">Utils.cpp:784</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_aded491cadebd6d0969d23f80cb0ef475"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aded491cadebd6d0969d23f80cb0ef475">mlir::affine::MemRefDependenceGraph::getIncomingMemRefAccesses</a></div><div class="ttdeci">unsigned getIncomingMemRefAccesses(unsigned id, Value memref) const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00605">Utils.cpp:605</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_ae3bdae51f114698511aa7be4b3133880"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#ae3bdae51f114698511aa7be4b3133880">mlir::affine::MemRefDependenceGraph::hasEdge</a></div><div class="ttdeci">bool hasEdge(unsigned srcId, unsigned dstId, Value value=nullptr) const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00517">Utils.cpp:517</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_aee33c4c116b0fceb1dc3ec2114d0916b"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#aee33c4c116b0fceb1dc3ec2114d0916b">mlir::affine::MemRefDependenceGraph::dump</a></div><div class="ttdeci">void dump() const</div><div class="ttdef"><b>Definition</b> <a href="#l00267">Utils.h:267</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_af0240c7ff60660612bd78f98bff995e4"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#af0240c7ff60660612bd78f98bff995e4">mlir::affine::MemRefDependenceGraph::print</a></div><div class="ttdeci">void print(raw_ostream &amp;os) const</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00833">Utils.cpp:833</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefDependenceGraph_html_afb1cdc99d9633c920e02a9a8975fdd41"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefDependenceGraph.html#afb1cdc99d9633c920e02a9a8975fdd41">mlir::affine::MemRefDependenceGraph::memrefEdgeCount</a></div><div class="ttdeci">DenseMap&lt; Value, unsigned &gt; memrefEdgeCount</div><div class="ttdef"><b>Definition</b> <a href="#l00150">Utils.h:150</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html">mlir::affine::MemRefRegion</a></div><div class="ttdoc">A region of a memref&#39;s data space; this is typically constructed by analyzing load/store op&#39;s on this...</div><div class="ttdef"><b>Definition</b> <a href="#l00489">Utils.h:489</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_a02e6b8cc86992af6bcd29f0357072ca6"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#a02e6b8cc86992af6bcd29f0357072ca6">mlir::affine::MemRefRegion::getConstantBoundingSizeAndShape</a></div><div class="ttdeci">std::optional&lt; int64_t &gt; getConstantBoundingSizeAndShape(SmallVectorImpl&lt; int64_t &gt; *shape=nullptr, SmallVectorImpl&lt; AffineMap &gt; *lbs=nullptr) const</div><div class="ttdoc">Returns a constant upper bound on the number of elements in this region if bounded by a known constan...</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01160">Utils.cpp:1160</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_a22317444c57ececdfd0b3f5497d1971c"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#a22317444c57ececdfd0b3f5497d1971c">mlir::affine::MemRefRegion::getRank</a></div><div class="ttdeci">unsigned getRank() const</div><div class="ttdoc">Returns the rank of the memref that this region corresponds to.</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01156">Utils.cpp:1156</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_a3d0ae2cb9072efe63434e12545d10486"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#a3d0ae2cb9072efe63434e12545d10486">mlir::affine::MemRefRegion::cst</a></div><div class="ttdeci">FlatAffineValueConstraints cst</div><div class="ttdoc">Region (data space) of the memref accessed.</div><div class="ttdef"><b>Definition</b> <a href="#l00586">Utils.h:586</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_a4255fd434f5d6dc27bebe8ffe3198dc7"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#a4255fd434f5d6dc27bebe8ffe3198dc7">mlir::affine::MemRefRegion::isWrite</a></div><div class="ttdeci">bool isWrite() const</div><div class="ttdef"><b>Definition</b> <a href="#l00537">Utils.h:537</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_a60e67b614605337ccb83b83bdaace70c"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#a60e67b614605337ccb83b83bdaace70c">mlir::affine::MemRefRegion::compute</a></div><div class="ttdeci">LogicalResult compute(Operation *op, unsigned loopDepth, const ComputationSliceState *sliceState=nullptr, bool addMemRefDimBounds=true, bool dropLocalVars=true, bool dropOuterIVs=true)</div><div class="ttdoc">Computes the memory region accessed by this memref with the region represented as constraints symboli...</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">Utils.cpp:1257</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_a772a10d9c01365d3d3a697f8679e1afc"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#a772a10d9c01365d3d3a697f8679e1afc">mlir::affine::MemRefRegion::getLowerAndUpperBound</a></div><div class="ttdeci">void getLowerAndUpperBound(unsigned pos, AffineMap &amp;lbMap, AffineMap &amp;ubMap) const</div><div class="ttdoc">Gets the lower and upper bound map for the dimensional variable at pos.</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01216">Utils.cpp:1216</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_a8fb53fa6d699f6834738fa2f220ac783"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#a8fb53fa6d699f6834738fa2f220ac783">mlir::affine::MemRefRegion::getRegionSize</a></div><div class="ttdeci">std::optional&lt; int64_t &gt; getRegionSize()</div><div class="ttdoc">Returns the size of this MemRefRegion in bytes.</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01438">Utils.cpp:1438</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_aa2761578967822bb7853e072a1a29bac"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#aa2761578967822bb7853e072a1a29bac">mlir::affine::MemRefRegion::unionBoundingBox</a></div><div class="ttdeci">LogicalResult unionBoundingBox(const MemRefRegion &amp;other)</div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01235">Utils.cpp:1235</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_aaa0de038280a27f97e36f354690dbe15"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#aaa0de038280a27f97e36f354690dbe15">mlir::affine::MemRefRegion::write</a></div><div class="ttdeci">bool write</div><div class="ttdoc">Read or write.</div><div class="ttdef"><b>Definition</b> <a href="#l00573">Utils.h:573</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_ab0382cfe83a9301c5cc63f73a1a1e8d3"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#ab0382cfe83a9301c5cc63f73a1a1e8d3">mlir::affine::MemRefRegion::setWrite</a></div><div class="ttdeci">void setWrite(bool flag)</div><div class="ttdef"><b>Definition</b> <a href="#l00538">Utils.h:538</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_abd8c328086327a660e050f9d525626d5"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#abd8c328086327a660e050f9d525626d5">mlir::affine::MemRefRegion::getConstraints</a></div><div class="ttdeci">FlatAffineValueConstraints * getConstraints()</div><div class="ttdef"><b>Definition</b> <a href="#l00535">Utils.h:535</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_ac097fcae970f4cd44eb14f9484deaf43"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#ac097fcae970f4cd44eb14f9484deaf43">mlir::affine::MemRefRegion::memref</a></div><div class="ttdeci">Value memref</div><div class="ttdoc">Memref that this region corresponds to.</div><div class="ttdef"><b>Definition</b> <a href="#l00570">Utils.h:570</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_ac6d5022fc3e167d5e4f2c9e9c116ae39"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#ac6d5022fc3e167d5e4f2c9e9c116ae39">mlir::affine::MemRefRegion::MemRefRegion</a></div><div class="ttdeci">MemRefRegion(Location loc)</div><div class="ttdef"><b>Definition</b> <a href="#l00490">Utils.h:490</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_afc423788ee75197d33435708ce67c2b9"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#afc423788ee75197d33435708ce67c2b9">mlir::affine::MemRefRegion::getConstraints</a></div><div class="ttdeci">const FlatAffineValueConstraints * getConstraints() const</div><div class="ttdef"><b>Definition</b> <a href="#l00536">Utils.h:536</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1MemRefRegion_html_aff8b1c63008105dbed4b81d798babf92"><div class="ttname"><a href="structmlir_1_1affine_1_1MemRefRegion.html#aff8b1c63008105dbed4b81d798babf92">mlir::affine::MemRefRegion::loc</a></div><div class="ttdeci">Location loc</div><div class="ttdoc">If there is more than one load/store op associated with the region, the location information would co...</div><div class="ttdef"><b>Definition</b> <a href="#l00577">Utils.h:577</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1SliceComputationResult_html_a37a45916fce7b4d2989ae128c037d3ef"><div class="ttname"><a href="structmlir_1_1affine_1_1SliceComputationResult.html#a37a45916fce7b4d2989ae128c037d3ef">mlir::affine::SliceComputationResult::SliceComputationResult</a></div><div class="ttdeci">SliceComputationResult(ResultEnum v)</div><div class="ttdef"><b>Definition</b> <a href="#l00311">Utils.h:311</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1SliceComputationResult_html_a4ee39b3fde28b841ed203728087810e9"><div class="ttname"><a href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9">mlir::affine::SliceComputationResult::ResultEnum</a></div><div class="ttdeci">ResultEnum</div><div class="ttdef"><b>Definition</b> <a href="#l00306">Utils.h:306</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1SliceComputationResult_html_a4ee39b3fde28b841ed203728087810e9a4386b2e4cd401f45247b3ff587a5e4d6"><div class="ttname"><a href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9a4386b2e4cd401f45247b3ff587a5e4d6">mlir::affine::SliceComputationResult::GenericFailure</a></div><div class="ttdeci">@ GenericFailure</div><div class="ttdef"><b>Definition</b> <a href="#l00309">Utils.h:309</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1SliceComputationResult_html_a4ee39b3fde28b841ed203728087810e9aa56e19629619cf1e69cb9f4ec40dcb7c"><div class="ttname"><a href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9aa56e19629619cf1e69cb9f4ec40dcb7c">mlir::affine::SliceComputationResult::IncorrectSliceFailure</a></div><div class="ttdeci">@ IncorrectSliceFailure</div><div class="ttdef"><b>Definition</b> <a href="#l00308">Utils.h:308</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1SliceComputationResult_html_a4ee39b3fde28b841ed203728087810e9aa85f3aac90ad660d5de9933c03cd26ef"><div class="ttname"><a href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9aa85f3aac90ad660d5de9933c03cd26ef">mlir::affine::SliceComputationResult::Success</a></div><div class="ttdeci">@ Success</div><div class="ttdef"><b>Definition</b> <a href="#l00307">Utils.h:307</a></div></div>
<div class="ttc" id="astructmlir_1_1affine_1_1SliceComputationResult_html_ae1bf161ba038ce8ed38567be7adba786"><div class="ttname"><a href="structmlir_1_1affine_1_1SliceComputationResult.html#ae1bf161ba038ce8ed38567be7adba786">mlir::affine::SliceComputationResult::value</a></div><div class="ttdeci">enum mlir::affine::SliceComputationResult::ResultEnum value</div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
