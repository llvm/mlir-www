<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::tensor Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1tensor.html">tensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::tensor Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html">ExtractSliceFromCollapseHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class assists with generating IR required to materialize an arbitrary-sized slice from the result of a CollapseShapeOp.  <a href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9d4142525a7f3e353e50a35cd66c945d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a9d4142525a7f3e353e50a35cd66c945d">ControlConstantExtractSliceFusionFn</a> = std::function&lt; bool(ExtractSliceOp)&gt;</td></tr>
<tr class="memdesc:a9d4142525a7f3e353e50a35cd66c945d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to control the folding of constant and extract slice.  <a href="namespacemlir_1_1tensor.html#a9d4142525a7f3e353e50a35cd66c945d">More...</a><br /></td></tr>
<tr class="separator:a9d4142525a7f3e353e50a35cd66c945d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b062361904c606cc522e992d1089c3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#ac4b062361904c606cc522e992d1089c3">ControlFoldFn</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt;</td></tr>
<tr class="separator:ac4b062361904c606cc522e992d1089c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acc8a002ba50ad2f3d5c09e4e0efdc0d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#acc8a002ba50ad2f3d5c09e4e0efdc0d3">registerAllExtensions</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:acc8a002ba50ad2f3d5c09e4e0efdc0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register all extensions of the Tensor dialect.  <a href="namespacemlir_1_1tensor.html#acc8a002ba50ad2f3d5c09e4e0efdc0d3">More...</a><br /></td></tr>
<tr class="separator:acc8a002ba50ad2f3d5c09e4e0efdc0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c009c40e6adaa31399030460514ab7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#ae4c009c40e6adaa31399030460514ab7">registerShardingInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ae4c009c40e6adaa31399030460514ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b0cdf08bf148506f761f70f24059f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#ac1b0cdf08bf148506f761f70f24059f0">preservesStaticInformation</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> source, <a class="el" href="classmlir_1_1Type.html">Type</a> target)</td></tr>
<tr class="memdesc:ac1b0cdf08bf148506f761f70f24059f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>target</code> is a ranked tensor type that preserves static information available in the <code>source</code> ranked tensor type.  <a href="namespacemlir_1_1tensor.html#ac1b0cdf08bf148506f761f70f24059f0">More...</a><br /></td></tr>
<tr class="separator:ac1b0cdf08bf148506f761f70f24059f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30deb019e8a71c65e127e245b9cf63fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a30deb019e8a71c65e127e245b9cf63fb">canFoldIntoConsumerOp</a> (CastOp castOp)</td></tr>
<tr class="memdesc:a30deb019e8a71c65e127e245b9cf63fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether tensor::CastOp casts to a more dynamic version of the source tensor.  <a href="namespacemlir_1_1tensor.html#a30deb019e8a71c65e127e245b9cf63fb">More...</a><br /></td></tr>
<tr class="separator:a30deb019e8a71c65e127e245b9cf63fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbbd2b47f452ac54390390eb2099edd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a1bbbd2b47f452ac54390390eb2099edd">canFoldIntoProducerOp</a> (CastOp castOp)</td></tr>
<tr class="memdesc:a1bbbd2b47f452ac54390390eb2099edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the tensor::CastOp casts to a more static version of the source tensor.  <a href="namespacemlir_1_1tensor.html#a1bbbd2b47f452ac54390390eb2099edd">More...</a><br /></td></tr>
<tr class="separator:a1bbbd2b47f452ac54390390eb2099edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a08b46210e9d5cac2cd665dac0bce07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a0a08b46210e9d5cac2cd665dac0bce07">hasFoldableTensorCastOperand</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a0a08b46210e9d5cac2cd665dac0bce07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of the operands of <code>op</code> is a CastOp that can be folded into its consumer, i.e.  <a href="namespacemlir_1_1tensor.html#a0a08b46210e9d5cac2cd665dac0bce07">More...</a><br /></td></tr>
<tr class="separator:a0a08b46210e9d5cac2cd665dac0bce07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265e307a38759e898773b475a475e2fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a265e307a38759e898773b475a475e2fe">getUpdatedOperandsAfterCastOpFolding</a> (DestinationStyleOpInterface op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;newResTy)</td></tr>
<tr class="memdesc:a265e307a38759e898773b475a475e2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that <code>op</code> contains at least one operand that is a foldable CastOp (i.e.  <a href="namespacemlir_1_1tensor.html#a265e307a38759e898773b475a475e2fe">More...</a><br /></td></tr>
<tr class="separator:a265e307a38759e898773b475a475e2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e4cc4be054eec0b07a42e2f63f05f2"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a00e4cc4be054eec0b07a42e2f63f05f2">foldTensorCast</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a00e4cc4be054eec0b07a42e2f63f05f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs folding of any operand of <code>op</code> if it comes from a tensor::CastOp that can be folded.  <a href="namespacemlir_1_1tensor.html#a00e4cc4be054eec0b07a42e2f63f05f2">More...</a><br /></td></tr>
<tr class="separator:a00e4cc4be054eec0b07a42e2f63f05f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d577c5f161da7be47b356b6363a7eae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a8d577c5f161da7be47b356b6363a7eae">getMixedSize</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> value, int64_t dim)</td></tr>
<tr class="memdesc:a8d577c5f161da7be47b356b6363a7eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of the given tensor value.  <a href="namespacemlir_1_1tensor.html#a8d577c5f161da7be47b356b6363a7eae">More...</a><br /></td></tr>
<tr class="separator:a8d577c5f161da7be47b356b6363a7eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d0935f6c223e44294137605bb39d60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#ad1d0935f6c223e44294137605bb39d60">getMixedSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:ad1d0935f6c223e44294137605bb39d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimensions of the given tensor value.  <a href="namespacemlir_1_1tensor.html#ad1d0935f6c223e44294137605bb39d60">More...</a><br /></td></tr>
<tr class="separator:ad1d0935f6c223e44294137605bb39d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfe3bede328e5dc72de55dfca72fe1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a6cfe3bede328e5dc72de55dfca72fe1d">createCanonicalRankReducingExtractSliceOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> tensor, RankedTensorType targetType)</td></tr>
<tr class="memdesc:a6cfe3bede328e5dc72de55dfca72fe1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rank-reducing ExtractSliceOp @[0 .  <a href="namespacemlir_1_1tensor.html#a6cfe3bede328e5dc72de55dfca72fe1d">More...</a><br /></td></tr>
<tr class="separator:a6cfe3bede328e5dc72de55dfca72fe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0730cfcf9d984a57414d62c2b18b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a6b0730cfcf9d984a57414d62c2b18b2f">createCanonicalRankReducingInsertSliceOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> tensor, <a class="el" href="classmlir_1_1Value.html">Value</a> dest)</td></tr>
<tr class="memdesc:a6b0730cfcf9d984a57414d62c2b18b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rank-reducing InsertSliceOp @[0 .  <a href="namespacemlir_1_1tensor.html#a6b0730cfcf9d984a57414d62c2b18b2f">More...</a><br /></td></tr>
<tr class="separator:a6b0730cfcf9d984a57414d62c2b18b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e502153b3c46a11dad42045c36bc31"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a90e502153b3c46a11dad42045c36bc31">getOrCreateDestination</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> opResult)</td></tr>
<tr class="memdesc:a90e502153b3c46a11dad42045c36bc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function for DestinationStyleOpInterface.  <a href="namespacemlir_1_1tensor.html#a90e502153b3c46a11dad42045c36bc31">More...</a><br /></td></tr>
<tr class="separator:a90e502153b3c46a11dad42045c36bc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28262a44a78b9ce6b2e43195dd2a085"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#ad28262a44a78b9ce6b2e43195dd2a085">getOrCreateDestinations</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ad28262a44a78b9ce6b2e43195dd2a085"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function for DestinationStyleOpInterface.  <a href="namespacemlir_1_1tensor.html#ad28262a44a78b9ce6b2e43195dd2a085">More...</a><br /></td></tr>
<tr class="separator:ad28262a44a78b9ce6b2e43195dd2a085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8704f34ea971ccefd3c0150f8b6bda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a7c8704f34ea971ccefd3c0150f8b6bda">isSameTypeWithoutEncoding</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> tp1, <a class="el" href="classmlir_1_1Type.html">Type</a> tp2)</td></tr>
<tr class="memdesc:a7c8704f34ea971ccefd3c0150f8b6bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if types are the same when ignoring encoding on ranked tensors.  <a href="namespacemlir_1_1tensor.html#a7c8704f34ea971ccefd3c0150f8b6bda">More...</a><br /></td></tr>
<tr class="separator:a7c8704f34ea971ccefd3c0150f8b6bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edfdd5a23215fd0d8d587be6ebae28a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a0edfdd5a23215fd0d8d587be6ebae28a">populateFoldConstantExtractSlicePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1tensor.html#a9d4142525a7f3e353e50a35cd66c945d">ControlConstantExtractSliceFusionFn</a> &amp;controlFn=[](ExtractSliceOp op) { return false;})</td></tr>
<tr class="memdesc:a0edfdd5a23215fd0d8d587be6ebae28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold the extract slice op with its constant operand.  <a href="namespacemlir_1_1tensor.html#a0edfdd5a23215fd0d8d587be6ebae28a">More...</a><br /></td></tr>
<tr class="separator:a0edfdd5a23215fd0d8d587be6ebae28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffb9f13d230b356ca5c58ee95a611db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a8ffb9f13d230b356ca5c58ee95a611db">populateFoldCollapseExtractPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a8ffb9f13d230b356ca5c58ee95a611db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold extracts of a collapse_shaped tensor to an extract of the source tensor.  <a href="namespacemlir_1_1tensor.html#a8ffb9f13d230b356ca5c58ee95a611db">More...</a><br /></td></tr>
<tr class="separator:a8ffb9f13d230b356ca5c58ee95a611db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537a26573013e086958f9f7a18fa65d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a537a26573013e086958f9f7a18fa65d5">registerInferTypeOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">mlir::DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a537a26573013e086958f9f7a18fa65d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers external models for Infer <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> interfaces for tensor ops.  <a href="namespacemlir_1_1tensor.html#a537a26573013e086958f9f7a18fa65d5">More...</a><br /></td></tr>
<tr class="separator:a537a26573013e086958f9f7a18fa65d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037e42ffbc07e707a1f2e648c49be367"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a037e42ffbc07e707a1f2e648c49be367">bubbleUpPadSlice</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, tensor::PadOp padOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes, bool generateZeroSliceGuard=true)</td></tr>
<tr class="memdesc:a037e42ffbc07e707a1f2e648c49be367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bubbles up a slice of this pad by taking the slice first and then performing the padding.  <a href="namespacemlir_1_1tensor.html#a037e42ffbc07e707a1f2e648c49be367">More...</a><br /></td></tr>
<tr class="separator:a037e42ffbc07e707a1f2e648c49be367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a4bebf333acf49aa338a6f810152f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a84a4bebf333acf49aa338a6f810152f5">registerTilingInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">mlir::DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a84a4bebf333acf49aa338a6f810152f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers external models for Tiling interface for tensor ops.  <a href="namespacemlir_1_1tensor.html#a84a4bebf333acf49aa338a6f810152f5">More...</a><br /></td></tr>
<tr class="separator:a84a4bebf333acf49aa338a6f810152f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b2a78b51f3a2f1e5f8ebdcabdb8037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#ae7b2a78b51f3a2f1e5f8ebdcabdb8037">registerTilingInterfaceExternalModelsForPackUnPackOps</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ae7b2a78b51f3a2f1e5f8ebdcabdb8037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the above registeration, but it is only for <code>tensor.pack</code> and <code>tensor.unpack</code> ops.  <a href="namespacemlir_1_1tensor.html#ae7b2a78b51f3a2f1e5f8ebdcabdb8037">More...</a><br /></td></tr>
<tr class="separator:ae7b2a78b51f3a2f1e5f8ebdcabdb8037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae180e649b9172ba9094eb52635792d9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#ae180e649b9172ba9094eb52635792d9a">registerValueBoundsOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ae180e649b9172ba9094eb52635792d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e647b877acb2e8497ffb6415f5ef98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a31e647b877acb2e8497ffb6415f5ef98">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a31e647b877acb2e8497ffb6415f5ef98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef6c3ff4458d28bdbb29b151ae4d9ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a7ef6c3ff4458d28bdbb29b151ae4d9ff">registerFindPayloadReplacementOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a7ef6c3ff4458d28bdbb29b151ae4d9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09a0f22283c4ef45935f058b6f629cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#aa09a0f22283c4ef45935f058b6f629cb">registerBufferizableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:aa09a0f22283c4ef45935f058b6f629cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e08e5e78426a356823fad9da7faf74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#ae9e08e5e78426a356823fad9da7faf74">registerRuntimeVerifiableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ae9e08e5e78426a356823fad9da7faf74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d6437bbf0214af0aa54891c0cc4f0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a72d6437bbf0214af0aa54891c0cc4f0a">registerSubsetOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a72d6437bbf0214af0aa54891c0cc4f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2224cac41fe066a9f63214b45cd24c0b"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a2224cac41fe066a9f63214b45cd24c0b">replaceExtractSliceWithTiledProducer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, tensor::ExtractSliceOp sliceOp, <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> producerOp)</td></tr>
<tr class="memdesc:a2224cac41fe066a9f63214b45cd24c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to swap an <code>tensor.extract_slice</code> with its producer when the producer implements the <code>TilingInterface</code>.  <a href="namespacemlir_1_1tensor.html#a2224cac41fe066a9f63214b45cd24c0b">More...</a><br /></td></tr>
<tr class="separator:a2224cac41fe066a9f63214b45cd24c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26569c717f5bd0eb52b7b92d84cfbdb4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a26569c717f5bd0eb52b7b92d84cfbdb4">replaceInsertSlicesWithTiledConsumer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; tensor::InsertSliceOp &gt; sliceOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt; consumerOperands)</td></tr>
<tr class="memdesc:a26569c717f5bd0eb52b7b92d84cfbdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to swap <code>tensor.insert_slice</code>s with their consumers when the consumer implements the <code>TilingInterface</code>.  <a href="namespacemlir_1_1tensor.html#a26569c717f5bd0eb52b7b92d84cfbdb4">More...</a><br /></td></tr>
<tr class="separator:a26569c717f5bd0eb52b7b92d84cfbdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543432e9d12118a7622a3089d8273ff3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a543432e9d12118a7622a3089d8273ff3">populateFoldTensorSubsetOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a543432e9d12118a7622a3089d8273ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for folding tensor subset ops into consumer load/store ops into <code>patterns</code>.  <a href="namespacemlir_1_1tensor.html#a543432e9d12118a7622a3089d8273ff3">More...</a><br /></td></tr>
<tr class="separator:a543432e9d12118a7622a3089d8273ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc69c3905c73a83187b7f09642273935"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#adc69c3905c73a83187b7f09642273935">populateFoldTensorSubsetIntoVectorTransferPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:adc69c3905c73a83187b7f09642273935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for folding tensor subset ops into vector transfer ops.  <a href="namespacemlir_1_1tensor.html#adc69c3905c73a83187b7f09642273935">More...</a><br /></td></tr>
<tr class="separator:adc69c3905c73a83187b7f09642273935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354a5a1166be4a8db79d65866e88182e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a354a5a1166be4a8db79d65866e88182e">populateMergeConsecutiveInsertExtractSlicePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a354a5a1166be4a8db79d65866e88182e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects patterns to merge consecutive tensor.insert_slice/extract_slice into one.  <a href="namespacemlir_1_1tensor.html#a354a5a1166be4a8db79d65866e88182e">More...</a><br /></td></tr>
<tr class="separator:a354a5a1166be4a8db79d65866e88182e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cd03acfd3c0a39d7b81142e09c0ea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a67cd03acfd3c0a39d7b81142e09c0ea6">populateBubbleUpExtractSliceOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a67cd03acfd3c0a39d7b81142e09c0ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns that are used to bubble up tensor.extract slice op above its producer.  <a href="namespacemlir_1_1tensor.html#a67cd03acfd3c0a39d7b81142e09c0ea6">More...</a><br /></td></tr>
<tr class="separator:a67cd03acfd3c0a39d7b81142e09c0ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f73bd63d8aa577bf0be474817cca20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#ab0f73bd63d8aa577bf0be474817cca20">populateDropRedundantInsertSliceRankExpansionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ab0f73bd63d8aa577bf0be474817cca20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that drop redundant tensor.insert_slice rank expansions.  <a href="namespacemlir_1_1tensor.html#ab0f73bd63d8aa577bf0be474817cca20">More...</a><br /></td></tr>
<tr class="separator:ab0f73bd63d8aa577bf0be474817cca20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59694a86108b2b08581a0910c8dc14a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a59694a86108b2b08581a0910c8dc14a0">populateReassociativeReshapeFoldingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a59694a86108b2b08581a0910c8dc14a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that fold <code>tensor.expand_shape</code> and <code>tensor.collapse_shape</code> into other ops.  <a href="namespacemlir_1_1tensor.html#a59694a86108b2b08581a0910c8dc14a0">More...</a><br /></td></tr>
<tr class="separator:a59694a86108b2b08581a0910c8dc14a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84385ac9917cc0e9d0b661b117a1aa95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a84385ac9917cc0e9d0b661b117a1aa95">populateBubbleUpExpandShapePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a84385ac9917cc0e9d0b661b117a1aa95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that bubble up <code>tensor.expand_shape</code> through <code>tensor.collapse_shape</code> ops.  <a href="namespacemlir_1_1tensor.html#a84385ac9917cc0e9d0b661b117a1aa95">More...</a><br /></td></tr>
<tr class="separator:a84385ac9917cc0e9d0b661b117a1aa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e85d021b66e41b155c2ac8a79470a0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a1e85d021b66e41b155c2ac8a79470a0b">populateFoldTensorEmptyPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, bool foldSingleUseOnly=false)</td></tr>
<tr class="memdesc:a1e85d021b66e41b155c2ac8a79470a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that fold tensor.empty with its consumers.  <a href="namespacemlir_1_1tensor.html#a1e85d021b66e41b155c2ac8a79470a0b">More...</a><br /></td></tr>
<tr class="separator:a1e85d021b66e41b155c2ac8a79470a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1858e8d94e747b946b919c2685463c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a4e1858e8d94e747b946b919c2685463c">populateDecomposeTensorConcatPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a4e1858e8d94e747b946b919c2685463c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that decompose <code>tensor.concat</code> into <code>tensor.empty</code> of a tensor of the concatenated size, followed by a chain of <code>tensor.insert_slice</code> operations on the inputs.  <a href="namespacemlir_1_1tensor.html#a4e1858e8d94e747b946b919c2685463c">More...</a><br /></td></tr>
<tr class="separator:a4e1858e8d94e747b946b919c2685463c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace25e5493ab1c4df8e63c524aba2dad0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#ace25e5493ab1c4df8e63c524aba2dad0">populateRewriteAsConstantPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1tensor.html#ac4b062361904c606cc522e992d1089c3">ControlFoldFn</a> &amp;controlFn)</td></tr>
<tr class="memdesc:ace25e5493ab1c4df8e63c524aba2dad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that replace tensor ops (such as tensor.generate) with constants when possible.  <a href="namespacemlir_1_1tensor.html#ace25e5493ab1c4df8e63c524aba2dad0">More...</a><br /></td></tr>
<tr class="separator:ace25e5493ab1c4df8e63c524aba2dad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6c410c5acbddda4ce39cb557a3a3e8"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#abc6c410c5acbddda4ce39cb557a3a3e8">buildIndependentOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, tensor::PadOp padOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> independencies)</td></tr>
<tr class="memdesc:abc6c410c5acbddda4ce39cb557a3a3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a new tensor::PadOp with low/high padding that is independent of all given independencies.  <a href="namespacemlir_1_1tensor.html#abc6c410c5acbddda4ce39cb557a3a3e8">More...</a><br /></td></tr>
<tr class="separator:abc6c410c5acbddda4ce39cb557a3a3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef702c5f3daef258e04bedc7489d0794"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#aef702c5f3daef258e04bedc7489d0794">buildIndependentOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, tensor::EmptyOp emptyOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> independencies)</td></tr>
<tr class="memdesc:aef702c5f3daef258e04bedc7489d0794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a new tensor::EmptyOp who's dynamic sizes are independent of all given independencies.  <a href="namespacemlir_1_1tensor.html#aef702c5f3daef258e04bedc7489d0794">More...</a><br /></td></tr>
<tr class="separator:aef702c5f3daef258e04bedc7489d0794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f36b140fcf2e0ed55e4cb6dfd4c63a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a08f36b140fcf2e0ed55e4cb6dfd4c63a">getCollapsedExtractSliceInfo</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, tensor::ExtractSliceOp sliceOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; reassociation, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;collapsedOffsets, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;collapsedSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;collapsedStrides)</td></tr>
<tr class="memdesc:a08f36b140fcf2e0ed55e4cb6dfd4c63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the offsets, sizes, and strides needed to build a collapsed <code>sliceOp</code>.  <a href="namespacemlir_1_1tensor.html#a08f36b140fcf2e0ed55e4cb6dfd4c63a">More...</a><br /></td></tr>
<tr class="separator:a08f36b140fcf2e0ed55e4cb6dfd4c63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef724c301cb8f5a7122f60317c7110e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#adef724c301cb8f5a7122f60317c7110e">getExpandedExtractSliceInfo</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, tensor::ExtractSliceOp sliceOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; reassociation, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; expandedShape, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;expandedOffsets, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;expandedSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;expandedStrides)</td></tr>
<tr class="memdesc:adef724c301cb8f5a7122f60317c7110e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the offsets, sizes, and strides needed to build an expanded <code>sliceOp</code>.  <a href="namespacemlir_1_1tensor.html#adef724c301cb8f5a7122f60317c7110e">More...</a><br /></td></tr>
<tr class="separator:adef724c301cb8f5a7122f60317c7110e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5549d629eff95d24dfb8efeb0f15e29e"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a5549d629eff95d24dfb8efeb0f15e29e">simplifyCollapseShapeWithRankReducingExtractSlice</a> (tensor::CollapseShapeOp op, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter)</td></tr>
<tr class="memdesc:a5549d629eff95d24dfb8efeb0f15e29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to simplify a <code>tensor.collapse_shape</code> operation by inserting a single rank-reducing <code>tensor.extract_slice</code> operation.  <a href="namespacemlir_1_1tensor.html#a5549d629eff95d24dfb8efeb0f15e29e">More...</a><br /></td></tr>
<tr class="separator:a5549d629eff95d24dfb8efeb0f15e29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d2ebbc0fa9b642f95770d7d5165906"><td class="memItemLeft" align="right" valign="top">PadOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a29d2ebbc0fa9b642f95770d7d5165906">createPadHighOp</a> (RankedTensorType resType, <a class="el" href="classmlir_1_1Value.html">Value</a> source, <a class="el" href="classmlir_1_1Value.html">Value</a> pad, bool nofold, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dynOutDims={})</td></tr>
<tr class="separator:a29d2ebbc0fa9b642f95770d7d5165906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450fa57046cd901b794bacb1d5bfcbcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a450fa57046cd901b794bacb1d5bfcbcb">createDynamicDimValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> rankedTensor)</td></tr>
<tr class="separator:a450fa57046cd901b794bacb1d5bfcbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeeab52065c4ebba910f4d323fc13af9"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; RankedTensorType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#aeeeab52065c4ebba910f4d323fc13af9">computeTransposedType</a> (RankedTensorType rankedTensorType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; transposeVector)</td></tr>
<tr class="memdesc:aeeeab52065c4ebba910f4d323fc13af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transposed <code>rankedTensorType</code> if <code>transposeVector</code> is non-empty.  <a href="namespacemlir_1_1tensor.html#aeeeab52065c4ebba910f4d323fc13af9">More...</a><br /></td></tr>
<tr class="separator:aeeeab52065c4ebba910f4d323fc13af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4bb2d9d3292647f99ba03588114517"><td class="memItemLeft" align="right" valign="top">CollapseShapeOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a7d4bb2d9d3292647f99ba03588114517">dropGivenUnitDims</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> src, const llvm::SmallBitVector &amp;<a class="el" href="namespacemlir.html#aeaf688b845e36e8284034d28fe9899bc">dropDims</a>)</td></tr>
<tr class="memdesc:a7d4bb2d9d3292647f99ba03588114517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create tensor.collapse_shape to drop unit dimensions in <code>dropDims</code> in tensor <code>src</code>.  <a href="namespacemlir_1_1tensor.html#a7d4bb2d9d3292647f99ba03588114517">More...</a><br /></td></tr>
<tr class="separator:a7d4bb2d9d3292647f99ba03588114517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c787d8d5df3e025be36da4b386c8dee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a4c787d8d5df3e025be36da4b386c8dee">isCastLikeInsertSliceOp</a> (InsertSliceOp op)</td></tr>
<tr class="memdesc:a4c787d8d5df3e025be36da4b386c8dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tensor.insert_slice is a cast-like operation if it merely rank-extends the source tensor or inserts the source tensor into a destination tensor with the same shape.  <a href="namespacemlir_1_1tensor.html#a4c787d8d5df3e025be36da4b386c8dee">More...</a><br /></td></tr>
<tr class="separator:a4c787d8d5df3e025be36da4b386c8dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83daf685932d89a8a3fbff57f383889e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor.html#a83daf685932d89a8a3fbff57f383889e">isCastLikeExtractSliceOp</a> (ExtractSliceOp op)</td></tr>
<tr class="memdesc:a83daf685932d89a8a3fbff57f383889e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tensor.extract_slice is a cast-like operation if it merely rank-reduces unit dimensions of the source tensor or extracts the entire source tensor.  <a href="namespacemlir_1_1tensor.html#a83daf685932d89a8a3fbff57f383889e">More...</a><br /></td></tr>
<tr class="separator:a83daf685932d89a8a3fbff57f383889e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9d4142525a7f3e353e50a35cd66c945d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4142525a7f3e353e50a35cd66c945d">&#9670;&nbsp;</a></span>ControlConstantExtractSliceFusionFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1tensor.html#a9d4142525a7f3e353e50a35cd66c945d">mlir::tensor::ControlConstantExtractSliceFusionFn</a> = typedef std::function&lt;bool(ExtractSliceOp)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to control the folding of constant and extract slice. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Tensor_2IR_2Tensor_8h_source.html#l00167">167</a> of file <a class="el" href="mlir_2Dialect_2Tensor_2IR_2Tensor_8h_source.html">Tensor.h</a>.</p>

</div>
</div>
<a id="ac4b062361904c606cc522e992d1089c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b062361904c606cc522e992d1089c3">&#9670;&nbsp;</a></span>ControlFoldFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1tensor.html#ac4b062361904c606cc522e992d1089c3">mlir::tensor::ControlFoldFn</a> = typedef std::function&lt;bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Tensor_2Transforms_2Transforms_8h_source.html#l00099">99</a> of file <a class="el" href="mlir_2Dialect_2Tensor_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a037e42ffbc07e707a1f2e648c49be367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037e42ffbc07e707a1f2e648c49be367">&#9670;&nbsp;</a></span>bubbleUpPadSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a> &gt; mlir::tensor::bubbleUpPadSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp&#160;</td>
          <td class="paramname"><em>padOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateZeroSliceGuard</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bubbles up a slice of this pad by taking the slice first and then performing the padding. </p>
<p><code>offsets</code> and <code>strides</code> specifies each dimension's start offset and size for the slice. The slice has unit strides along all dimensions.</p>
<p>Specifically, this function converts: </p><div class="fragment"><div class="line">%0 = tensor.pad %source low[...] high[...] { linalg.yield %cst }</div>
<div class="line">%1 = &lt;extract-slice&gt; %0 offsets=[...], sizes[...]</div>
</div><!-- fragment --><p> into </p><div class="fragment"><div class="line">%0 = tensor.extract_slice %source ...</div>
<div class="line">%0 = tensor.pad %0 low[...] high[...] { linalg.yield %cst }</div>
</div><!-- fragment --><p>If <code>generateZeroSliceGuard</code> is true, the generated IR will contain logic to guard against the case that we might take a zero-sized slice from the original source. For such cases, we <code>tensor.generate</code> to generate the full tensor. </p>

<p class="definition">Definition at line <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">88</a> of file <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html">TensorTilingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00072">mlir::dispatchIndexOpFoldResults()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01221">mlir::AffineMap::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00061">getMixedSize()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00220">mlir::getPrunedAttributeList()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">mlir::isZeroInteger()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01329">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01439">mlir::affine::makeComposedFoldedAffineMax()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01432">mlir::affine::makeComposedFoldedAffineMin()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00212">max()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00204">min()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00972">mlir::linalg::ExtractSliceOfPadTensorSwapPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="aef702c5f3daef258e04bedc7489d0794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef702c5f3daef258e04bedc7489d0794">&#9670;&nbsp;</a></span>buildIndependentOp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::tensor::buildIndependentOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::EmptyOp&#160;</td>
          <td class="paramname"><em>emptyOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>independencies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a new tensor::EmptyOp who's dynamic sizes are independent of all given independencies. </p>
<p>If the op is already independent of all independencies, the same EmptyOp result is returned.</p>
<p>Failure indicates the no suitable upper bound for the dynamic sizes could be found. </p>

<p class="definition">Definition at line <a class="el" href="Tensor_2Transforms_2IndependenceTransforms_8cpp_source.html#l00107">107</a> of file <a class="el" href="Tensor_2Transforms_2IndependenceTransforms_8cpp_source.html">IndependenceTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Tensor_2Transforms_2IndependenceTransforms_8cpp_source.html#l00020">makeIndependent()</a>, and <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="abc6c410c5acbddda4ce39cb557a3a3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6c410c5acbddda4ce39cb557a3a3e8">&#9670;&nbsp;</a></span>buildIndependentOp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::tensor::buildIndependentOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp&#160;</td>
          <td class="paramname"><em>padOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>independencies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a new tensor::PadOp with low/high padding that is independent of all given independencies. </p>
<p>If the op is already independent of all independencies, the same PadOp result is returned.</p>
<p>Failure indicates the no suitable upper bound for low/high padding could be found.</p>
<p>Example: scf.for iv = lb to ub step step { high = affine.apply affine_map&lt;(d0)[s0] -&gt; (s0 - d0)&gt; (i)[ub] p = tensor.pad t low[5] high[high] ... ... }</p>
<p>The function builds IR such as: high_new = affine.apply affine_map&lt;()[s0, s1] -&gt; (-s0 + s1)&gt; ()[lb, ub] p_hoistable = tensor.pad t low[5] high[high_new] dim = tensor.dim t, c0 size = affine.apply affine_map&lt;(d0)[s0, s1] -&gt; (-d0 + s0 + s1 + 5)&gt; (iv)[ub, dim] slice = tensor.extract_slice p_hoistable [0] [size] [1]</p>
<p>The slice is returned. </p>

<p class="definition">Definition at line <a class="el" href="Tensor_2Transforms_2IndependenceTransforms_8cpp_source.html#l00036">36</a> of file <a class="el" href="Tensor_2Transforms_2IndependenceTransforms_8cpp_source.html">IndependenceTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="Builders_8cpp_source.html#l00364">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Tensor_2Transforms_2IndependenceTransforms_8cpp_source.html#l00020">makeIndependent()</a>, and <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a30deb019e8a71c65e127e245b9cf63fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30deb019e8a71c65e127e245b9cf63fb">&#9670;&nbsp;</a></span>canFoldIntoConsumerOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::tensor::canFoldIntoConsumerOp </td>
          <td>(</td>
          <td class="paramtype">CastOp&#160;</td>
          <td class="paramname"><em>castOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether tensor::CastOp casts to a more dynamic version of the source tensor. </p>
<p>This is useful to fold a tensor.cast into a consuming op and implement canonicalization patterns for ops in different dialects that may consume the results of tensor.cast operations. Such foldable tensor.cast operations are typically inserted as <code>extract_slice</code> ops and are canonicalized, to preserve the type compatibility of their uses.</p>
<p>Returns true when all conditions are met:</p><ol type="1">
<li>source and result are ranked tensors with same element type and rank.</li>
<li>the tensor type has more static information than the result</li>
</ol>
<p>Example: </p><div class="fragment"><div class="line">%1 = tensor.cast %0 : tensor&lt;8x16xf32&gt; to tensor&lt;?x?xf32&gt;</div>
<div class="line">%2 = consumer %1 ... : tensor&lt;?x?xf32&gt; ...</div>
</div><!-- fragment --><p>folds into:</p>
<div class="fragment"><div class="line">%2 = consumer %0 ... : tensor&lt;8x16xf32&gt; ...</div>
</div><!-- fragment --><p>This is useful to fold a tensor.cast into a consuming op and implement canonicalization patterns for ops in different dialects that may consume the results of tensor.cast operations. Such foldable tensor.cast operations are typically inserted as <code>slice</code> ops and are canonicalized, to preserve the type compatibility of their uses.</p>
<p>Returns true when all conditions are met:</p><ol type="1">
<li>source and result are ranked tensors with same element type and rank.</li>
<li>the tensor type has more static information than the result</li>
</ol>
<p>Example: </p><div class="fragment"><div class="line">%1 = tensor.cast %0 : tensor&lt;8x16xf32&gt; to tensor&lt;?x?xf32&gt;</div>
<div class="line">%2 = consumer %1 ... : tensor&lt;?x?xf32&gt; ...</div>
</div><!-- fragment --><p>folds into:</p>
<div class="fragment"><div class="line">%2 = consumer %0 ... : tensor&lt;8x16xf32&gt; ...</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00322">322</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00270">preservesStaticInformation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l00830">FoldCopyOfCast()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00391">foldTensorCast()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00369">getUpdatedOperandsAfterCastOpFolding()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l02638">CollapseShapeOpMemRefCastFolder::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a1bbbd2b47f452ac54390390eb2099edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbbd2b47f452ac54390390eb2099edd">&#9670;&nbsp;</a></span>canFoldIntoProducerOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::tensor::canFoldIntoProducerOp </td>
          <td>(</td>
          <td class="paramtype">CastOp&#160;</td>
          <td class="paramname"><em>castOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the tensor::CastOp casts to a more static version of the source tensor. </p>
<p>This is useful to fold into a producing op and implement canonicaliation patterns with the <code>tensor.cast</code> op as the root, but producer being from different dialects. Returns true when all conditions are met:</p><ol type="1">
<li>source and result and ranked tensors with same element type and rank.</li>
<li>the result type has more static information than the source.</li>
</ol>
<p>Example: </p><div class="fragment"><div class="line">%1 = producer ... : tensor&lt;?x?xf32&gt;</div>
<div class="line">%2 = tensor.cast %1 : tensor&lt;?x?xf32&gt; to tensor&lt;8x16xf32&gt;</div>
</div><!-- fragment --><p>can be canonicalized to :</p>
<div class="fragment"><div class="line">%2 = producer ... : tensor&lt;8x16xf32&gt;</div>
</div><!-- fragment --><p> Not all ops might be canonicalizable this way, but for those that can be, this method provides a check that it is worth doing the canonicalization.</p>
<p>This is useful to fold into a producing op and implement canonicalization patterns with the <code>tensor.cast</code> op as the root, but producer being from different dialects. Returns true when all conditions are met:</p><ol type="1">
<li>source and result and ranked tensors with same element type and rank.</li>
<li>the result type has more static information than the source.</li>
</ol>
<p>Example: </p><div class="fragment"><div class="line">%1 = producer ... : tensor&lt;?x?xf32&gt;</div>
<div class="line">%2 = tensor.cast %1 : tensor&lt;?x?xf32&gt; to tensor&lt;8x16xf32&gt;</div>
</div><!-- fragment --><p>can be canonicalized to :</p>
<div class="fragment"><div class="line">%2 = producer ... : tensor&lt;8x16xf32&gt;</div>
</div><!-- fragment --><p> Not all ops might be canonicalizable this way, but for those that can be, this method provides a check that it is worth doing the canonicalization. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00353">353</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00270">preservesStaticInformation()</a>.</p>

</div>
</div>
<a id="aeeeab52065c4ebba910f4d323fc13af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeeab52065c4ebba910f4d323fc13af9">&#9670;&nbsp;</a></span>computeTransposedType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; RankedTensorType &gt; mlir::tensor::computeTransposedType </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>rankedTensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>transposeVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the transposed <code>rankedTensorType</code> if <code>transposeVector</code> is non-empty. </p>
<p>Fail if <code>transposeVector</code> is not a permutation matching the tensor rank. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00076">76</a> of file <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00226">mlir::applyPermutationToVector()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00223">mlir::isPermutationVector()</a>, and <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00241">mlir::RankedTensorType::Builder::setShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HoistPadding_8cpp_source.html#l00683">buildPackingLoopNestImpl()</a>, and <a class="el" href="HoistPadding_8cpp_source.html#l00943">mlir::linalg::hoistPaddingOnTensors()</a>.</p>

</div>
</div>
<a id="a6cfe3bede328e5dc72de55dfca72fe1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfe3bede328e5dc72de55dfca72fe1d">&#9670;&nbsp;</a></span>createCanonicalRankReducingExtractSliceOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::tensor::createCanonicalRankReducingExtractSliceOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>targetType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a rank-reducing ExtractSliceOp @[0 . </p>
<p>. 0] with strides [1 .. 1] and appropriate sizes (i.e. <code>tensor.getSizes()</code>) to reduce the rank of <code>tensor</code> to that of <code>targetType</code>. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l02777">2777</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00525">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00070">getMixedSizes()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00972">mlir::linalg::ExtractSliceOfPadTensorSwapPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a6b0730cfcf9d984a57414d62c2b18b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0730cfcf9d984a57414d62c2b18b2f">&#9670;&nbsp;</a></span>createCanonicalRankReducingInsertSliceOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::tensor::createCanonicalRankReducingInsertSliceOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a rank-reducing InsertSliceOp @[0 . </p>
<p>. 0] with strides [1 .. 1] and appropriate sizes (i.e. <code>dest.getSizes()</code>). The result is a new tensor with rank increased to that of <code>dest</code>, obtained by inserting <code>tensor</code> into <code>dest</code> at the canonical [0 .. 0] position. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l03182">3182</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00525">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00070">getMixedSizes()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a450fa57046cd901b794bacb1d5bfcbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450fa57046cd901b794bacb1d5bfcbcb">&#9670;&nbsp;</a></span>createDynamicDimValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::tensor::createDynamicDimValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>rankedTensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00062">62</a> of file <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SplitReduction_8cpp_source.html#l00241">mlir::linalg::splitReductionByScaling()</a>.</p>

</div>
</div>
<a id="a29d2ebbc0fa9b642f95770d7d5165906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d2ebbc0fa9b642f95770d7d5165906">&#9670;&nbsp;</a></span>createPadHighOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PadOp mlir::tensor::createPadHighOp </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>resType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>pad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nofold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>dynOutDims</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00023">23</a> of file <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00061">getMixedSize()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01329">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01018">getPackOpSourceOrPaddedSource()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00243">mlir::linalg::makeComposedPadHighOp()</a>.</p>

</div>
</div>
<a id="a7d4bb2d9d3292647f99ba03588114517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4bb2d9d3292647f99ba03588114517">&#9670;&nbsp;</a></span>dropGivenUnitDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CollapseShapeOp mlir::tensor::dropGivenUnitDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>dropDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create tensor.collapse_shape to drop unit dimensions in <code>dropDims</code> in tensor <code>src</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00095">95</a> of file <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00256">mlir::dropDims()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00469">setBit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00229">mlir::linalg::fuseProducerOfTensor()</a>.</p>

</div>
</div>
<a id="a00e4cc4be054eec0b07a42e2f63f05f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e4cc4be054eec0b07a42e2f63f05f2">&#9670;&nbsp;</a></span>foldTensorCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::tensor::foldTensorCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs folding of any operand of <code>op</code> if it comes from a tensor::CastOp that can be folded. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00391">391</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00322">canFoldIntoConsumerOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>.</p>

</div>
</div>
<a id="a08f36b140fcf2e0ed55e4cb6dfd4c63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f36b140fcf2e0ed55e4cb6dfd4c63a">&#9670;&nbsp;</a></span>getCollapsedExtractSliceInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::tensor::getCollapsedExtractSliceInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ExtractSliceOp&#160;</td>
          <td class="paramname"><em>sliceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>collapsedOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>collapsedSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>collapsedStrides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the offsets, sizes, and strides needed to build a collapsed <code>sliceOp</code>. </p>
<p>The dimensions to collapse are specified by <code>reassociation</code>.</p>
<p>This fails when the specified collapse cannot be represented by a valid ExtractSliceOp. </p>

<p class="definition">Definition at line <a class="el" href="ReshapePatterns_8cpp_source.html#l00463">463</a> of file <a class="el" href="ReshapePatterns_8cpp_source.html">ReshapePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00827">mlir::ValueBoundsConstraintSet::areEqual()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01221">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00070">getMixedSizes()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00022">mlir::isOneInteger()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">mlir::isZeroInteger()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01329">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

</div>
</div>
<a id="adef724c301cb8f5a7122f60317c7110e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef724c301cb8f5a7122f60317c7110e">&#9670;&nbsp;</a></span>getExpandedExtractSliceInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::tensor::getExpandedExtractSliceInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ExtractSliceOp&#160;</td>
          <td class="paramname"><em>sliceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>reassociation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>expandedShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expandedOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expandedSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expandedStrides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the offsets, sizes, and strides needed to build an expanded <code>sliceOp</code>. </p>
<p>The dimensions to expand are specified by <code>reassociation</code> and <code>expandedShape</code>.</p>
<p>This fails when the specified expansion cannot be represented by a valid ExtractSliceOp. </p>

<p class="definition">Definition at line <a class="el" href="ReshapePatterns_8cpp_source.html#l00583">583</a> of file <a class="el" href="ReshapePatterns_8cpp_source.html">ReshapePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, and <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>.</p>

</div>
</div>
<a id="a8d577c5f161da7be47b356b6363a7eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d577c5f161da7be47b356b6363a7eae">&#9670;&nbsp;</a></span>getMixedSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::tensor::getMixedSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dimension of the given tensor value. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00061">61</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00525">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">bubbleUpPadSlice()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00023">createPadHighOp()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00070">getMixedSizes()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00217">mlir::linalg::lowerPack()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01237">mlir::linalg::DecomposeOuterUnitDimsUnPackOpPattern::matchAndRewrite()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00921">mlir::linalg::DecomposePadOpPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ad1d0935f6c223e44294137605bb39d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d0935f6c223e44294137605bb39d60">&#9670;&nbsp;</a></span>getMixedSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::tensor::getMixedSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dimensions of the given tensor value. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00070">70</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00061">getMixedSize()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00078">mlir::tensor::ExtractSliceFromCollapseHelper::create()</a>, <a class="el" href="TensorOps_8cpp_source.html#l02777">createCanonicalRankReducingExtractSliceOp()</a>, <a class="el" href="TensorOps_8cpp_source.html#l03182">createCanonicalRankReducingInsertSliceOp()</a>, <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00126">mlir::linalg::createDestinationPassingStyleInitOperand()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00319">mlir::vector::createReadOrMaskedRead()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00251">expandValue()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00865">fuseWithReshapeByExpansion()</a>, <a class="el" href="ReshapePatterns_8cpp_source.html#l00463">getCollapsedExtractSliceInfo()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00298">mlir::vector::getMixedSizesXfer()</a>, <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00059">getOrCreateOperandsMatchingResultTypes()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00217">mlir::linalg::lowerPack()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00346">mlir::linalg::lowerUnPack()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00921">mlir::linalg::DecomposePadOpPattern::matchAndRewrite()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05019">mlir::linalg::reifyResultShapesImpl()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00429">mlir::linalg::rewriteInDestinationPassingStyle()</a>, and <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00158">simplifyCollapseShapeWithRankReducingExtractSlice()</a>.</p>

</div>
</div>
<a id="a90e502153b3c46a11dad42045c36bc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e502153b3c46a11dad42045c36bc31">&#9670;&nbsp;</a></span>getOrCreateDestination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::tensor::getOrCreateDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>opResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a helper function for DestinationStyleOpInterface. </p>
<p>If there is a destination operand for the given <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a>, return that operand. Otherwise, return an empty tensor (<code>tensor.empty</code>) with the shape of the <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a>. Dynamic dimensions are queried via ReifyRankedShapedTypeOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00079">79</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Value_8h_source.html#l00459">mlir::OpResult::getResultNumber()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00027">mlir::reifyResultShapes()</a>, and <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l00114">getOrCreateDestinations()</a>, and <a class="el" href="TileUsingInterface_8cpp_source.html#l01451">mlir::scf::yieldReplacementForFusedProducer()</a>.</p>

</div>
</div>
<a id="ad28262a44a78b9ce6b2e43195dd2a085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28262a44a78b9ce6b2e43195dd2a085">&#9670;&nbsp;</a></span>getOrCreateDestinations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::tensor::getOrCreateDestinations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a helper function for DestinationStyleOpInterface. </p>
<p>Get or create destinations for every tensor <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> of the given op. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00114">114</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00079">getOrCreateDestination()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00726">createInitialTensorsForTiling()</a>, <a class="el" href="Split_8cpp_source.html#l00067">mlir::linalg::splitOp()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00889">tileAndFuseFirstExtractUseThroughContainingOpBlockArgument()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l01336">mlir::scf::tileAndFuseProducerOfSlice()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00589">mlir::linalg::tileReductionUsingForall()</a>.</p>

</div>
</div>
<a id="a265e307a38759e898773b475a475e2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265e307a38759e898773b475a475e2fe">&#9670;&nbsp;</a></span>getUpdatedOperandsAfterCastOpFolding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::tensor::getUpdatedOperandsAfterCastOpFolding </td>
          <td>(</td>
          <td class="paramtype">DestinationStyleOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newResTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assuming that <code>op</code> contains at least one operand that is a foldable CastOp (i.e. </p>
<p><code>hasFoldableTensorCastOperand</code> returns true), calculate the updated operands. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00369">369</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00322">canFoldIntoConsumerOp()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l00360">hasFoldableTensorCastOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l04092">FoldTensorCastProducerOp::matchAndRewrite()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05732">mlir::linalg::FoldTensorCastPackOp::matchAndRewrite()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l06055">mlir::linalg::FoldTensorCastUnPackOp::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a0a08b46210e9d5cac2cd665dac0bce07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a08b46210e9d5cac2cd665dac0bce07">&#9670;&nbsp;</a></span>hasFoldableTensorCastOperand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::tensor::hasFoldableTensorCastOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if any of the operands of <code>op</code> is a CastOp that can be folded into its consumer, i.e. </p>
<p><code>op</code>. This is effectively a convenience wrapper for <code>canFoldIntoProducerOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00360">360</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l04060">foldTensorCastPrecondition()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00369">getUpdatedOperandsAfterCastOpFolding()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05732">mlir::linalg::FoldTensorCastPackOp::matchAndRewrite()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l06055">mlir::linalg::FoldTensorCastUnPackOp::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a83daf685932d89a8a3fbff57f383889e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83daf685932d89a8a3fbff57f383889e">&#9670;&nbsp;</a></span>isCastLikeExtractSliceOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::tensor::isCastLikeExtractSliceOp </td>
          <td>(</td>
          <td class="paramtype">ExtractSliceOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A tensor.extract_slice is a cast-like operation if it merely rank-reduces unit dimensions of the source tensor or extracts the entire source tensor. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00149">149</a> of file <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00827">mlir::ValueBoundsConstraintSet::areEqual()</a>, and <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>.</p>

</div>
</div>
<a id="a4c787d8d5df3e025be36da4b386c8dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c787d8d5df3e025be36da4b386c8dee">&#9670;&nbsp;</a></span>isCastLikeInsertSliceOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::tensor::isCastLikeInsertSliceOp </td>
          <td>(</td>
          <td class="paramtype">InsertSliceOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A tensor.insert_slice is a cast-like operation if it merely rank-extends the source tensor or inserts the source tensor into a destination tensor with the same shape. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00125">125</a> of file <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00827">mlir::ValueBoundsConstraintSet::areEqual()</a>, and <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>.</p>

</div>
</div>
<a id="a7c8704f34ea971ccefd3c0150f8b6bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8704f34ea971ccefd3c0150f8b6bda">&#9670;&nbsp;</a></span>isSameTypeWithoutEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::tensor::isSameTypeWithoutEncoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>tp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>tp2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if types are the same when ignoring encoding on ranked tensors. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00128">128</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l02043">verifyTensorReshapeOp()</a>.</p>

</div>
</div>
<a id="a84385ac9917cc0e9d0b661b117a1aa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84385ac9917cc0e9d0b661b117a1aa95">&#9670;&nbsp;</a></span>populateBubbleUpExpandShapePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::populateBubbleUpExpandShapePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns that bubble up <code>tensor.expand_shape</code> through <code>tensor.collapse_shape</code> ops. </p>

<p class="definition">Definition at line <a class="el" href="ReshapePatterns_8cpp_source.html#l00731">731</a> of file <a class="el" href="ReshapePatterns_8cpp_source.html">ReshapePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a67cd03acfd3c0a39d7b81142e09c0ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67cd03acfd3c0a39d7b81142e09c0ea6">&#9670;&nbsp;</a></span>populateBubbleUpExtractSliceOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::populateBubbleUpExtractSliceOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns that are used to bubble up tensor.extract slice op above its producer. </p>
<p>When used as cleanup patterns of tile and fuse, enables fusing the producer with the consumer even if the producer does not implement the tiling interface. </p>

<p class="definition">Definition at line <a class="el" href="ReshapePatterns_8cpp_source.html#l00736">736</a> of file <a class="el" href="ReshapePatterns_8cpp_source.html">ReshapePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a4e1858e8d94e747b946b919c2685463c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1858e8d94e747b946b919c2685463c">&#9670;&nbsp;</a></span>populateDecomposeTensorConcatPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::populateDecomposeTensorConcatPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns that decompose <code>tensor.concat</code> into <code>tensor.empty</code> of a tensor of the concatenated size, followed by a chain of <code>tensor.insert_slice</code> operations on the inputs. </p>
<p>This is intended to be used as a fallback tensor -&gt; tensor lowering that decomposes concat such that it can be bufferized into a sequence of copies. </p>

<p class="definition">Definition at line <a class="el" href="ConcatOpPatterns_8cpp_source.html#l00046">46</a> of file <a class="el" href="ConcatOpPatterns_8cpp_source.html">ConcatOpPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ab0f73bd63d8aa577bf0be474817cca20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f73bd63d8aa577bf0be474817cca20">&#9670;&nbsp;</a></span>populateDropRedundantInsertSliceRankExpansionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::populateDropRedundantInsertSliceRankExpansionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns that drop redundant tensor.insert_slice rank expansions. </p>

<p class="definition">Definition at line <a class="el" href="MergeConsecutiveInsertExtractSlicePatterns_8cpp_source.html#l00238">238</a> of file <a class="el" href="MergeConsecutiveInsertExtractSlicePatterns_8cpp_source.html">MergeConsecutiveInsertExtractSlicePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a8ffb9f13d230b356ca5c58ee95a611db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ffb9f13d230b356ca5c58ee95a611db">&#9670;&nbsp;</a></span>populateFoldCollapseExtractPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::populateFoldCollapseExtractPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold extracts of a collapse_shaped tensor to an extract of the source tensor. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l01443">1443</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a0edfdd5a23215fd0d8d587be6ebae28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edfdd5a23215fd0d8d587be6ebae28a">&#9670;&nbsp;</a></span>populateFoldConstantExtractSlicePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::populateFoldConstantExtractSlicePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1tensor.html#a9d4142525a7f3e353e50a35cd66c945d">ControlConstantExtractSliceFusionFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlFn</em> = <code>[](ExtractSliceOp&#160;op)&#160;{&#160;&#160;&#160;return&#160;false;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold the extract slice op with its constant operand. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l02690">2690</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

</div>
</div>
<a id="a1e85d021b66e41b155c2ac8a79470a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e85d021b66e41b155c2ac8a79470a0b">&#9670;&nbsp;</a></span>populateFoldTensorEmptyPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::populateFoldTensorEmptyPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>foldSingleUseOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns that fold tensor.empty with its consumers. </p>
<p>If <code>singleUseOnly</code> is set to "true", only tensor.empty ops with a single use are folded. </p>

<p class="definition">Definition at line <a class="el" href="EmptyOpPatterns_8cpp_source.html#l00130">130</a> of file <a class="el" href="EmptyOpPatterns_8cpp_source.html">EmptyOpPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="DropUnitDims_8cpp_source.html#l00804">populateFoldUnitExtentDimsViaReshapesPatterns()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00824">populateFoldUnitExtentDimsViaSlicesPatterns()</a>.</p>

</div>
</div>
<a id="adc69c3905c73a83187b7f09642273935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc69c3905c73a83187b7f09642273935">&#9670;&nbsp;</a></span>populateFoldTensorSubsetIntoVectorTransferPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::populateFoldTensorSubsetIntoVectorTransferPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for folding tensor subset ops into vector transfer ops. </p>

<p class="definition">Definition at line <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00254">254</a> of file <a class="el" href="FoldTensorSubsetOps_8cpp_source.html">FoldTensorSubsetOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00247">populateFoldTensorSubsetOpPatterns()</a>.</p>

</div>
</div>
<a id="a543432e9d12118a7622a3089d8273ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543432e9d12118a7622a3089d8273ff3">&#9670;&nbsp;</a></span>populateFoldTensorSubsetOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::populateFoldTensorSubsetOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for folding tensor subset ops into consumer load/store ops into <code>patterns</code>. </p>
<p>(This includes patterns for folding tensor subset ops into vector transfer ops.) </p>

<p class="definition">Definition at line <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00247">247</a> of file <a class="el" href="FoldTensorSubsetOps_8cpp_source.html">FoldTensorSubsetOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, and <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00254">populateFoldTensorSubsetIntoVectorTransferPatterns()</a>.</p>

</div>
</div>
<a id="a354a5a1166be4a8db79d65866e88182e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354a5a1166be4a8db79d65866e88182e">&#9670;&nbsp;</a></span>populateMergeConsecutiveInsertExtractSlicePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::populateMergeConsecutiveInsertExtractSlicePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects patterns to merge consecutive tensor.insert_slice/extract_slice into one. </p>
<p>These patterns are in this separate entry point because the bufferization is sensitive to IR structure, particularly those tensor.extract_slice and tensor.insert_slice ops for creating the slices. </p>

<p class="definition">Definition at line <a class="el" href="MergeConsecutiveInsertExtractSlicePatterns_8cpp_source.html#l00230">230</a> of file <a class="el" href="MergeConsecutiveInsertExtractSlicePatterns_8cpp_source.html">MergeConsecutiveInsertExtractSlicePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a59694a86108b2b08581a0910c8dc14a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59694a86108b2b08581a0910c8dc14a0">&#9670;&nbsp;</a></span>populateReassociativeReshapeFoldingPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::populateReassociativeReshapeFoldingPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns that fold <code>tensor.expand_shape</code> and <code>tensor.collapse_shape</code> into other ops. </p>

<p class="definition">Definition at line <a class="el" href="ReshapePatterns_8cpp_source.html#l00720">720</a> of file <a class="el" href="ReshapePatterns_8cpp_source.html">ReshapePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ace25e5493ab1c4df8e63c524aba2dad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace25e5493ab1c4df8e63c524aba2dad0">&#9670;&nbsp;</a></span>populateRewriteAsConstantPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::populateRewriteAsConstantPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1tensor.html#ac4b062361904c606cc522e992d1089c3">ControlFoldFn</a> &amp;&#160;</td>
          <td class="paramname"><em>controlFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns that replace tensor ops (such as tensor.generate) with constants when possible. </p>

<p class="definition">Definition at line <a class="el" href="RewriteAsConstant_8cpp_source.html#l00211">211</a> of file <a class="el" href="RewriteAsConstant_8cpp_source.html">RewriteAsConstant.cpp</a>.</p>

</div>
</div>
<a id="ac1b0cdf08bf148506f761f70f24059f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b0cdf08bf148506f761f70f24059f0">&#9670;&nbsp;</a></span>preservesStaticInformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::tensor::preservesStaticInformation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>target</code> is a ranked tensor type that preserves static information available in the <code>source</code> ranked tensor type. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00270">270</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l00322">canFoldIntoConsumerOp()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l00353">canFoldIntoProducerOp()</a>.</p>

</div>
</div>
<a id="acc8a002ba50ad2f3d5c09e4e0efdc0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8a002ba50ad2f3d5c09e4e0efdc0d3">&#9670;&nbsp;</a></span>registerAllExtensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::registerAllExtensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register all extensions of the Tensor dialect. </p>
<p>This should generally only be used by tools, or other use cases that really do want <em>all</em> extensions of the dialect. All other cases should prefer to instead register the specific extensions they intend to take advantage of. </p>

<p class="definition">Definition at line <a class="el" href="Tensor_2Extensions_2AllExtensions_8cpp_source.html#l00014">14</a> of file <a class="el" href="Tensor_2Extensions_2AllExtensions_8cpp_source.html">AllExtensions.cpp</a>.</p>

<p class="reference">References <a class="el" href="Arith_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00098">mlir::arith::registerShardingInterfaceExternalModels()</a>.</p>

</div>
</div>
<a id="aa09a0f22283c4ef45935f058b6f629cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09a0f22283c4ef45935f058b6f629cb">&#9670;&nbsp;</a></span>registerBufferizableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::registerBufferizableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l01215">1215</a> of file <a class="el" href="Tensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html">BufferizableOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, <a class="el" href="MLIRContext_8h_source.html#l00110">mlir::MLIRContext::loadDialect()</a>, and <a class="el" href="Tensor_2Transforms_2SubsetInsertionOpInterfaceImpl_8cpp_source.html#l00087">registerSubsetOpInterfaceExternalModels()</a>.</p>

</div>
</div>
<a id="a7ef6c3ff4458d28bdbb29b151ae4d9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef6c3ff4458d28bdbb29b151ae4d9ff">&#9670;&nbsp;</a></span>registerFindPayloadReplacementOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::registerFindPayloadReplacementOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TensorTransformOps_8cpp_source.html#l00071">71</a> of file <a class="el" href="TensorTransformOps_8cpp_source.html">TensorTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a537a26573013e086958f9f7a18fa65d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537a26573013e086958f9f7a18fa65d5">&#9670;&nbsp;</a></span>registerInferTypeOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::registerInferTypeOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">mlir::DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers external models for Infer <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> interfaces for tensor ops. </p>
<p>Currently, it registers:</p>
<ul>
<li>ReifyRankedShapedTypeOpInterface for <code>tensor.collapse_shape</code>.</li>
<li>ReifyRankedShapedTypeOpInterface for <code>tensor.expand_shape</code>.</li>
</ul>
<p>Unfortunately, a "normal" internal registration is not possible at the moment, because of the dependency of the interface implementation for these ops on <code>affine.apply</code> and Affine dialect already depends on TensorOps. In order to break the cyclic dependency (TensorOps-&gt;AffineOps-&gt;TensorOps) the implementation is moved to a separate library. </p>

<p class="definition">Definition at line <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00128">128</a> of file <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html">TensorInferTypeOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ae9e08e5e78426a356823fad9da7faf74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e08e5e78426a356823fad9da7faf74">&#9670;&nbsp;</a></span>registerRuntimeVerifiableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::registerRuntimeVerifiableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tensor_2Transforms_2RuntimeOpVerification_8cpp_source.html#l00194">194</a> of file <a class="el" href="Tensor_2Transforms_2RuntimeOpVerification_8cpp_source.html">RuntimeOpVerification.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

</div>
</div>
<a id="ae4c009c40e6adaa31399030460514ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c009c40e6adaa31399030460514ab7">&#9670;&nbsp;</a></span>registerShardingInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::registerShardingInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tensor_2Extensions_2ShardingExtensions_8cpp_source.html#l00104">104</a> of file <a class="el" href="Tensor_2Extensions_2ShardingExtensions_8cpp_source.html">ShardingExtensions.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

</div>
</div>
<a id="a72d6437bbf0214af0aa54891c0cc4f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d6437bbf0214af0aa54891c0cc4f0a">&#9670;&nbsp;</a></span>registerSubsetOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::registerSubsetOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tensor_2Transforms_2SubsetInsertionOpInterfaceImpl_8cpp_source.html#l00087">87</a> of file <a class="el" href="Tensor_2Transforms_2SubsetInsertionOpInterfaceImpl_8cpp_source.html">SubsetInsertionOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l01215">registerBufferizableOpInterfaceExternalModels()</a>.</p>

</div>
</div>
<a id="a84a4bebf333acf49aa338a6f810152f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a4bebf333acf49aa338a6f810152f5">&#9670;&nbsp;</a></span>registerTilingInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::registerTilingInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">mlir::DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers external models for Tiling interface for tensor ops. </p>
<p>Currently, it registers:</p>
<ul>
<li>TilingInterface for <code>tensor.pad</code>, <code>tensor.pack</code>, and <code>tensor.unpack</code>.</li>
</ul>
<p>Unfortunately, a "normal" internal registration is not possible at the moment, because of the dependency of the interface implementation for these ops on <code>affine.apply</code> and Affine dialect already depends on TensorOps. In order to break the cyclic dependency (TensorOps-&gt;AffineOps-&gt;TensorOps) the implementation is moved to a separate library. </p>

<p class="definition">Definition at line <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00311">311</a> of file <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html">TensorTilingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

</div>
</div>
<a id="ae7b2a78b51f3a2f1e5f8ebdcabdb8037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b2a78b51f3a2f1e5f8ebdcabdb8037">&#9670;&nbsp;</a></span>registerTilingInterfaceExternalModelsForPackUnPackOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::registerTilingInterfaceExternalModelsForPackUnPackOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the above registeration, but it is only for <code>tensor.pack</code> and <code>tensor.unpack</code> ops. </p>

</div>
</div>
<a id="a31e647b877acb2e8497ffb6415f5ef98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e647b877acb2e8497ffb6415f5ef98">&#9670;&nbsp;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TensorTransformOps_8cpp_source.html#l00258">258</a> of file <a class="el" href="TensorTransformOps_8cpp_source.html">TensorTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00222">mlir::DialectRegistry::addExtensions()</a>.</p>

</div>
</div>
<a id="ae180e649b9172ba9094eb52635792d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae180e649b9172ba9094eb52635792d9a">&#9670;&nbsp;</a></span>registerValueBoundsOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::tensor::registerValueBoundsOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tensor_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00116">116</a> of file <a class="el" href="Tensor_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

</div>
</div>
<a id="a2224cac41fe066a9f63214b45cd24c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2224cac41fe066a9f63214b45cd24c0b">&#9670;&nbsp;</a></span>replaceExtractSliceWithTiledProducer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a> &gt; mlir::tensor::replaceExtractSliceWithTiledProducer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ExtractSliceOp&#160;</td>
          <td class="paramname"><em>sliceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>producerOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to swap an <code>tensor.extract_slice</code> with its producer when the producer implements the <code>TilingInterface</code>. </p>
<p>The pattern itself does not provide a mechanism to control where the application happens. With use of transform dialect that control is done within the transform dialect. Other use cases can inherit from this pattern and add necessary controls. </p>

<p class="definition">Definition at line <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html#l00025">25</a> of file <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html">SwapExtractSliceWithProducerPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Value_8h_source.html#l00456">mlir::OpResult::getOwner()</a>, <a class="el" href="Value_8h_source.html#l00459">mlir::OpResult::getResultNumber()</a>, <a class="el" href="Builders_8h_source.html#l00091">mlir::Builder::getType()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00022">mlir::isOneInteger()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l01336">mlir::scf::tileAndFuseProducerOfSlice()</a>.</p>

</div>
</div>
<a id="a26569c717f5bd0eb52b7b92d84cfbdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26569c717f5bd0eb52b7b92d84cfbdb4">&#9670;&nbsp;</a></span>replaceInsertSlicesWithTiledConsumer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a> &gt; mlir::tensor::replaceInsertSlicesWithTiledConsumer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; tensor::InsertSliceOp &gt;&#160;</td>
          <td class="paramname"><em>sliceOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt;&#160;</td>
          <td class="paramname"><em>consumerOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to swap <code>tensor.insert_slice</code>s with their consumers when the consumer implements the <code>TilingInterface</code>. </p>
<p>The size of <code>sliceOps</code> and <code>consumerOperands</code> is expected to be the same. Every entry in <code>consumerOperands</code> represents a use of the the corresponding entry in <code>sliceOps</code> in the consumer. All entries of <code>consumerOperands</code> is expected to be uses in the same consumer. </p>

<p class="definition">Definition at line <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html#l00061">61</a> of file <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html">SwapExtractSliceWithProducerPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="Value_8cpp_source.html#l00226">mlir::OpOperand::getOperandNumber()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00022">mlir::isOneInteger()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l02191">mlir::scf::tileAndFuseConsumerOfSlices()</a>.</p>

</div>
</div>
<a id="a5549d629eff95d24dfb8efeb0f15e29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5549d629eff95d24dfb8efeb0f15e29e">&#9670;&nbsp;</a></span>simplifyCollapseShapeWithRankReducingExtractSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::tensor::simplifyCollapseShapeWithRankReducingExtractSlice </td>
          <td>(</td>
          <td class="paramtype">tensor::CollapseShapeOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to simplify a <code>tensor.collapse_shape</code> operation by inserting a single rank-reducing <code>tensor.extract_slice</code> operation. </p>
<p>The <code>extract_slice</code> op will either take the place of the source, allowing for a new, simpler <code>collapse_shape</code> op to replace <code>op</code>, or the <code>collapse_shape</code> op will be completely replaced by the <code>extract_slice</code> result. Either way, <code>op</code> is replaced and the new op is returned.</p>
<h3><a class="anchor" id="autotoc_md28"></a>
Example:</h3>
<div class="fragment"><div class="line">%result = tensor.collapse_shape %0 [[0, 1], [2, 3]]</div>
<div class="line">   : tensor&lt;?x1x30x10xf32&gt; to tensor&lt;?x300xf32&gt;</div>
</div><!-- fragment --><p> can be transformed to</p>
<div class="fragment"><div class="line">%tmp = tensor.extract_slice %0 [0, 0, 0, 0]</div>
<div class="line">                        [0, %dim1, 30, 30]</div>
<div class="line">                        [1, 1, 1 1]</div>
<div class="line">  : tensor&lt;?x1x30x10xf32&gt; to tensor&lt;?x30x10xf32&gt;</div>
<div class="line">%result = tensor.collapse_shape %tmp [[0], [1, 2]]</div>
<div class="line">  : tensor&lt;?x30x10xf32&gt; to tensor&lt;?x300xf32&gt;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md29"></a>
Example:</h3>
<div class="fragment"><div class="line">%result = tensor.collapse_shape %1 [[0, 1], [2]]</div>
<div class="line">   : tensor&lt;?x1x30xf32&gt; to tensor&lt;?x30xf32&gt;</div>
</div><!-- fragment --><p> can be transformed to </p><div class="fragment"><div class="line">%result = tensor.extract_slice %1 [0, 0, 0]</div>
<div class="line">                                  [%dim2, 1, 30]</div>
<div class="line">                                  [1, 1, 1]</div>
<div class="line">   : tensor&lt;?x1x30xf32&gt; to tensor&lt;?x30xf32&gt;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md30"></a>
Unsupported cases:</h3>
<p>This transform doesn't yet support reducing the rank of the reassociation indices, which would require inserting a <code>tensor.expand_shape</code> op similar to the following example: </p><div class="fragment"><div class="line">%result = tensor.collapse_shape %0 [[0, 1], [2, 3]]</div>
<div class="line">   : tensor&lt;1x1x30x10xf32&gt; to tensor&lt;1x300xf32&gt;</div>
</div><!-- fragment --><p> can be transformed to </p><div class="fragment"><div class="line">%tmp = tensor.extract_slice %0 [0, 0, 0, 0]</div>
<div class="line">                        [0, 1, 30, 30]</div>
<div class="line">                        [1, 1, 1 1]</div>
<div class="line">  : tensor&lt;1x1x30x10xf32&gt; to tensor&lt;30x10xf32&gt;</div>
<div class="line">%result0 = tensor.collapse_shape %tmp [[0, 1]]</div>
<div class="line">  : tensor&lt;30x10xf32&gt; to tensor&lt;300xf32&gt;</div>
<div class="line">%result1 = tensor.expand_shape %tmp [[0, 1], [2]] :... tensor&lt;1x300xf32&gt;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00158">158</a> of file <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html">ExtractSliceFromReshapeUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00070">getMixedSizes()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00529">mlir::RewriterBase::replaceOpWithNewOp()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 27 2025 16:33:12 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
