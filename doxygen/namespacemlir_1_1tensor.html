<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::tensor Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="namespacemlir_1_1tensor.html">tensor</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mlir::tensor Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:impl" id="r_impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tensor_1_1impl.html">impl</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:ExtractSliceFromCollapseHelper" id="r_ExtractSliceFromCollapseHelper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html">ExtractSliceFromCollapseHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class assists with generating IR required to materialize an arbitrary-sized slice from the result of a CollapseShapeOp.  <a href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad7cc2482e6a2a89d1bc8bf619c6578e0" id="r_ad7cc2482e6a2a89d1bc8bf619c6578e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7cc2482e6a2a89d1bc8bf619c6578e0">ControlConstantExtractSliceFusionFn</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(ExtractSliceOp)&gt;</td></tr>
<tr class="memdesc:ad7cc2482e6a2a89d1bc8bf619c6578e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to control the folding of constant and extract slice.  <br /></td></tr>
<tr class="memitem:a743879c07b987ba7432f0dd71aea8100" id="r_a743879c07b987ba7432f0dd71aea8100"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a743879c07b987ba7432f0dd71aea8100">ControlFoldFn</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acc8a002ba50ad2f3d5c09e4e0efdc0d3" id="r_acc8a002ba50ad2f3d5c09e4e0efdc0d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc8a002ba50ad2f3d5c09e4e0efdc0d3">registerAllExtensions</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:acc8a002ba50ad2f3d5c09e4e0efdc0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register all extensions of the Tensor dialect.  <br /></td></tr>
<tr class="memitem:ae4c009c40e6adaa31399030460514ab7" id="r_ae4c009c40e6adaa31399030460514ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4c009c40e6adaa31399030460514ab7">registerShardingInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:ac1b0cdf08bf148506f761f70f24059f0" id="r_ac1b0cdf08bf148506f761f70f24059f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1b0cdf08bf148506f761f70f24059f0">preservesStaticInformation</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> source, <a class="el" href="classmlir_1_1Type.html">Type</a> <a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>)</td></tr>
<tr class="memdesc:ac1b0cdf08bf148506f761f70f24059f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <span class="tt">target</span> is a ranked tensor type that preserves static information available in the <span class="tt">source</span> ranked tensor type.  <br /></td></tr>
<tr class="memitem:a30deb019e8a71c65e127e245b9cf63fb" id="r_a30deb019e8a71c65e127e245b9cf63fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30deb019e8a71c65e127e245b9cf63fb">canFoldIntoConsumerOp</a> (CastOp castOp)</td></tr>
<tr class="memdesc:a30deb019e8a71c65e127e245b9cf63fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether tensor::CastOp casts to a more dynamic version of the source tensor.  <br /></td></tr>
<tr class="memitem:a1bbbd2b47f452ac54390390eb2099edd" id="r_a1bbbd2b47f452ac54390390eb2099edd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bbbd2b47f452ac54390390eb2099edd">canFoldIntoProducerOp</a> (CastOp castOp)</td></tr>
<tr class="memdesc:a1bbbd2b47f452ac54390390eb2099edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the tensor::CastOp casts to a more static version of the source tensor.  <br /></td></tr>
<tr class="memitem:a0a08b46210e9d5cac2cd665dac0bce07" id="r_a0a08b46210e9d5cac2cd665dac0bce07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a08b46210e9d5cac2cd665dac0bce07">hasFoldableTensorCastOperand</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a0a08b46210e9d5cac2cd665dac0bce07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of the operands of <span class="tt">op</span> is a CastOp that can be folded into its consumer, i.e.  <br /></td></tr>
<tr class="memitem:a265e307a38759e898773b475a475e2fe" id="r_a265e307a38759e898773b475a475e2fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a265e307a38759e898773b475a475e2fe">getUpdatedOperandsAfterCastOpFolding</a> (DestinationStyleOpInterface op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;newResTy)</td></tr>
<tr class="memdesc:a265e307a38759e898773b475a475e2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that <span class="tt">op</span> contains at least one operand that is a foldable CastOp (i.e.  <br /></td></tr>
<tr class="memitem:a00e4cc4be054eec0b07a42e2f63f05f2" id="r_a00e4cc4be054eec0b07a42e2f63f05f2"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00e4cc4be054eec0b07a42e2f63f05f2">foldTensorCast</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a00e4cc4be054eec0b07a42e2f63f05f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs folding of any operand of <span class="tt">op</span> if it comes from a tensor::CastOp that can be folded.  <br /></td></tr>
<tr class="memitem:a8d577c5f161da7be47b356b6363a7eae" id="r_a8d577c5f161da7be47b356b6363a7eae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d577c5f161da7be47b356b6363a7eae">getMixedSize</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classint64__t.html">int64_t</a> dim)</td></tr>
<tr class="memdesc:a8d577c5f161da7be47b356b6363a7eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of the given tensor value.  <br /></td></tr>
<tr class="memitem:ad1d0935f6c223e44294137605bb39d60" id="r_ad1d0935f6c223e44294137605bb39d60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1d0935f6c223e44294137605bb39d60">getMixedSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:ad1d0935f6c223e44294137605bb39d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimensions of the given tensor value.  <br /></td></tr>
<tr class="memitem:a6cfe3bede328e5dc72de55dfca72fe1d" id="r_a6cfe3bede328e5dc72de55dfca72fe1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cfe3bede328e5dc72de55dfca72fe1d">createCanonicalRankReducingExtractSliceOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> tensor, RankedTensorType targetType)</td></tr>
<tr class="memdesc:a6cfe3bede328e5dc72de55dfca72fe1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rank-reducing ExtractSliceOp @[0 .  <br /></td></tr>
<tr class="memitem:a6b0730cfcf9d984a57414d62c2b18b2f" id="r_a6b0730cfcf9d984a57414d62c2b18b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b0730cfcf9d984a57414d62c2b18b2f">createCanonicalRankReducingInsertSliceOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> tensor, <a class="el" href="classmlir_1_1Value.html">Value</a> dest)</td></tr>
<tr class="memdesc:a6b0730cfcf9d984a57414d62c2b18b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rank-reducing InsertSliceOp @[0 .  <br /></td></tr>
<tr class="memitem:a90e502153b3c46a11dad42045c36bc31" id="r_a90e502153b3c46a11dad42045c36bc31"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90e502153b3c46a11dad42045c36bc31">getOrCreateDestination</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> opResult)</td></tr>
<tr class="memdesc:a90e502153b3c46a11dad42045c36bc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function for DestinationStyleOpInterface.  <br /></td></tr>
<tr class="memitem:ad28262a44a78b9ce6b2e43195dd2a085" id="r_ad28262a44a78b9ce6b2e43195dd2a085"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad28262a44a78b9ce6b2e43195dd2a085">getOrCreateDestinations</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memdesc:ad28262a44a78b9ce6b2e43195dd2a085"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function for DestinationStyleOpInterface.  <br /></td></tr>
<tr class="memitem:a7c8704f34ea971ccefd3c0150f8b6bda" id="r_a7c8704f34ea971ccefd3c0150f8b6bda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c8704f34ea971ccefd3c0150f8b6bda">isSameTypeWithoutEncoding</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> tp1, <a class="el" href="classmlir_1_1Type.html">Type</a> tp2)</td></tr>
<tr class="memdesc:a7c8704f34ea971ccefd3c0150f8b6bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if types are the same when ignoring encoding on ranked tensors.  <br /></td></tr>
<tr class="memitem:a0edfdd5a23215fd0d8d587be6ebae28a" id="r_a0edfdd5a23215fd0d8d587be6ebae28a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0edfdd5a23215fd0d8d587be6ebae28a">populateFoldConstantExtractSlicePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="#ad7cc2482e6a2a89d1bc8bf619c6578e0">ControlConstantExtractSliceFusionFn</a> &amp;controlFn=[](ExtractSliceOp op) { return <a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>;})</td></tr>
<tr class="memdesc:a0edfdd5a23215fd0d8d587be6ebae28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold the extract slice op with its constant operand.  <br /></td></tr>
<tr class="memitem:a8ffb9f13d230b356ca5c58ee95a611db" id="r_a8ffb9f13d230b356ca5c58ee95a611db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ffb9f13d230b356ca5c58ee95a611db">populateFoldCollapseExtractPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a8ffb9f13d230b356ca5c58ee95a611db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold extracts of a collapse_shaped tensor to an extract of the source tensor.  <br /></td></tr>
<tr class="memitem:a537a26573013e086958f9f7a18fa65d5" id="r_a537a26573013e086958f9f7a18fa65d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a537a26573013e086958f9f7a18fa65d5">registerInferTypeOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">mlir::DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a537a26573013e086958f9f7a18fa65d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers external models for Infer <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> interfaces for tensor ops.  <br /></td></tr>
<tr class="memitem:a037e42ffbc07e707a1f2e648c49be367" id="r_a037e42ffbc07e707a1f2e648c49be367"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a037e42ffbc07e707a1f2e648c49be367">bubbleUpPadSlice</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, tensor::PadOp padOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes, <a class="el" href="classbool.html">bool</a> generateZeroSliceGuard=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:a037e42ffbc07e707a1f2e648c49be367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bubbles up a slice of this pad by taking the slice first and then performing the padding.  <br /></td></tr>
<tr class="memitem:a84a4bebf333acf49aa338a6f810152f5" id="r_a84a4bebf333acf49aa338a6f810152f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84a4bebf333acf49aa338a6f810152f5">registerTilingInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">mlir::DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a84a4bebf333acf49aa338a6f810152f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers external models for Tiling interface for tensor ops.  <br /></td></tr>
<tr class="memitem:ae7b2a78b51f3a2f1e5f8ebdcabdb8037" id="r_ae7b2a78b51f3a2f1e5f8ebdcabdb8037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7b2a78b51f3a2f1e5f8ebdcabdb8037">registerTilingInterfaceExternalModelsForPackUnPackOps</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:ae7b2a78b51f3a2f1e5f8ebdcabdb8037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the above registeration, but it is only for <span class="tt">tensor.pack</span> and <span class="tt">tensor.unpack</span> ops.  <br /></td></tr>
<tr class="memitem:ae180e649b9172ba9094eb52635792d9a" id="r_ae180e649b9172ba9094eb52635792d9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae180e649b9172ba9094eb52635792d9a">registerValueBoundsOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a31e647b877acb2e8497ffb6415f5ef98" id="r_a31e647b877acb2e8497ffb6415f5ef98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31e647b877acb2e8497ffb6415f5ef98">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a7ef6c3ff4458d28bdbb29b151ae4d9ff" id="r_a7ef6c3ff4458d28bdbb29b151ae4d9ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ef6c3ff4458d28bdbb29b151ae4d9ff">registerFindPayloadReplacementOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:aa09a0f22283c4ef45935f058b6f629cb" id="r_aa09a0f22283c4ef45935f058b6f629cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa09a0f22283c4ef45935f058b6f629cb">registerBufferizableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:ac3c4bca0034c5799b63e2fb7a1f2b0ec" id="r_ac3c4bca0034c5799b63e2fb7a1f2b0ec"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3c4bca0034c5799b63e2fb7a1f2b0ec">createFoldTensorSubsetOpsPass</a> ()</td></tr>
<tr class="memitem:a79d0c562f22006da966db7aa716f3007" id="r_a79d0c562f22006da966db7aa716f3007"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79d0c562f22006da966db7aa716f3007">registerFoldTensorSubsetOpsPass</a> ()</td></tr>
<tr class="memitem:a1ef9f618a0dce73a3d6c5a894bd5fba6" id="r_a1ef9f618a0dce73a3d6c5a894bd5fba6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ef9f618a0dce73a3d6c5a894bd5fba6">registerFoldTensorSubsetOpsPassPass</a> ()</td></tr>
<tr class="memitem:a185b24ebe1faf6889dec856bd643be8d" id="r_a185b24ebe1faf6889dec856bd643be8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a185b24ebe1faf6889dec856bd643be8d">registerTensorPasses</a> ()</td></tr>
<tr class="memitem:ae9e08e5e78426a356823fad9da7faf74" id="r_ae9e08e5e78426a356823fad9da7faf74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9e08e5e78426a356823fad9da7faf74">registerRuntimeVerifiableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a72d6437bbf0214af0aa54891c0cc4f0a" id="r_a72d6437bbf0214af0aa54891c0cc4f0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72d6437bbf0214af0aa54891c0cc4f0a">registerSubsetOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a2224cac41fe066a9f63214b45cd24c0b" id="r_a2224cac41fe066a9f63214b45cd24c0b"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2224cac41fe066a9f63214b45cd24c0b">replaceExtractSliceWithTiledProducer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, tensor::ExtractSliceOp sliceOp, <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> producerOp)</td></tr>
<tr class="memdesc:a2224cac41fe066a9f63214b45cd24c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to swap an <span class="tt">tensor.extract_slice</span> with its producer when the producer implements the <span class="tt">TilingInterface</span>.  <br /></td></tr>
<tr class="memitem:a26569c717f5bd0eb52b7b92d84cfbdb4" id="r_a26569c717f5bd0eb52b7b92d84cfbdb4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26569c717f5bd0eb52b7b92d84cfbdb4">replaceInsertSlicesWithTiledConsumer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; tensor::InsertSliceOp &gt; sliceOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt; consumerOperands)</td></tr>
<tr class="memdesc:a26569c717f5bd0eb52b7b92d84cfbdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to swap <span class="tt">tensor.insert_slice</span>s with their consumers when the consumer implements the <span class="tt">TilingInterface</span>.  <br /></td></tr>
<tr class="memitem:a543432e9d12118a7622a3089d8273ff3" id="r_a543432e9d12118a7622a3089d8273ff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a543432e9d12118a7622a3089d8273ff3">populateFoldTensorSubsetOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a543432e9d12118a7622a3089d8273ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for folding tensor subset ops into consumer load/store ops into <span class="tt">patterns</span>.  <br /></td></tr>
<tr class="memitem:adc69c3905c73a83187b7f09642273935" id="r_adc69c3905c73a83187b7f09642273935"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc69c3905c73a83187b7f09642273935">populateFoldTensorSubsetIntoVectorTransferPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:adc69c3905c73a83187b7f09642273935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for folding tensor subset ops into vector transfer ops.  <br /></td></tr>
<tr class="memitem:a354a5a1166be4a8db79d65866e88182e" id="r_a354a5a1166be4a8db79d65866e88182e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a354a5a1166be4a8db79d65866e88182e">populateMergeConsecutiveInsertExtractSlicePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a354a5a1166be4a8db79d65866e88182e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects patterns to merge consecutive tensor.insert_slice/extract_slice into one.  <br /></td></tr>
<tr class="memitem:a67cd03acfd3c0a39d7b81142e09c0ea6" id="r_a67cd03acfd3c0a39d7b81142e09c0ea6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67cd03acfd3c0a39d7b81142e09c0ea6">populateBubbleUpExtractSliceOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a67cd03acfd3c0a39d7b81142e09c0ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns that are used to bubble up tensor.extract slice op above its producer.  <br /></td></tr>
<tr class="memitem:ab0f73bd63d8aa577bf0be474817cca20" id="r_ab0f73bd63d8aa577bf0be474817cca20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0f73bd63d8aa577bf0be474817cca20">populateDropRedundantInsertSliceRankExpansionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ab0f73bd63d8aa577bf0be474817cca20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns that drop redundant tensor.insert_slice rank expansions.  <br /></td></tr>
<tr class="memitem:a59694a86108b2b08581a0910c8dc14a0" id="r_a59694a86108b2b08581a0910c8dc14a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59694a86108b2b08581a0910c8dc14a0">populateReassociativeReshapeFoldingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a59694a86108b2b08581a0910c8dc14a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns that fold <span class="tt">tensor.expand_shape</span> and <span class="tt">tensor.collapse_shape</span> into other ops.  <br /></td></tr>
<tr class="memitem:a84385ac9917cc0e9d0b661b117a1aa95" id="r_a84385ac9917cc0e9d0b661b117a1aa95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84385ac9917cc0e9d0b661b117a1aa95">populateBubbleUpExpandShapePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a84385ac9917cc0e9d0b661b117a1aa95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns that bubble up <span class="tt">tensor.expand_shape</span> through <span class="tt">tensor.collapse_shape</span> ops.  <br /></td></tr>
<tr class="memitem:a1e85d021b66e41b155c2ac8a79470a0b" id="r_a1e85d021b66e41b155c2ac8a79470a0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e85d021b66e41b155c2ac8a79470a0b">populateFoldTensorEmptyPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classbool.html">bool</a> foldSingleUseOnly=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a1e85d021b66e41b155c2ac8a79470a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns that fold tensor.empty with its consumers.  <br /></td></tr>
<tr class="memitem:a4e1858e8d94e747b946b919c2685463c" id="r_a4e1858e8d94e747b946b919c2685463c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e1858e8d94e747b946b919c2685463c">populateDecomposeTensorConcatPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a4e1858e8d94e747b946b919c2685463c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns that decompose <span class="tt">tensor.concat</span> into <span class="tt">tensor.empty</span> of a tensor of the concatenated size, followed by a chain of <span class="tt">tensor.insert_slice</span> operations on the inputs.  <br /></td></tr>
<tr class="memitem:ace25e5493ab1c4df8e63c524aba2dad0" id="r_ace25e5493ab1c4df8e63c524aba2dad0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace25e5493ab1c4df8e63c524aba2dad0">populateRewriteAsConstantPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="#a743879c07b987ba7432f0dd71aea8100">ControlFoldFn</a> &amp;controlFn)</td></tr>
<tr class="memdesc:ace25e5493ab1c4df8e63c524aba2dad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns that replace tensor ops (such as tensor.generate) with constants when possible.  <br /></td></tr>
<tr class="memitem:abc6c410c5acbddda4ce39cb557a3a3e8" id="r_abc6c410c5acbddda4ce39cb557a3a3e8"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc6c410c5acbddda4ce39cb557a3a3e8">buildIndependentOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, tensor::PadOp padOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> independencies)</td></tr>
<tr class="memdesc:abc6c410c5acbddda4ce39cb557a3a3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a new tensor::PadOp with low/high padding that is independent of all given independencies.  <br /></td></tr>
<tr class="memitem:aef702c5f3daef258e04bedc7489d0794" id="r_aef702c5f3daef258e04bedc7489d0794"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef702c5f3daef258e04bedc7489d0794">buildIndependentOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, tensor::EmptyOp emptyOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> independencies)</td></tr>
<tr class="memdesc:aef702c5f3daef258e04bedc7489d0794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a new tensor::EmptyOp who's dynamic sizes are independent of all given independencies.  <br /></td></tr>
<tr class="memitem:a08f36b140fcf2e0ed55e4cb6dfd4c63a" id="r_a08f36b140fcf2e0ed55e4cb6dfd4c63a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08f36b140fcf2e0ed55e4cb6dfd4c63a">getCollapsedExtractSliceInfo</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, tensor::ExtractSliceOp sliceOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; reassociation, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;collapsedOffsets, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;collapsedSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;collapsedStrides)</td></tr>
<tr class="memdesc:a08f36b140fcf2e0ed55e4cb6dfd4c63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the offsets, sizes, and strides needed to build a collapsed <span class="tt">sliceOp</span>.  <br /></td></tr>
<tr class="memitem:adef724c301cb8f5a7122f60317c7110e" id="r_adef724c301cb8f5a7122f60317c7110e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adef724c301cb8f5a7122f60317c7110e">getExpandedExtractSliceInfo</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, tensor::ExtractSliceOp sliceOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; reassociation, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; expandedShape, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;expandedOffsets, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;expandedSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;expandedStrides)</td></tr>
<tr class="memdesc:adef724c301cb8f5a7122f60317c7110e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the offsets, sizes, and strides needed to build an expanded <span class="tt">sliceOp</span>.  <br /></td></tr>
<tr class="memitem:a5549d629eff95d24dfb8efeb0f15e29e" id="r_a5549d629eff95d24dfb8efeb0f15e29e"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5549d629eff95d24dfb8efeb0f15e29e">simplifyCollapseShapeWithRankReducingExtractSlice</a> (tensor::CollapseShapeOp op, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter)</td></tr>
<tr class="memdesc:a5549d629eff95d24dfb8efeb0f15e29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to simplify a <span class="tt">tensor.collapse_shape</span> operation by inserting a single rank-reducing <span class="tt">tensor.extract_slice</span> operation.  <br /></td></tr>
<tr class="memitem:a29d2ebbc0fa9b642f95770d7d5165906" id="r_a29d2ebbc0fa9b642f95770d7d5165906"><td class="memItemLeft" align="right" valign="top">PadOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29d2ebbc0fa9b642f95770d7d5165906">createPadHighOp</a> (RankedTensorType resType, <a class="el" href="classmlir_1_1Value.html">Value</a> source, <a class="el" href="classmlir_1_1Value.html">Value</a> pad, <a class="el" href="classbool.html">bool</a> nofold, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dynOutDims={})</td></tr>
<tr class="memitem:a450fa57046cd901b794bacb1d5bfcbcb" id="r_a450fa57046cd901b794bacb1d5bfcbcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a450fa57046cd901b794bacb1d5bfcbcb">createDynamicDimValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> rankedTensor)</td></tr>
<tr class="memitem:aeeeab52065c4ebba910f4d323fc13af9" id="r_aeeeab52065c4ebba910f4d323fc13af9"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; RankedTensorType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeeeab52065c4ebba910f4d323fc13af9">computeTransposedType</a> (RankedTensorType rankedTensorType, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; transposeVector)</td></tr>
<tr class="memdesc:aeeeab52065c4ebba910f4d323fc13af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transposed <span class="tt">rankedTensorType</span> if <span class="tt">transposeVector</span> is non-empty.  <br /></td></tr>
<tr class="memitem:a7d4bb2d9d3292647f99ba03588114517" id="r_a7d4bb2d9d3292647f99ba03588114517"><td class="memItemLeft" align="right" valign="top">CollapseShapeOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d4bb2d9d3292647f99ba03588114517">dropGivenUnitDims</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> src, const llvm::SmallBitVector &amp;<a class="el" href="namespacemlir.html#aeaf688b845e36e8284034d28fe9899bc">dropDims</a>)</td></tr>
<tr class="memdesc:a7d4bb2d9d3292647f99ba03588114517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create tensor.collapse_shape to drop unit dimensions in <span class="tt">dropDims</span> in tensor <span class="tt">src</span>.  <br /></td></tr>
<tr class="memitem:a4c787d8d5df3e025be36da4b386c8dee" id="r_a4c787d8d5df3e025be36da4b386c8dee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c787d8d5df3e025be36da4b386c8dee">isCastLikeInsertSliceOp</a> (InsertSliceOp op)</td></tr>
<tr class="memdesc:a4c787d8d5df3e025be36da4b386c8dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tensor.insert_slice is a cast-like operation if it merely rank-extends the source tensor or inserts the source tensor into a destination tensor with the same shape.  <br /></td></tr>
<tr class="memitem:a83daf685932d89a8a3fbff57f383889e" id="r_a83daf685932d89a8a3fbff57f383889e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83daf685932d89a8a3fbff57f383889e">isCastLikeExtractSliceOp</a> (ExtractSliceOp op)</td></tr>
<tr class="memdesc:a83daf685932d89a8a3fbff57f383889e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tensor.extract_slice is a cast-like operation if it merely rank-reduces unit dimensions of the source tensor or extracts the entire source tensor.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ad7cc2482e6a2a89d1bc8bf619c6578e0" name="ad7cc2482e6a2a89d1bc8bf619c6578e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7cc2482e6a2a89d1bc8bf619c6578e0">&#9670;&#160;</a></span>ControlConstantExtractSliceFusionFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad7cc2482e6a2a89d1bc8bf619c6578e0">mlir::tensor::ControlConstantExtractSliceFusionFn</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(ExtractSliceOp)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to control the folding of constant and extract slice. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Tensor_2IR_2Tensor_8h_source.html#l00167">167</a> of file <a class="el" href="mlir_2Dialect_2Tensor_2IR_2Tensor_8h_source.html">Tensor.h</a>.</p>

</div>
</div>
<a id="a743879c07b987ba7432f0dd71aea8100" name="a743879c07b987ba7432f0dd71aea8100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743879c07b987ba7432f0dd71aea8100">&#9670;&#160;</a></span>ControlFoldFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a743879c07b987ba7432f0dd71aea8100">mlir::tensor::ControlFoldFn</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Tensor_2Transforms_2Transforms_8h_source.html#l00099">99</a> of file <a class="el" href="mlir_2Dialect_2Tensor_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a037e42ffbc07e707a1f2e648c49be367" name="a037e42ffbc07e707a1f2e648c49be367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037e42ffbc07e707a1f2e648c49be367">&#9670;&#160;</a></span>bubbleUpPadSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a> &gt; mlir::tensor::bubbleUpPadSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp</td>          <td class="paramname"><span class="paramname"><em>padOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>generateZeroSliceGuard</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bubbles up a slice of this pad by taking the slice first and then performing the padding. </p>
<p><span class="tt">offsets</span> and <span class="tt">strides</span> specifies each dimension's start offset and size for the slice. The slice has unit strides along all dimensions.</p>
<p>Specifically, this function converts: </p><div class="fragment"><div class="line">%0 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.pad %source low[...] high[...] { <a class="code hl_namespace" href="namespacemlir_1_1linalg.html">linalg</a>.yield %cst }</div>
<div class="line">%1 = &lt;extract-slice&gt; %0 offsets=[...], sizes[...]</div>
<div class="ttc" id="anamespacemlir_1_1linalg_html"><div class="ttname"><a href="namespacemlir_1_1linalg.html">mlir::linalg</a></div><div class="ttdef"><b>Definition</b> <a href="LinalgToStandard_8h_source.html#l00024">LinalgToStandard.h:24</a></div></div>
<div class="ttc" id="anamespacemlir_1_1tensor_html"><div class="ttname"><a href="namespacemlir_1_1tensor.html">mlir::tensor</a></div><div class="ttdef"><b>Definition</b> <a href="BufferizationTransformOps_8h_source.html#l00019">BufferizationTransformOps.h:19</a></div></div>
</div><!-- fragment --><p> into </p><div class="fragment"><div class="line">%0 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.extract_slice %source ...</div>
<div class="line">%0 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.pad %0 low[...] high[...] { <a class="code hl_namespace" href="namespacemlir_1_1linalg.html">linalg</a>.yield %cst }</div>
</div><!-- fragment --><p>If <span class="tt">generateZeroSliceGuard</span> is true, the generated IR will contain logic to guard against the case that we might take a zero-sized slice from the original source. For such cases, we <span class="tt">tensor.generate</span> to generate the full tensor. </p>

<p class="definition">Definition at line <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">88</a> of file <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html">TensorTilingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00072">mlir::dispatchIndexOpFoldResults()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00057">getMixedSize()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00220">mlir::getPrunedAttributeList()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">mlir::isZeroInteger()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01579">mlir::affine::makeComposedFoldedAffineMax()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01572">mlir::affine::makeComposedFoldedAffineMin()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00212">max()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00204">min()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00972">mlir::linalg::ExtractSliceOfPadTensorSwapPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="aef702c5f3daef258e04bedc7489d0794" name="aef702c5f3daef258e04bedc7489d0794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef702c5f3daef258e04bedc7489d0794">&#9670;&#160;</a></span>buildIndependentOp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::tensor::buildIndependentOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::EmptyOp</td>          <td class="paramname"><span class="paramname"><em>emptyOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>independencies</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a new tensor::EmptyOp who's dynamic sizes are independent of all given independencies. </p>
<p>If the op is already independent of all independencies, the same EmptyOp result is returned.</p>
<p>Failure indicates the no suitable upper bound for the dynamic sizes could be found. </p>

<p class="definition">Definition at line <a class="el" href="Tensor_2Transforms_2IndependenceTransforms_8cpp_source.html#l00107">107</a> of file <a class="el" href="Tensor_2Transforms_2IndependenceTransforms_8cpp_source.html">IndependenceTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="Tensor_2Transforms_2IndependenceTransforms_8cpp_source.html#l00020">makeIndependent()</a>.</p>

</div>
</div>
<a id="abc6c410c5acbddda4ce39cb557a3a3e8" name="abc6c410c5acbddda4ce39cb557a3a3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6c410c5acbddda4ce39cb557a3a3e8">&#9670;&#160;</a></span>buildIndependentOp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::tensor::buildIndependentOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::PadOp</td>          <td class="paramname"><span class="paramname"><em>padOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>independencies</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a new tensor::PadOp with low/high padding that is independent of all given independencies. </p>
<p>If the op is already independent of all independencies, the same PadOp result is returned.</p>
<p>Failure indicates the no suitable upper bound for low/high padding could be found.</p>
<p>Example: scf.for iv = lb to ub step step { high = affine.apply affine_map&lt;(d0)[s0] -&gt; (s0 - d0)&gt; (i)[ub] p = tensor.pad t low[5] high[high] ... ... }</p>
<p>The function builds IR such as: high_new = affine.apply affine_map&lt;()[s0, s1] -&gt; (-s0 + s1)&gt; ()[lb, ub] p_hoistable = tensor.pad t low[5] high[high_new] dim = tensor.dim t, c0 size = affine.apply affine_map&lt;(d0)[s0, s1] -&gt; (-d0 + s0 + s1 + 5)&gt; (iv)[ub, dim] slice = tensor.extract_slice p_hoistable [0] [size] [1]</p>
<p>The slice is returned. </p>

<p class="definition">Definition at line <a class="el" href="Tensor_2Transforms_2IndependenceTransforms_8cpp_source.html#l00036">36</a> of file <a class="el" href="Tensor_2Transforms_2IndependenceTransforms_8cpp_source.html">IndependenceTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="Tensor_2Transforms_2IndependenceTransforms_8cpp_source.html#l00020">makeIndependent()</a>.</p>

</div>
</div>
<a id="a30deb019e8a71c65e127e245b9cf63fb" name="a30deb019e8a71c65e127e245b9cf63fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30deb019e8a71c65e127e245b9cf63fb">&#9670;&#160;</a></span>canFoldIntoConsumerOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::tensor::canFoldIntoConsumerOp </td>
          <td>(</td>
          <td class="paramtype">CastOp</td>          <td class="paramname"><span class="paramname"><em>castOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether tensor::CastOp casts to a more dynamic version of the source tensor. </p>
<p>This is useful to fold a tensor.cast into a consuming op and implement canonicalization patterns for ops in different dialects that may consume the results of tensor.cast operations. Such foldable tensor.cast operations are typically inserted as <span class="tt">extract_slice</span> ops and are canonicalized, to preserve the type compatibility of their uses.</p>
<p>Returns true when all conditions are met:</p><ol type="1">
<li>source and result are ranked tensors with same element type and rank.</li>
<li>the tensor type has more static information than the result</li>
</ol>
<p>Example: </p><div class="fragment"><div class="line">%1 = tensor.cast %0 : tensor&lt;8x16xf32&gt; to tensor&lt;?x?xf32&gt;</div>
<div class="line">%2 = consumer %1 ... : tensor&lt;?x?xf32&gt; ...</div>
</div><!-- fragment --><p>folds into:</p>
<div class="fragment"><div class="line">%2 = consumer %0 ... : tensor&lt;8x16xf32&gt; ...</div>
</div><!-- fragment --><p>This is useful to fold a tensor.cast into a consuming op and implement canonicalization patterns for ops in different dialects that may consume the results of tensor.cast operations. Such foldable tensor.cast operations are typically inserted as <span class="tt">slice</span> ops and are canonicalized, to preserve the type compatibility of their uses.</p>
<p>Returns true when all conditions are met:</p><ol type="1">
<li>source and result are ranked tensors with same element type and rank.</li>
<li>the tensor type has more static information than the result</li>
</ol>
<p>Example: </p><div class="fragment"><div class="line">%1 = tensor.cast %0 : tensor&lt;8x16xf32&gt; to tensor&lt;?x?xf32&gt;</div>
<div class="line">%2 = consumer %1 ... : tensor&lt;?x?xf32&gt; ...</div>
</div><!-- fragment --><p>folds into:</p>
<div class="fragment"><div class="line">%2 = consumer %0 ... : tensor&lt;8x16xf32&gt; ...</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00318">318</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00266">preservesStaticInformation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l00387">foldTensorCast()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l00365">getUpdatedOperandsAfterCastOpFolding()</a>.</p>

</div>
</div>
<a id="a1bbbd2b47f452ac54390390eb2099edd" name="a1bbbd2b47f452ac54390390eb2099edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbbd2b47f452ac54390390eb2099edd">&#9670;&#160;</a></span>canFoldIntoProducerOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::tensor::canFoldIntoProducerOp </td>
          <td>(</td>
          <td class="paramtype">CastOp</td>          <td class="paramname"><span class="paramname"><em>castOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the tensor::CastOp casts to a more static version of the source tensor. </p>
<p>This is useful to fold into a producing op and implement canonicaliation patterns with the <span class="tt">tensor.cast</span> op as the root, but producer being from different dialects. Returns true when all conditions are met:</p><ol type="1">
<li>source and result and ranked tensors with same element type and rank.</li>
<li>the result type has more static information than the source.</li>
</ol>
<p>Example: </p><div class="fragment"><div class="line">%1 = producer ... : tensor&lt;?x?xf32&gt;</div>
<div class="line">%2 = tensor.cast %1 : tensor&lt;?x?xf32&gt; to tensor&lt;8x16xf32&gt;</div>
</div><!-- fragment --><p>can be canonicalized to :</p>
<div class="fragment"><div class="line">%2 = producer ... : tensor&lt;8x16xf32&gt;</div>
</div><!-- fragment --><p> Not all ops might be canonicalizable this way, but for those that can be, this method provides a check that it is worth doing the canonicalization.</p>
<p>This is useful to fold into a producing op and implement canonicalization patterns with the <span class="tt">tensor.cast</span> op as the root, but producer being from different dialects. Returns true when all conditions are met:</p><ol type="1">
<li>source and result and ranked tensors with same element type and rank.</li>
<li>the result type has more static information than the source.</li>
</ol>
<p>Example: </p><div class="fragment"><div class="line">%1 = producer ... : tensor&lt;?x?xf32&gt;</div>
<div class="line">%2 = tensor.cast %1 : tensor&lt;?x?xf32&gt; to tensor&lt;8x16xf32&gt;</div>
</div><!-- fragment --><p>can be canonicalized to :</p>
<div class="fragment"><div class="line">%2 = producer ... : tensor&lt;8x16xf32&gt;</div>
</div><!-- fragment --><p> Not all ops might be canonicalizable this way, but for those that can be, this method provides a check that it is worth doing the canonicalization. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00349">349</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00266">preservesStaticInformation()</a>.</p>

</div>
</div>
<a id="aeeeab52065c4ebba910f4d323fc13af9" name="aeeeab52065c4ebba910f4d323fc13af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeeab52065c4ebba910f4d323fc13af9">&#9670;&#160;</a></span>computeTransposedType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; RankedTensorType &gt; mlir::tensor::computeTransposedType </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType</td>          <td class="paramname"><span class="paramname"><em>rankedTensorType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>transposeVector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the transposed <span class="tt">rankedTensorType</span> if <span class="tt">transposeVector</span> is non-empty. </p>
<p>Fail if <span class="tt">transposeVector</span> is not a permutation matching the tensor rank. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00076">76</a> of file <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00226">mlir::applyPermutationToVector()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00204">mlir::isPermutationVector()</a>, and <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00241">mlir::RankedTensorType::Builder::setShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HoistPadding_8cpp_source.html#l00683">buildPackingLoopNestImpl()</a>, and <a class="el" href="HoistPadding_8cpp_source.html#l00942">mlir::linalg::hoistPaddingOnTensors()</a>.</p>

</div>
</div>
<a id="a6cfe3bede328e5dc72de55dfca72fe1d" name="a6cfe3bede328e5dc72de55dfca72fe1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfe3bede328e5dc72de55dfca72fe1d">&#9670;&#160;</a></span>createCanonicalRankReducingExtractSliceOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::tensor::createCanonicalRankReducingExtractSliceOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>tensor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RankedTensorType</td>          <td class="paramname"><span class="paramname"><em>targetType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a rank-reducing ExtractSliceOp @[0 . </p>
<p>. 0] with strides [1 .. 1] and appropriate sizes (i.e. <span class="tt">tensor.getSizes()</span>) to reduce the rank of <span class="tt">tensor</span> to that of <span class="tt">targetType</span>. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l02780">2780</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="TensorOps_8cpp_source.html#l00066">getMixedSizes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00972">mlir::linalg::ExtractSliceOfPadTensorSwapPattern::matchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01594">mlir::linalg::DownscaleConv2DOp::returningMatchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01526">mlir::linalg::DownscaleDepthwiseConv2DNhwcHwcOp::returningMatchAndRewrite()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01406">mlir::linalg::DownscaleSizeOneWindowed2DConvolution&lt; Conv2DOp, Conv1DOp &gt;::returningMatchAndRewrite()</a>.</p>

</div>
</div>
<a id="a6b0730cfcf9d984a57414d62c2b18b2f" name="a6b0730cfcf9d984a57414d62c2b18b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0730cfcf9d984a57414d62c2b18b2f">&#9670;&#160;</a></span>createCanonicalRankReducingInsertSliceOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::tensor::createCanonicalRankReducingInsertSliceOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>tensor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a rank-reducing InsertSliceOp @[0 . </p>
<p>. 0] with strides [1 .. 1] and appropriate sizes (i.e. <span class="tt">dest.getSizes()</span>). The result is a new tensor with rank increased to that of <span class="tt">dest</span>, obtained by inserting <span class="tt">tensor</span> into <span class="tt">dest</span> at the canonical [0 .. 0] position. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l03185">3185</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="TensorOps_8cpp_source.html#l00066">getMixedSizes()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01594">mlir::linalg::DownscaleConv2DOp::returningMatchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01526">mlir::linalg::DownscaleDepthwiseConv2DNhwcHwcOp::returningMatchAndRewrite()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01406">mlir::linalg::DownscaleSizeOneWindowed2DConvolution&lt; Conv2DOp, Conv1DOp &gt;::returningMatchAndRewrite()</a>.</p>

</div>
</div>
<a id="a450fa57046cd901b794bacb1d5bfcbcb" name="a450fa57046cd901b794bacb1d5bfcbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450fa57046cd901b794bacb1d5bfcbcb">&#9670;&#160;</a></span>createDynamicDimValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::tensor::createDynamicDimValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rankedTensor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00062">62</a> of file <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SplitReduction_8cpp_source.html#l00241">mlir::linalg::splitReductionByScaling()</a>.</p>

</div>
</div>
<a id="ac3c4bca0034c5799b63e2fb7a1f2b0ec" name="ac3c4bca0034c5799b63e2fb7a1f2b0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c4bca0034c5799b63e2fb7a1f2b0ec">&#9670;&#160;</a></span>createFoldTensorSubsetOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::tensor::createFoldTensorSubsetOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00081">81</a> of file <a class="el" href="FoldTensorSubsetOps_8cpp_source.html">FoldTensorSubsetOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>.</p>

</div>
</div>
<a id="a29d2ebbc0fa9b642f95770d7d5165906" name="a29d2ebbc0fa9b642f95770d7d5165906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d2ebbc0fa9b642f95770d7d5165906">&#9670;&#160;</a></span>createPadHighOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PadOp mlir::tensor::createPadHighOp </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType</td>          <td class="paramname"><span class="paramname"><em>resType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>pad</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>nofold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>dynOutDims</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00023">23</a> of file <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00057">getMixedSize()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01018">getPackOpSourceOrPaddedSource()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01510">mlir::linalg::makeComposedPadHighOp()</a>.</p>

</div>
</div>
<a id="a7d4bb2d9d3292647f99ba03588114517" name="a7d4bb2d9d3292647f99ba03588114517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4bb2d9d3292647f99ba03588114517">&#9670;&#160;</a></span>dropGivenUnitDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CollapseShapeOp mlir::tensor::dropGivenUnitDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>dropDims</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create tensor.collapse_shape to drop unit dimensions in <span class="tt">dropDims</span> in tensor <span class="tt">src</span>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00095">95</a> of file <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00237">mlir::dropDims()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00469">setBit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00229">mlir::linalg::fuseProducerOfTensor()</a>.</p>

</div>
</div>
<a id="a00e4cc4be054eec0b07a42e2f63f05f2" name="a00e4cc4be054eec0b07a42e2f63f05f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e4cc4be054eec0b07a42e2f63f05f2">&#9670;&#160;</a></span>foldTensorCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::tensor::foldTensorCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs folding of any operand of <span class="tt">op</span> if it comes from a tensor::CastOp that can be folded. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00387">387</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00318">canFoldIntoConsumerOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a08f36b140fcf2e0ed55e4cb6dfd4c63a" name="a08f36b140fcf2e0ed55e4cb6dfd4c63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f36b140fcf2e0ed55e4cb6dfd4c63a">&#9670;&#160;</a></span>getCollapsedExtractSliceInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::tensor::getCollapsedExtractSliceInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ExtractSliceOp</td>          <td class="paramname"><span class="paramname"><em>sliceOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reassociation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>collapsedOffsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>collapsedSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>collapsedStrides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the offsets, sizes, and strides needed to build a collapsed <span class="tt">sliceOp</span>. </p>
<p>The dimensions to collapse are specified by <span class="tt">reassociation</span>.</p>
<p>This fails when the specified collapse cannot be represented by a valid ExtractSliceOp. </p>

<p class="definition">Definition at line <a class="el" href="ReshapePatterns_8cpp_source.html#l00462">462</a> of file <a class="el" href="ReshapePatterns_8cpp_source.html">ReshapePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00821">mlir::ValueBoundsConstraintSet::areEqual()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00066">getMixedSizes()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00022">mlir::isOneInteger()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00020">mlir::isZeroInteger()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="XeGPUDialect_8cpp_source.html#l00972">mul</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="adef724c301cb8f5a7122f60317c7110e" name="adef724c301cb8f5a7122f60317c7110e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef724c301cb8f5a7122f60317c7110e">&#9670;&#160;</a></span>getExpandedExtractSliceInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::tensor::getExpandedExtractSliceInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ExtractSliceOp</td>          <td class="paramname"><span class="paramname"><em>sliceOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reassociation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>expandedShape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expandedOffsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expandedSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expandedStrides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the offsets, sizes, and strides needed to build an expanded <span class="tt">sliceOp</span>. </p>
<p>The dimensions to expand are specified by <span class="tt">reassociation</span> and <span class="tt">expandedShape</span>.</p>
<p>This fails when the specified expansion cannot be represented by a valid ExtractSliceOp. </p>

<p class="definition">Definition at line <a class="el" href="ReshapePatterns_8cpp_source.html#l00582">582</a> of file <a class="el" href="ReshapePatterns_8cpp_source.html">ReshapePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a8d577c5f161da7be47b356b6363a7eae" name="a8d577c5f161da7be47b356b6363a7eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d577c5f161da7be47b356b6363a7eae">&#9670;&#160;</a></span>getMixedSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::tensor::getMixedSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dimension of the given tensor value. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00057">57</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00526">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">bubbleUpPadSlice()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00023">createPadHighOp()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00066">getMixedSizes()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00217">mlir::linalg::lowerPack()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l01271">mlir::linalg::DecomposeOuterUnitDimsUnPackOpPattern::matchAndRewrite()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00921">mlir::linalg::DecomposePadOpPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ad1d0935f6c223e44294137605bb39d60" name="ad1d0935f6c223e44294137605bb39d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d0935f6c223e44294137605bb39d60">&#9670;&#160;</a></span>getMixedSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::tensor::getMixedSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dimensions of the given tensor value. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00066">66</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00057">getMixedSize()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00078">mlir::tensor::ExtractSliceFromCollapseHelper::create()</a>, <a class="el" href="TensorOps_8cpp_source.html#l02780">createCanonicalRankReducingExtractSliceOp()</a>, <a class="el" href="TensorOps_8cpp_source.html#l03185">createCanonicalRankReducingInsertSliceOp()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l03240">mlir::memref::createCanonicalRankReducingSubViewOp()</a>, <a class="el" href="Linalg_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00126">mlir::linalg::createDestinationPassingStyleInitOperand()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00333">mlir::vector::createReadOrMaskedRead()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00251">expandValue()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00865">fuseWithReshapeByExpansion()</a>, <a class="el" href="ReshapePatterns_8cpp_source.html#l00462">getCollapsedExtractSliceInfo()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00298">mlir::vector::getMixedSizesXfer()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00217">mlir::linalg::lowerPack()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00345">mlir::linalg::lowerUnPack()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00921">mlir::linalg::DecomposePadOpPattern::matchAndRewrite()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05021">mlir::linalg::reifyResultShapesImpl()</a>, <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00429">mlir::linalg::rewriteInDestinationPassingStyle()</a>, and <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00158">simplifyCollapseShapeWithRankReducingExtractSlice()</a>.</p>

</div>
</div>
<a id="a90e502153b3c46a11dad42045c36bc31" name="a90e502153b3c46a11dad42045c36bc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e502153b3c46a11dad42045c36bc31">&#9670;&#160;</a></span>getOrCreateDestination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::tensor::getOrCreateDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a></td>          <td class="paramname"><span class="paramname"><em>opResult</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a helper function for DestinationStyleOpInterface. </p>
<p>If there is a destination operand for the given <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a>, return that operand. Otherwise, return an empty tensor (<span class="tt">tensor.empty</span>) with the shape of the <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a>. Dynamic dimensions are queried via ReifyRankedShapedTypeOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00075">75</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00469">mlir::OpResult::getResultNumber()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00027">mlir::reifyResultShapes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l00110">getOrCreateDestinations()</a>.</p>

</div>
</div>
<a id="ad28262a44a78b9ce6b2e43195dd2a085" name="ad28262a44a78b9ce6b2e43195dd2a085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28262a44a78b9ce6b2e43195dd2a085">&#9670;&#160;</a></span>getOrCreateDestinations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::tensor::getOrCreateDestinations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a helper function for DestinationStyleOpInterface. </p>
<p>Get or create destinations for every tensor <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> of the given op. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00110">110</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="TensorOps_8cpp_source.html#l00075">getOrCreateDestination()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l00726">createInitialTensorsForTiling()</a>, <a class="el" href="Split_8cpp_source.html#l00067">mlir::linalg::splitOp()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l01080">tileAndFuseFirstExtractUseThroughContainingOpBlockArgument()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00588">mlir::linalg::tileReductionUsingForall()</a>.</p>

</div>
</div>
<a id="a265e307a38759e898773b475a475e2fe" name="a265e307a38759e898773b475a475e2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265e307a38759e898773b475a475e2fe">&#9670;&#160;</a></span>getUpdatedOperandsAfterCastOpFolding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::tensor::getUpdatedOperandsAfterCastOpFolding </td>
          <td>(</td>
          <td class="paramtype">DestinationStyleOpInterface</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>newResTy</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assuming that <span class="tt">op</span> contains at least one operand that is a foldable CastOp (i.e. </p>
<p><span class="tt">hasFoldableTensorCastOperand</span> returns true), calculate the updated operands. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00365">365</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="TensorOps_8cpp_source.html#l00318">canFoldIntoConsumerOp()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l00356">hasFoldableTensorCastOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l04107">FoldTensorCastProducerOp::matchAndRewrite()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05741">mlir::linalg::FoldTensorCastPackOp::matchAndRewrite()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l06064">mlir::linalg::FoldTensorCastUnPackOp::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a0a08b46210e9d5cac2cd665dac0bce07" name="a0a08b46210e9d5cac2cd665dac0bce07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a08b46210e9d5cac2cd665dac0bce07">&#9670;&#160;</a></span>hasFoldableTensorCastOperand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::tensor::hasFoldableTensorCastOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if any of the operands of <span class="tt">op</span> is a CastOp that can be folded into its consumer, i.e. </p>
<p><span class="tt">op</span>. This is effectively a convenience wrapper for <span class="tt">canFoldIntoProducerOp</span>. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00356">356</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l04075">foldTensorCastPrecondition()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00365">getUpdatedOperandsAfterCastOpFolding()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l05741">mlir::linalg::FoldTensorCastPackOp::matchAndRewrite()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l06064">mlir::linalg::FoldTensorCastUnPackOp::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a83daf685932d89a8a3fbff57f383889e" name="a83daf685932d89a8a3fbff57f383889e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83daf685932d89a8a3fbff57f383889e">&#9670;&#160;</a></span>isCastLikeExtractSliceOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::tensor::isCastLikeExtractSliceOp </td>
          <td>(</td>
          <td class="paramtype">ExtractSliceOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A tensor.extract_slice is a cast-like operation if it merely rank-reduces unit dimensions of the source tensor or extracts the entire source tensor. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00149">149</a> of file <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00821">mlir::ValueBoundsConstraintSet::areEqual()</a>.</p>

</div>
</div>
<a id="a4c787d8d5df3e025be36da4b386c8dee" name="a4c787d8d5df3e025be36da4b386c8dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c787d8d5df3e025be36da4b386c8dee">&#9670;&#160;</a></span>isCastLikeInsertSliceOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::tensor::isCastLikeInsertSliceOp </td>
          <td>(</td>
          <td class="paramtype">InsertSliceOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A tensor.insert_slice is a cast-like operation if it merely rank-extends the source tensor or inserts the source tensor into a destination tensor with the same shape. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00125">125</a> of file <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00821">mlir::ValueBoundsConstraintSet::areEqual()</a>.</p>

</div>
</div>
<a id="a7c8704f34ea971ccefd3c0150f8b6bda" name="a7c8704f34ea971ccefd3c0150f8b6bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8704f34ea971ccefd3c0150f8b6bda">&#9670;&#160;</a></span>isSameTypeWithoutEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::tensor::isSameTypeWithoutEncoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>tp1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>tp2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if types are the same when ignoring encoding on ranked tensors. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00124">124</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l02037">verifyTensorReshapeOp()</a>.</p>

</div>
</div>
<a id="a84385ac9917cc0e9d0b661b117a1aa95" name="a84385ac9917cc0e9d0b661b117a1aa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84385ac9917cc0e9d0b661b117a1aa95">&#9670;&#160;</a></span>populateBubbleUpExpandShapePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::populateBubbleUpExpandShapePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">patterns</span> with patterns that bubble up <span class="tt">tensor.expand_shape</span> through <span class="tt">tensor.collapse_shape</span> ops. </p>

<p class="definition">Definition at line <a class="el" href="ReshapePatterns_8cpp_source.html#l00730">730</a> of file <a class="el" href="ReshapePatterns_8cpp_source.html">ReshapePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a67cd03acfd3c0a39d7b81142e09c0ea6" name="a67cd03acfd3c0a39d7b81142e09c0ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67cd03acfd3c0a39d7b81142e09c0ea6">&#9670;&#160;</a></span>populateBubbleUpExtractSliceOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::populateBubbleUpExtractSliceOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns that are used to bubble up tensor.extract slice op above its producer. </p>
<p>When used as cleanup patterns of tile and fuse, enables fusing the producer with the consumer even if the producer does not implement the tiling interface. </p>

<p class="definition">Definition at line <a class="el" href="ReshapePatterns_8cpp_source.html#l00735">735</a> of file <a class="el" href="ReshapePatterns_8cpp_source.html">ReshapePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a4e1858e8d94e747b946b919c2685463c" name="a4e1858e8d94e747b946b919c2685463c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1858e8d94e747b946b919c2685463c">&#9670;&#160;</a></span>populateDecomposeTensorConcatPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::populateDecomposeTensorConcatPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">patterns</span> with patterns that decompose <span class="tt">tensor.concat</span> into <span class="tt">tensor.empty</span> of a tensor of the concatenated size, followed by a chain of <span class="tt">tensor.insert_slice</span> operations on the inputs. </p>
<p>This is intended to be used as a fallback tensor -&gt; tensor lowering that decomposes concat such that it can be bufferized into a sequence of copies. </p>

<p class="definition">Definition at line <a class="el" href="ConcatOpPatterns_8cpp_source.html#l00046">46</a> of file <a class="el" href="ConcatOpPatterns_8cpp_source.html">ConcatOpPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ab0f73bd63d8aa577bf0be474817cca20" name="ab0f73bd63d8aa577bf0be474817cca20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f73bd63d8aa577bf0be474817cca20">&#9670;&#160;</a></span>populateDropRedundantInsertSliceRankExpansionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::populateDropRedundantInsertSliceRankExpansionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">patterns</span> with patterns that drop redundant tensor.insert_slice rank expansions. </p>

<p class="definition">Definition at line <a class="el" href="MergeConsecutiveInsertExtractSlicePatterns_8cpp_source.html#l00238">238</a> of file <a class="el" href="MergeConsecutiveInsertExtractSlicePatterns_8cpp_source.html">MergeConsecutiveInsertExtractSlicePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a8ffb9f13d230b356ca5c58ee95a611db" name="a8ffb9f13d230b356ca5c58ee95a611db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ffb9f13d230b356ca5c58ee95a611db">&#9670;&#160;</a></span>populateFoldCollapseExtractPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::populateFoldCollapseExtractPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold extracts of a collapse_shaped tensor to an extract of the source tensor. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l01437">1437</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a0edfdd5a23215fd0d8d587be6ebae28a" name="a0edfdd5a23215fd0d8d587be6ebae28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edfdd5a23215fd0d8d587be6ebae28a">&#9670;&#160;</a></span>populateFoldConstantExtractSlicePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::populateFoldConstantExtractSlicePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad7cc2482e6a2a89d1bc8bf619c6578e0">ControlConstantExtractSliceFusionFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>controlFn</em></span><span class="paramdefsep"> = </span><span class="paramdefval">[](ExtractSliceOp&#160;op)&#160;{&#160;&#160;&#160;return&#160;<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>;&#160;}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold the extract slice op with its constant operand. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l02694">2694</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a1e85d021b66e41b155c2ac8a79470a0b" name="a1e85d021b66e41b155c2ac8a79470a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e85d021b66e41b155c2ac8a79470a0b">&#9670;&#160;</a></span>populateFoldTensorEmptyPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::populateFoldTensorEmptyPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>foldSingleUseOnly</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">patterns</span> with patterns that fold tensor.empty with its consumers. </p>
<p>If <span class="tt">singleUseOnly</span> is set to "true", only tensor.empty ops with a single use are folded. </p>

<p class="definition">Definition at line <a class="el" href="EmptyOpPatterns_8cpp_source.html#l00130">130</a> of file <a class="el" href="EmptyOpPatterns_8cpp_source.html">EmptyOpPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="DropUnitDims_8cpp_source.html#l00803">populateFoldUnitExtentDimsViaReshapesPatterns()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00823">populateFoldUnitExtentDimsViaSlicesPatterns()</a>.</p>

</div>
</div>
<a id="adc69c3905c73a83187b7f09642273935" name="adc69c3905c73a83187b7f09642273935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc69c3905c73a83187b7f09642273935">&#9670;&#160;</a></span>populateFoldTensorSubsetIntoVectorTransferPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::populateFoldTensorSubsetIntoVectorTransferPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for folding tensor subset ops into vector transfer ops. </p>

<p class="definition">Definition at line <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00254">254</a> of file <a class="el" href="FoldTensorSubsetOps_8cpp_source.html">FoldTensorSubsetOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00247">populateFoldTensorSubsetOpPatterns()</a>.</p>

</div>
</div>
<a id="a543432e9d12118a7622a3089d8273ff3" name="a543432e9d12118a7622a3089d8273ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543432e9d12118a7622a3089d8273ff3">&#9670;&#160;</a></span>populateFoldTensorSubsetOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::populateFoldTensorSubsetOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for folding tensor subset ops into consumer load/store ops into <span class="tt">patterns</span>. </p>
<p>(This includes patterns for folding tensor subset ops into vector transfer ops.) </p>

<p class="definition">Definition at line <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00247">247</a> of file <a class="el" href="FoldTensorSubsetOps_8cpp_source.html">FoldTensorSubsetOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, and <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00254">populateFoldTensorSubsetIntoVectorTransferPatterns()</a>.</p>

</div>
</div>
<a id="a354a5a1166be4a8db79d65866e88182e" name="a354a5a1166be4a8db79d65866e88182e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354a5a1166be4a8db79d65866e88182e">&#9670;&#160;</a></span>populateMergeConsecutiveInsertExtractSlicePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::populateMergeConsecutiveInsertExtractSlicePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects patterns to merge consecutive tensor.insert_slice/extract_slice into one. </p>
<p>These patterns are in this separate entry point because the bufferization is sensitive to IR structure, particularly those tensor.extract_slice and tensor.insert_slice ops for creating the slices. </p>

<p class="definition">Definition at line <a class="el" href="MergeConsecutiveInsertExtractSlicePatterns_8cpp_source.html#l00230">230</a> of file <a class="el" href="MergeConsecutiveInsertExtractSlicePatterns_8cpp_source.html">MergeConsecutiveInsertExtractSlicePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a59694a86108b2b08581a0910c8dc14a0" name="a59694a86108b2b08581a0910c8dc14a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59694a86108b2b08581a0910c8dc14a0">&#9670;&#160;</a></span>populateReassociativeReshapeFoldingPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::populateReassociativeReshapeFoldingPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">patterns</span> with patterns that fold <span class="tt">tensor.expand_shape</span> and <span class="tt">tensor.collapse_shape</span> into other ops. </p>

<p class="definition">Definition at line <a class="el" href="ReshapePatterns_8cpp_source.html#l00719">719</a> of file <a class="el" href="ReshapePatterns_8cpp_source.html">ReshapePatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ace25e5493ab1c4df8e63c524aba2dad0" name="ace25e5493ab1c4df8e63c524aba2dad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace25e5493ab1c4df8e63c524aba2dad0">&#9670;&#160;</a></span>populateRewriteAsConstantPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::populateRewriteAsConstantPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a743879c07b987ba7432f0dd71aea8100">ControlFoldFn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>controlFn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <span class="tt">patterns</span> with patterns that replace tensor ops (such as tensor.generate) with constants when possible. </p>

<p class="definition">Definition at line <a class="el" href="RewriteAsConstant_8cpp_source.html#l00211">211</a> of file <a class="el" href="RewriteAsConstant_8cpp_source.html">RewriteAsConstant.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ac1b0cdf08bf148506f761f70f24059f0" name="ac1b0cdf08bf148506f761f70f24059f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b0cdf08bf148506f761f70f24059f0">&#9670;&#160;</a></span>preservesStaticInformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::tensor::preservesStaticInformation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <span class="tt">target</span> is a ranked tensor type that preserves static information available in the <span class="tt">source</span> ranked tensor type. </p>

<p class="definition">Definition at line <a class="el" href="TensorOps_8cpp_source.html#l00266">266</a> of file <a class="el" href="TensorOps_8cpp_source.html">TensorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorOps_8cpp_source.html#l00318">canFoldIntoConsumerOp()</a>, and <a class="el" href="TensorOps_8cpp_source.html#l00349">canFoldIntoProducerOp()</a>.</p>

</div>
</div>
<a id="acc8a002ba50ad2f3d5c09e4e0efdc0d3" name="acc8a002ba50ad2f3d5c09e4e0efdc0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8a002ba50ad2f3d5c09e4e0efdc0d3">&#9670;&#160;</a></span>registerAllExtensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::registerAllExtensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register all extensions of the Tensor dialect. </p>
<p>This should generally only be used by tools, or other use cases that really do want <em>all</em> extensions of the dialect. All other cases should prefer to instead register the specific extensions they intend to take advantage of. </p>

<p class="definition">Definition at line <a class="el" href="Tensor_2Extensions_2AllExtensions_8cpp_source.html#l00014">14</a> of file <a class="el" href="Tensor_2Extensions_2AllExtensions_8cpp_source.html">AllExtensions.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tensor_2Extensions_2ShardingExtensions_8cpp_source.html#l00104">registerShardingInterfaceExternalModels()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="aa09a0f22283c4ef45935f058b6f629cb" name="aa09a0f22283c4ef45935f058b6f629cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09a0f22283c4ef45935f058b6f629cb">&#9670;&#160;</a></span>registerBufferizableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::registerBufferizableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l01191">1191</a> of file <a class="el" href="Tensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html">BufferizableOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, <a class="el" href="MLIRContext_8h_source.html#l00110">mlir::MLIRContext::loadDialect()</a>, and <a class="el" href="Tensor_2Transforms_2SubsetInsertionOpInterfaceImpl_8cpp_source.html#l00087">registerSubsetOpInterfaceExternalModels()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a7ef6c3ff4458d28bdbb29b151ae4d9ff" name="a7ef6c3ff4458d28bdbb29b151ae4d9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef6c3ff4458d28bdbb29b151ae4d9ff">&#9670;&#160;</a></span>registerFindPayloadReplacementOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::registerFindPayloadReplacementOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TensorTransformOps_8cpp_source.html#l00071">71</a> of file <a class="el" href="TensorTransformOps_8cpp_source.html">TensorTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a79d0c562f22006da966db7aa716f3007" name="a79d0c562f22006da966db7aa716f3007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d0c562f22006da966db7aa716f3007">&#9670;&#160;</a></span>registerFoldTensorSubsetOpsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::registerFoldTensorSubsetOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Transforms_2Passes_8h_source.html#l00096">96</a> of file <a class="el" href="Dialect_2Tensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a1ef9f618a0dce73a3d6c5a894bd5fba6" name="a1ef9f618a0dce73a3d6c5a894bd5fba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef9f618a0dce73a3d6c5a894bd5fba6">&#9670;&#160;</a></span>registerFoldTensorSubsetOpsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::registerFoldTensorSubsetOpsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Transforms_2Passes_8h_source.html#l00103">103</a> of file <a class="el" href="Dialect_2Tensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a537a26573013e086958f9f7a18fa65d5" name="a537a26573013e086958f9f7a18fa65d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537a26573013e086958f9f7a18fa65d5">&#9670;&#160;</a></span>registerInferTypeOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::registerInferTypeOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">mlir::DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers external models for Infer <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> interfaces for tensor ops. </p>
<p>Currently, it registers:</p>
<ul>
<li>ReifyRankedShapedTypeOpInterface for <span class="tt">tensor.collapse_shape</span>.</li>
<li>ReifyRankedShapedTypeOpInterface for <span class="tt">tensor.expand_shape</span>.</li>
</ul>
<p>Unfortunately, a "normal" internal registration is not possible at the moment, because of the dependency of the interface implementation for these ops on <span class="tt">affine.apply</span> and Affine dialect already depends on TensorOps. In order to break the cyclic dependency (TensorOps-&gt;AffineOps-&gt;TensorOps) the implementation is moved to a separate library. </p>

<p class="definition">Definition at line <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00131">131</a> of file <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html">TensorInferTypeOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ae9e08e5e78426a356823fad9da7faf74" name="ae9e08e5e78426a356823fad9da7faf74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e08e5e78426a356823fad9da7faf74">&#9670;&#160;</a></span>registerRuntimeVerifiableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::registerRuntimeVerifiableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tensor_2Transforms_2RuntimeOpVerification_8cpp_source.html#l00244">244</a> of file <a class="el" href="Tensor_2Transforms_2RuntimeOpVerification_8cpp_source.html">RuntimeOpVerification.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ae4c009c40e6adaa31399030460514ab7" name="ae4c009c40e6adaa31399030460514ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c009c40e6adaa31399030460514ab7">&#9670;&#160;</a></span>registerShardingInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::registerShardingInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tensor_2Extensions_2ShardingExtensions_8cpp_source.html#l00104">104</a> of file <a class="el" href="Tensor_2Extensions_2ShardingExtensions_8cpp_source.html">ShardingExtensions.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tensor_2Extensions_2AllExtensions_8cpp_source.html#l00014">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a72d6437bbf0214af0aa54891c0cc4f0a" name="a72d6437bbf0214af0aa54891c0cc4f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d6437bbf0214af0aa54891c0cc4f0a">&#9670;&#160;</a></span>registerSubsetOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::registerSubsetOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tensor_2Transforms_2SubsetInsertionOpInterfaceImpl_8cpp_source.html#l00087">87</a> of file <a class="el" href="Tensor_2Transforms_2SubsetInsertionOpInterfaceImpl_8cpp_source.html">SubsetInsertionOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>, and <a class="el" href="Tensor_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l01191">registerBufferizableOpInterfaceExternalModels()</a>.</p>

</div>
</div>
<a id="a185b24ebe1faf6889dec856bd643be8d" name="a185b24ebe1faf6889dec856bd643be8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185b24ebe1faf6889dec856bd643be8d">&#9670;&#160;</a></span>registerTensorPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::registerTensorPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Tensor_2Transforms_2Passes_8h_source.html#l00117">117</a> of file <a class="el" href="Dialect_2Tensor_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllPasses_8cpp_source.html#l00059">mlir::registerAllPasses()</a>.</p>

</div>
</div>
<a id="a84a4bebf333acf49aa338a6f810152f5" name="a84a4bebf333acf49aa338a6f810152f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a4bebf333acf49aa338a6f810152f5">&#9670;&#160;</a></span>registerTilingInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::registerTilingInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">mlir::DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers external models for Tiling interface for tensor ops. </p>
<p>Currently, it registers:</p>
<ul>
<li>TilingInterface for <span class="tt">tensor.pad</span>, <span class="tt">tensor.pack</span>, and <span class="tt">tensor.unpack</span>.</li>
</ul>
<p>Unfortunately, a "normal" internal registration is not possible at the moment, because of the dependency of the interface implementation for these ops on <span class="tt">affine.apply</span> and Affine dialect already depends on TensorOps. In order to break the cyclic dependency (TensorOps-&gt;AffineOps-&gt;TensorOps) the implementation is moved to a separate library. </p>

<p class="definition">Definition at line <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00311">311</a> of file <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html">TensorTilingInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ae7b2a78b51f3a2f1e5f8ebdcabdb8037" name="ae7b2a78b51f3a2f1e5f8ebdcabdb8037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b2a78b51f3a2f1e5f8ebdcabdb8037">&#9670;&#160;</a></span>registerTilingInterfaceExternalModelsForPackUnPackOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::registerTilingInterfaceExternalModelsForPackUnPackOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the above registeration, but it is only for <span class="tt">tensor.pack</span> and <span class="tt">tensor.unpack</span> ops. </p>

</div>
</div>
<a id="a31e647b877acb2e8497ffb6415f5ef98" name="a31e647b877acb2e8497ffb6415f5ef98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e647b877acb2e8497ffb6415f5ef98">&#9670;&#160;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TensorTransformOps_8cpp_source.html#l00258">258</a> of file <a class="el" href="TensorTransformOps_8cpp_source.html">TensorTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00222">mlir::DialectRegistry::addExtensions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="ae180e649b9172ba9094eb52635792d9a" name="ae180e649b9172ba9094eb52635792d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae180e649b9172ba9094eb52635792d9a">&#9670;&#160;</a></span>registerValueBoundsOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::tensor::registerValueBoundsOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tensor_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00116">116</a> of file <a class="el" href="Tensor_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a2224cac41fe066a9f63214b45cd24c0b" name="a2224cac41fe066a9f63214b45cd24c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2224cac41fe066a9f63214b45cd24c0b">&#9670;&#160;</a></span>replaceExtractSliceWithTiledProducer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a> &gt; mlir::tensor::replaceExtractSliceWithTiledProducer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ExtractSliceOp</td>          <td class="paramname"><span class="paramname"><em>sliceOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a></td>          <td class="paramname"><span class="paramname"><em>producerOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to swap an <span class="tt">tensor.extract_slice</span> with its producer when the producer implements the <span class="tt">TilingInterface</span>. </p>
<p>The pattern itself does not provide a mechanism to control where the application happens. With use of transform dialect that control is done within the transform dialect. Other use cases can inherit from this pattern and add necessary controls. </p>

<p class="definition">Definition at line <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html#l00025">25</a> of file <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html">SwapExtractSliceWithProducerPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Value_8h_source.html#l00466">mlir::OpResult::getOwner()</a>, <a class="el" href="Value_8h_source.html#l00469">mlir::OpResult::getResultNumber()</a>, <a class="el" href="Builders_8h_source.html#l00091">mlir::Builder::getType()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00022">mlir::isOneInteger()</a>.</p>

</div>
</div>
<a id="a26569c717f5bd0eb52b7b92d84cfbdb4" name="a26569c717f5bd0eb52b7b92d84cfbdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26569c717f5bd0eb52b7b92d84cfbdb4">&#9670;&#160;</a></span>replaceInsertSlicesWithTiledConsumer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1TilingResult.html">TilingResult</a> &gt; mlir::tensor::replaceInsertSlicesWithTiledConsumer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; tensor::InsertSliceOp &gt;</td>          <td class="paramname"><span class="paramname"><em>sliceOps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>consumerOperands</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to swap <span class="tt">tensor.insert_slice</span>s with their consumers when the consumer implements the <span class="tt">TilingInterface</span>. </p>
<p>The size of <span class="tt">sliceOps</span> and <span class="tt">consumerOperands</span> is expected to be the same. Every entry in <span class="tt">consumerOperands</span> represents a use of the the corresponding entry in <span class="tt">sliceOps</span> in the consumer. All entries of <span class="tt">consumerOperands</span> is expected to be uses in the same consumer. </p>

<p class="definition">Definition at line <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html#l00061">61</a> of file <a class="el" href="SwapExtractSliceWithProducerPatterns_8cpp_source.html">SwapExtractSliceWithProducerPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00226">mlir::OpOperand::getOperandNumber()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00022">mlir::isOneInteger()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TileUsingInterface_8cpp_source.html#l02188">tileAndFuseConsumerOfSlicesImpl()</a>.</p>

</div>
</div>
<a id="a5549d629eff95d24dfb8efeb0f15e29e" name="a5549d629eff95d24dfb8efeb0f15e29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5549d629eff95d24dfb8efeb0f15e29e">&#9670;&#160;</a></span>simplifyCollapseShapeWithRankReducingExtractSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::tensor::simplifyCollapseShapeWithRankReducingExtractSlice </td>
          <td>(</td>
          <td class="paramtype">tensor::CollapseShapeOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to simplify a <span class="tt">tensor.collapse_shape</span> operation by inserting a single rank-reducing <span class="tt">tensor.extract_slice</span> operation. </p>
<p>The <span class="tt">extract_slice</span> op will either take the place of the source, allowing for a new, simpler <span class="tt">collapse_shape</span> op to replace <span class="tt">op</span>, or the <span class="tt">collapse_shape</span> op will be completely replaced by the <span class="tt">extract_slice</span> result. Either way, <span class="tt">op</span> is replaced and the new op is returned.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md28"></a>
Example:</h3>
<div class="fragment"><div class="line">%<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a> = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.collapse_shape %0 [[0, 1], [2, 3]]</div>
<div class="line">   : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x1x30x10xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x300xf32&gt;</a></div>
<div class="ttc" id="aLinalgTransformOps_8cpp_html_a937d4dd628a8858b443a399410d2600b"><div class="ttname"><a href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a></div><div class="ttdeci">result</div><div class="ttdef"><b>Definition</b> <a href="LinalgTransformOps_8cpp_source.html#l02098">LinalgTransformOps.cpp:2098</a></div></div>
</div><!-- fragment --><p> can be transformed to</p>
<div class="fragment"><div class="line">%tmp = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.extract_slice %0 [0, 0, 0, 0]</div>
<div class="line">                        [0, %dim1, 30, 30]</div>
<div class="line">                        [1, 1, 1 1]</div>
<div class="line">  : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x1x30x10xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x30x10xf32&gt;</a></div>
<div class="line">%<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a> = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.collapse_shape %tmp [[0], [1, 2]]</div>
<div class="line">  : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x30x10xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x300xf32&gt;</a></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md29"></a>
Example:</h3>
<div class="fragment"><div class="line">%<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a> = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.collapse_shape %1 [[0, 1], [2]]</div>
<div class="line">   : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x1x30xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x30xf32&gt;</a></div>
</div><!-- fragment --><p> can be transformed to </p><div class="fragment"><div class="line">%<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a> = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.extract_slice %1 [0, 0, 0]</div>
<div class="line">                                  [%dim2, 1, 30]</div>
<div class="line">                                  [1, 1, 1]</div>
<div class="line">   : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x1x30xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x30xf32&gt;</a></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md30"></a>
Unsupported cases:</h3>
<p>This transform doesn't yet support reducing the rank of the reassociation indices, which would require inserting a <span class="tt">tensor.expand_shape</span> op similar to the following example: </p><div class="fragment"><div class="line">%<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a> = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.collapse_shape %0 [[0, 1], [2, 3]]</div>
<div class="line">   : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;1x1x30x10xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;1x300xf32&gt;</a></div>
</div><!-- fragment --><p> can be transformed to </p><div class="fragment"><div class="line">%tmp = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.extract_slice %0 [0, 0, 0, 0]</div>
<div class="line">                        [0, 1, 30, 30]</div>
<div class="line">                        [1, 1, 1 1]</div>
<div class="line">  : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;1x1x30x10xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;30x10xf32&gt;</a></div>
<div class="line">%result0 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.collapse_shape %tmp [[0, 1]]</div>
<div class="line">  : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;30x10xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;300xf32&gt;</a></div>
<div class="line">%result1 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.expand_shape %tmp [[0, 1], [2]] :... <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;1x300xf32&gt;</a></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00158">158</a> of file <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html">ExtractSliceFromReshapeUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00066">getMixedSizes()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00529">mlir::RewriterBase::replaceOpWithNewOp()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
