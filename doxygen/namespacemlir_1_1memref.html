<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::memref Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1memref.html">memref</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::memref Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html">LinearizedMemRefInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a <code>memref</code> with <code>offset</code>, <code>sizes</code> and <code>strides</code>, returns the offset, size, and potentially the size padded at the front to use for the linearized <code>memref</code>.  <a href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa6d03c4cab7fc5604ab8b5d105b31d4b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#aa6d03c4cab7fc5604ab8b5d105b31d4b">foldMemRefCast</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> inner=nullptr)</td></tr>
<tr class="memdesc:aa6d03c4cab7fc5604ab8b5d105b31d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a common utility used for patterns of the form "someop(memref.cast) -&gt; someop".  <a href="namespacemlir_1_1memref.html#aa6d03c4cab7fc5604ab8b5d105b31d4b">More...</a><br /></td></tr>
<tr class="separator:aa6d03c4cab7fc5604ab8b5d105b31d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593c42d0eefa6f2456d3ed618384de85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a593c42d0eefa6f2456d3ed618384de85">getTensorTypeFromMemRefType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a593c42d0eefa6f2456d3ed618384de85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unranked/ranked tensor type for the given unranked/ranked memref type.  <a href="namespacemlir_1_1memref.html#a593c42d0eefa6f2456d3ed618384de85">More...</a><br /></td></tr>
<tr class="separator:a593c42d0eefa6f2456d3ed618384de85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb87b9964b1655bdedbdd1b7656225d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a7bb87b9964b1655bdedbdd1b7656225d">findDealloc</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> allocValue)</td></tr>
<tr class="memdesc:a7bb87b9964b1655bdedbdd1b7656225d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a single dealloc operation for the given allocated value.  <a href="namespacemlir_1_1memref.html#a7bb87b9964b1655bdedbdd1b7656225d">More...</a><br /></td></tr>
<tr class="separator:a7bb87b9964b1655bdedbdd1b7656225d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a881164870086f3048d50a9ff9cd702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a5a881164870086f3048d50a9ff9cd702">getMixedSize</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> value, int64_t dim)</td></tr>
<tr class="memdesc:a5a881164870086f3048d50a9ff9cd702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of the given memref value.  <a href="namespacemlir_1_1memref.html#a5a881164870086f3048d50a9ff9cd702">More...</a><br /></td></tr>
<tr class="separator:a5a881164870086f3048d50a9ff9cd702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c13e32e47a301b4ccac4b27404de51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ab0c13e32e47a301b4ccac4b27404de51">getMixedSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:ab0c13e32e47a301b4ccac4b27404de51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimensions of the given memref value.  <a href="namespacemlir_1_1memref.html#ab0c13e32e47a301b4ccac4b27404de51">More...</a><br /></td></tr>
<tr class="separator:ab0c13e32e47a301b4ccac4b27404de51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e796656fc119467035c6e1d1568a59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ae1e796656fc119467035c6e1d1568a59">createCanonicalRankReducingSubViewOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> memref, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; targetShape)</td></tr>
<tr class="memdesc:ae1e796656fc119467035c6e1d1568a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rank-reducing SubViewOp @[0 .  <a href="namespacemlir_1_1memref.html#ae1e796656fc119467035c6e1d1568a59">More...</a><br /></td></tr>
<tr class="separator:ae1e796656fc119467035c6e1d1568a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08647ff099a98052f95e4caff149a2f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a08647ff099a98052f95e4caff149a2f9">registerMemorySlotExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a08647ff099a98052f95e4caff149a2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b49994f10e98cb119abfb38f23c0c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ac2b49994f10e98cb119abfb38f23c0c3">registerValueBoundsOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ac2b49994f10e98cb119abfb38f23c0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1adc6a8d5aefc17867d0815b586c3b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ae1adc6a8d5aefc17867d0815b586c3b9">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ae1adc6a8d5aefc17867d0815b586c3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1883b3342d764a07311e3f8a79d8dd1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a1883b3342d764a07311e3f8a79d8dd1e">registerAllocationOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a1883b3342d764a07311e3f8a79d8dd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3091713b0337b82187ff9f4ab2f25a5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a3091713b0337b82187ff9f4ab2f25a5a">registerBufferViewFlowOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a3091713b0337b82187ff9f4ab2f25a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c5916519d8d818c95097ef22e882ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#af6c5916519d8d818c95097ef22e882ee">populateComposeSubViewPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:af6c5916519d8d818c95097ef22e882ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fa7b00c1ccb23e5f4a528377dd4ee9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ad7fa7b00c1ccb23e5f4a528377dd4ee9">registerRuntimeVerifiableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ad7fa7b00c1ccb23e5f4a528377dd4ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72dbb57f66b3381ca288a092d376802"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#aa72dbb57f66b3381ca288a092d376802">populateExpandOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aa72dbb57f66b3381ca288a092d376802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects a set of patterns to rewrite ops within the memref dialect.  <a href="namespacemlir_1_1memref.html#aa72dbb57f66b3381ca288a092d376802">More...</a><br /></td></tr>
<tr class="separator:aa72dbb57f66b3381ca288a092d376802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b92ea4d1067ac456aa6899baa8512a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a0b92ea4d1067ac456aa6899baa8512a9">populateFoldMemRefAliasOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a0b92ea4d1067ac456aa6899baa8512a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for folding memref aliasing ops into consumer load/store ops into <code>patterns</code>.  <a href="namespacemlir_1_1memref.html#a0b92ea4d1067ac456aa6899baa8512a9">More...</a><br /></td></tr>
<tr class="separator:a0b92ea4d1067ac456aa6899baa8512a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313c2f5f760c17a276fac9bb108951c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a313c2f5f760c17a276fac9bb108951c9">populateResolveRankedShapedTypeResultDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a313c2f5f760c17a276fac9bb108951c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns that resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>ReifyRankedShapedTypeOpInterface</code>, in terms of shapes of its input operands.  <a href="namespacemlir_1_1memref.html#a313c2f5f760c17a276fac9bb108951c9">More...</a><br /></td></tr>
<tr class="separator:a313c2f5f760c17a276fac9bb108951c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf97a8143d457b645153d6f40e6aed84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#aaf97a8143d457b645153d6f40e6aed84">populateResolveShapedTypeResultDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aaf97a8143d457b645153d6f40e6aed84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns that resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>InferShapedTypeOpInterface</code>, in terms of shapes of its input operands.  <a href="namespacemlir_1_1memref.html#aaf97a8143d457b645153d6f40e6aed84">More...</a><br /></td></tr>
<tr class="separator:aaf97a8143d457b645153d6f40e6aed84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a91532e484d6485dc36756f1b1bace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ae0a91532e484d6485dc36756f1b1bace">populateExpandStridedMetadataPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ae0a91532e484d6485dc36756f1b1bace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for expanding memref operations that modify the metadata (sizes, offset, strides) of a memref into easier to analyze constructs.  <a href="namespacemlir_1_1memref.html#ae0a91532e484d6485dc36756f1b1bace">More...</a><br /></td></tr>
<tr class="separator:ae0a91532e484d6485dc36756f1b1bace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933e3cb75cf93999afc61710776fea07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a933e3cb75cf93999afc61710776fea07">populateResolveExtractStridedMetadataPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a933e3cb75cf93999afc61710776fea07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for resolving <code>memref.extract_strided_metadata</code> into <code>memref.extract_strided_metadata</code> of its source.  <a href="namespacemlir_1_1memref.html#a933e3cb75cf93999afc61710776fea07">More...</a><br /></td></tr>
<tr class="separator:a933e3cb75cf93999afc61710776fea07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b5486ce1776bc5afddb8ec9cc97f2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ad3b5486ce1776bc5afddb8ec9cc97f2a">populateExpandReallocPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, bool emitDeallocs=true)</td></tr>
<tr class="memdesc:ad3b5486ce1776bc5afddb8ec9cc97f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for expanding <code>memref.realloc</code> operations.  <a href="namespacemlir_1_1memref.html#ad3b5486ce1776bc5afddb8ec9cc97f2a">More...</a><br /></td></tr>
<tr class="separator:ad3b5486ce1776bc5afddb8ec9cc97f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7d0c93988c246b870a8f5f851f4eb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a0f7d0c93988c246b870a8f5f851f4eb3">populateMemRefWideIntEmulationPatterns</a> (const <a class="el" href="classmlir_1_1arith_1_1WideIntEmulationConverter.html">arith::WideIntEmulationConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a0f7d0c93988c246b870a8f5f851f4eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for emulating wide integer memref operations with ops over narrower integer types.  <a href="namespacemlir_1_1memref.html#a0f7d0c93988c246b870a8f5f851f4eb3">More...</a><br /></td></tr>
<tr class="separator:a0f7d0c93988c246b870a8f5f851f4eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0e1bd45d93d6da7bf22b61465492b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a6c0e1bd45d93d6da7bf22b61465492b9">populateMemRefWideIntEmulationConversions</a> (<a class="el" href="classmlir_1_1arith_1_1WideIntEmulationConverter.html">arith::WideIntEmulationConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:a6c0e1bd45d93d6da7bf22b61465492b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends type conversions for emulating wide integer memref operations with ops over narrowe integer types.  <a href="namespacemlir_1_1memref.html#a6c0e1bd45d93d6da7bf22b61465492b9">More...</a><br /></td></tr>
<tr class="separator:a6c0e1bd45d93d6da7bf22b61465492b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d12c8c0a0feb1452a1340adca2b62d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ab6d12c8c0a0feb1452a1340adca2b62d">populateMemRefNarrowTypeEmulationPatterns</a> (const <a class="el" href="classmlir_1_1arith_1_1NarrowTypeEmulationConverter.html">arith::NarrowTypeEmulationConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ab6d12c8c0a0feb1452a1340adca2b62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for emulating memref operations over narrow types with ops over wider types.  <a href="namespacemlir_1_1memref.html#ab6d12c8c0a0feb1452a1340adca2b62d">More...</a><br /></td></tr>
<tr class="separator:ab6d12c8c0a0feb1452a1340adca2b62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5416c0ea0d3dcf0c0ce09270c16bb4c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a5416c0ea0d3dcf0c0ce09270c16bb4c7">populateMemRefNarrowTypeEmulationConversions</a> (<a class="el" href="classmlir_1_1arith_1_1NarrowTypeEmulationConverter.html">arith::NarrowTypeEmulationConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:a5416c0ea0d3dcf0c0ce09270c16bb4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends type conversions for emulating memref operations over narrow types with ops over wider types.  <a href="namespacemlir_1_1memref.html#a5416c0ea0d3dcf0c0ce09270c16bb4c7">More...</a><br /></td></tr>
<tr class="separator:a5416c0ea0d3dcf0c0ce09270c16bb4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637539fbb3044706f07e949413eac30d"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; memref::AllocOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a637539fbb3044706f07e949413eac30d">multiBuffer</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, memref::AllocOp allocOp, unsigned multiplier, bool skipOverrideAnalysis=false)</td></tr>
<tr class="memdesc:a637539fbb3044706f07e949413eac30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation to do multi-buffering/array expansion to remove dependencies on the temporary allocation between consecutive loop iterations.  <a href="namespacemlir_1_1memref.html#a637539fbb3044706f07e949413eac30d">More...</a><br /></td></tr>
<tr class="separator:a637539fbb3044706f07e949413eac30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ffe31231e4fd88511f0d2446b4218d"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; memref::AllocOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ae4ffe31231e4fd88511f0d2446b4218d">multiBuffer</a> (memref::AllocOp allocOp, unsigned multiplier, bool skipOverrideAnalysis=false)</td></tr>
<tr class="memdesc:ae4ffe31231e4fd88511f0d2446b4218d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call into <code>multiBuffer</code> with locally constructed <a class="el" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ...">IRRewriter</a>.  <a href="namespacemlir_1_1memref.html#ae4ffe31231e4fd88511f0d2446b4218d">More...</a><br /></td></tr>
<tr class="separator:ae4ffe31231e4fd88511f0d2446b4218d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05667d80ad6b23301f24c722a4dbb28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ad05667d80ad6b23301f24c722a4dbb28">populateExtractAddressComputationsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ad05667d80ad6b23301f24c722a4dbb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for extracting address computations from the instructions with memory accesses such that these memory accesses use only a base pointer.  <a href="namespacemlir_1_1memref.html#ad05667d80ad6b23301f24c722a4dbb28">More...</a><br /></td></tr>
<tr class="separator:ad05667d80ad6b23301f24c722a4dbb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7d21ec8b60f6c5b3c94a28513f155e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a7d7d21ec8b60f6c5b3c94a28513f155e">populateFlattenMemrefsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="separator:a7d7d21ec8b60f6c5b3c94a28513f155e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf86c211b0ab9ea0b1ea4943a4e6d6e"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a1bf86c211b0ab9ea0b1ea4943a4e6d6e">buildIndependentOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, AllocaOp allocaOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> independencies)</td></tr>
<tr class="memdesc:a1bf86c211b0ab9ea0b1ea4943a4e6d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a new memref::AllocaOp whose dynamic sizes are independent of all given independencies.  <a href="namespacemlir_1_1memref.html#a1bf86c211b0ab9ea0b1ea4943a4e6d6e">More...</a><br /></td></tr>
<tr class="separator:a1bf86c211b0ab9ea0b1ea4943a4e6d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390d7b6bfa73372eec5b1d2cd2bf937b"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a390d7b6bfa73372eec5b1d2cd2bf937b">replaceWithIndependentOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, memref::AllocaOp allocaOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> independencies)</td></tr>
<tr class="memdesc:a390d7b6bfa73372eec5b1d2cd2bf937b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a new memref::AllocaOp whose dynamic sizes are independent of all given independencies.  <a href="namespacemlir_1_1memref.html#a390d7b6bfa73372eec5b1d2cd2bf937b">More...</a><br /></td></tr>
<tr class="separator:a390d7b6bfa73372eec5b1d2cd2bf937b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bb58d33cedbbc97322a912c2c67971"><td class="memItemLeft" align="right" valign="top">memref::AllocaOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ad3bb58d33cedbbc97322a912c2c67971">allocToAlloca</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, memref::AllocOp alloc, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(memref::AllocOp, memref::DeallocOp)&gt; filter=nullptr)</td></tr>
<tr class="memdesc:ad3bb58d33cedbbc97322a912c2c67971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the given <code>alloc</code> with the corresponding <code>alloca</code> and returns it if the following conditions are met:  <a href="namespacemlir_1_1memref.html#ad3bb58d33cedbbc97322a912c2c67971">More...</a><br /></td></tr>
<tr class="separator:ad3bb58d33cedbbc97322a912c2c67971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd556718fd72c7099dc94f99d30ccd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a6dd556718fd72c7099dc94f99d30ccd1">isStaticShapeAndContiguousRowMajor</a> (MemRefType type)</td></tr>
<tr class="memdesc:a6dd556718fd72c7099dc94f99d30ccd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the memref type has static shapes and represents a contiguous chunk of memory.  <a href="namespacemlir_1_1memref.html#a6dd556718fd72c7099dc94f99d30ccd1">More...</a><br /></td></tr>
<tr class="separator:a6dd556718fd72c7099dc94f99d30ccd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e822c5ce40c4b3815acd8657d6c8c3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html">LinearizedMemRefInfo</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a68e822c5ce40c4b3815acd8657d6c8c3">getLinearizedMemRefOffsetAndSize</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, int srcBits, int dstBits, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> offset, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; strides, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; indices={})</td></tr>
<tr class="separator:a68e822c5ce40c4b3815acd8657d6c8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec5fa6d6d4ab684b9a5ff4ef7e668b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html">LinearizedMemRefInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a0ec5fa6d6d4ab684b9a5ff4ef7e668b6">getLinearizedMemRefOffsetAndSize</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, int srcBits, int dstBits, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> offset, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes)</td></tr>
<tr class="memdesc:a0ec5fa6d6d4ab684b9a5ff4ef7e668b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a <code>memref</code> with <code>offset</code> and <code>sizes</code>, returns the offset and size to use for the linearized <code>memref</code>, assuming that the strides are computed from a row-major ordering of the sizes;.  <a href="namespacemlir_1_1memref.html#a0ec5fa6d6d4ab684b9a5ff4ef7e668b6">More...</a><br /></td></tr>
<tr class="separator:a0ec5fa6d6d4ab684b9a5ff4ef7e668b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4147c59f3a9e3d7d845d27760a8b565b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a4147c59f3a9e3d7d845d27760a8b565b">eraseDeadAllocAndStores</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *parentOp)</td></tr>
<tr class="memdesc:a4147c59f3a9e3d7d845d27760a8b565b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track temporary allocations that are never read from.  <a href="namespacemlir_1_1memref.html#a4147c59f3a9e3d7d845d27760a8b565b">More...</a><br /></td></tr>
<tr class="separator:a4147c59f3a9e3d7d845d27760a8b565b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95cc10c54ee522c94ec39f10cb01f42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ad95cc10c54ee522c94ec39f10cb01f42">computeSuffixProductIRBlock</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes)</td></tr>
<tr class="memdesc:ad95cc10c54ee522c94ec39f10cb01f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of sizes, return the suffix product.  <a href="namespacemlir_1_1memref.html#ad95cc10c54ee522c94ec39f10cb01f42">More...</a><br /></td></tr>
<tr class="separator:ad95cc10c54ee522c94ec39f10cb01f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ae133576a4e6e35d6af6c2a0145384"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a73ae133576a4e6e35d6af6c2a0145384">computeStridesIRBlock</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes)</td></tr>
<tr class="separator:a73ae133576a4e6e35d6af6c2a0145384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3122c6f825e6d5a2372e58e7bd6eb2fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a7f8ab57590177d757d89848504dd7c5f">MemrefValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a3122c6f825e6d5a2372e58e7bd6eb2fc">skipFullyAliasingOperations</a> (<a class="el" href="namespacemlir.html#a7f8ab57590177d757d89848504dd7c5f">MemrefValue</a> source)</td></tr>
<tr class="memdesc:a3122c6f825e6d5a2372e58e7bd6eb2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk up the source chain until an operation that changes/defines the view of memory is found (i.e.  <a href="namespacemlir_1_1memref.html#a3122c6f825e6d5a2372e58e7bd6eb2fc">More...</a><br /></td></tr>
<tr class="separator:a3122c6f825e6d5a2372e58e7bd6eb2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395ef51018e96d34a3f91f08896513a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a395ef51018e96d34a3f91f08896513a4">isSameViewOrTrivialAlias</a> (<a class="el" href="namespacemlir.html#a7f8ab57590177d757d89848504dd7c5f">MemrefValue</a> a, <a class="el" href="namespacemlir.html#a7f8ab57590177d757d89848504dd7c5f">MemrefValue</a> b)</td></tr>
<tr class="memdesc:a395ef51018e96d34a3f91f08896513a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two (memref) values are the same or statically known to alias the same region of memory.  <a href="namespacemlir_1_1memref.html#a395ef51018e96d34a3f91f08896513a4">More...</a><br /></td></tr>
<tr class="separator:a395ef51018e96d34a3f91f08896513a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd2524604ba8a298b44470f68eb5076"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a7f8ab57590177d757d89848504dd7c5f">MemrefValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a6dd2524604ba8a298b44470f68eb5076">skipViewLikeOps</a> (<a class="el" href="namespacemlir.html#a7f8ab57590177d757d89848504dd7c5f">MemrefValue</a> source)</td></tr>
<tr class="memdesc:a6dd2524604ba8a298b44470f68eb5076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk up the source chain until we find an operation that is not a view of the source memref (i.e.  <a href="namespacemlir_1_1memref.html#a6dd2524604ba8a298b44470f68eb5076">More...</a><br /></td></tr>
<tr class="separator:a6dd2524604ba8a298b44470f68eb5076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94d07e58f1f9fe168739a6ef8f495a6"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ad94d07e58f1f9fe168739a6ef8f495a6">resolveSourceIndicesExpandShape</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, memref::ExpandShapeOp expandShapeOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> indices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;sourceIndices, bool startsInbounds)</td></tr>
<tr class="memdesc:ad94d07e58f1f9fe168739a6ef8f495a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the 'indices' of a load/store operation where the memref is a result of a expand_shape op, returns the indices w.r.t to the source memref of the expand_shape op.  <a href="namespacemlir_1_1memref.html#ad94d07e58f1f9fe168739a6ef8f495a6">More...</a><br /></td></tr>
<tr class="separator:ad94d07e58f1f9fe168739a6ef8f495a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505b0a7d0ecf056721f2be2220c97b39"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a505b0a7d0ecf056721f2be2220c97b39">resolveSourceIndicesCollapseShape</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, memref::CollapseShapeOp collapseShapeOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> indices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;sourceIndices)</td></tr>
<tr class="memdesc:a505b0a7d0ecf056721f2be2220c97b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the 'indices' of a load/store operation where the memref is a result of a collapse_shape op, returns the indices w.r.t to the source memref of the collapse_shape op.  <a href="namespacemlir_1_1memref.html#a505b0a7d0ecf056721f2be2220c97b39">More...</a><br /></td></tr>
<tr class="separator:a505b0a7d0ecf056721f2be2220c97b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2b990b3c696031cd589f1859416013"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a1c2b990b3c696031cd589f1859416013">resultIsNotRead</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, std::vector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;uses)</td></tr>
<tr class="memdesc:a1c2b990b3c696031cd589f1859416013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all the uses of op are not read/load.  <a href="namespacemlir_1_1memref.html#a1c2b990b3c696031cd589f1859416013">More...</a><br /></td></tr>
<tr class="separator:a1c2b990b3c696031cd589f1859416013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceacaf6bc933660c2ca3e75767c8e01e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#aceacaf6bc933660c2ca3e75767c8e01e">computeSuffixProductIRBlockImpl</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> unit)</td></tr>
<tr class="separator:aceacaf6bc933660c2ca3e75767c8e01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad3bb58d33cedbbc97322a912c2c67971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bb58d33cedbbc97322a912c2c67971">&#9670;&nbsp;</a></span>allocToAlloca()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">memref::AllocaOp mlir::memref::allocToAlloca </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::AllocOp&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(memref::AllocOp, memref::DeallocOp)&gt;&#160;</td>
          <td class="paramname"><em>filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the given <code>alloc</code> with the corresponding <code>alloca</code> and returns it if the following conditions are met: </p>
<ul>
<li>the corresponding dealloc is available in the same block as the alloc;</li>
<li>the filter, if provided, succeeds on the alloc/dealloc pair. Otherwise returns nullptr and leaves the IR unchanged. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00178">178</a> of file <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html">IndependenceTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00519">mlir::RewriterBase::replaceOpWithNewOp()</a>, and <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a1bf86c211b0ab9ea0b1ea4943a4e6d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf86c211b0ab9ea0b1ea4943a4e6d6e">&#9670;&nbsp;</a></span>buildIndependentOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; mlir::memref::buildIndependentOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocaOp&#160;</td>
          <td class="paramname"><em>allocaOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>independencies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a new memref::AllocaOp whose dynamic sizes are independent of all given independencies. </p>
<p>If the op is already independent of all independencies, the same AllocaOp result is returned.</p>
<p>Failure indicates the no suitable upper bound for the dynamic sizes could be found. </p>

<p class="reference">Referenced by <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00166">replaceWithIndependentOp()</a>.</p>

</div>
</div>
<a id="a73ae133576a4e6e35d6af6c2a0145384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ae133576a4e6e35d6af6c2a0145384">&#9670;&nbsp;</a></span>computeStridesIRBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; mlir::memref::computeStridesIRBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html#l00100">100</a> of file <a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

<p class="reference">References <a class="el" href="MemRefUtils_8cpp_source.html#l00187">computeSuffixProductIRBlock()</a>.</p>

</div>
</div>
<a id="ad95cc10c54ee522c94ec39f10cb01f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95cc10c54ee522c94ec39f10cb01f42">&#9670;&nbsp;</a></span>computeSuffixProductIRBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::memref::computeSuffixProductIRBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of sizes, return the suffix product. </p>
<p>When applied to slicing, this is the calculation needed to derive the strides (i.e. the number of linear indices to skip along the (k-1) most minor dimensions to get the next k-slice).</p>
<p>This is the basis to linearize an n-D offset confined to <code>[0 ... sizes]</code>.</p>
<p>Assuming <code>sizes</code> is <code>[s0, .. sn]</code>, return the vector&lt;Value&gt; <code>[s1 * ... * sn, s2 * ... * sn, ..., sn, 1]</code>.</p>
<p>It is the caller's responsibility to provide valid <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> type values and construct valid IR in the end.</p>
<p><code>sizes</code> elements are asserted to be non-negative.</p>
<p>Return an empty vector if <code>sizes</code> is empty.</p>
<p>The function emits an IR block which computes suffix product for provided sizes. </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00187">187</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefUtils_8cpp_source.html#l00172">computeSuffixProductIRBlockImpl()</a>, and <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html#l00100">computeStridesIRBlock()</a>.</p>

</div>
</div>
<a id="aceacaf6bc933660c2ca3e75767c8e01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceacaf6bc933660c2ca3e75767c8e01e">&#9670;&nbsp;</a></span>computeSuffixProductIRBlockImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&gt; mlir::memref::computeSuffixProductIRBlockImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00172">172</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefUtils_8cpp_source.html#l00187">computeSuffixProductIRBlock()</a>.</p>

</div>
</div>
<a id="ae1e796656fc119467035c6e1d1568a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e796656fc119467035c6e1d1568a59">&#9670;&nbsp;</a></span>createCanonicalRankReducingSubViewOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::memref::createCanonicalRankReducingSubViewOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>targetShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a rank-reducing SubViewOp @[0 . </p>
<p>. 0] with strides [1 .. 1] and appropriate sizes (i.e. <code>memref.getSizes()</code>) to reduce the rank of <code>memref</code> to that of <code>targetShape</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03064">3064</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00517">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00077">getMixedSizes()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a4147c59f3a9e3d7d845d27760a8b565b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4147c59f3a9e3d7d845d27760a8b565b">&#9670;&nbsp;</a></span>eraseDeadAllocAndStores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::eraseDeadAllocAndStores </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>parentOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Track temporary allocations that are never read from. </p>
<p>If this is the case it means both the allocations and associated stores can be removed. </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00156">156</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00139">resultIsNotRead()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a7bb87b9964b1655bdedbdd1b7656225d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb87b9964b1655bdedbdd1b7656225d">&#9670;&nbsp;</a></span>findDealloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::memref::findDealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>allocValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a single dealloc operation for the given allocated value. </p>
<p>Finds the unique dealloc operation (if one exists) for <code>allocValue</code>.</p>
<p>If there are &gt; 1 deallocates for <code>allocValue</code>, returns std::nullopt, else returns the single deallocate if it exists or nullptr. </p>

<p class="definition">Definition at line <a class="el" href="MemRefDialect_8cpp_source.html#l00063">63</a> of file <a class="el" href="MemRefDialect_8cpp_source.html">MemRefDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00218">mlir::Value::getUsers()</a>.</p>

</div>
</div>
<a id="aa6d03c4cab7fc5604ab8b5d105b31d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d03c4cab7fc5604ab8b5d105b31d4b">&#9670;&nbsp;</a></span>foldMemRefCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::memref::foldMemRefCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>inner</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a common utility used for patterns of the form "someop(memref.cast) -&gt; someop". </p>
<p>This is a common class used for patterns of the form "someop(memrefcast) -&gt; someop".</p>
<p>It folds the source of any memref.cast into the root operation directly. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00045">45</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01911">mlir::affine::AffineDmaStartOp::fold()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02020">mlir::affine::AffineDmaWaitOp::fold()</a>.</p>

</div>
</div>
<a id="a0ec5fa6d6d4ab684b9a5ff4ef7e668b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec5fa6d6d4ab684b9a5ff4ef7e668b6">&#9670;&nbsp;</a></span>getLinearizedMemRefOffsetAndSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html">LinearizedMemRefInfo</a> mlir::memref::getLinearizedMemRefOffsetAndSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a <code>memref</code> with <code>offset</code> and <code>sizes</code>, returns the offset and size to use for the linearized <code>memref</code>, assuming that the strides are computed from a row-major ordering of the sizes;. </p>
<ul>
<li>If the linearization is done for emulating load/stores of element type with bitwidth <code>srcBits</code> using element type with bitwidth <code>dstBits</code>, the linearized offset and size are scaled down by <code>dstBits</code>/<code>srcBits</code>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00113">113</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00051">getLinearizedMemRefOffsetAndSize()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

</div>
</div>
<a id="a68e822c5ce40c4b3815acd8657d6c8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e822c5ce40c4b3815acd8657d6c8c3">&#9670;&nbsp;</a></span>getLinearizedMemRefOffsetAndSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html">LinearizedMemRefInfo</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::memref::getLinearizedMemRefOffsetAndSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00051">51</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00330">mlir::bindSymbolsList()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00959">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00367">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01437">mlir::affine::makeComposedFoldedAffineMax()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FlattenMemRefs_8cpp_source.html#l00051">getFlattenMemrefAndOffset()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00113">getLinearizedMemRefOffsetAndSize()</a>, and <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00140">getLinearizedSrcIndices()</a>.</p>

</div>
</div>
<a id="a5a881164870086f3048d50a9ff9cd702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a881164870086f3048d50a9ff9cd702">&#9670;&nbsp;</a></span>getMixedSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::memref::getMixedSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dimension of the given memref value. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00068">68</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00517">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00036">createInBoundsCond()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l00077">getMixedSizes()</a>.</p>

</div>
</div>
<a id="ab0c13e32e47a301b4ccac4b27404de51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c13e32e47a301b4ccac4b27404de51">&#9670;&nbsp;</a></span>getMixedSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::memref::getMixedSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dimensions of the given memref value. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00077">77</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefOps_8cpp_source.html#l00068">getMixedSize()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00952">HopperBuilder::buildGlobalMemRefDescriptor()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00980">HopperBuilder::buildTmaAsyncLoad()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l03064">createCanonicalRankReducingSubViewOp()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00317">mlir::vector::createReadOrMaskedRead()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00296">mlir::vector::getMixedSizesXfer()</a>, and <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00269">rankReducingSubviewDroppingUnitDims()</a>.</p>

</div>
</div>
<a id="a593c42d0eefa6f2456d3ed618384de85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593c42d0eefa6f2456d3ed618384de85">&#9670;&nbsp;</a></span>getTensorTypeFromMemRefType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::memref::getTensorTypeFromMemRefType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an unranked/ranked tensor type for the given unranked/ranked memref type. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00060">60</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l01485">parseGlobalMemrefOpTypeAndInitialValue()</a>.</p>

</div>
</div>
<a id="a395ef51018e96d34a3f91f08896513a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395ef51018e96d34a3f91f08896513a4">&#9670;&nbsp;</a></span>isSameViewOrTrivialAlias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::memref::isSameViewOrTrivialAlias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a7f8ab57590177d757d89848504dd7c5f">MemrefValue</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a7f8ab57590177d757d89848504dd7c5f">MemrefValue</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two (memref) values are the same or statically known to alias the same region of memory. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html#l00111">111</a> of file <a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

<p class="reference">References <a class="el" href="MemRefUtils_8cpp_source.html#l00193">skipFullyAliasingOperations()</a>.</p>

</div>
</div>
<a id="a6dd556718fd72c7099dc94f99d30ccd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd556718fd72c7099dc94f99d30ccd1">&#9670;&nbsp;</a></span>isStaticShapeAndContiguousRowMajor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::memref::isStaticShapeAndContiguousRowMajor </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true, if the memref type has static shapes and represents a contiguous chunk of memory. </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00023">23</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

</div>
</div>
<a id="ae4ffe31231e4fd88511f0d2446b4218d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ffe31231e4fd88511f0d2446b4218d">&#9670;&nbsp;</a></span>multiBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; memref::AllocOp &gt; mlir::memref::multiBuffer </td>
          <td>(</td>
          <td class="paramtype">memref::AllocOp&#160;</td>
          <td class="paramname"><em>allocOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipOverrideAnalysis</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call into <code>multiBuffer</code> with locally constructed <a class="el" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ...">IRRewriter</a>. </p>

<p class="definition">Definition at line <a class="el" href="MultiBuffer_8cpp_source.html#l00244">244</a> of file <a class="el" href="MultiBuffer_8cpp_source.html">MultiBuffer.cpp</a>.</p>

<p class="reference">References <a class="el" href="MultiBuffer_8cpp_source.html#l00098">multiBuffer()</a>.</p>

</div>
</div>
<a id="a637539fbb3044706f07e949413eac30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637539fbb3044706f07e949413eac30d">&#9670;&nbsp;</a></span>multiBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; memref::AllocOp &gt; mlir::memref::multiBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::AllocOp&#160;</td>
          <td class="paramname"><em>allocOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipOverrideAnalysis</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transformation to do multi-buffering/array expansion to remove dependencies on the temporary allocation between consecutive loop iterations. </p>
<p>It returns the new allocation if the original allocation was multi-buffered and returns failure() otherwise. When <code>skipOverrideAnalysis</code>, the pass will apply the transformation without checking thwt the buffer is overrided at the beginning of each iteration. This implies that user knows that there is no data carried across loop iterations. Example: </p><div class="fragment"><div class="line">%0 = memref.alloc() : memref&lt;4x128xf32&gt;</div>
<div class="line">scf.for %iv = %c1 to %c1024 step %c3 {</div>
<div class="line">  memref.copy %1, %0 : memref&lt;4x128xf32&gt; to memref&lt;4x128xf32&gt;</div>
<div class="line">  <span class="stringliteral">&quot;some_use&quot;</span>(%0) : (memref&lt;4x128xf32&gt;) -&gt; ()</div>
<div class="line">}</div>
</div><!-- fragment --><p> into: </p><div class="fragment"><div class="line">%0 = memref.alloc() : memref&lt;5x4x128xf32&gt;</div>
<div class="line">scf.for %iv = %c1 to %c1024 step %c3 {</div>
<div class="line">  %s = arith.subi %iv, %c1 : index</div>
<div class="line">  %d = arith.divsi %s, %c3 : index</div>
<div class="line">  %i = arith.remsi %d, %c5 : index</div>
<div class="line">  %sv = memref.subview %0[%i, 0, 0] [1, 4, 128] [1, 1, 1] :</div>
<div class="line">    memref&lt;5x4x128xf32&gt; to memref&lt;4x128xf32, strided&lt;[128, 1], offset: ?&gt;&gt;</div>
<div class="line">  memref.copy %1, %sv : memref&lt;4x128xf32&gt; to memref&lt;4x128xf32, strided&lt;...&gt;&gt;</div>
<div class="line">  <span class="stringliteral">&quot;some_use&quot;</span>(%sv) : (memref&lt;4x128xf32, strided&lt;...&gt;) -&gt; ()</div>
<div class="line">}</div>
</div><!-- fragment --> <p>Make sure there is no loop-carried dependency on the allocation.</p>

<p class="definition">Definition at line <a class="el" href="MultiBuffer_8cpp_source.html#l00098">98</a> of file <a class="el" href="MultiBuffer_8cpp_source.html">MultiBuffer.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00029">DBGS</a>, <a class="el" href="Dominance_8h_source.html#l00158">mlir::DominanceInfo::dominates()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00873">mlir::Operation::getUsers()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01274">mlir::affine::makeComposedAffineApply()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00033">overrideBuffer()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00044">replaceUsesAndPropagateType()</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00429">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00193">mlir::MemRefType::Builder::setShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MultiBuffer_8cpp_source.html#l00244">multiBuffer()</a>.</p>

</div>
</div>
<a id="af6c5916519d8d818c95097ef22e882ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c5916519d8d818c95097ef22e882ee">&#9670;&nbsp;</a></span>populateComposeSubViewPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateComposeSubViewPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ComposeSubView_8cpp_source.html#l00139">139</a> of file <a class="el" href="ComposeSubView_8cpp_source.html">ComposeSubView.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="aa72dbb57f66b3381ca288a092d376802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72dbb57f66b3381ca288a092d376802">&#9670;&nbsp;</a></span>populateExpandOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateExpandOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects a set of patterns to rewrite ops within the memref dialect. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html#l00107">107</a> of file <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html">ExpandOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ad3b5486ce1776bc5afddb8ec9cc97f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b5486ce1776bc5afddb8ec9cc97f2a">&#9670;&nbsp;</a></span>populateExpandReallocPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateExpandReallocPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emitDeallocs</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for expanding <code>memref.realloc</code> operations. </p>

<p class="definition">Definition at line <a class="el" href="ExpandRealloc_8cpp_source.html#l00168">168</a> of file <a class="el" href="ExpandRealloc_8cpp_source.html">ExpandRealloc.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ae0a91532e484d6485dc36756f1b1bace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a91532e484d6485dc36756f1b1bace">&#9670;&nbsp;</a></span>populateExpandStridedMetadataPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateExpandStridedMetadataPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for expanding memref operations that modify the metadata (sizes, offset, strides) of a memref into easier to analyze constructs. </p>

<p class="definition">Definition at line <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l01197">1197</a> of file <a class="el" href="ExpandStridedMetadata_8cpp_source.html">ExpandStridedMetadata.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ad05667d80ad6b23301f24c722a4dbb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05667d80ad6b23301f24c722a4dbb28">&#9670;&nbsp;</a></span>populateExtractAddressComputationsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateExtractAddressComputationsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for extracting address computations from the instructions with memory accesses such that these memory accesses use only a base pointer. </p>
<p>For instance, </p><div class="fragment"><div class="line">memref.load %base[%off0, ...]</div>
</div><!-- fragment --><p>Will be rewritten in: </p><div class="fragment"><div class="line">%new_base = memref.subview %base[%off0,...][1,...][1,...]</div>
<div class="line">memref.load %new_base[%c0,...]</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ExtractAddressComputations_8cpp_source.html#l00282">282</a> of file <a class="el" href="ExtractAddressComputations_8cpp_source.html">ExtractAddressComputations.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a7d7d21ec8b60f6c5b3c94a28513f155e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7d21ec8b60f6c5b3c94a28513f155e">&#9670;&nbsp;</a></span>populateFlattenMemrefsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateFlattenMemrefsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FlattenMemRefs_8cpp_source.html#l00274">274</a> of file <a class="el" href="FlattenMemRefs_8cpp_source.html">FlattenMemRefs.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a0b92ea4d1067ac456aa6899baa8512a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b92ea4d1067ac456aa6899baa8512a9">&#9670;&nbsp;</a></span>populateFoldMemRefAliasOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateFoldMemRefAliasOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for folding memref aliasing ops into consumer load/store ops into <code>patterns</code>. </p>

<p class="definition">Definition at line <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00644">644</a> of file <a class="el" href="FoldMemRefAliasOps_8cpp_source.html">FoldMemRefAliasOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a5416c0ea0d3dcf0c0ce09270c16bb4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5416c0ea0d3dcf0c0ce09270c16bb4c7">&#9670;&nbsp;</a></span>populateMemRefNarrowTypeEmulationConversions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateMemRefNarrowTypeEmulationConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1arith_1_1NarrowTypeEmulationConverter.html">arith::NarrowTypeEmulationConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends type conversions for emulating memref operations over narrow types with ops over wider types. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00635">635</a> of file <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html">EmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00161">mlir::TypeConverter::addConversion()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00122">mlir::Type::getIntOrFloatBitWidth()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00617">getLinearizedShape()</a>, <a class="el" href="NarrowTypeEmulationConverter_8h_source.html#l00024">mlir::arith::NarrowTypeEmulationConverter::getLoadStoreBitwidth()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00056">mlir::Type::isInteger()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00116">mlir::Type::isIntOrFloat()</a>.</p>

</div>
</div>
<a id="ab6d12c8c0a0feb1452a1340adca2b62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d12c8c0a0feb1452a1340adca2b62d">&#9670;&nbsp;</a></span>populateMemRefNarrowTypeEmulationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateMemRefNarrowTypeEmulationPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1arith_1_1NarrowTypeEmulationConverter.html">arith::NarrowTypeEmulationConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for emulating memref operations over narrow types with ops over wider types. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00602">602</a> of file <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html">EmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, and <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l01219">populateResolveExtractStridedMetadataPatterns()</a>.</p>

</div>
</div>
<a id="a6c0e1bd45d93d6da7bf22b61465492b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0e1bd45d93d6da7bf22b61465492b9">&#9670;&nbsp;</a></span>populateMemRefWideIntEmulationConversions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateMemRefWideIntEmulationConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1arith_1_1WideIntEmulationConverter.html">arith::WideIntEmulationConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends type conversions for emulating wide integer memref operations with ops over narrowe integer types. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html#l00148">148</a> of file <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html">EmulateWideInt.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00161">mlir::TypeConverter::addConversion()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03027">mlir::TypeConverter::convertType()</a>, and <a class="el" href="WideIntEmulationConverter_8h_source.html#l00027">mlir::arith::WideIntEmulationConverter::getMaxTargetIntBitWidth()</a>.</p>

</div>
</div>
<a id="a0f7d0c93988c246b870a8f5f851f4eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7d0c93988c246b870a8f5f851f4eb3">&#9670;&nbsp;</a></span>populateMemRefWideIntEmulationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateMemRefWideIntEmulationPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1arith_1_1WideIntEmulationConverter.html">arith::WideIntEmulationConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for emulating wide integer memref operations with ops over narrower integer types. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html#l00140">140</a> of file <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html">EmulateWideInt.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a933e3cb75cf93999afc61710776fea07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933e3cb75cf93999afc61710776fea07">&#9670;&nbsp;</a></span>populateResolveExtractStridedMetadataPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateResolveExtractStridedMetadataPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for resolving <code>memref.extract_strided_metadata</code> into <code>memref.extract_strided_metadata</code> of its source. </p>

<p class="definition">Definition at line <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l01219">1219</a> of file <a class="el" href="ExpandStridedMetadata_8cpp_source.html">ExpandStridedMetadata.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00602">populateMemRefNarrowTypeEmulationPatterns()</a>.</p>

</div>
</div>
<a id="a313c2f5f760c17a276fac9bb108951c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313c2f5f760c17a276fac9bb108951c9">&#9670;&nbsp;</a></span>populateResolveRankedShapedTypeResultDimsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateResolveRankedShapedTypeResultDimsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns that resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>ReifyRankedShapedTypeOpInterface</code>, in terms of shapes of its input operands. </p>

<p class="definition">Definition at line <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00180">180</a> of file <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html">ResolveShapedTypeResultDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="DropUnitDims_8cpp_source.html#l00804">populateFoldUnitExtentDimsViaReshapesPatterns()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00824">populateFoldUnitExtentDimsViaSlicesPatterns()</a>.</p>

</div>
</div>
<a id="aaf97a8143d457b645153d6f40e6aed84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf97a8143d457b645153d6f40e6aed84">&#9670;&nbsp;</a></span>populateResolveShapedTypeResultDimsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateResolveShapedTypeResultDimsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns that resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>InferShapedTypeOpInterface</code>, in terms of shapes of its input operands. </p>

<p class="definition">Definition at line <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00187">187</a> of file <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html">ResolveShapedTypeResultDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="DropUnitDims_8cpp_source.html#l00804">populateFoldUnitExtentDimsViaReshapesPatterns()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00824">populateFoldUnitExtentDimsViaSlicesPatterns()</a>.</p>

</div>
</div>
<a id="a1883b3342d764a07311e3f8a79d8dd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1883b3342d764a07311e3f8a79d8dd1e">&#9670;&nbsp;</a></span>registerAllocationOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::registerAllocationOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AllocationOpInterfaceImpl_8cpp_source.html#l00062">62</a> of file <a class="el" href="AllocationOpInterfaceImpl_8cpp_source.html">AllocationOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00107">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a3091713b0337b82187ff9f4ab2f25a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3091713b0337b82187ff9f4ab2f25a5a">&#9670;&nbsp;</a></span>registerBufferViewFlowOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::registerBufferViewFlowOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2BufferViewFlowOpInterfaceImpl_8cpp_source.html#l00043">43</a> of file <a class="el" href="MemRef_2Transforms_2BufferViewFlowOpInterfaceImpl_8cpp_source.html">BufferViewFlowOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

</div>
</div>
<a id="a08647ff099a98052f95e4caff149a2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08647ff099a98052f95e4caff149a2f9">&#9670;&nbsp;</a></span>registerMemorySlotExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::registerMemorySlotExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefMemorySlot_8cpp_source.html#l00347">347</a> of file <a class="el" href="MemRefMemorySlot_8cpp_source.html">MemRefMemorySlot.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00107">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ad7fa7b00c1ccb23e5f4a528377dd4ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fa7b00c1ccb23e5f4a528377dd4ee9">&#9670;&nbsp;</a></span>registerRuntimeVerifiableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::registerRuntimeVerifiableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2RuntimeOpVerification_8cpp_source.html#l00347">347</a> of file <a class="el" href="MemRef_2Transforms_2RuntimeOpVerification_8cpp_source.html">RuntimeOpVerification.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

</div>
</div>
<a id="ae1adc6a8d5aefc17867d0815b586c3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1adc6a8d5aefc17867d0815b586c3b9">&#9670;&nbsp;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefTransformOps_8cpp_source.html#l00334">334</a> of file <a class="el" href="MemRefTransformOps_8cpp_source.html">MemRefTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00222">mlir::DialectRegistry::addExtensions()</a>.</p>

</div>
</div>
<a id="ac2b49994f10e98cb119abfb38f23c0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b49994f10e98cb119abfb38f23c0c3">&#9670;&nbsp;</a></span>registerValueBoundsOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::registerValueBoundsOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRef_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00117">117</a> of file <a class="el" href="MemRef_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

</div>
</div>
<a id="a390d7b6bfa73372eec5b1d2cd2bf937b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390d7b6bfa73372eec5b1d2cd2bf937b">&#9670;&nbsp;</a></span>replaceWithIndependentOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::memref::replaceWithIndependentOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::AllocaOp&#160;</td>
          <td class="paramname"><em>allocaOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>independencies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a new memref::AllocaOp whose dynamic sizes are independent of all given independencies. </p>
<p>If the op is already independent of all independencies, the same AllocaOp result is returned.</p>
<p>The original AllocaOp is replaced with the new one, wrapped in a SubviewOp. The result type of the replacement is different from the original allocation type: it has the same shape, but a different layout map. This function updates all users that do not have a memref result or memref region block argument, and some frequently used memref dialect ops (such as memref.subview). It does not update other uses such as the init_arg of an scf.for op. Such uses are wrapped in unrealized_conversion_cast.</p>
<p>Failure indicates the no suitable upper bound for the dynamic sizes could be found.</p>
<p>Example (make independent of iv): </p><div class="fragment"><div class="line">scf.for %iv = %c0 to %sz step %c1 {</div>
<div class="line">  %0 = memref.alloca(%iv) : memref&lt;?xf32&gt;</div>
<div class="line">  %1 = memref.subview %0[0][5][1] : ...</div>
<div class="line">  linalg.generic outs(%1 : ...) ...</div>
<div class="line">  %2 = scf.for ... iter_arg(%arg0 = %0) ...</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>The above IR is rewritten to:</p>
<div class="fragment"><div class="line">scf.for %iv = %c0 to %sz step %c1 {</div>
<div class="line">  %0 = memref.alloca(%sz - 1) : memref&lt;?xf32&gt;</div>
<div class="line">  %0_subview = memref.subview %0[0][%iv][1]</div>
<div class="line">      : memref&lt;?xf32&gt; to memref&lt;?xf32, #map&gt;</div>
<div class="line">  %1 = memref.subview %0_subview[0][5][1] : ...</div>
<div class="line">  linalg.generic outs(%1 : ...) ...</div>
<div class="line">  %cast = unrealized_conversion_cast %0_subview</div>
<div class="line">      : memref&lt;?xf32, #map&gt; to memref&lt;?xf32&gt;</div>
<div class="line">  %2 = scf.for ... iter_arg(%arg0 = %cast) ...</div>
<div class="line"> ...</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00166">166</a> of file <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html">IndependenceTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1memref.html#a1bf86c211b0ab9ea0b1ea4943a4e6d6e">buildIndependentOp()</a>, and <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00096">replaceAndPropagateMemRefType()</a>.</p>

</div>
</div>
<a id="a505b0a7d0ecf056721f2be2220c97b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505b0a7d0ecf056721f2be2220c97b39">&#9670;&nbsp;</a></span>resolveSourceIndicesCollapseShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::memref::resolveSourceIndicesCollapseShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::CollapseShapeOp&#160;</td>
          <td class="paramname"><em>collapseShapeOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the 'indices' of a load/store operation where the memref is a result of a collapse_shape op, returns the indices w.r.t to the source memref of the collapse_shape op. </p>
<p>For example</p>
<p>%0 = ... : memref&lt;2x6x42xf32&gt; %1 = memref.collapse_shape %0 [[0, 1], [2]] : memref&lt;2x6x42xf32&gt; into memref&lt;12x42xf32&gt; %2 = load %1[i1, i2] : memref&lt;12x42xf32&gt;</p>
<p>could be folded into</p>
<p>%2 = load %0[i1 / 6, i1 % 6, i2] : memref&lt;2x6x42xf32&gt; </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00248">248</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00108">mlir::delinearize()</a>, <a class="el" href="Builders_8cpp_source.html#l00373">mlir::Builder::getConstantAffineMap()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01327">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldMemRefsOps_8cpp_source.html#l00033">mlir::amdgpu::FoldMemRefOpsIntoGatherToLDSOp::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ad94d07e58f1f9fe168739a6ef8f495a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94d07e58f1f9fe168739a6ef8f495a6">&#9670;&nbsp;</a></span>resolveSourceIndicesExpandShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::memref::resolveSourceIndicesExpandShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::ExpandShapeOp&#160;</td>
          <td class="paramname"><em>expandShapeOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startsInbounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the 'indices' of a load/store operation where the memref is a result of a expand_shape op, returns the indices w.r.t to the source memref of the expand_shape op. </p>
<p>For example</p>
<p>%0 = ... : memref&lt;12x42xf32&gt; %1 = memref.expand_shape %0 [[0, 1], [2]] : memref&lt;12x42xf32&gt; into memref&lt;2x6x42xf32&gt; %2 = load %1[i1, i2, i3] : memref&lt;2x6x42xf32</p>
<p>could be folded into</p>
<p>%2 = load %0[6 * i1 + i2, i3] : memref&lt;12x42xf32&gt; </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00221">221</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldMemRefsOps_8cpp_source.html#l00033">mlir::amdgpu::FoldMemRefOpsIntoGatherToLDSOp::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a1c2b990b3c696031cd589f1859416013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2b990b3c696031cd589f1859416013">&#9670;&nbsp;</a></span>resultIsNotRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::memref::resultIsNotRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>uses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all the uses of op are not read/load. </p>
<p>There can be SubviewOp users as long as all its users are also StoreOp/transfer_write. If return true it also fills out the uses, if it returns false uses is unchanged. </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00139">139</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00674">mlir::Operation::getNumRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00846">mlir::Operation::getUses()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefUtils_8cpp_source.html#l00156">eraseDeadAllocAndStores()</a>.</p>

</div>
</div>
<a id="a3122c6f825e6d5a2372e58e7bd6eb2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3122c6f825e6d5a2372e58e7bd6eb2fc">&#9670;&nbsp;</a></span>skipFullyAliasingOperations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a7f8ab57590177d757d89848504dd7c5f">MemrefValue</a> mlir::memref::skipFullyAliasingOperations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a7f8ab57590177d757d89848504dd7c5f">MemrefValue</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk up the source chain until an operation that changes/defines the view of memory is found (i.e. </p>
<p>skip operations that alias the entire view). </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00193">193</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html#l00111">isSameViewOrTrivialAlias()</a>.</p>

</div>
</div>
<a id="a6dd2524604ba8a298b44470f68eb5076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd2524604ba8a298b44470f68eb5076">&#9670;&nbsp;</a></span>skipViewLikeOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a7f8ab57590177d757d89848504dd7c5f">MemrefValue</a> mlir::memref::skipViewLikeOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a7f8ab57590177d757d89848504dd7c5f">MemrefValue</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk up the source chain until we find an operation that is not a view of the source memref (i.e. </p>
<p>implements ViewLikeOpInterface). </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00210">210</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:31 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
