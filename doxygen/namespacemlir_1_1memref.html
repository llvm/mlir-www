<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::memref Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="namespacemlir_1_1memref.html">memref</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mlir::memref Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:impl" id="r_impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref_1_1impl.html">impl</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:ExpandReallocPassOptions" id="r_ExpandReallocPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1memref_1_1ExpandReallocPassOptions.html">ExpandReallocPassOptions</a></td></tr>
<tr class="memitem:LinearizedMemRefInfo" id="r_LinearizedMemRefInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html">LinearizedMemRefInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a <span class="tt">memref</span> with <span class="tt">offset</span>, <span class="tt">sizes</span> and <span class="tt">strides</span>, returns the offset, size, and potentially the size padded at the front to use for the linearized <span class="tt">memref</span>.  <a href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:MemRefEmulateWideIntOptions" id="r_MemRefEmulateWideIntOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1memref_1_1MemRefEmulateWideIntOptions.html">MemRefEmulateWideIntOptions</a></td></tr>
<tr class="memitem:ResolveRankedShapeTypeResultDimsPassOptions" id="r_ResolveRankedShapeTypeResultDimsPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1memref_1_1ResolveRankedShapeTypeResultDimsPassOptions.html">ResolveRankedShapeTypeResultDimsPassOptions</a></td></tr>
<tr class="memitem:ResolveShapedTypeResultDimsPassOptions" id="r_ResolveShapedTypeResultDimsPassOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1memref_1_1ResolveShapedTypeResultDimsPassOptions.html">ResolveShapedTypeResultDimsPassOptions</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa6d03c4cab7fc5604ab8b5d105b31d4b" id="r_aa6d03c4cab7fc5604ab8b5d105b31d4b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6d03c4cab7fc5604ab8b5d105b31d4b">foldMemRefCast</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> inner=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:aa6d03c4cab7fc5604ab8b5d105b31d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a common utility used for patterns of the form "someop(memref.cast) -&gt; someop".  <br /></td></tr>
<tr class="memitem:a593c42d0eefa6f2456d3ed618384de85" id="r_a593c42d0eefa6f2456d3ed618384de85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a593c42d0eefa6f2456d3ed618384de85">getTensorTypeFromMemRefType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a593c42d0eefa6f2456d3ed618384de85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unranked/ranked tensor type for the given unranked/ranked memref type.  <br /></td></tr>
<tr class="memitem:a7bb87b9964b1655bdedbdd1b7656225d" id="r_a7bb87b9964b1655bdedbdd1b7656225d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bb87b9964b1655bdedbdd1b7656225d">findDealloc</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> allocValue)</td></tr>
<tr class="memdesc:a7bb87b9964b1655bdedbdd1b7656225d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a single dealloc operation for the given allocated value.  <br /></td></tr>
<tr class="memitem:a5a881164870086f3048d50a9ff9cd702" id="r_a5a881164870086f3048d50a9ff9cd702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a881164870086f3048d50a9ff9cd702">getMixedSize</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classint64__t.html">int64_t</a> dim)</td></tr>
<tr class="memdesc:a5a881164870086f3048d50a9ff9cd702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of the given memref value.  <br /></td></tr>
<tr class="memitem:ab0c13e32e47a301b4ccac4b27404de51" id="r_ab0c13e32e47a301b4ccac4b27404de51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0c13e32e47a301b4ccac4b27404de51">getMixedSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:ab0c13e32e47a301b4ccac4b27404de51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimensions of the given memref value.  <br /></td></tr>
<tr class="memitem:ae1e796656fc119467035c6e1d1568a59" id="r_ae1e796656fc119467035c6e1d1568a59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1e796656fc119467035c6e1d1568a59">createCanonicalRankReducingSubViewOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> memref, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; targetShape)</td></tr>
<tr class="memdesc:ae1e796656fc119467035c6e1d1568a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rank-reducing SubViewOp @[0 .  <br /></td></tr>
<tr class="memitem:a08647ff099a98052f95e4caff149a2f9" id="r_a08647ff099a98052f95e4caff149a2f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08647ff099a98052f95e4caff149a2f9">registerMemorySlotExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:ac2b49994f10e98cb119abfb38f23c0c3" id="r_ac2b49994f10e98cb119abfb38f23c0c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2b49994f10e98cb119abfb38f23c0c3">registerValueBoundsOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:ae1adc6a8d5aefc17867d0815b586c3b9" id="r_ae1adc6a8d5aefc17867d0815b586c3b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1adc6a8d5aefc17867d0815b586c3b9">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a1883b3342d764a07311e3f8a79d8dd1e" id="r_a1883b3342d764a07311e3f8a79d8dd1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1883b3342d764a07311e3f8a79d8dd1e">registerAllocationOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a3091713b0337b82187ff9f4ab2f25a5a" id="r_a3091713b0337b82187ff9f4ab2f25a5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3091713b0337b82187ff9f4ab2f25a5a">registerBufferViewFlowOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:af6c5916519d8d818c95097ef22e882ee" id="r_af6c5916519d8d818c95097ef22e882ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6c5916519d8d818c95097ef22e882ee">populateComposeSubViewPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memitem:a99fb325810b0fcc6288e676d1e2c2a3c" id="r_a99fb325810b0fcc6288e676d1e2c2a3c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99fb325810b0fcc6288e676d1e2c2a3c">createExpandOpsPass</a> ()</td></tr>
<tr class="memitem:a744eb3f94f8b702f8b3fd4cbf44c6936" id="r_a744eb3f94f8b702f8b3fd4cbf44c6936"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a744eb3f94f8b702f8b3fd4cbf44c6936">createExpandReallocPass</a> ()</td></tr>
<tr class="memitem:aee3aaa8593829021111521de19e0436d" id="r_aee3aaa8593829021111521de19e0436d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee3aaa8593829021111521de19e0436d">createExpandReallocPass</a> (<a class="el" href="structmlir_1_1memref_1_1ExpandReallocPassOptions.html">ExpandReallocPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:aa20018faaeeda08f6324707b1d7a35b5" id="r_aa20018faaeeda08f6324707b1d7a35b5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa20018faaeeda08f6324707b1d7a35b5">createExpandStridedMetadataPass</a> ()</td></tr>
<tr class="memitem:ad2752837f93dabafde9964830ba49b9b" id="r_ad2752837f93dabafde9964830ba49b9b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2752837f93dabafde9964830ba49b9b">createFlattenMemrefsPass</a> ()</td></tr>
<tr class="memitem:ac59f94779f90f21674c18e6a91b86f2e" id="r_ac59f94779f90f21674c18e6a91b86f2e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac59f94779f90f21674c18e6a91b86f2e">createFoldMemRefAliasOpsPass</a> ()</td></tr>
<tr class="memitem:aa70509bb8928e72ce64452aaa240e1b2" id="r_aa70509bb8928e72ce64452aaa240e1b2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa70509bb8928e72ce64452aaa240e1b2">createMemRefEmulateWideInt</a> ()</td></tr>
<tr class="memitem:ab0e7c2f7ea11cf4b57402559216c3d3b" id="r_ab0e7c2f7ea11cf4b57402559216c3d3b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0e7c2f7ea11cf4b57402559216c3d3b">createMemRefEmulateWideInt</a> (<a class="el" href="structmlir_1_1memref_1_1MemRefEmulateWideIntOptions.html">MemRefEmulateWideIntOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:abb46e18f142e7bb753e230622e19d821" id="r_abb46e18f142e7bb753e230622e19d821"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb46e18f142e7bb753e230622e19d821">createNormalizeMemRefsPass</a> ()</td></tr>
<tr class="memitem:a6b227fd726a398a704059ea381d12bfd" id="r_a6b227fd726a398a704059ea381d12bfd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b227fd726a398a704059ea381d12bfd">createReifyResultShapesPass</a> ()</td></tr>
<tr class="memitem:a1dc2e9d2c2137c12828dc29a2072e97a" id="r_a1dc2e9d2c2137c12828dc29a2072e97a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dc2e9d2c2137c12828dc29a2072e97a">createResolveRankedShapeTypeResultDimsPass</a> ()</td></tr>
<tr class="memitem:a8ae506b8176b558526016b5ed944c563" id="r_a8ae506b8176b558526016b5ed944c563"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ae506b8176b558526016b5ed944c563">createResolveRankedShapeTypeResultDimsPass</a> (<a class="el" href="structmlir_1_1memref_1_1ResolveRankedShapeTypeResultDimsPassOptions.html">ResolveRankedShapeTypeResultDimsPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:ad2e93b11b6632195cdb030f657b04806" id="r_ad2e93b11b6632195cdb030f657b04806"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2e93b11b6632195cdb030f657b04806">createResolveShapedTypeResultDimsPass</a> ()</td></tr>
<tr class="memitem:a4932f0729b38ea3c4b5f2320bb0804a1" id="r_a4932f0729b38ea3c4b5f2320bb0804a1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4932f0729b38ea3c4b5f2320bb0804a1">createResolveShapedTypeResultDimsPass</a> (<a class="el" href="structmlir_1_1memref_1_1ResolveShapedTypeResultDimsPassOptions.html">ResolveShapedTypeResultDimsPassOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a0b7380139903012a6df52390cb1d153d" id="r_a0b7380139903012a6df52390cb1d153d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b7380139903012a6df52390cb1d153d">registerExpandOpsPass</a> ()</td></tr>
<tr class="memitem:abc9cf2e3d61ef302027144d770ba2eb6" id="r_abc9cf2e3d61ef302027144d770ba2eb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc9cf2e3d61ef302027144d770ba2eb6">registerExpandOpsPassPass</a> ()</td></tr>
<tr class="memitem:a21d3f69da9b785ceb6184d6a08418795" id="r_a21d3f69da9b785ceb6184d6a08418795"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21d3f69da9b785ceb6184d6a08418795">registerExpandReallocPass</a> ()</td></tr>
<tr class="memitem:a739f63ce1ee4315030d1198a529d58ae" id="r_a739f63ce1ee4315030d1198a529d58ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a739f63ce1ee4315030d1198a529d58ae">registerExpandReallocPassPass</a> ()</td></tr>
<tr class="memitem:a1b064c2145bd2da900aa20f39ee524d8" id="r_a1b064c2145bd2da900aa20f39ee524d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b064c2145bd2da900aa20f39ee524d8">registerExpandStridedMetadataPass</a> ()</td></tr>
<tr class="memitem:ab825c1cecd9231e596c14d3820a5067f" id="r_ab825c1cecd9231e596c14d3820a5067f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab825c1cecd9231e596c14d3820a5067f">registerExpandStridedMetadataPassPass</a> ()</td></tr>
<tr class="memitem:a5354eca84b151ada55e752c0c5cfbf4c" id="r_a5354eca84b151ada55e752c0c5cfbf4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5354eca84b151ada55e752c0c5cfbf4c">registerFlattenMemrefsPass</a> ()</td></tr>
<tr class="memitem:a46b157af8897d28b96e4169dc8d55279" id="r_a46b157af8897d28b96e4169dc8d55279"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46b157af8897d28b96e4169dc8d55279">registerFlattenMemrefsPassPass</a> ()</td></tr>
<tr class="memitem:a57cfa26220dd26c9426a52d3c92f106f" id="r_a57cfa26220dd26c9426a52d3c92f106f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57cfa26220dd26c9426a52d3c92f106f">registerFoldMemRefAliasOpsPass</a> ()</td></tr>
<tr class="memitem:ac4e1101ae27c4b2223c441236a0d40ed" id="r_ac4e1101ae27c4b2223c441236a0d40ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4e1101ae27c4b2223c441236a0d40ed">registerFoldMemRefAliasOpsPassPass</a> ()</td></tr>
<tr class="memitem:aff2fe6f317333418b5f2382f6733cb93" id="r_aff2fe6f317333418b5f2382f6733cb93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff2fe6f317333418b5f2382f6733cb93">registerMemRefEmulateWideInt</a> ()</td></tr>
<tr class="memitem:af098529bf685620f47d5e2b8b8aa31b0" id="r_af098529bf685620f47d5e2b8b8aa31b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af098529bf685620f47d5e2b8b8aa31b0">registerMemRefEmulateWideIntPass</a> ()</td></tr>
<tr class="memitem:a1667c8bc6a8917684c1b2decd0dfe066" id="r_a1667c8bc6a8917684c1b2decd0dfe066"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1667c8bc6a8917684c1b2decd0dfe066">registerNormalizeMemRefsPass</a> ()</td></tr>
<tr class="memitem:adc09f9b2fb6c03884efd9a6053d2ddd4" id="r_adc09f9b2fb6c03884efd9a6053d2ddd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc09f9b2fb6c03884efd9a6053d2ddd4">registerNormalizeMemRefsPassPass</a> ()</td></tr>
<tr class="memitem:a7e0287e46cb7fac2d2119050c55666a6" id="r_a7e0287e46cb7fac2d2119050c55666a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e0287e46cb7fac2d2119050c55666a6">registerReifyResultShapesPass</a> ()</td></tr>
<tr class="memitem:a2d5eafa4a75e3f46e9a1d3f80ed0a46a" id="r_a2d5eafa4a75e3f46e9a1d3f80ed0a46a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d5eafa4a75e3f46e9a1d3f80ed0a46a">registerReifyResultShapesPassPass</a> ()</td></tr>
<tr class="memitem:a8bca34df84259a7968251cf756127c18" id="r_a8bca34df84259a7968251cf756127c18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bca34df84259a7968251cf756127c18">registerResolveRankedShapeTypeResultDimsPass</a> ()</td></tr>
<tr class="memitem:aedfd4b331cf2febf6eecc78c0465c803" id="r_aedfd4b331cf2febf6eecc78c0465c803"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedfd4b331cf2febf6eecc78c0465c803">registerResolveRankedShapeTypeResultDimsPassPass</a> ()</td></tr>
<tr class="memitem:a7cfeeb0c3bf931bc1c4af941917b90c0" id="r_a7cfeeb0c3bf931bc1c4af941917b90c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cfeeb0c3bf931bc1c4af941917b90c0">registerResolveShapedTypeResultDimsPass</a> ()</td></tr>
<tr class="memitem:a1c53d20166600950eb0270c6995b9fa5" id="r_a1c53d20166600950eb0270c6995b9fa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c53d20166600950eb0270c6995b9fa5">registerResolveShapedTypeResultDimsPassPass</a> ()</td></tr>
<tr class="memitem:a3d338b34b45d19cefd8d797849c325ff" id="r_a3d338b34b45d19cefd8d797849c325ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d338b34b45d19cefd8d797849c325ff">registerMemRefPasses</a> ()</td></tr>
<tr class="memitem:ad7fa7b00c1ccb23e5f4a528377dd4ee9" id="r_ad7fa7b00c1ccb23e5f4a528377dd4ee9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7fa7b00c1ccb23e5f4a528377dd4ee9">registerRuntimeVerifiableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:aa72dbb57f66b3381ca288a092d376802" id="r_aa72dbb57f66b3381ca288a092d376802"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa72dbb57f66b3381ca288a092d376802">populateExpandOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aa72dbb57f66b3381ca288a092d376802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects a set of patterns to rewrite ops within the memref dialect.  <br /></td></tr>
<tr class="memitem:a0b92ea4d1067ac456aa6899baa8512a9" id="r_a0b92ea4d1067ac456aa6899baa8512a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b92ea4d1067ac456aa6899baa8512a9">populateFoldMemRefAliasOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a0b92ea4d1067ac456aa6899baa8512a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for folding memref aliasing ops into consumer load/store ops into <span class="tt">patterns</span>.  <br /></td></tr>
<tr class="memitem:a313c2f5f760c17a276fac9bb108951c9" id="r_a313c2f5f760c17a276fac9bb108951c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a313c2f5f760c17a276fac9bb108951c9">populateResolveRankedShapedTypeResultDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a313c2f5f760c17a276fac9bb108951c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns that resolve <span class="tt">memref.dim</span> operations with values that are defined by operations that implement the <span class="tt">ReifyRankedShapedTypeOpInterface</span>, in terms of shapes of its input operands.  <br /></td></tr>
<tr class="memitem:aaf97a8143d457b645153d6f40e6aed84" id="r_aaf97a8143d457b645153d6f40e6aed84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf97a8143d457b645153d6f40e6aed84">populateResolveShapedTypeResultDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aaf97a8143d457b645153d6f40e6aed84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns that resolve <span class="tt">memref.dim</span> operations with values that are defined by operations that implement the <span class="tt">InferShapedTypeOpInterface</span>, in terms of shapes of its input operands.  <br /></td></tr>
<tr class="memitem:ae0a91532e484d6485dc36756f1b1bace" id="r_ae0a91532e484d6485dc36756f1b1bace"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0a91532e484d6485dc36756f1b1bace">populateExpandStridedMetadataPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ae0a91532e484d6485dc36756f1b1bace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for expanding memref operations that modify the metadata (sizes, offset, strides) of a memref into easier to analyze constructs.  <br /></td></tr>
<tr class="memitem:a933e3cb75cf93999afc61710776fea07" id="r_a933e3cb75cf93999afc61710776fea07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a933e3cb75cf93999afc61710776fea07">populateResolveExtractStridedMetadataPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a933e3cb75cf93999afc61710776fea07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for resolving <span class="tt">memref.extract_strided_metadata</span> into <span class="tt">memref.extract_strided_metadata</span> of its source.  <br /></td></tr>
<tr class="memitem:ad3b5486ce1776bc5afddb8ec9cc97f2a" id="r_ad3b5486ce1776bc5afddb8ec9cc97f2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3b5486ce1776bc5afddb8ec9cc97f2a">populateExpandReallocPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classbool.html">bool</a> emitDeallocs=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:ad3b5486ce1776bc5afddb8ec9cc97f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for expanding <span class="tt">memref.realloc</span> operations.  <br /></td></tr>
<tr class="memitem:a0f7d0c93988c246b870a8f5f851f4eb3" id="r_a0f7d0c93988c246b870a8f5f851f4eb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f7d0c93988c246b870a8f5f851f4eb3">populateMemRefWideIntEmulationPatterns</a> (const <a class="el" href="classmlir_1_1arith_1_1WideIntEmulationConverter.html">arith::WideIntEmulationConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a0f7d0c93988c246b870a8f5f851f4eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for emulating wide integer memref operations with ops over narrower integer types.  <br /></td></tr>
<tr class="memitem:a6c0e1bd45d93d6da7bf22b61465492b9" id="r_a6c0e1bd45d93d6da7bf22b61465492b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c0e1bd45d93d6da7bf22b61465492b9">populateMemRefWideIntEmulationConversions</a> (<a class="el" href="classmlir_1_1arith_1_1WideIntEmulationConverter.html">arith::WideIntEmulationConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:a6c0e1bd45d93d6da7bf22b61465492b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends type conversions for emulating wide integer memref operations with ops over narrowe integer types.  <br /></td></tr>
<tr class="memitem:ab6d12c8c0a0feb1452a1340adca2b62d" id="r_ab6d12c8c0a0feb1452a1340adca2b62d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6d12c8c0a0feb1452a1340adca2b62d">populateMemRefNarrowTypeEmulationPatterns</a> (const <a class="el" href="classmlir_1_1arith_1_1NarrowTypeEmulationConverter.html">arith::NarrowTypeEmulationConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ab6d12c8c0a0feb1452a1340adca2b62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for emulating memref operations over narrow types with ops over wider types.  <br /></td></tr>
<tr class="memitem:a5416c0ea0d3dcf0c0ce09270c16bb4c7" id="r_a5416c0ea0d3dcf0c0ce09270c16bb4c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5416c0ea0d3dcf0c0ce09270c16bb4c7">populateMemRefNarrowTypeEmulationConversions</a> (<a class="el" href="classmlir_1_1arith_1_1NarrowTypeEmulationConverter.html">arith::NarrowTypeEmulationConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:a5416c0ea0d3dcf0c0ce09270c16bb4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends type conversions for emulating memref operations over narrow types with ops over wider types.  <br /></td></tr>
<tr class="memitem:a637539fbb3044706f07e949413eac30d" id="r_a637539fbb3044706f07e949413eac30d"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; memref::AllocOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a637539fbb3044706f07e949413eac30d">multiBuffer</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, memref::AllocOp allocOp, <a class="el" href="classunsigned.html">unsigned</a> multiplier, <a class="el" href="classbool.html">bool</a> skipOverrideAnalysis=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a637539fbb3044706f07e949413eac30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation to do multi-buffering/array expansion to remove dependencies on the temporary allocation between consecutive loop iterations.  <br /></td></tr>
<tr class="memitem:ae4ffe31231e4fd88511f0d2446b4218d" id="r_ae4ffe31231e4fd88511f0d2446b4218d"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; memref::AllocOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4ffe31231e4fd88511f0d2446b4218d">multiBuffer</a> (memref::AllocOp allocOp, <a class="el" href="classunsigned.html">unsigned</a> multiplier, <a class="el" href="classbool.html">bool</a> skipOverrideAnalysis=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:ae4ffe31231e4fd88511f0d2446b4218d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call into <span class="tt">multiBuffer</span> with locally constructed <a class="el" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ...">IRRewriter</a>.  <br /></td></tr>
<tr class="memitem:ad05667d80ad6b23301f24c722a4dbb28" id="r_ad05667d80ad6b23301f24c722a4dbb28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad05667d80ad6b23301f24c722a4dbb28">populateExtractAddressComputationsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ad05667d80ad6b23301f24c722a4dbb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for extracting address computations from the instructions with memory accesses such that these memory accesses use only a base pointer.  <br /></td></tr>
<tr class="memitem:aa16b0e5dafcfb80dac42280375ca65a9" id="r_aa16b0e5dafcfb80dac42280375ca65a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa16b0e5dafcfb80dac42280375ca65a9">populateFlattenVectorOpsOnMemrefPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aa16b0e5dafcfb80dac42280375ca65a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns for flattening multi-dimensional memref operations into one-dimensional memref operations.  <br /></td></tr>
<tr class="memitem:a8543ccab5ef166a2dab4da47e0ca3579" id="r_a8543ccab5ef166a2dab4da47e0ca3579"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8543ccab5ef166a2dab4da47e0ca3579">populateFlattenMemrefOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:a7d7d21ec8b60f6c5b3c94a28513f155e" id="r_a7d7d21ec8b60f6c5b3c94a28513f155e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d7d21ec8b60f6c5b3c94a28513f155e">populateFlattenMemrefsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:ad18abceb07a035165626e5d419cfbd02" id="r_ad18abceb07a035165626e5d419cfbd02"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad18abceb07a035165626e5d419cfbd02">buildIndependentOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, AllocaOp allocaOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> independencies)</td></tr>
<tr class="memdesc:ad18abceb07a035165626e5d419cfbd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a new memref::AllocaOp whose dynamic sizes are independent of all given independencies.  <br /></td></tr>
<tr class="memitem:a390d7b6bfa73372eec5b1d2cd2bf937b" id="r_a390d7b6bfa73372eec5b1d2cd2bf937b"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a390d7b6bfa73372eec5b1d2cd2bf937b">replaceWithIndependentOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, memref::AllocaOp allocaOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> independencies)</td></tr>
<tr class="memdesc:a390d7b6bfa73372eec5b1d2cd2bf937b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a new memref::AllocaOp whose dynamic sizes are independent of all given independencies.  <br /></td></tr>
<tr class="memitem:ad3bb58d33cedbbc97322a912c2c67971" id="r_ad3bb58d33cedbbc97322a912c2c67971"><td class="memItemLeft" align="right" valign="top">memref::AllocaOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3bb58d33cedbbc97322a912c2c67971">allocToAlloca</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, memref::AllocOp alloc, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(memref::AllocOp, memref::DeallocOp)&gt; filter=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:ad3bb58d33cedbbc97322a912c2c67971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the given <span class="tt">alloc</span> with the corresponding <span class="tt">alloca</span> and returns it if the following conditions are met:  <br /></td></tr>
<tr class="memitem:a6dd556718fd72c7099dc94f99d30ccd1" id="r_a6dd556718fd72c7099dc94f99d30ccd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dd556718fd72c7099dc94f99d30ccd1">isStaticShapeAndContiguousRowMajor</a> (MemRefType type)</td></tr>
<tr class="memdesc:a6dd556718fd72c7099dc94f99d30ccd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the memref type has static shapes and represents a contiguous chunk of memory.  <br /></td></tr>
<tr class="memitem:a68e822c5ce40c4b3815acd8657d6c8c3" id="r_a68e822c5ce40c4b3815acd8657d6c8c3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html">LinearizedMemRefInfo</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68e822c5ce40c4b3815acd8657d6c8c3">getLinearizedMemRefOffsetAndSize</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, int srcBits, int dstBits, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> offset, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; strides, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; <a class="el" href="AffineAnalysis_8cpp.html#a7b261d2d5f193015afc3427b0c0951ed">indices</a>={})</td></tr>
<tr class="memitem:a0ec5fa6d6d4ab684b9a5ff4ef7e668b6" id="r_a0ec5fa6d6d4ab684b9a5ff4ef7e668b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html">LinearizedMemRefInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ec5fa6d6d4ab684b9a5ff4ef7e668b6">getLinearizedMemRefOffsetAndSize</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, int srcBits, int dstBits, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> offset, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes)</td></tr>
<tr class="memdesc:a0ec5fa6d6d4ab684b9a5ff4ef7e668b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a <span class="tt">memref</span> with <span class="tt">offset</span> and <span class="tt">sizes</span>, returns the offset and size to use for the linearized <span class="tt">memref</span>, assuming that the strides are computed from a row-major ordering of the sizes;.  <br /></td></tr>
<tr class="memitem:a4147c59f3a9e3d7d845d27760a8b565b" id="r_a4147c59f3a9e3d7d845d27760a8b565b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4147c59f3a9e3d7d845d27760a8b565b">eraseDeadAllocAndStores</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *parentOp)</td></tr>
<tr class="memdesc:a4147c59f3a9e3d7d845d27760a8b565b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track temporary allocations that are never read from.  <br /></td></tr>
<tr class="memitem:ad95cc10c54ee522c94ec39f10cb01f42" id="r_ad95cc10c54ee522c94ec39f10cb01f42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad95cc10c54ee522c94ec39f10cb01f42">computeSuffixProductIRBlock</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes)</td></tr>
<tr class="memdesc:ad95cc10c54ee522c94ec39f10cb01f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of sizes, return the suffix product.  <br /></td></tr>
<tr class="memitem:a9e8eb2ea927097b9dd3015960b7c71b1" id="r_a9e8eb2ea927097b9dd3015960b7c71b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e8eb2ea927097b9dd3015960b7c71b1">computeStridesIRBlock</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes)</td></tr>
<tr class="memitem:a3122c6f825e6d5a2372e58e7bd6eb2fc" id="r_a3122c6f825e6d5a2372e58e7bd6eb2fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a92e239e8ecf7770f9cbdc4cdb0ccd0f6">MemrefValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3122c6f825e6d5a2372e58e7bd6eb2fc">skipFullyAliasingOperations</a> (<a class="el" href="namespacemlir.html#a92e239e8ecf7770f9cbdc4cdb0ccd0f6">MemrefValue</a> source)</td></tr>
<tr class="memdesc:a3122c6f825e6d5a2372e58e7bd6eb2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk up the source chain until an operation that changes/defines the view of memory is found (i.e.  <br /></td></tr>
<tr class="memitem:a395ef51018e96d34a3f91f08896513a4" id="r_a395ef51018e96d34a3f91f08896513a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a395ef51018e96d34a3f91f08896513a4">isSameViewOrTrivialAlias</a> (<a class="el" href="namespacemlir.html#a92e239e8ecf7770f9cbdc4cdb0ccd0f6">MemrefValue</a> a, <a class="el" href="namespacemlir.html#a92e239e8ecf7770f9cbdc4cdb0ccd0f6">MemrefValue</a> <a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>)</td></tr>
<tr class="memdesc:a395ef51018e96d34a3f91f08896513a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two (memref) values are the same or statically known to alias the same region of memory.  <br /></td></tr>
<tr class="memitem:a6dd2524604ba8a298b44470f68eb5076" id="r_a6dd2524604ba8a298b44470f68eb5076"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a92e239e8ecf7770f9cbdc4cdb0ccd0f6">MemrefValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dd2524604ba8a298b44470f68eb5076">skipViewLikeOps</a> (<a class="el" href="namespacemlir.html#a92e239e8ecf7770f9cbdc4cdb0ccd0f6">MemrefValue</a> source)</td></tr>
<tr class="memdesc:a6dd2524604ba8a298b44470f68eb5076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk up the source chain until we find an operation that is not a view of the source memref (i.e.  <br /></td></tr>
<tr class="memitem:ad94d07e58f1f9fe168739a6ef8f495a6" id="r_ad94d07e58f1f9fe168739a6ef8f495a6"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad94d07e58f1f9fe168739a6ef8f495a6">resolveSourceIndicesExpandShape</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, memref::ExpandShapeOp expandShapeOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> <a class="el" href="AffineAnalysis_8cpp.html#a7b261d2d5f193015afc3427b0c0951ed">indices</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;sourceIndices, <a class="el" href="classbool.html">bool</a> startsInbounds)</td></tr>
<tr class="memdesc:ad94d07e58f1f9fe168739a6ef8f495a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the 'indices' of a load/store operation where the memref is a result of a expand_shape op, returns the indices w.r.t to the source memref of the expand_shape op.  <br /></td></tr>
<tr class="memitem:a505b0a7d0ecf056721f2be2220c97b39" id="r_a505b0a7d0ecf056721f2be2220c97b39"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a505b0a7d0ecf056721f2be2220c97b39">resolveSourceIndicesCollapseShape</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, memref::CollapseShapeOp collapseShapeOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> <a class="el" href="AffineAnalysis_8cpp.html#a7b261d2d5f193015afc3427b0c0951ed">indices</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;sourceIndices)</td></tr>
<tr class="memdesc:a505b0a7d0ecf056721f2be2220c97b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the 'indices' of a load/store operation where the memref is a result of a collapse_shape op, returns the indices w.r.t to the source memref of the collapse_shape op.  <br /></td></tr>
<tr class="memitem:a1c2b990b3c696031cd589f1859416013" id="r_a1c2b990b3c696031cd589f1859416013"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c2b990b3c696031cd589f1859416013">resultIsNotRead</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, std::vector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;uses)</td></tr>
<tr class="memdesc:a1c2b990b3c696031cd589f1859416013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all the uses of op are not read/load.  <br /></td></tr>
<tr class="memitem:abb38ac217ab225f01a609b0b0e79d5ab" id="r_abb38ac217ab225f01a609b0b0e79d5ab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb38ac217ab225f01a609b0b0e79d5ab">computeSuffixProductIRBlockImpl</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> unit)</td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ad3bb58d33cedbbc97322a912c2c67971" name="ad3bb58d33cedbbc97322a912c2c67971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bb58d33cedbbc97322a912c2c67971">&#9670;&#160;</a></span>allocToAlloca()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">memref::AllocaOp mlir::memref::allocToAlloca </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::AllocOp</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(memref::AllocOp, memref::DeallocOp)&gt;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the given <span class="tt">alloc</span> with the corresponding <span class="tt">alloca</span> and returns it if the following conditions are met: </p>
<ul>
<li>the corresponding dealloc is available in the same block as the alloc;</li>
<li>the filter, if provided, succeeds on the alloc/dealloc pair. Otherwise returns nullptr and leaves the IR unchanged. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00178">178</a> of file <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html">IndependenceTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>, <a class="el" href="PatternMatch_8h_source.html#l00529">mlir::RewriterBase::replaceOpWithNewOp()</a>, and <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="ad18abceb07a035165626e5d419cfbd02" name="ad18abceb07a035165626e5d419cfbd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18abceb07a035165626e5d419cfbd02">&#9670;&#160;</a></span>buildIndependentOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::memref::buildIndependentOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocaOp</td>          <td class="paramname"><span class="paramname"><em>allocaOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>independencies</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a new memref::AllocaOp whose dynamic sizes are independent of all given independencies. </p>
<p>If the op is already independent of all independencies, the same AllocaOp result is returned.</p>
<p>Failure indicates the no suitable upper bound for the dynamic sizes could be found. </p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00166">replaceWithIndependentOp()</a>.</p>

</div>
</div>
<a id="a9e8eb2ea927097b9dd3015960b7c71b1" name="a9e8eb2ea927097b9dd3015960b7c71b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8eb2ea927097b9dd3015960b7c71b1">&#9670;&#160;</a></span>computeStridesIRBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::memref::computeStridesIRBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html#l00100">100</a> of file <a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

<p class="reference">References <a class="el" href="MemRefUtils_8cpp_source.html#l00190">computeSuffixProductIRBlock()</a>.</p>

</div>
</div>
<a id="ad95cc10c54ee522c94ec39f10cb01f42" name="ad95cc10c54ee522c94ec39f10cb01f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95cc10c54ee522c94ec39f10cb01f42">&#9670;&#160;</a></span>computeSuffixProductIRBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::memref::computeSuffixProductIRBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of sizes, return the suffix product. </p>
<p>When applied to slicing, this is the calculation needed to derive the strides (i.e. the number of linear indices to skip along the (k-1) most minor dimensions to get the next k-slice).</p>
<p>This is the basis to linearize an n-D offset confined to <span class="tt">[0 ... sizes]</span>.</p>
<p>Assuming <span class="tt">sizes</span> is <span class="tt">[s0, .. sn]</span>, return the <a class="el" href="namespacemlir_1_1vector.html">vector&lt;Value&gt;</a> <span class="tt">[s1 * ... * sn, s2 * ... * sn, ..., sn, 1]</span>.</p>
<p>It is the caller's responsibility to provide valid <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> type values and construct valid IR in the end.</p>
<p><span class="tt">sizes</span> elements are asserted to be non-negative.</p>
<p>Return an empty vector if <span class="tt">sizes</span> is empty.</p>
<p>The function emits an IR block which computes suffix product for provided sizes. </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00190">190</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefUtils_8cpp_source.html#l00175">computeSuffixProductIRBlockImpl()</a>, and <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html#l00100">computeStridesIRBlock()</a>.</p>

</div>
</div>
<a id="abb38ac217ab225f01a609b0b0e79d5ab" name="abb38ac217ab225f01a609b0b0e79d5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb38ac217ab225f01a609b0b0e79d5ab">&#9670;&#160;</a></span>computeSuffixProductIRBlockImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::memref::computeSuffixProductIRBlockImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>unit</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00175">175</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefUtils_8cpp_source.html#l00190">computeSuffixProductIRBlock()</a>.</p>

</div>
</div>
<a id="ae1e796656fc119467035c6e1d1568a59" name="ae1e796656fc119467035c6e1d1568a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e796656fc119467035c6e1d1568a59">&#9670;&#160;</a></span>createCanonicalRankReducingSubViewOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::memref::createCanonicalRankReducingSubViewOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>memref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>targetShape</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a rank-reducing SubViewOp @[0 . </p>
<p>. 0] with strides [1 .. 1] and appropriate sizes (i.e. <span class="tt">memref.getSizes()</span>) to reduce the rank of <span class="tt">memref</span> to that of <span class="tt">targetShape</span>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l03240">3240</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="TensorOps_8cpp_source.html#l00066">mlir::tensor::getMixedSizes()</a>.</p>

</div>
</div>
<a id="a99fb325810b0fcc6288e676d1e2c2a3c" name="a99fb325810b0fcc6288e676d1e2c2a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fb325810b0fcc6288e676d1e2c2a3c">&#9670;&#160;</a></span>createExpandOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::memref::createExpandOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html#l00088">88</a> of file <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html">ExpandOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp.html#a420db562c84b0a026e92385cb33aaf6f">getContext()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html#l00107">populateExpandOpsPatterns()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="a744eb3f94f8b702f8b3fd4cbf44c6936" name="a744eb3f94f8b702f8b3fd4cbf44c6936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744eb3f94f8b702f8b3fd4cbf44c6936">&#9670;&#160;</a></span>createExpandReallocPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::memref::createExpandReallocPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandRealloc_8cpp_source.html#l00181">181</a> of file <a class="el" href="ExpandRealloc_8cpp_source.html">ExpandRealloc.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizationPipelines_8cpp_source.html#l00024">mlir::bufferization::buildBufferDeallocationPipeline()</a>, and <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="aee3aaa8593829021111521de19e0436d" name="aee3aaa8593829021111521de19e0436d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3aaa8593829021111521de19e0436d">&#9670;&#160;</a></span>createExpandReallocPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::memref::createExpandReallocPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1memref_1_1ExpandReallocPassOptions.html">ExpandReallocPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExpandRealloc_8cpp_source.html#l00185">185</a> of file <a class="el" href="ExpandRealloc_8cpp_source.html">ExpandRealloc.cpp</a>.</p>

</div>
</div>
<a id="aa20018faaeeda08f6324707b1d7a35b5" name="aa20018faaeeda08f6324707b1d7a35b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20018faaeeda08f6324707b1d7a35b5">&#9670;&#160;</a></span>createExpandStridedMetadataPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::memref::createExpandStridedMetadataPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l00261">261</a> of file <a class="el" href="ExpandStridedMetadata_8cpp_source.html">ExpandStridedMetadata.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00959">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="Builders_8cpp_source.html#l00368">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00026">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="ad2752837f93dabafde9964830ba49b9b" name="ad2752837f93dabafde9964830ba49b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2752837f93dabafde9964830ba49b9b">&#9670;&#160;</a></span>createFlattenMemrefsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::memref::createFlattenMemrefsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="FlattenMemRefs_8cpp_source.html#l00338">338</a> of file <a class="el" href="FlattenMemRefs_8cpp_source.html">FlattenMemRefs.cpp</a>.</p>

</div>
</div>
<a id="ac59f94779f90f21674c18e6a91b86f2e" name="ac59f94779f90f21674c18e6a91b86f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59f94779f90f21674c18e6a91b86f2e">&#9670;&#160;</a></span>createFoldMemRefAliasOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::memref::createFoldMemRefAliasOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00415">415</a> of file <a class="el" href="FoldMemRefAliasOps_8cpp_source.html">FoldMemRefAliasOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00202">calculateExpandedAccessIndices()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>.</p>

</div>
</div>
<a id="aa70509bb8928e72ce64452aaa240e1b2" name="aa70509bb8928e72ce64452aaa240e1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70509bb8928e72ce64452aaa240e1b2">&#9670;&#160;</a></span>createMemRefEmulateWideInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::memref::createMemRefEmulateWideInt </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html#l00506">506</a> of file <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html">EmulateWideInt.cpp</a>.</p>

</div>
</div>
<a id="ab0e7c2f7ea11cf4b57402559216c3d3b" name="ab0e7c2f7ea11cf4b57402559216c3d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e7c2f7ea11cf4b57402559216c3d3b">&#9670;&#160;</a></span>createMemRefEmulateWideInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::memref::createMemRefEmulateWideInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1memref_1_1MemRefEmulateWideIntOptions.html">MemRefEmulateWideIntOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html#l00510">510</a> of file <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html">EmulateWideInt.cpp</a>.</p>

</div>
</div>
<a id="abb46e18f142e7bb753e230622e19d821" name="abb46e18f142e7bb753e230622e19d821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb46e18f142e7bb753e230622e19d821">&#9670;&#160;</a></span>createNormalizeMemRefsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::memref::createNormalizeMemRefsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00585">585</a> of file <a class="el" href="NormalizeMemRefs_8cpp_source.html">NormalizeMemRefs.cpp</a>.</p>

</div>
</div>
<a id="a6b227fd726a398a704059ea381d12bfd" name="a6b227fd726a398a704059ea381d12bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b227fd726a398a704059ea381d12bfd">&#9670;&#160;</a></span>createReifyResultShapesPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::memref::createReifyResultShapesPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="ReifyResultShapes_8cpp_source.html#l00662">662</a> of file <a class="el" href="ReifyResultShapes_8cpp_source.html">ReifyResultShapes.cpp</a>.</p>

</div>
</div>
<a id="a1dc2e9d2c2137c12828dc29a2072e97a" name="a1dc2e9d2c2137c12828dc29a2072e97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc2e9d2c2137c12828dc29a2072e97a">&#9670;&#160;</a></span>createResolveRankedShapeTypeResultDimsPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::memref::createResolveRankedShapeTypeResultDimsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00754">754</a> of file <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html">ResolveShapedTypeResultDims.cpp</a>.</p>

</div>
</div>
<a id="a8ae506b8176b558526016b5ed944c563" name="a8ae506b8176b558526016b5ed944c563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae506b8176b558526016b5ed944c563">&#9670;&#160;</a></span>createResolveRankedShapeTypeResultDimsPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::memref::createResolveRankedShapeTypeResultDimsPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1memref_1_1ResolveRankedShapeTypeResultDimsPassOptions.html">ResolveRankedShapeTypeResultDimsPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00758">758</a> of file <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html">ResolveShapedTypeResultDims.cpp</a>.</p>

</div>
</div>
<a id="ad2e93b11b6632195cdb030f657b04806" name="ad2e93b11b6632195cdb030f657b04806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e93b11b6632195cdb030f657b04806">&#9670;&#160;</a></span>createResolveShapedTypeResultDimsPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::memref::createResolveShapedTypeResultDimsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00851">851</a> of file <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html">ResolveShapedTypeResultDims.cpp</a>.</p>

</div>
</div>
<a id="a4932f0729b38ea3c4b5f2320bb0804a1" name="a4932f0729b38ea3c4b5f2320bb0804a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4932f0729b38ea3c4b5f2320bb0804a1">&#9670;&#160;</a></span>createResolveShapedTypeResultDimsPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::memref::createResolveShapedTypeResultDimsPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1memref_1_1ResolveShapedTypeResultDimsPassOptions.html">ResolveShapedTypeResultDimsPassOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00855">855</a> of file <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html">ResolveShapedTypeResultDims.cpp</a>.</p>

</div>
</div>
<a id="a4147c59f3a9e3d7d845d27760a8b565b" name="a4147c59f3a9e3d7d845d27760a8b565b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4147c59f3a9e3d7d845d27760a8b565b">&#9670;&#160;</a></span>eraseDeadAllocAndStores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::eraseDeadAllocAndStores </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>parentOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Track temporary allocations that are never read from. </p>
<p>If this is the case it means both the allocations and associated stores can be removed. </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00159">159</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00139">resultIsNotRead()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a7bb87b9964b1655bdedbdd1b7656225d" name="a7bb87b9964b1655bdedbdd1b7656225d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb87b9964b1655bdedbdd1b7656225d">&#9670;&#160;</a></span>findDealloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::memref::findDealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>allocValue</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a single dealloc operation for the given allocated value. </p>
<p>Finds the unique dealloc operation (if one exists) for <span class="tt">allocValue</span>.</p>
<p>If there are &gt; 1 deallocates for <span class="tt">allocValue</span>, returns std::nullopt, else returns the single deallocate if it exists or nullptr. </p>

<p class="definition">Definition at line <a class="el" href="MemRefDialect_8cpp_source.html#l00064">64</a> of file <a class="el" href="MemRefDialect_8cpp_source.html">MemRefDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00218">mlir::Value::getUsers()</a>, and <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00217">mlir::hasEffect()</a>.</p>

</div>
</div>
<a id="aa6d03c4cab7fc5604ab8b5d105b31d4b" name="aa6d03c4cab7fc5604ab8b5d105b31d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d03c4cab7fc5604ab8b5d105b31d4b">&#9670;&#160;</a></span>foldMemRefCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::memref::foldMemRefCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>inner</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a common utility used for patterns of the form "someop(memref.cast) -&gt; someop". </p>
<p>This is a common class used for patterns of the form "someop(memrefcast) -&gt; someop".</p>
<p>It folds the source of any memref.cast into the root operation directly. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00045">45</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02053">mlir::affine::AffineDmaStartOp::fold()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02162">mlir::affine::AffineDmaWaitOp::fold()</a>.</p>

</div>
</div>
<a id="a0ec5fa6d6d4ab684b9a5ff4ef7e668b6" name="a0ec5fa6d6d4ab684b9a5ff4ef7e668b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec5fa6d6d4ab684b9a5ff4ef7e668b6">&#9670;&#160;</a></span>getLinearizedMemRefOffsetAndSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html">LinearizedMemRefInfo</a> mlir::memref::getLinearizedMemRefOffsetAndSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>srcBits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dstBits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a <span class="tt">memref</span> with <span class="tt">offset</span> and <span class="tt">sizes</span>, returns the offset and size to use for the linearized <span class="tt">memref</span>, assuming that the strides are computed from a row-major ordering of the sizes;. </p>
<ul>
<li>If the linearization is done for emulating load/stores of element type with bitwidth <span class="tt">srcBits</span> using element type with bitwidth <span class="tt">dstBits</span>, the linearized offset and size are scaled down by <span class="tt">dstBits</span>/<span class="tt">srcBits</span>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00113">113</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00051">getLinearizedMemRefOffsetAndSize()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

</div>
</div>
<a id="a68e822c5ce40c4b3815acd8657d6c8c3" name="a68e822c5ce40c4b3815acd8657d6c8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e822c5ce40c4b3815acd8657d6c8c3">&#9670;&#160;</a></span>getLinearizedMemRefOffsetAndSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html">LinearizedMemRefInfo</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::memref::getLinearizedMemRefOffsetAndSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>srcBits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dstBits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>strides</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00051">51</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00330">mlir::bindSymbolsList()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00959">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00372">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01579">mlir::affine::makeComposedFoldedAffineMax()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FlattenMemRefs_8cpp_source.html#l00051">getFlattenMemrefAndOffset()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00113">getLinearizedMemRefOffsetAndSize()</a>, and <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00140">getLinearizedSrcIndices()</a>.</p>

</div>
</div>
<a id="a5a881164870086f3048d50a9ff9cd702" name="a5a881164870086f3048d50a9ff9cd702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a881164870086f3048d50a9ff9cd702">&#9670;&#160;</a></span>getMixedSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::memref::getMixedSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dimension of the given memref value. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00068">68</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00526">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00036">createInBoundsCond()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l00077">getMixedSizes()</a>.</p>

</div>
</div>
<a id="ab0c13e32e47a301b4ccac4b27404de51" name="ab0c13e32e47a301b4ccac4b27404de51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c13e32e47a301b4ccac4b27404de51">&#9670;&#160;</a></span>getMixedSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::memref::getMixedSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dimensions of the given memref value. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00077">77</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefOps_8cpp_source.html#l00068">getMixedSize()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00944">HopperBuilder::buildGlobalMemRefDescriptor()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00973">HopperBuilder::buildTmaAsyncLoad()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00333">mlir::vector::createReadOrMaskedRead()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00298">mlir::vector::getMixedSizesXfer()</a>, and <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00395">rankReducingSubviewDroppingUnitDims()</a>.</p>

</div>
</div>
<a id="a593c42d0eefa6f2456d3ed618384de85" name="a593c42d0eefa6f2456d3ed618384de85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593c42d0eefa6f2456d3ed618384de85">&#9670;&#160;</a></span>getTensorTypeFromMemRefType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::memref::getTensorTypeFromMemRefType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an unranked/ranked tensor type for the given unranked/ranked memref type. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00060">60</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l01577">parseGlobalMemrefOpTypeAndInitialValue()</a>.</p>

</div>
</div>
<a id="a395ef51018e96d34a3f91f08896513a4" name="a395ef51018e96d34a3f91f08896513a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395ef51018e96d34a3f91f08896513a4">&#9670;&#160;</a></span>isSameViewOrTrivialAlias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::memref::isSameViewOrTrivialAlias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a92e239e8ecf7770f9cbdc4cdb0ccd0f6">MemrefValue</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a92e239e8ecf7770f9cbdc4cdb0ccd0f6">MemrefValue</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two (memref) values are the same or statically known to alias the same region of memory. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html#l00111">111</a> of file <a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html">MemRefUtils.h</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="MemRefUtils_8cpp_source.html#l00196">skipFullyAliasingOperations()</a>.</p>

</div>
</div>
<a id="a6dd556718fd72c7099dc94f99d30ccd1" name="a6dd556718fd72c7099dc94f99d30ccd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd556718fd72c7099dc94f99d30ccd1">&#9670;&#160;</a></span>isStaticShapeAndContiguousRowMajor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::memref::isStaticShapeAndContiguousRowMajor </td>
          <td>(</td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true, if the memref type has static shapes and represents a contiguous chunk of memory. </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00023">23</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

</div>
</div>
<a id="ae4ffe31231e4fd88511f0d2446b4218d" name="ae4ffe31231e4fd88511f0d2446b4218d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ffe31231e4fd88511f0d2446b4218d">&#9670;&#160;</a></span>multiBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; memref::AllocOp &gt; mlir::memref::multiBuffer </td>
          <td>(</td>
          <td class="paramtype">memref::AllocOp</td>          <td class="paramname"><span class="paramname"><em>allocOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>multiplier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>skipOverrideAnalysis</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call into <span class="tt">multiBuffer</span> with locally constructed <a class="el" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ...">IRRewriter</a>. </p>

<p class="definition">Definition at line <a class="el" href="MultiBuffer_8cpp_source.html#l00228">228</a> of file <a class="el" href="MultiBuffer_8cpp_source.html">MultiBuffer.cpp</a>.</p>

<p class="reference">References <a class="el" href="MultiBuffer_8cpp_source.html#l00082">multiBuffer()</a>.</p>

</div>
</div>
<a id="a637539fbb3044706f07e949413eac30d" name="a637539fbb3044706f07e949413eac30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637539fbb3044706f07e949413eac30d">&#9670;&#160;</a></span>multiBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; memref::AllocOp &gt; mlir::memref::multiBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::AllocOp</td>          <td class="paramname"><span class="paramname"><em>allocOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>multiplier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>skipOverrideAnalysis</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transformation to do multi-buffering/array expansion to remove dependencies on the temporary allocation between consecutive loop iterations. </p>
<p>It returns the new allocation if the original allocation was multi-buffered and returns failure() otherwise. When <span class="tt">skipOverrideAnalysis</span>, the pass will apply the transformation without checking thwt the buffer is overrided at the beginning of each iteration. This implies that user knows that there is no data carried across loop iterations. Example: </p><div class="fragment"><div class="line">%0 = <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>.alloc() : <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;4x128xf32&gt;</a></div>
<div class="line"><a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for %iv = %c1 to %c1024 step %c3 {</div>
<div class="line">  <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>.copy %1, %0 : <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;4x128xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;4x128xf32&gt;</a></div>
<div class="line">  <span class="stringliteral">&quot;some_use&quot;</span>(%0) : (<a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>&lt;4x128xf32&gt;) -&gt; ()</div>
<div class="line">}</div>
<div class="ttc" id="anamespacemlir_1_1memref_html"><div class="ttname"><a href="namespacemlir_1_1memref.html">mlir::memref</a></div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Passes_8h_source.html#l00026">Passes.h:26</a></div></div>
<div class="ttc" id="anamespacemlir_1_1scf_html"><div class="ttname"><a href="namespacemlir_1_1scf.html">mlir::scf</a></div><div class="ttdef"><b>Definition</b> <a href="SCFToGPU_8h_source.html#l00024">SCFToGPU.h:24</a></div></div>
</div><!-- fragment --><p> into: </p><div class="fragment"><div class="line">%0 = <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>.alloc() : <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;5x4x128xf32&gt;</a></div>
<div class="line"><a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for %iv = %c1 to %c1024 step %c3 {</div>
<div class="line">  %s = <a class="code hl_namespace" href="namespacemlir_1_1arith.html">arith</a>.subi %iv, %c1 : <a class="code hl_namespace" href="namespacemlir_1_1index.html">index</a></div>
<div class="line">  %d = <a class="code hl_namespace" href="namespacemlir_1_1arith.html">arith</a>.divsi %s, %c3 : <a class="code hl_namespace" href="namespacemlir_1_1index.html">index</a></div>
<div class="line">  %i = <a class="code hl_namespace" href="namespacemlir_1_1arith.html">arith</a>.remsi %d, %c5 : <a class="code hl_namespace" href="namespacemlir_1_1index.html">index</a></div>
<div class="line">  %sv = <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>.subview %0[%i, 0, 0] [1, 4, 128] [1, 1, 1] :</div>
<div class="line">    <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;5x4x128xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;4x128xf32, strided&lt;[128, 1], offset: ?&gt;</a>&gt;</div>
<div class="line">  <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>.copy %1, %sv : <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;4x128xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>&lt;4x128xf32, strided&lt;...&gt;&gt;</div>
<div class="line">  <span class="stringliteral">&quot;some_use&quot;</span>(%sv) : (<a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>&lt;4x128xf32, strided&lt;...&gt;) -&gt; ()</div>
<div class="line">}</div>
<div class="ttc" id="anamespacemlir_1_1arith_html"><div class="ttname"><a href="namespacemlir_1_1arith.html">mlir::arith</a></div><div class="ttdef"><b>Definition</b> <a href="ArithCommon_2AttrToLLVMConverter_8h_source.html#l00020">AttrToLLVMConverter.h:20</a></div></div>
<div class="ttc" id="anamespacemlir_1_1index_html"><div class="ttname"><a href="namespacemlir_1_1index.html">mlir::index</a></div><div class="ttdef"><b>Definition</b> <a href="IndexToLLVM_8h_source.html#l00023">IndexToLLVM.h:23</a></div></div>
</div><!-- fragment --> <p>Make sure there is no loop-carried dependency on the allocation.</p>

<p class="definition">Definition at line <a class="el" href="MultiBuffer_8cpp_source.html#l00082">82</a> of file <a class="el" href="MultiBuffer_8cpp_source.html">MultiBuffer.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00029">DBGS</a>, <a class="el" href="Dominance_8h_source.html#l00158">mlir::DominanceInfo::dominates()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00873">mlir::Operation::getUsers()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01416">mlir::affine::makeComposedAffineApply()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00033">overrideBuffer()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00044">replaceUsesAndPropagateType()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00203">mlir::MemRefType::Builder::setLayout()</a>, and <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00193">mlir::MemRefType::Builder::setShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MultiBuffer_8cpp_source.html#l00228">multiBuffer()</a>.</p>

</div>
</div>
<a id="af6c5916519d8d818c95097ef22e882ee" name="af6c5916519d8d818c95097ef22e882ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c5916519d8d818c95097ef22e882ee">&#9670;&#160;</a></span>populateComposeSubViewPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::populateComposeSubViewPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ComposeSubView_8cpp_source.html#l00139">139</a> of file <a class="el" href="ComposeSubView_8cpp_source.html">ComposeSubView.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="aa72dbb57f66b3381ca288a092d376802" name="aa72dbb57f66b3381ca288a092d376802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72dbb57f66b3381ca288a092d376802">&#9670;&#160;</a></span>populateExpandOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::populateExpandOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects a set of patterns to rewrite ops within the memref dialect. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html#l00107">107</a> of file <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html">ExpandOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html#l00088">createExpandOpsPass()</a>.</p>

</div>
</div>
<a id="ad3b5486ce1776bc5afddb8ec9cc97f2a" name="ad3b5486ce1776bc5afddb8ec9cc97f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b5486ce1776bc5afddb8ec9cc97f2a">&#9670;&#160;</a></span>populateExpandReallocPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::populateExpandReallocPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>emitDeallocs</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for expanding <span class="tt">memref.realloc</span> operations. </p>

<p class="definition">Definition at line <a class="el" href="ExpandRealloc_8cpp_source.html#l00168">168</a> of file <a class="el" href="ExpandRealloc_8cpp_source.html">ExpandRealloc.cpp</a>.</p>

</div>
</div>
<a id="ae0a91532e484d6485dc36756f1b1bace" name="ae0a91532e484d6485dc36756f1b1bace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a91532e484d6485dc36756f1b1bace">&#9670;&#160;</a></span>populateExpandStridedMetadataPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::populateExpandStridedMetadataPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for expanding memref operations that modify the metadata (sizes, offset, strides) of a memref into easier to analyze constructs. </p>

<p class="definition">Definition at line <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l01116">1116</a> of file <a class="el" href="ExpandStridedMetadata_8cpp_source.html">ExpandStridedMetadata.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ad05667d80ad6b23301f24c722a4dbb28" name="ad05667d80ad6b23301f24c722a4dbb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05667d80ad6b23301f24c722a4dbb28">&#9670;&#160;</a></span>populateExtractAddressComputationsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::populateExtractAddressComputationsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for extracting address computations from the instructions with memory accesses such that these memory accesses use only a base pointer. </p>
<p>For instance, </p><div class="fragment"><div class="line">memref.load %base[%off0, ...]</div>
</div><!-- fragment --><p>Will be rewritten in: </p><div class="fragment"><div class="line">%new_base = memref.subview %base[%off0,...][1,...][1,...]</div>
<div class="line">memref.load %new_base[%c0,...]</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ExtractAddressComputations_8cpp_source.html#l00282">282</a> of file <a class="el" href="ExtractAddressComputations_8cpp_source.html">ExtractAddressComputations.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a8543ccab5ef166a2dab4da47e0ca3579" name="a8543ccab5ef166a2dab4da47e0ca3579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8543ccab5ef166a2dab4da47e0ca3579">&#9670;&#160;</a></span>populateFlattenMemrefOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::populateFlattenMemrefOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FlattenMemRefs_8cpp_source.html#l00285">285</a> of file <a class="el" href="FlattenMemRefs_8cpp_source.html">FlattenMemRefs.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="FlattenMemRefs_8cpp_source.html#l00294">mlir::memref::impl::FlattenMemrefsPassBase&lt; DerivedT &gt;::getArgumentName()</a>.</p>

</div>
</div>
<a id="a7d7d21ec8b60f6c5b3c94a28513f155e" name="a7d7d21ec8b60f6c5b3c94a28513f155e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7d21ec8b60f6c5b3c94a28513f155e">&#9670;&#160;</a></span>populateFlattenMemrefsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::populateFlattenMemrefsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FlattenMemRefs_8cpp_source.html#l00293">293</a> of file <a class="el" href="FlattenMemRefs_8cpp_source.html">FlattenMemRefs.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="aa16b0e5dafcfb80dac42280375ca65a9" name="aa16b0e5dafcfb80dac42280375ca65a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16b0e5dafcfb80dac42280375ca65a9">&#9670;&#160;</a></span>populateFlattenVectorOpsOnMemrefPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::populateFlattenVectorOpsOnMemrefPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns for flattening multi-dimensional memref operations into one-dimensional memref operations. </p>

<p class="definition">Definition at line <a class="el" href="FlattenMemRefs_8cpp_source.html#l00274">274</a> of file <a class="el" href="FlattenMemRefs_8cpp_source.html">FlattenMemRefs.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="FlattenMemRefs_8cpp_source.html#l00294">mlir::memref::impl::FlattenMemrefsPassBase&lt; DerivedT &gt;::getArgumentName()</a>.</p>

</div>
</div>
<a id="a0b92ea4d1067ac456aa6899baa8512a9" name="a0b92ea4d1067ac456aa6899baa8512a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b92ea4d1067ac456aa6899baa8512a9">&#9670;&#160;</a></span>populateFoldMemRefAliasOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::populateFoldMemRefAliasOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for folding memref aliasing ops into consumer load/store ops into <span class="tt">patterns</span>. </p>

<p class="definition">Definition at line <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00671">671</a> of file <a class="el" href="FoldMemRefAliasOps_8cpp_source.html">FoldMemRefAliasOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a5416c0ea0d3dcf0c0ce09270c16bb4c7" name="a5416c0ea0d3dcf0c0ce09270c16bb4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5416c0ea0d3dcf0c0ce09270c16bb4c7">&#9670;&#160;</a></span>populateMemRefNarrowTypeEmulationConversions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::populateMemRefNarrowTypeEmulationConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1arith_1_1NarrowTypeEmulationConverter.html">arith::NarrowTypeEmulationConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends type conversions for emulating memref operations over narrow types with ops over wider types. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00635">635</a> of file <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html">EmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00122">mlir::Type::getIntOrFloatBitWidth()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00617">getLinearizedShape()</a>, <a class="el" href="NarrowTypeEmulationConverter_8h_source.html#l00024">mlir::arith::NarrowTypeEmulationConverter::getLoadStoreBitwidth()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00056">mlir::Type::isInteger()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00116">mlir::Type::isIntOrFloat()</a>.</p>

</div>
</div>
<a id="ab6d12c8c0a0feb1452a1340adca2b62d" name="ab6d12c8c0a0feb1452a1340adca2b62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d12c8c0a0feb1452a1340adca2b62d">&#9670;&#160;</a></span>populateMemRefNarrowTypeEmulationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::populateMemRefNarrowTypeEmulationPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1arith_1_1NarrowTypeEmulationConverter.html">arith::NarrowTypeEmulationConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for emulating memref operations over narrow types with ops over wider types. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00602">602</a> of file <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html">EmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, and <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l01137">populateResolveExtractStridedMetadataPatterns()</a>.</p>

</div>
</div>
<a id="a6c0e1bd45d93d6da7bf22b61465492b9" name="a6c0e1bd45d93d6da7bf22b61465492b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0e1bd45d93d6da7bf22b61465492b9">&#9670;&#160;</a></span>populateMemRefWideIntEmulationConversions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::populateMemRefWideIntEmulationConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1arith_1_1WideIntEmulationConverter.html">arith::WideIntEmulationConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends type conversions for emulating wide integer memref operations with ops over narrowe integer types. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html#l00148">148</a> of file <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html">EmulateWideInt.cpp</a>.</p>

<p class="reference">References <a class="el" href="WideIntEmulationConverter_8h_source.html#l00027">mlir::arith::WideIntEmulationConverter::getMaxTargetIntBitWidth()</a>.</p>

</div>
</div>
<a id="a0f7d0c93988c246b870a8f5f851f4eb3" name="a0f7d0c93988c246b870a8f5f851f4eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7d0c93988c246b870a8f5f851f4eb3">&#9670;&#160;</a></span>populateMemRefWideIntEmulationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::populateMemRefWideIntEmulationPatterns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1arith_1_1WideIntEmulationConverter.html">arith::WideIntEmulationConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for emulating wide integer memref operations with ops over narrower integer types. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html#l00140">140</a> of file <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html">EmulateWideInt.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a933e3cb75cf93999afc61710776fea07" name="a933e3cb75cf93999afc61710776fea07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933e3cb75cf93999afc61710776fea07">&#9670;&#160;</a></span>populateResolveExtractStridedMetadataPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::populateResolveExtractStridedMetadataPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for resolving <span class="tt">memref.extract_strided_metadata</span> into <span class="tt">memref.extract_strided_metadata</span> of its source. </p>

<p class="definition">Definition at line <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l01137">1137</a> of file <a class="el" href="ExpandStridedMetadata_8cpp_source.html">ExpandStridedMetadata.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00602">populateMemRefNarrowTypeEmulationPatterns()</a>.</p>

</div>
</div>
<a id="a313c2f5f760c17a276fac9bb108951c9" name="a313c2f5f760c17a276fac9bb108951c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313c2f5f760c17a276fac9bb108951c9">&#9670;&#160;</a></span>populateResolveRankedShapedTypeResultDimsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::populateResolveRankedShapedTypeResultDimsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns that resolve <span class="tt">memref.dim</span> operations with values that are defined by operations that implement the <span class="tt">ReifyRankedShapedTypeOpInterface</span>, in terms of shapes of its input operands. </p>

<p class="definition">Definition at line <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00181">181</a> of file <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html">ResolveShapedTypeResultDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="DropUnitDims_8cpp_source.html#l00803">populateFoldUnitExtentDimsViaReshapesPatterns()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00823">populateFoldUnitExtentDimsViaSlicesPatterns()</a>.</p>

</div>
</div>
<a id="aaf97a8143d457b645153d6f40e6aed84" name="aaf97a8143d457b645153d6f40e6aed84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf97a8143d457b645153d6f40e6aed84">&#9670;&#160;</a></span>populateResolveShapedTypeResultDimsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::populateResolveShapedTypeResultDimsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns that resolve <span class="tt">memref.dim</span> operations with values that are defined by operations that implement the <span class="tt">InferShapedTypeOpInterface</span>, in terms of shapes of its input operands. </p>

<p class="definition">Definition at line <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00188">188</a> of file <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html">ResolveShapedTypeResultDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="DropUnitDims_8cpp_source.html#l00803">populateFoldUnitExtentDimsViaReshapesPatterns()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00823">populateFoldUnitExtentDimsViaSlicesPatterns()</a>.</p>

</div>
</div>
<a id="a1883b3342d764a07311e3f8a79d8dd1e" name="a1883b3342d764a07311e3f8a79d8dd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1883b3342d764a07311e3f8a79d8dd1e">&#9670;&#160;</a></span>registerAllocationOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerAllocationOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AllocationOpInterfaceImpl_8cpp_source.html#l00062">62</a> of file <a class="el" href="AllocationOpInterfaceImpl_8cpp_source.html">AllocationOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a3091713b0337b82187ff9f4ab2f25a5a" name="a3091713b0337b82187ff9f4ab2f25a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3091713b0337b82187ff9f4ab2f25a5a">&#9670;&#160;</a></span>registerBufferViewFlowOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerBufferViewFlowOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2BufferViewFlowOpInterfaceImpl_8cpp_source.html#l00043">43</a> of file <a class="el" href="MemRef_2Transforms_2BufferViewFlowOpInterfaceImpl_8cpp_source.html">BufferViewFlowOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a0b7380139903012a6df52390cb1d153d" name="a0b7380139903012a6df52390cb1d153d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7380139903012a6df52390cb1d153d">&#9670;&#160;</a></span>registerExpandOpsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerExpandOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l00879">879</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="abc9cf2e3d61ef302027144d770ba2eb6" name="abc9cf2e3d61ef302027144d770ba2eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9cf2e3d61ef302027144d770ba2eb6">&#9670;&#160;</a></span>registerExpandOpsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerExpandOpsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l00886">886</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a21d3f69da9b785ceb6184d6a08418795" name="a21d3f69da9b785ceb6184d6a08418795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d3f69da9b785ceb6184d6a08418795">&#9670;&#160;</a></span>registerExpandReallocPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerExpandReallocPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l00900">900</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a739f63ce1ee4315030d1198a529d58ae" name="a739f63ce1ee4315030d1198a529d58ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739f63ce1ee4315030d1198a529d58ae">&#9670;&#160;</a></span>registerExpandReallocPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerExpandReallocPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l00907">907</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a1b064c2145bd2da900aa20f39ee524d8" name="a1b064c2145bd2da900aa20f39ee524d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b064c2145bd2da900aa20f39ee524d8">&#9670;&#160;</a></span>registerExpandStridedMetadataPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerExpandStridedMetadataPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l00921">921</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ab825c1cecd9231e596c14d3820a5067f" name="ab825c1cecd9231e596c14d3820a5067f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab825c1cecd9231e596c14d3820a5067f">&#9670;&#160;</a></span>registerExpandStridedMetadataPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerExpandStridedMetadataPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l00928">928</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a5354eca84b151ada55e752c0c5cfbf4c" name="a5354eca84b151ada55e752c0c5cfbf4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5354eca84b151ada55e752c0c5cfbf4c">&#9670;&#160;</a></span>registerFlattenMemrefsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerFlattenMemrefsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l00942">942</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a46b157af8897d28b96e4169dc8d55279" name="a46b157af8897d28b96e4169dc8d55279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b157af8897d28b96e4169dc8d55279">&#9670;&#160;</a></span>registerFlattenMemrefsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerFlattenMemrefsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l00949">949</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a57cfa26220dd26c9426a52d3c92f106f" name="a57cfa26220dd26c9426a52d3c92f106f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cfa26220dd26c9426a52d3c92f106f">&#9670;&#160;</a></span>registerFoldMemRefAliasOpsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerFoldMemRefAliasOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l00963">963</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ac4e1101ae27c4b2223c441236a0d40ed" name="ac4e1101ae27c4b2223c441236a0d40ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e1101ae27c4b2223c441236a0d40ed">&#9670;&#160;</a></span>registerFoldMemRefAliasOpsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerFoldMemRefAliasOpsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l00970">970</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a08647ff099a98052f95e4caff149a2f9" name="a08647ff099a98052f95e4caff149a2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08647ff099a98052f95e4caff149a2f9">&#9670;&#160;</a></span>registerMemorySlotExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerMemorySlotExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefMemorySlot_8cpp_source.html#l00332">332</a> of file <a class="el" href="MemRefMemorySlot_8cpp_source.html">MemRefMemorySlot.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="aff2fe6f317333418b5f2382f6733cb93" name="aff2fe6f317333418b5f2382f6733cb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2fe6f317333418b5f2382f6733cb93">&#9670;&#160;</a></span>registerMemRefEmulateWideInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerMemRefEmulateWideInt </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l00984">984</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="af098529bf685620f47d5e2b8b8aa31b0" name="af098529bf685620f47d5e2b8b8aa31b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af098529bf685620f47d5e2b8b8aa31b0">&#9670;&#160;</a></span>registerMemRefEmulateWideIntPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerMemRefEmulateWideIntPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l00991">991</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a3d338b34b45d19cefd8d797849c325ff" name="a3d338b34b45d19cefd8d797849c325ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d338b34b45d19cefd8d797849c325ff">&#9670;&#160;</a></span>registerMemRefPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerMemRefPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l01089">1089</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllPasses_8cpp_source.html#l00059">mlir::registerAllPasses()</a>.</p>

</div>
</div>
<a id="a1667c8bc6a8917684c1b2decd0dfe066" name="a1667c8bc6a8917684c1b2decd0dfe066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1667c8bc6a8917684c1b2decd0dfe066">&#9670;&#160;</a></span>registerNormalizeMemRefsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerNormalizeMemRefsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l01005">1005</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="adc09f9b2fb6c03884efd9a6053d2ddd4" name="adc09f9b2fb6c03884efd9a6053d2ddd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc09f9b2fb6c03884efd9a6053d2ddd4">&#9670;&#160;</a></span>registerNormalizeMemRefsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerNormalizeMemRefsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l01012">1012</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a7e0287e46cb7fac2d2119050c55666a6" name="a7e0287e46cb7fac2d2119050c55666a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0287e46cb7fac2d2119050c55666a6">&#9670;&#160;</a></span>registerReifyResultShapesPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerReifyResultShapesPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l01026">1026</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a2d5eafa4a75e3f46e9a1d3f80ed0a46a" name="a2d5eafa4a75e3f46e9a1d3f80ed0a46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5eafa4a75e3f46e9a1d3f80ed0a46a">&#9670;&#160;</a></span>registerReifyResultShapesPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerReifyResultShapesPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l01033">1033</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a8bca34df84259a7968251cf756127c18" name="a8bca34df84259a7968251cf756127c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bca34df84259a7968251cf756127c18">&#9670;&#160;</a></span>registerResolveRankedShapeTypeResultDimsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerResolveRankedShapeTypeResultDimsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l01047">1047</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aedfd4b331cf2febf6eecc78c0465c803" name="aedfd4b331cf2febf6eecc78c0465c803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfd4b331cf2febf6eecc78c0465c803">&#9670;&#160;</a></span>registerResolveRankedShapeTypeResultDimsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerResolveRankedShapeTypeResultDimsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l01054">1054</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a7cfeeb0c3bf931bc1c4af941917b90c0" name="a7cfeeb0c3bf931bc1c4af941917b90c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfeeb0c3bf931bc1c4af941917b90c0">&#9670;&#160;</a></span>registerResolveShapedTypeResultDimsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerResolveShapedTypeResultDimsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l01068">1068</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a1c53d20166600950eb0270c6995b9fa5" name="a1c53d20166600950eb0270c6995b9fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c53d20166600950eb0270c6995b9fa5">&#9670;&#160;</a></span>registerResolveShapedTypeResultDimsPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerResolveShapedTypeResultDimsPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html#l01075">1075</a> of file <a class="el" href="Dialect_2MemRef_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ad7fa7b00c1ccb23e5f4a528377dd4ee9" name="ad7fa7b00c1ccb23e5f4a528377dd4ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fa7b00c1ccb23e5f4a528377dd4ee9">&#9670;&#160;</a></span>registerRuntimeVerifiableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerRuntimeVerifiableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2RuntimeOpVerification_8cpp_source.html#l00403">403</a> of file <a class="el" href="MemRef_2Transforms_2RuntimeOpVerification_8cpp_source.html">RuntimeOpVerification.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ae1adc6a8d5aefc17867d0815b586c3b9" name="ae1adc6a8d5aefc17867d0815b586c3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1adc6a8d5aefc17867d0815b586c3b9">&#9670;&#160;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefTransformOps_8cpp_source.html#l00334">334</a> of file <a class="el" href="MemRefTransformOps_8cpp_source.html">MemRefTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00222">mlir::DialectRegistry::addExtensions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="ac2b49994f10e98cb119abfb38f23c0c3" name="ac2b49994f10e98cb119abfb38f23c0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b49994f10e98cb119abfb38f23c0c3">&#9670;&#160;</a></span>registerValueBoundsOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::memref::registerValueBoundsOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRef_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00149">149</a> of file <a class="el" href="MemRef_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a390d7b6bfa73372eec5b1d2cd2bf937b" name="a390d7b6bfa73372eec5b1d2cd2bf937b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390d7b6bfa73372eec5b1d2cd2bf937b">&#9670;&#160;</a></span>replaceWithIndependentOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::memref::replaceWithIndependentOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::AllocaOp</td>          <td class="paramname"><span class="paramname"><em>allocaOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>independencies</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a new memref::AllocaOp whose dynamic sizes are independent of all given independencies. </p>
<p>If the op is already independent of all independencies, the same AllocaOp result is returned.</p>
<p>The original AllocaOp is replaced with the new one, wrapped in a SubviewOp. The result type of the replacement is different from the original allocation type: it has the same shape, but a different layout map. This function updates all users that do not have a memref result or memref region block argument, and some frequently used memref dialect ops (such as memref.subview). It does not update other uses such as the init_arg of an scf.for op. Such uses are wrapped in unrealized_conversion_cast.</p>
<p>Failure indicates the no suitable upper bound for the dynamic sizes could be found.</p>
<p>Example (make independent of iv): </p><div class="fragment"><div class="line"><a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for %iv = %c0 to %sz step %c1 {</div>
<div class="line">  %0 = <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>.alloca(%iv) : <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;?xf32&gt;</a></div>
<div class="line">  %1 = <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>.subview %0[0][5][1] : ...</div>
<div class="line">  <a class="code hl_namespace" href="namespacemlir_1_1linalg.html">linalg</a>.generic outs(%1 : ...) ...</div>
<div class="line">  %2 = <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for ... iter_arg(%arg0 = %0) ...</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="anamespacemlir_1_1linalg_html"><div class="ttname"><a href="namespacemlir_1_1linalg.html">mlir::linalg</a></div><div class="ttdef"><b>Definition</b> <a href="LinalgToStandard_8h_source.html#l00024">LinalgToStandard.h:24</a></div></div>
</div><!-- fragment --><p>The above IR is rewritten to:</p>
<div class="fragment"><div class="line"><a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for %iv = %c0 to %sz step %c1 {</div>
<div class="line">  %0 = <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>.alloca(%sz - 1) : <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;?xf32&gt;</a></div>
<div class="line">  %0_subview = <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>.subview %0[0][%iv][1]</div>
<div class="line">      : <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;?xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;?xf32, #map&gt;</a></div>
<div class="line">  %1 = <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>.subview %0_subview[0][5][1] : ...</div>
<div class="line">  <a class="code hl_namespace" href="namespacemlir_1_1linalg.html">linalg</a>.generic outs(%1 : ...) ...</div>
<div class="line">  %cast = unrealized_conversion_cast %0_subview</div>
<div class="line">      : <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;?xf32, #map&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;?xf32&gt;</a></div>
<div class="line">  %2 = <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for ... iter_arg(%arg0 = %cast) ...</div>
<div class="line"> ...</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00166">166</a> of file <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html">IndependenceTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="#ad18abceb07a035165626e5d419cfbd02">buildIndependentOp()</a>, <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00096">replaceAndPropagateMemRefType()</a>, and <a class="el" href="LoopUtils_8cpp.html#af34d730a7920f1ae277f8c166146132d">replacement()</a>.</p>

</div>
</div>
<a id="a505b0a7d0ecf056721f2be2220c97b39" name="a505b0a7d0ecf056721f2be2220c97b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505b0a7d0ecf056721f2be2220c97b39">&#9670;&#160;</a></span>resolveSourceIndicesCollapseShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::memref::resolveSourceIndicesCollapseShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::CollapseShapeOp</td>          <td class="paramname"><span class="paramname"><em>collapseShapeOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceIndices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the 'indices' of a load/store operation where the memref is a result of a collapse_shape op, returns the indices w.r.t to the source memref of the collapse_shape op. </p>
<p>For example</p>
<p>%0 = ... : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;2x6x42xf32&gt;</a> %1 = memref.collapse_shape %0 [[0, 1], [2]] : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;2x6x42xf32&gt;</a> into <a class="el" href="namespacemlir_1_1memref.html">memref&lt;12x42xf32&gt;</a> %2 = load %1[i1, i2] : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;12x42xf32&gt;</a></p>
<p>could be folded into</p>
<p>%2 = load %0[i1 / 6, i1 % 6, i2] : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;2x6x42xf32&gt;</a> </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00253">253</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00097">mlir::delinearize()</a>, <a class="el" href="Builders_8cpp_source.html#l00378">mlir::Builder::getConstantAffineMap()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldMemRefsOps_8cpp_source.html#l00031">mlir::amdgpu::foldMemrefViewOp()</a>.</p>

</div>
</div>
<a id="ad94d07e58f1f9fe168739a6ef8f495a6" name="ad94d07e58f1f9fe168739a6ef8f495a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94d07e58f1f9fe168739a6ef8f495a6">&#9670;&#160;</a></span>resolveSourceIndicesExpandShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::memref::resolveSourceIndicesExpandShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::ExpandShapeOp</td>          <td class="paramname"><span class="paramname"><em>expandShapeOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceIndices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>startsInbounds</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the 'indices' of a load/store operation where the memref is a result of a expand_shape op, returns the indices w.r.t to the source memref of the expand_shape op. </p>
<p>For example</p>
<p>%0 = ... : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;12x42xf32&gt;</a> %1 = memref.expand_shape %0 [[0, 1], [2]] : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;12x42xf32&gt;</a> into <a class="el" href="namespacemlir_1_1memref.html">memref&lt;2x6x42xf32&gt;</a> %2 = load %1[i1, i2, i3] : memref&lt;2x6x42xf32</p>
<p>could be folded into</p>
<p>%2 = load %0[6 * i1 + i2, i3] : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;12x42xf32&gt;</a> </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00226">226</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldMemRefsOps_8cpp_source.html#l00031">mlir::amdgpu::foldMemrefViewOp()</a>.</p>

</div>
</div>
<a id="a1c2b990b3c696031cd589f1859416013" name="a1c2b990b3c696031cd589f1859416013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2b990b3c696031cd589f1859416013">&#9670;&#160;</a></span>resultIsNotRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::memref::resultIsNotRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>uses</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all the uses of op are not read/load. </p>
<p>There can be view-like-op users as long as all its users are also StoreOp/transfer_write. If return true it also fills out the uses, if it returns false uses is unchanged. </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00139">139</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00674">mlir::Operation::getNumRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00846">mlir::Operation::getUses()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00217">mlir::hasEffect()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00757">mlir::Operation::mightHaveTrait()</a>, and <a class="el" href="MemRefUtils_8cpp_source.html#l00139">resultIsNotRead()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefUtils_8cpp_source.html#l00159">eraseDeadAllocAndStores()</a>, and <a class="el" href="MemRefUtils_8cpp_source.html#l00139">resultIsNotRead()</a>.</p>

</div>
</div>
<a id="a3122c6f825e6d5a2372e58e7bd6eb2fc" name="a3122c6f825e6d5a2372e58e7bd6eb2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3122c6f825e6d5a2372e58e7bd6eb2fc">&#9670;&#160;</a></span>skipFullyAliasingOperations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a92e239e8ecf7770f9cbdc4cdb0ccd0f6">MemrefValue</a> mlir::memref::skipFullyAliasingOperations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a92e239e8ecf7770f9cbdc4cdb0ccd0f6">MemrefValue</a></td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk up the source chain until an operation that changes/defines the view of memory is found (i.e. </p>
<p>skip operations that alias the entire view). </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00196">196</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2MemRef_2Utils_2MemRefUtils_8h_source.html#l00111">isSameViewOrTrivialAlias()</a>.</p>

</div>
</div>
<a id="a6dd2524604ba8a298b44470f68eb5076" name="a6dd2524604ba8a298b44470f68eb5076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd2524604ba8a298b44470f68eb5076">&#9670;&#160;</a></span>skipViewLikeOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a92e239e8ecf7770f9cbdc4cdb0ccd0f6">MemrefValue</a> mlir::memref::skipViewLikeOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a92e239e8ecf7770f9cbdc4cdb0ccd0f6">MemrefValue</a></td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk up the source chain until we find an operation that is not a view of the source memref (i.e. </p>
<p>implements ViewLikeOpInterface). </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00213">213</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
