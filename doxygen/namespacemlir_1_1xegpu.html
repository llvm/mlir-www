<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::xegpu Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1xegpu.html">xegpu</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::xegpu Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1xegpu_1_1targetinfo"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu_1_1targetinfo.html">targetinfo</a></td></tr>
<tr class="memdesc:namespacemlir_1_1xegpu_1_1targetinfo"><td class="mdescLeft">&#160;</td><td class="mdescRight">HW dependent constants. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1xegpu_1_1UnrollOptions.html">UnrollOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to control the XeGPU unrolling.  <a href="structmlir_1_1xegpu_1_1UnrollOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1xegpu_1_1FoldConvertLayoutOp.html">FoldConvertLayoutOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a75f0c70660bc13821493fc7c5b9ffa28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a75f0c70660bc13821493fc7c5b9ffa28">populateXeGPUFoldAliasOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a75f0c70660bc13821493fc7c5b9ffa28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for folding aliasing ops into XeGPU ops into <code>patterns</code>.  <a href="namespacemlir_1_1xegpu.html#a75f0c70660bc13821493fc7c5b9ffa28">More...</a><br /></td></tr>
<tr class="separator:a75f0c70660bc13821493fc7c5b9ffa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39a7d1520005ea372b9b513a1d7b442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#af39a7d1520005ea372b9b513a1d7b442">populateXeGPUSubgroupDistributePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:af39a7d1520005ea372b9b513a1d7b442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for XeGPU SIMT distribution into <code>patterns</code>.  <a href="namespacemlir_1_1xegpu.html#af39a7d1520005ea372b9b513a1d7b442">More...</a><br /></td></tr>
<tr class="separator:af39a7d1520005ea372b9b513a1d7b442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe602b848e4d20950d3b63b62be81db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#aafe602b848e4d20950d3b63b62be81db">populateXeGPUWgToSgDistributePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="separator:aafe602b848e4d20950d3b63b62be81db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6a1b5c8f4c32cbe9c5648017a727b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a2a6a1b5c8f4c32cbe9c5648017a727b0">populateXeGPUUnrollPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="structmlir_1_1xegpu_1_1UnrollOptions.html">UnrollOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a2a6a1b5c8f4c32cbe9c5648017a727b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to unroll xegpu operations to a smaller shapes.  <a href="namespacemlir_1_1xegpu.html#a2a6a1b5c8f4c32cbe9c5648017a727b0">More...</a><br /></td></tr>
<tr class="separator:a2a6a1b5c8f4c32cbe9c5648017a727b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeae20690a58f5264daf481dbbeea718"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#aeeae20690a58f5264daf481dbbeea718">flattenValues</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> &gt; values)</td></tr>
<tr class="memdesc:aeeae20690a58f5264daf481dbbeea718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten a set of <a class="el" href="classmlir_1_1ValueRange.html" title="This class provides an abstraction over the different types of ranges over Values.">ValueRange</a> into a single <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value&gt;</a>  <a href="namespacemlir_1_1xegpu.html#aeeae20690a58f5264daf481dbbeea718">More...</a><br /></td></tr>
<tr class="separator:aeeae20690a58f5264daf481dbbeea718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95421174e54b5dfc990dfb4357fa13c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; VectorType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#af95421174e54b5dfc990dfb4357fa13c">getDistributedVectorType</a> (xegpu::TensorDescType tdescTy)</td></tr>
<tr class="memdesc:af95421174e54b5dfc990dfb4357fa13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If tensor descriptor has a layout attribute it is used in SIMT mode.  <a href="namespacemlir_1_1xegpu.html#af95421174e54b5dfc990dfb4357fa13c">More...</a><br /></td></tr>
<tr class="separator:af95421174e54b5dfc990dfb4357fa13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60682a2548d69a53a19a1c5f9f1f5539"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; VectorType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a60682a2548d69a53a19a1c5f9f1f5539">getDistributedVectorType</a> (VectorType originalType, LayoutAttr layout)</td></tr>
<tr class="memdesc:a60682a2548d69a53a19a1c5f9f1f5539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to get the distributed vector type for a given vector type according to a given LayoutAttr.  <a href="namespacemlir_1_1xegpu.html#a60682a2548d69a53a19a1c5f9f1f5539">More...</a><br /></td></tr>
<tr class="separator:a60682a2548d69a53a19a1c5f9f1f5539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672ad62c985a7ae405189e62c203dd64"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a672ad62c985a7ae405189e62c203dd64">getLayoutName</a> (const <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;operand)</td></tr>
<tr class="memdesc:a672ad62c985a7ae405189e62c203dd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the attribute name for the <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> to attach DistributeLayoutAttr.  <a href="namespacemlir_1_1xegpu.html#a672ad62c985a7ae405189e62c203dd64">More...</a><br /></td></tr>
<tr class="separator:a672ad62c985a7ae405189e62c203dd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e16131cbf381ec91db7c11c881bccc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#ad7e16131cbf381ec91db7c11c881bccc">getLayoutName</a> (const <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> result)</td></tr>
<tr class="memdesc:ad7e16131cbf381ec91db7c11c881bccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the attribute name for the <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> to attach DistributeLayoutAttr.  <a href="namespacemlir_1_1xegpu.html#ad7e16131cbf381ec91db7c11c881bccc">More...</a><br /></td></tr>
<tr class="separator:ad7e16131cbf381ec91db7c11c881bccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee7c8e8e7f2b771725494bc1a03d34f"><td class="memItemLeft" align="right" valign="top">DistributeLayoutAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a9ee7c8e8e7f2b771725494bc1a03d34f">getDistributeLayoutAttr</a> (const <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a9ee7c8e8e7f2b771725494bc1a03d34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the DistributeLayoutAttr associated with a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="namespacemlir_1_1xegpu.html#a9ee7c8e8e7f2b771725494bc1a03d34f">More...</a><br /></td></tr>
<tr class="separator:a9ee7c8e8e7f2b771725494bc1a03d34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573db04f9c0e4ad6a124ce87207211ea"><td class="memTemplParams" colspan="2">template&lt;typename AttrTy &gt; </td></tr>
<tr class="memitem:a573db04f9c0e4ad6a124ce87207211ea"><td class="memTemplItemLeft" align="right" valign="top">AttrTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a573db04f9c0e4ad6a124ce87207211ea">getDistributeLayoutAttrOfType</a> (const <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="separator:a573db04f9c0e4ad6a124ce87207211ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78826a829c5b6d5b7e9bfb34b4c4efab"><td class="memItemLeft" align="right" valign="top">DistributeLayoutAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a78826a829c5b6d5b7e9bfb34b4c4efab">getDistributeLayoutAttr</a> (const <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;opr)</td></tr>
<tr class="memdesc:a78826a829c5b6d5b7e9bfb34b4c4efab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the DistributeLayoutAttr associated with a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>.  <a href="namespacemlir_1_1xegpu.html#a78826a829c5b6d5b7e9bfb34b4c4efab">More...</a><br /></td></tr>
<tr class="separator:a78826a829c5b6d5b7e9bfb34b4c4efab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a318151281ddbd2b97dda586faf77e"><td class="memTemplParams" colspan="2">template&lt;typename AttrTy &gt; </td></tr>
<tr class="memitem:ad8a318151281ddbd2b97dda586faf77e"><td class="memTemplItemLeft" align="right" valign="top">AttrTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#ad8a318151281ddbd2b97dda586faf77e">getDistributeLayoutAttrOfType</a> (const <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;opr)</td></tr>
<tr class="separator:ad8a318151281ddbd2b97dda586faf77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92279b8b5784964666324ae2f19da636"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;std::is_same_v&lt;T, OpOperand&gt; ||                                      std::is_same_v&lt;T, OpResult&gt;&gt;&gt; </td></tr>
<tr class="memitem:a92279b8b5784964666324ae2f19da636"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a92279b8b5784964666324ae2f19da636">removeLayoutAttr</a> (const T &amp;operandOrResult)</td></tr>
<tr class="memdesc:a92279b8b5784964666324ae2f19da636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the LayoutAttr for a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> or <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> if it exists.  <a href="namespacemlir_1_1xegpu.html#a92279b8b5784964666324ae2f19da636">More...</a><br /></td></tr>
<tr class="separator:a92279b8b5784964666324ae2f19da636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8e74148db06970f9e51f8da0a7066d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#ace8e74148db06970f9e51f8da0a7066d">removeLayoutAttrs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ace8e74148db06970f9e51f8da0a7066d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the DistributeLayoutAttr for each <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> and <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> of the given operation if they exist.  <a href="namespacemlir_1_1xegpu.html#ace8e74148db06970f9e51f8da0a7066d">More...</a><br /></td></tr>
<tr class="separator:ace8e74148db06970f9e51f8da0a7066d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135563059420d04e692f2b0ebe45d196"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;std::is_same_v&lt;T, OpOperand&gt; ||                                      std::is_same_v&lt;T, OpResult&gt;&gt;&gt; </td></tr>
<tr class="memitem:a135563059420d04e692f2b0ebe45d196"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a135563059420d04e692f2b0ebe45d196">setDistributeLayoutAttr</a> (const T &amp;operandOrResult, const DistributeLayoutAttr layout)</td></tr>
<tr class="memdesc:a135563059420d04e692f2b0ebe45d196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the DistributeLayoutAttr for a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> or <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> by attaching it to the owner's dictionary attributes.  <a href="namespacemlir_1_1xegpu.html#a135563059420d04e692f2b0ebe45d196">More...</a><br /></td></tr>
<tr class="separator:a135563059420d04e692f2b0ebe45d196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397eda9b2fa84b7d3efb02e3e00a31e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a397eda9b2fa84b7d3efb02e3e00a31e2">setDistributeLayoutAttrs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; DistributeLayoutAttr(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; getLayoutImpl)</td></tr>
<tr class="memdesc:a397eda9b2fa84b7d3efb02e3e00a31e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the DistributeLayoutAttr for each <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> and <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> of the given operation.  <a href="namespacemlir_1_1xegpu.html#a397eda9b2fa84b7d3efb02e3e00a31e2">More...</a><br /></td></tr>
<tr class="separator:a397eda9b2fa84b7d3efb02e3e00a31e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75bd4eba883b91f2a5d2d178c191b23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#ac75bd4eba883b91f2a5d2d178c191b23">extractVectorsWithShapeFromValue</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape)</td></tr>
<tr class="memdesc:ac75bd4eba883b91f2a5d2d178c191b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a set of small vectors from a value with a given shape using vector.extract_stride_slice.  <a href="namespacemlir_1_1xegpu.html#ac75bd4eba883b91f2a5d2d178c191b23">More...</a><br /></td></tr>
<tr class="separator:ac75bd4eba883b91f2a5d2d178c191b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1324225dbcd24fdd170015ec6ac2cbda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a1324225dbcd24fdd170015ec6ac2cbda">createVectorWithShapeFromValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape)</td></tr>
<tr class="memdesc:a1324225dbcd24fdd170015ec6ac2cbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vector of shape from a set of values using vector.insert_stride_slice.  <a href="namespacemlir_1_1xegpu.html#a1324225dbcd24fdd170015ec6ac2cbda">More...</a><br /></td></tr>
<tr class="separator:a1324225dbcd24fdd170015ec6ac2cbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953f1853d57571851e0d294bf32c1d6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a953f1853d57571851e0d294bf32c1d6e">doSCFStructuralTypeConversionWithTensorType</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> converter)</td></tr>
<tr class="memdesc:a953f1853d57571851e0d294bf32c1d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do type conversion for SCF structural ops, e.g., scf.for using SCF structure type convertion patterns.  <a href="namespacemlir_1_1xegpu.html#a953f1853d57571851e0d294bf32c1d6e">More...</a><br /></td></tr>
<tr class="separator:a953f1853d57571851e0d294bf32c1d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1887aba98e226a6b84b47df63e0151"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#abe1887aba98e226a6b84b47df63e0151">getChipStr</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:abe1887aba98e226a6b84b47df63e0151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the chip string from the XeVM target attribute of the parent GPU module operation.  <a href="namespacemlir_1_1xegpu.html#abe1887aba98e226a6b84b47df63e0151">More...</a><br /></td></tr>
<tr class="separator:abe1887aba98e226a6b84b47df63e0151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45e69b6fe92c401ee3457f7ee6d0fc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#af45e69b6fe92c401ee3457f7ee6d0fc0">addElementwise</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; lhs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; rhs)</td></tr>
<tr class="memdesc:af45e69b6fe92c401ee3457f7ee6d0fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates element-wise addition ops of two arrays with same length.  <a href="namespacemlir_1_1xegpu.html#af45e69b6fe92c401ee3457f7ee6d0fc0">More...</a><br /></td></tr>
<tr class="separator:af45e69b6fe92c401ee3457f7ee6d0fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a085b51c7714f3da8b3af332508ae2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#af3a085b51c7714f3da8b3af332508ae2">addWithRightAligned</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; lhs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; rhs)</td></tr>
<tr class="memdesc:af3a085b51c7714f3da8b3af332508ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates element-wise addition ops of two arrays with automatic alignment.  <a href="namespacemlir_1_1xegpu.html#af3a085b51c7714f3da8b3af332508ae2">More...</a><br /></td></tr>
<tr class="separator:af3a085b51c7714f3da8b3af332508ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ece25b11bdd795a6cdc4fcaeba8cf82"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a3ece25b11bdd795a6cdc4fcaeba8cf82">genOffsetsComputingInsts</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sgId, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sgLayout, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizePerSg, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizePerWg)</td></tr>
<tr class="memdesc:a3ece25b11bdd795a6cdc4fcaeba8cf82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates instructions to compute offsets for a subgroup identified by its multidimensional indices (sgId), using the specified subgroup layout (sgLayout), subgroup data dimensions (sizePerSg), and the overall data dimensions (sizePerWg).  <a href="namespacemlir_1_1xegpu.html#a3ece25b11bdd795a6cdc4fcaeba8cf82">More...</a><br /></td></tr>
<tr class="separator:a3ece25b11bdd795a6cdc4fcaeba8cf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752dbc6d66e2e4c7a8bf99ef9445e9a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a752dbc6d66e2e4c7a8bf99ef9445e9a1">isSharedMemory</a> (const MemRefType &amp;memrefTy)</td></tr>
<tr class="separator:a752dbc6d66e2e4c7a8bf99ef9445e9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bb73c4f06f33aae170fa98f533b114"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37bb73c4f06f33aae170fa98f533b114"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a37bb73c4f06f33aae170fa98f533b114">makeString</a> (T array, bool breakline=false)</td></tr>
<tr class="separator:a37bb73c4f06f33aae170fa98f533b114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3dff54c5cb14963c5ca7ad0fa02d1e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#aed3dff54c5cb14963c5ca7ad0fa02d1e">getShapeOf</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:aed3dff54c5cb14963c5ca7ad0fa02d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94817be42310b4aeaa0b36ef1d4e4306"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a94817be42310b4aeaa0b36ef1d4e4306">isReadHintOrNone</a> (const CachePolicyAttr &amp;attr)</td></tr>
<tr class="separator:a94817be42310b4aeaa0b36ef1d4e4306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903596de026307a95776dd25aad2c571"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a903596de026307a95776dd25aad2c571">isWriteHintOrNone</a> (const CachePolicyAttr &amp;attr)</td></tr>
<tr class="separator:a903596de026307a95776dd25aad2c571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72ba30df773294ed4ec8005328f0cca"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#aa72ba30df773294ed4ec8005328f0cca">isValidGatherScatterParams</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> maskTy, VectorType valueTy, TensorDescType tdescTy, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="separator:aa72ba30df773294ed4ec8005328f0cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7b2fb13d1e938b8f1ffc74c8a3b9af"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a3d7b2fb13d1e938b8f1ffc74c8a3b9af">isValidGatherScatterBufferParams</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> offsetsTy, <a class="el" href="classmlir_1_1Type.html">Type</a> maskTy, VectorType valueTy, int64_t chunkSize, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="separator:a3d7b2fb13d1e938b8f1ffc74c8a3b9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c96995fb17a5d43cda989190b7a317"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a68c96995fb17a5d43cda989190b7a317">parseOptionalDynamicIndexList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;values, <a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> &amp;integers, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; *valueTypes=nullptr, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a>)</td></tr>
<tr class="separator:a68c96995fb17a5d43cda989190b7a317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1e37151e7fc9f7de671c3c512e939a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a6a1e37151e7fc9f7de671c3c512e939a">printOptionalDynamicIndexList</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a> values, <a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> integers)</td></tr>
<tr class="separator:a6a1e37151e7fc9f7de671c3c512e939a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="af45e69b6fe92c401ee3457f7ee6d0fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45e69b6fe92c401ee3457f7ee6d0fc0">&#9670;&nbsp;</a></span>addElementwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::xegpu::addElementwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates element-wise addition ops of two arrays with same length. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00451">451</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00525">mlir::OpBuilder::createOrFold()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00476">addWithRightAligned()</a>.</p>

</div>
</div>
<a id="af3a085b51c7714f3da8b3af332508ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a085b51c7714f3da8b3af332508ae2">&#9670;&nbsp;</a></span>addWithRightAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::xegpu::addWithRightAligned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates element-wise addition ops of two arrays with automatic alignment. </p>
<p>When the input arrays have different sizes, the shorter array is right-aligned with the longer array, and the unmatched leading elements from the longer array are preserved unchanged. This is commonly used for offset computation where higher-dimensional offsets need to be added to lower-dimensional adjustments.</p>
<p>Example: lhs = [l1, l2, l3], rhs = [r1, r2] Result: [11, l2+r1, l3+r2] </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00476">476</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="XeGPUUtils_8cpp_source.html#l00451">addElementwise()</a>.</p>

</div>
</div>
<a id="a1324225dbcd24fdd170015ec6ac2cbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1324225dbcd24fdd170015ec6ac2cbda">&#9670;&nbsp;</a></span>createVectorWithShapeFromValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::xegpu::createVectorWithShapeFromValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a vector of shape from a set of values using vector.insert_stride_slice. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00260">260</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>, <a class="el" href="classmlir_1_1ValueRange.html#ab8f3a1aeea4da0acfaad1bc71b072017">mlir::ValueRange::getTypes()</a>, and <a class="el" href="Builders_8cpp_source.html#l00324">mlir::Builder::getZeroAttr()</a>.</p>

</div>
</div>
<a id="a953f1853d57571851e0d294bf32c1d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953f1853d57571851e0d294bf32c1d6e">&#9670;&nbsp;</a></span>doSCFStructuralTypeConversionWithTensorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::doSCFStructuralTypeConversionWithTensorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a>&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do type conversion for SCF structural ops, e.g., scf.for using SCF structure type convertion patterns. </p>
<p>Since VectorType cannot carry the layout attribute, which is needed to guide the type conversion for XeGPU, they are first converted into RankedTensorType, where the layout attribute can be attached. And then upstream SCF structural type conversion patterns are applied with the provided converter. TODO: This is a temporary solution. We should refactor it when context-aware type conversion is available. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00285">285</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00174">mlir::TypeConverter::addConversion()</a>, <a class="el" href="DialectConversion_8h_source.html#l01094">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l01079">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00200">mlir::TypeConverter::addSourceMaterialization()</a>, <a class="el" href="DialectConversion_8h_source.html#l00224">mlir::TypeConverter::addTargetMaterialization()</a>, <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l04117">mlir::applyPartialConversion()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00032">flattenValues()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00117">getDistributeLayoutAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00397">mlir::Operation::getOperandTypes()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00420">mlir::Operation::getOpResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00428">mlir::Operation::getResultTypes()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="Value_8h_source.html#l00188">mlir::Value::getUses()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, <a class="el" href="StructuralTypeConversions_8cpp_source.html#l00267">mlir::scf::populateSCFStructuralTypeConversionsAndLegality()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02072">mlir::ConversionPatternRewriter::replaceOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02092">mlir::ConversionPatternRewriter::replaceOpWithMultiple()</a>, <a class="el" href="Value_8h_source.html#l00116">mlir::Value::setType()</a>, <a class="el" href="WalkResult_8h_source.html#l00048">mlir::WalkResult::skip()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="ac75bd4eba883b91f2a5d2d178c191b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75bd4eba883b91f2a5d2d178c191b23">&#9670;&nbsp;</a></span>extractVectorsWithShapeFromValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::xegpu::extractVectorsWithShapeFromValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a set of small vectors from a value with a given shape using vector.extract_stride_slice. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00240">240</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00117">mlir::computeShapeRatio()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="aeeae20690a58f5264daf481dbbeea718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeae20690a58f5264daf481dbbeea718">&#9670;&nbsp;</a></span>flattenValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::xegpu::flattenValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten a set of <a class="el" href="classmlir_1_1ValueRange.html" title="This class provides an abstraction over the different types of ranges over Values.">ValueRange</a> into a single <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value&gt;</a> </p>
<p>convert ArrayRef&lt;ValueRange&gt; into <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value&gt;</a> </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00032">32</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00285">doSCFStructuralTypeConversionWithTensorType()</a>.</p>

</div>
</div>
<a id="a3ece25b11bdd795a6cdc4fcaeba8cf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ece25b11bdd795a6cdc4fcaeba8cf82">&#9670;&nbsp;</a></span>genOffsetsComputingInsts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::xegpu::genOffsetsComputingInsts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sgId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sgLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizePerSg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizePerWg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates instructions to compute offsets for a subgroup identified by its multidimensional indices (sgId), using the specified subgroup layout (sgLayout), subgroup data dimensions (sizePerSg), and the overall data dimensions (sizePerWg). </p>

<p class="definition">Definition at line <a class="el" href="XeGPUDialect_8cpp_source.html#l00045">45</a> of file <a class="el" href="XeGPUDialect_8cpp_source.html">XeGPUDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00079">mlir::computeElementwiseMul()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="Builders_8h_source.html#l00525">mlir::OpBuilder::createOrFold()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00204">min()</a>.</p>

</div>
</div>
<a id="abe1887aba98e226a6b84b47df63e0151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1887aba98e226a6b84b47df63e0151">&#9670;&nbsp;</a></span>getChipStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::string &gt; mlir::xegpu::getChipStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the chip string from the XeVM target attribute of the parent GPU module operation. </p>
<p>Returns the chip identifier if found, or nullopt if no GPU module parent or XeVM target attribute exists. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00432">432</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00238">mlir::Operation::getParentOfType()</a>.</p>

</div>
</div>
<a id="a60682a2548d69a53a19a1c5f9f1f5539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60682a2548d69a53a19a1c5f9f1f5539">&#9670;&nbsp;</a></span>getDistributedVectorType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;VectorType&gt; mlir::xegpu::getDistributedVectorType </td>
          <td>(</td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>originalType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LayoutAttr&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to get the distributed vector type for a given vector type according to a given LayoutAttr. </p>

</div>
</div>
<a id="af95421174e54b5dfc990dfb4357fa13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95421174e54b5dfc990dfb4357fa13c">&#9670;&nbsp;</a></span>getDistributedVectorType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; VectorType &gt; mlir::xegpu::getDistributedVectorType </td>
          <td>(</td>
          <td class="paramtype">xegpu::TensorDescType&#160;</td>
          <td class="paramname"><em>tdescTy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If tensor descriptor has a layout attribute it is used in SIMT mode. </p>
<p>In this mode, the distributed vector shape is determined as follows: Definitions: lane_data_size = lane_data[0] × lane_data[1] subgroup_size = lane_layout[0] × lane_layout[1] distribution_unit_size = subgroup_size × lane_data_size</p>
<p>Case 1: Regular loads/stores. The following conditions must be met:</p><ul>
<li>tensor_desc[0] == lane_layout[0] Distributed vector is a 1D vector with shape: [chunk_size]</li>
</ul>
<p>Case 2: <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a> loads/stores Additional definitions: tensor_size = tensor_desc[0] * .. * tensor_desc[r-1] * array_length n_distribution_units = tensor_size / distribution_unit_size fragment_size = n_distribution_units * lane_data_size Given above definitions, the following conditions must be met:</p><ul>
<li>tensor_desc[0] % (lane_layout[0] × lane_data[0]) == 0</li>
<li>tensor_desc[1] % (lane_layout[1] × lane_data[1]) == 0 Distributed vector is a 1D vector with shape: [fragment_size] </li>
</ul>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00040">40</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

</div>
</div>
<a id="a78826a829c5b6d5b7e9bfb34b4c4efab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78826a829c5b6d5b7e9bfb34b4c4efab">&#9670;&nbsp;</a></span>getDistributeLayoutAttr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xegpu::DistributeLayoutAttr mlir::xegpu::getDistributeLayoutAttr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>opr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the DistributeLayoutAttr associated with a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>. </p>
<p>It will first check the operand_layout_{id} of the owner operation. If not found, it will check the operand itself and its defining op. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00163">163</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00117">getDistributeLayoutAttr()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00106">getLayoutName()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00560">mlir::Operation::hasAttr()</a>.</p>

</div>
</div>
<a id="a9ee7c8e8e7f2b771725494bc1a03d34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee7c8e8e7f2b771725494bc1a03d34f">&#9670;&nbsp;</a></span>getDistributeLayoutAttr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xegpu::DistributeLayoutAttr mlir::xegpu::getDistributeLayoutAttr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the DistributeLayoutAttr associated with a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>
<p>For TensorDescType values, the DistributeLayoutAttr is extracted from the TensorDescType itself. For other values, it is obtained from the attributes of the defining operation. Returns nullptr if no DistributeLayoutAttr is found. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00117">117</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00106">getLayoutName()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00560">mlir::Operation::hasAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00285">doSCFStructuralTypeConversionWithTensorType()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00163">getDistributeLayoutAttr()</a>, and <a class="el" href="XeGPUUtils_8h_source.html#l00080">getDistributeLayoutAttrOfType()</a>.</p>

</div>
</div>
<a id="ad8a318151281ddbd2b97dda586faf77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a318151281ddbd2b97dda586faf77e">&#9670;&nbsp;</a></span>getDistributeLayoutAttrOfType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AttrTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">AttrTy mlir::xegpu::getDistributeLayoutAttrOfType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>opr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8h_source.html#l00090">90</a> of file <a class="el" href="XeGPUUtils_8h_source.html">XeGPUUtils.h</a>.</p>

<p class="reference">References <a class="el" href="XeGPUUtils_8cpp_source.html#l00117">getDistributeLayoutAttr()</a>.</p>

</div>
</div>
<a id="a573db04f9c0e4ad6a124ce87207211ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573db04f9c0e4ad6a124ce87207211ea">&#9670;&nbsp;</a></span>getDistributeLayoutAttrOfType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AttrTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">AttrTy mlir::xegpu::getDistributeLayoutAttrOfType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8h_source.html#l00080">80</a> of file <a class="el" href="XeGPUUtils_8h_source.html">XeGPUUtils.h</a>.</p>

<p class="reference">References <a class="el" href="XeGPUUtils_8cpp_source.html#l00117">getDistributeLayoutAttr()</a>.</p>

</div>
</div>
<a id="a672ad62c985a7ae405189e62c203dd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672ad62c985a7ae405189e62c203dd64">&#9670;&nbsp;</a></span>getLayoutName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::xegpu::getLayoutName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the attribute name for the <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> to attach DistributeLayoutAttr. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00106">106</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00117">getDistributeLayoutAttr()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00215">removeLayoutAttr()</a>, and <a class="el" href="XeGPUUtils_8cpp_source.html#l00179">setDistributeLayoutAttr()</a>.</p>

</div>
</div>
<a id="ad7e16131cbf381ec91db7c11c881bccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e16131cbf381ec91db7c11c881bccc">&#9670;&nbsp;</a></span>getLayoutName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::xegpu::getLayoutName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the attribute name for the <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> to attach DistributeLayoutAttr. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00112">112</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00459">mlir::OpResult::getResultNumber()</a>.</p>

</div>
</div>
<a id="aed3dff54c5cb14963c5ca7ad0fa02d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3dff54c5cb14963c5ca7ad0fa02d1e">&#9670;&nbsp;</a></span>getShapeOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; mlir::xegpu::getShapeOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00052">52</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUOps_8cpp_source.html#l00125">isValidGatherScatterBufferParams()</a>, and <a class="el" href="XeGPUOps_8cpp_source.html#l00078">isValidGatherScatterParams()</a>.</p>

</div>
</div>
<a id="a94817be42310b4aeaa0b36ef1d4e4306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94817be42310b4aeaa0b36ef1d4e4306">&#9670;&nbsp;</a></span>isReadHintOrNone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::xegpu::isReadHintOrNone </td>
          <td>(</td>
          <td class="paramtype">const CachePolicyAttr &amp;&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00061">61</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp.html#a13cd3ed9dcb153ca533c4ad45950c3b8">kind</a>.</p>

</div>
</div>
<a id="a752dbc6d66e2e4c7a8bf99ef9445e9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752dbc6d66e2e4c7a8bf99ef9445e9a1">&#9670;&nbsp;</a></span>isSharedMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::xegpu::isSharedMemory </td>
          <td>(</td>
          <td class="paramtype">const MemRefType &amp;&#160;</td>
          <td class="paramname"><em>memrefTy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00026">26</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

</div>
</div>
<a id="a3d7b2fb13d1e938b8f1ffc74c8a3b9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7b2fb13d1e938b8f1ffc74c8a3b9af">&#9670;&nbsp;</a></span>isValidGatherScatterBufferParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::xegpu::isValidGatherScatterBufferParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>offsetsTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>maskTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>valueTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>chunkSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00125">125</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, and <a class="el" href="XeGPUOps_8cpp_source.html#l00052">getShapeOf()</a>.</p>

</div>
</div>
<a id="aa72ba30df773294ed4ec8005328f0cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72ba30df773294ed4ec8005328f0cca">&#9670;&nbsp;</a></span>isValidGatherScatterParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::xegpu::isValidGatherScatterParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>maskTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>valueTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TensorDescType&#160;</td>
          <td class="paramname"><em>tdescTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00078">78</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="XeGPUOps_8cpp_source.html#l00052">getShapeOf()</a>, and <a class="el" href="XeGPUOps_8cpp_source.html#l00038">makeString()</a>.</p>

</div>
</div>
<a id="a903596de026307a95776dd25aad2c571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903596de026307a95776dd25aad2c571">&#9670;&nbsp;</a></span>isWriteHintOrNone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::xegpu::isWriteHintOrNone </td>
          <td>(</td>
          <td class="paramtype">const CachePolicyAttr &amp;&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00069">69</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp.html#a13cd3ed9dcb153ca533c4ad45950c3b8">kind</a>.</p>

</div>
</div>
<a id="a37bb73c4f06f33aae170fa98f533b114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bb73c4f06f33aae170fa98f533b114">&#9670;&nbsp;</a></span>makeString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string mlir::xegpu::makeString </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>breakline</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00038">38</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUOps_8cpp_source.html#l00078">isValidGatherScatterParams()</a>.</p>

</div>
</div>
<a id="a68c96995fb17a5d43cda989190b7a317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c96995fb17a5d43cda989190b7a317">&#9670;&nbsp;</a></span>parseOptionalDynamicIndexList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::xegpu::parseOptionalDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> &amp;&#160;</td>
          <td class="paramname"><em>integers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; *&#160;</td>
          <td class="paramname"><em>valueTypes</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a>&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00343">343</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00167">mlir::Builder::getDenseI64ArrayAttr()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a709cff503c00735e0a35ecd795364a2a">mlir::AsmParser::parseColonType()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2839f5b817f7fd118a6b0381da695436">mlir::AsmParser::parseCommaSeparatedList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00752">mlir::AsmParser::parseInteger()</a>, <a class="el" href="classmlir_1_1AsmParser.html#aed41da9f5ed12ea4b41136ef1b6239dd">mlir::AsmParser::parseOptionalLSquare()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a8fd765b541880aa1f11ca238ce62ad9d">mlir::OpAsmParser::parseOptionalOperand()</a>, and <a class="el" href="classmlir_1_1AsmParser.html#a3a1446df423154a41d52374b062ee1ff">mlir::AsmParser::parseRSquare()</a>.</p>

</div>
</div>
<a id="a75f0c70660bc13821493fc7c5b9ffa28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f0c70660bc13821493fc7c5b9ffa28">&#9670;&nbsp;</a></span>populateXeGPUFoldAliasOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::populateXeGPUFoldAliasOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for folding aliasing ops into XeGPU ops into <code>patterns</code>. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUFoldAliasOps_8cpp_source.html#l00063">63</a> of file <a class="el" href="XeGPUFoldAliasOps_8cpp_source.html">XeGPUFoldAliasOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="af39a7d1520005ea372b9b513a1d7b442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39a7d1520005ea372b9b513a1d7b442">&#9670;&nbsp;</a></span>populateXeGPUSubgroupDistributePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::populateXeGPUSubgroupDistributePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for XeGPU SIMT distribution into <code>patterns</code>. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUSubgroupDistribute_8cpp_source.html#l01415">1415</a> of file <a class="el" href="XeGPUSubgroupDistribute_8cpp_source.html">XeGPUSubgroupDistribute.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a2a6a1b5c8f4c32cbe9c5648017a727b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6a1b5c8f4c32cbe9c5648017a727b0">&#9670;&nbsp;</a></span>populateXeGPUUnrollPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::populateXeGPUUnrollPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1xegpu_1_1UnrollOptions.html">UnrollOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to unroll xegpu operations to a smaller shapes. </p>
<p>Users can control whether an operation to be unrolled or not, as well as its target shape via <code>options</code> structure. (via setting filterConstraint and nativeShape respectively, both of them are function refs taking <code>op</code> as input). An <code>op</code> is unrolled to the <code>targetShape</code> as follows, for each of its operands:</p><ol type="1">
<li>the unrolled type <code>unrolledType</code> and number of unrolled instances <code>numUnrolledInstances</code> are computed from the <code>targetShape</code>.</li>
<li>pack each operand. ExtractStridedSlice are created to break-up the vector operands. And BuiltinUnrealizedCastop are created to break-up the TensorDesc operands.</li>
<li>the original op is cloned <code>numUnrolledInstances</code> times, once for each result.</li>
<li>unpack the results. InsertStridedSlice are inserted for VectorType result, and BuiltinUnrealizedCastOp are inserted for TensorDescType result to re-assemble the slices into the original shape. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="XeGPUUnroll_8cpp_source.html#l01017">1017</a> of file <a class="el" href="XeGPUUnroll_8cpp_source.html">XeGPUUnroll.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="aafe602b848e4d20950d3b63b62be81db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe602b848e4d20950d3b63b62be81db">&#9670;&nbsp;</a></span>populateXeGPUWgToSgDistributePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::populateXeGPUWgToSgDistributePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUWgToSgDistribute_8cpp_source.html#l01098">1098</a> of file <a class="el" href="XeGPUWgToSgDistribute_8cpp_source.html">XeGPUWgToSgDistribute.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a6a1e37151e7fc9f7de671c3c512e939a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1e37151e7fc9f7de671c3c512e939a">&#9670;&nbsp;</a></span>printOptionalDynamicIndexList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::printOptionalDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a>&#160;</td>
          <td class="paramname"><em>integers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00381">381</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="ViewLikeInterface_8cpp_source.html#l00195">mlir::printDynamicIndexList()</a>, and <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">mlir::AsmParser::Square</a>.</p>

</div>
</div>
<a id="a92279b8b5784964666324ae2f19da636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92279b8b5784964666324ae2f19da636">&#9670;&nbsp;</a></span>removeLayoutAttr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;std::is_same_v&lt;T, OpOperand&gt; ||                                      std::is_same_v&lt;T, OpResult&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::removeLayoutAttr </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>operandOrResult</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the LayoutAttr for a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> or <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> if it exists. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00215">215</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="XeGPUUtils_8cpp_source.html#l00106">getLayoutName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00575">mlir::Operation::hasAttrOfType()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00600">mlir::Operation::removeAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00230">removeLayoutAttrs()</a>.</p>

</div>
</div>
<a id="ace8e74148db06970f9e51f8da0a7066d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8e74148db06970f9e51f8da0a7066d">&#9670;&nbsp;</a></span>removeLayoutAttrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::removeLayoutAttrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the DistributeLayoutAttr for each <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> and <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> of the given operation if they exist. </p>
<p>If the operation contains regions, it is also applied recursively to the contained operations </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00230">230</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00420">mlir::Operation::getOpResults()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00215">removeLayoutAttr()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a135563059420d04e692f2b0ebe45d196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135563059420d04e692f2b0ebe45d196">&#9670;&nbsp;</a></span>setDistributeLayoutAttr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;std::is_same_v&lt;T, OpOperand&gt; ||                                      std::is_same_v&lt;T, OpResult&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::setDistributeLayoutAttr </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>operandOrResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DistributeLayoutAttr&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the DistributeLayoutAttr for a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> or <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> by attaching it to the owner's dictionary attributes. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00179">179</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="XeGPUUtils_8cpp_source.html#l00106">getLayoutName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00575">mlir::Operation::hasAttrOfType()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00582">mlir::Operation::setAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUPropagateLayout_8cpp_source.html#l00909">updateControlFlowOps()</a>, and <a class="el" href="XeGPUPropagateLayout_8cpp_source.html#l00851">updateOp()</a>.</p>

</div>
</div>
<a id="a397eda9b2fa84b7d3efb02e3e00a31e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397eda9b2fa84b7d3efb02e3e00a31e2">&#9670;&nbsp;</a></span>setDistributeLayoutAttrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::setDistributeLayoutAttrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; DistributeLayoutAttr(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;&#160;</td>
          <td class="paramname"><em>getLayoutImpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the DistributeLayoutAttr for each <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> and <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> of the given operation. </p>
<p>If the operation contains regions, it is also applied recursively to the contained operations </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00197">197</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00420">mlir::Operation::getOpResults()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 27 2025 16:33:13 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
