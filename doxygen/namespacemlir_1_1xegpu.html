<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::xegpu Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1xegpu.html">xegpu</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::xegpu Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1xegpu_1_1targetinfo"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu_1_1targetinfo.html">targetinfo</a></td></tr>
<tr class="memdesc:namespacemlir_1_1xegpu_1_1targetinfo"><td class="mdescLeft">&#160;</td><td class="mdescRight">HW dependent constants. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1xegpu_1_1UnrollOptions.html">UnrollOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to control the XeGPU unrolling.  <a href="structmlir_1_1xegpu_1_1UnrollOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1xegpu_1_1FoldConvertLayoutOp.html">FoldConvertLayoutOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a75f0c70660bc13821493fc7c5b9ffa28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a75f0c70660bc13821493fc7c5b9ffa28">populateXeGPUFoldAliasOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a75f0c70660bc13821493fc7c5b9ffa28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for folding aliasing ops into XeGPU ops into <code>patterns</code>.  <a href="namespacemlir_1_1xegpu.html#a75f0c70660bc13821493fc7c5b9ffa28">More...</a><br /></td></tr>
<tr class="separator:a75f0c70660bc13821493fc7c5b9ffa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39a7d1520005ea372b9b513a1d7b442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#af39a7d1520005ea372b9b513a1d7b442">populateXeGPUSubgroupDistributePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:af39a7d1520005ea372b9b513a1d7b442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for XeGPU SIMT distribution into <code>patterns</code>.  <a href="namespacemlir_1_1xegpu.html#af39a7d1520005ea372b9b513a1d7b442">More...</a><br /></td></tr>
<tr class="separator:af39a7d1520005ea372b9b513a1d7b442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe602b848e4d20950d3b63b62be81db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#aafe602b848e4d20950d3b63b62be81db">populateXeGPUWgToSgDistributePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="separator:aafe602b848e4d20950d3b63b62be81db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6a1b5c8f4c32cbe9c5648017a727b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a2a6a1b5c8f4c32cbe9c5648017a727b0">populateXeGPUUnrollPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="structmlir_1_1xegpu_1_1UnrollOptions.html">UnrollOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a2a6a1b5c8f4c32cbe9c5648017a727b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to unroll xegpu operations to a smaller shapes.  <a href="namespacemlir_1_1xegpu.html#a2a6a1b5c8f4c32cbe9c5648017a727b0">More...</a><br /></td></tr>
<tr class="separator:a2a6a1b5c8f4c32cbe9c5648017a727b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeae20690a58f5264daf481dbbeea718"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#aeeae20690a58f5264daf481dbbeea718">flattenValues</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> &gt; values)</td></tr>
<tr class="memdesc:aeeae20690a58f5264daf481dbbeea718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten a set of <a class="el" href="classmlir_1_1ValueRange.html" title="This class provides an abstraction over the different types of ranges over Values.">ValueRange</a> into a single <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value&gt;</a>  <a href="namespacemlir_1_1xegpu.html#aeeae20690a58f5264daf481dbbeea718">More...</a><br /></td></tr>
<tr class="separator:aeeae20690a58f5264daf481dbbeea718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95421174e54b5dfc990dfb4357fa13c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; VectorType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#af95421174e54b5dfc990dfb4357fa13c">getDistributedVectorType</a> (xegpu::TensorDescType tdescTy)</td></tr>
<tr class="memdesc:af95421174e54b5dfc990dfb4357fa13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If tensor descriptor has a layout attribute it is used in SIMT mode.  <a href="namespacemlir_1_1xegpu.html#af95421174e54b5dfc990dfb4357fa13c">More...</a><br /></td></tr>
<tr class="separator:af95421174e54b5dfc990dfb4357fa13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60682a2548d69a53a19a1c5f9f1f5539"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; VectorType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a60682a2548d69a53a19a1c5f9f1f5539">getDistributedVectorType</a> (VectorType originalType, LayoutAttr layout)</td></tr>
<tr class="memdesc:a60682a2548d69a53a19a1c5f9f1f5539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to get the distributed vector type for a given vector type according to a given LayoutAttr.  <a href="namespacemlir_1_1xegpu.html#a60682a2548d69a53a19a1c5f9f1f5539">More...</a><br /></td></tr>
<tr class="separator:a60682a2548d69a53a19a1c5f9f1f5539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672ad62c985a7ae405189e62c203dd64"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a672ad62c985a7ae405189e62c203dd64">getLayoutName</a> (const <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;operand)</td></tr>
<tr class="memdesc:a672ad62c985a7ae405189e62c203dd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the attribute name for the <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> to attach LayoutAttr.  <a href="namespacemlir_1_1xegpu.html#a672ad62c985a7ae405189e62c203dd64">More...</a><br /></td></tr>
<tr class="separator:a672ad62c985a7ae405189e62c203dd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e16131cbf381ec91db7c11c881bccc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#ad7e16131cbf381ec91db7c11c881bccc">getLayoutName</a> (const <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> result)</td></tr>
<tr class="memdesc:ad7e16131cbf381ec91db7c11c881bccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the attribute name for the <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> to attach LayoutAttr.  <a href="namespacemlir_1_1xegpu.html#ad7e16131cbf381ec91db7c11c881bccc">More...</a><br /></td></tr>
<tr class="separator:ad7e16131cbf381ec91db7c11c881bccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae68d0f2a6c692c9665306ebed7e851"><td class="memItemLeft" align="right" valign="top">LayoutAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a2ae68d0f2a6c692c9665306ebed7e851">getLayoutAttr</a> (const <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a2ae68d0f2a6c692c9665306ebed7e851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the LayoutAttr associated with a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="namespacemlir_1_1xegpu.html#a2ae68d0f2a6c692c9665306ebed7e851">More...</a><br /></td></tr>
<tr class="separator:a2ae68d0f2a6c692c9665306ebed7e851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f7d322d84b8f3c4a1a02f3b5d98fc3"><td class="memItemLeft" align="right" valign="top">LayoutAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#ac8f7d322d84b8f3c4a1a02f3b5d98fc3">getLayoutAttr</a> (const <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;opr)</td></tr>
<tr class="memdesc:ac8f7d322d84b8f3c4a1a02f3b5d98fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the LayoutAttr associated with a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>.  <a href="namespacemlir_1_1xegpu.html#ac8f7d322d84b8f3c4a1a02f3b5d98fc3">More...</a><br /></td></tr>
<tr class="separator:ac8f7d322d84b8f3c4a1a02f3b5d98fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92279b8b5784964666324ae2f19da636"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;std::is_same_v&lt;T, OpOperand&gt; ||                                      std::is_same_v&lt;T, OpResult&gt;&gt;&gt; </td></tr>
<tr class="memitem:a92279b8b5784964666324ae2f19da636"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a92279b8b5784964666324ae2f19da636">removeLayoutAttr</a> (const T &amp;operandOrResult)</td></tr>
<tr class="memdesc:a92279b8b5784964666324ae2f19da636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the LayoutAttr for a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> or <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> if it exists.  <a href="namespacemlir_1_1xegpu.html#a92279b8b5784964666324ae2f19da636">More...</a><br /></td></tr>
<tr class="separator:a92279b8b5784964666324ae2f19da636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8e74148db06970f9e51f8da0a7066d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#ace8e74148db06970f9e51f8da0a7066d">removeLayoutAttrs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ace8e74148db06970f9e51f8da0a7066d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the LayoutAttr for each <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> and <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> of the given operation if they exist.  <a href="namespacemlir_1_1xegpu.html#ace8e74148db06970f9e51f8da0a7066d">More...</a><br /></td></tr>
<tr class="separator:ace8e74148db06970f9e51f8da0a7066d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d061472bfed55c12960494849bbd863"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;std::is_same_v&lt;T, OpOperand&gt; ||                                      std::is_same_v&lt;T, OpResult&gt;&gt;&gt; </td></tr>
<tr class="memitem:a2d061472bfed55c12960494849bbd863"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a2d061472bfed55c12960494849bbd863">setLayoutAttr</a> (const T &amp;operandOrResult, const LayoutAttr layout)</td></tr>
<tr class="memdesc:a2d061472bfed55c12960494849bbd863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the LayoutAttr for a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> or <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> by attaching it to the owner's dictionary attributes.  <a href="namespacemlir_1_1xegpu.html#a2d061472bfed55c12960494849bbd863">More...</a><br /></td></tr>
<tr class="separator:a2d061472bfed55c12960494849bbd863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52df05ec264826691647bf27c42956f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#aa52df05ec264826691647bf27c42956f">setLayoutAttrs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; LayoutAttr(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; getLayoutImpl)</td></tr>
<tr class="memdesc:aa52df05ec264826691647bf27c42956f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the LayoutAttr for each <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> and <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> of the given operation.  <a href="namespacemlir_1_1xegpu.html#aa52df05ec264826691647bf27c42956f">More...</a><br /></td></tr>
<tr class="separator:aa52df05ec264826691647bf27c42956f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75bd4eba883b91f2a5d2d178c191b23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#ac75bd4eba883b91f2a5d2d178c191b23">extractVectorsWithShapeFromValue</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape)</td></tr>
<tr class="memdesc:ac75bd4eba883b91f2a5d2d178c191b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a set of small vectors from a value with a given shape using vector.extract_stride_slice.  <a href="namespacemlir_1_1xegpu.html#ac75bd4eba883b91f2a5d2d178c191b23">More...</a><br /></td></tr>
<tr class="separator:ac75bd4eba883b91f2a5d2d178c191b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1324225dbcd24fdd170015ec6ac2cbda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a1324225dbcd24fdd170015ec6ac2cbda">createVectorWithShapeFromValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape)</td></tr>
<tr class="memdesc:a1324225dbcd24fdd170015ec6ac2cbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vector of shape from a set of values using vector.insert_stride_slice.  <a href="namespacemlir_1_1xegpu.html#a1324225dbcd24fdd170015ec6ac2cbda">More...</a><br /></td></tr>
<tr class="separator:a1324225dbcd24fdd170015ec6ac2cbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953f1853d57571851e0d294bf32c1d6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a953f1853d57571851e0d294bf32c1d6e">doSCFStructuralTypeConversionWithTensorType</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> converter)</td></tr>
<tr class="memdesc:a953f1853d57571851e0d294bf32c1d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do type conversion for SCF structural ops, e.g., scf.for using SCF structure type convertion patterns.  <a href="namespacemlir_1_1xegpu.html#a953f1853d57571851e0d294bf32c1d6e">More...</a><br /></td></tr>
<tr class="separator:a953f1853d57571851e0d294bf32c1d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bb73c4f06f33aae170fa98f533b114"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37bb73c4f06f33aae170fa98f533b114"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a37bb73c4f06f33aae170fa98f533b114">makeString</a> (T array, bool breakline=false)</td></tr>
<tr class="separator:a37bb73c4f06f33aae170fa98f533b114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3dff54c5cb14963c5ca7ad0fa02d1e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#aed3dff54c5cb14963c5ca7ad0fa02d1e">getShapeOf</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:aed3dff54c5cb14963c5ca7ad0fa02d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f243bc3a18aa8352e22706b715933d4"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a8f243bc3a18aa8352e22706b715933d4">getRankOf</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="separator:a8f243bc3a18aa8352e22706b715933d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94817be42310b4aeaa0b36ef1d4e4306"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a94817be42310b4aeaa0b36ef1d4e4306">isReadHintOrNone</a> (const CachePolicyAttr &amp;attr)</td></tr>
<tr class="separator:a94817be42310b4aeaa0b36ef1d4e4306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903596de026307a95776dd25aad2c571"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a903596de026307a95776dd25aad2c571">isWriteHintOrNone</a> (const CachePolicyAttr &amp;attr)</td></tr>
<tr class="separator:a903596de026307a95776dd25aad2c571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72ba30df773294ed4ec8005328f0cca"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#aa72ba30df773294ed4ec8005328f0cca">isValidGatherScatterParams</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> maskTy, VectorType valueTy, TensorDescType tdescTy, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="separator:aa72ba30df773294ed4ec8005328f0cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ab84ef14080d230c638975cb37d7a5"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#aa2ab84ef14080d230c638975cb37d7a5">isValidGatherScatterBufferParams</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> maskTy, VectorType valueTy, int64_t chunkSize, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>)</td></tr>
<tr class="separator:aa2ab84ef14080d230c638975cb37d7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c96995fb17a5d43cda989190b7a317"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a68c96995fb17a5d43cda989190b7a317">parseOptionalDynamicIndexList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;values, <a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> &amp;integers, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; *valueTypes=nullptr, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a> delimiter=<a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a>)</td></tr>
<tr class="separator:a68c96995fb17a5d43cda989190b7a317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1e37151e7fc9f7de671c3c512e939a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu.html#a6a1e37151e7fc9f7de671c3c512e939a">printOptionalDynamicIndexList</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;printer, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a> values, <a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> integers)</td></tr>
<tr class="separator:a6a1e37151e7fc9f7de671c3c512e939a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1324225dbcd24fdd170015ec6ac2cbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1324225dbcd24fdd170015ec6ac2cbda">&#9670;&nbsp;</a></span>createVectorWithShapeFromValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::xegpu::createVectorWithShapeFromValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a vector of shape from a set of values using vector.insert_stride_slice. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00237">237</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00909">mlir::DenseElementsAttr::get()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>, <a class="el" href="classmlir_1_1ValueRange.html#ab8f3a1aeea4da0acfaad1bc71b072017">mlir::ValueRange::getTypes()</a>, and <a class="el" href="Builders_8cpp_source.html#l00319">mlir::Builder::getZeroAttr()</a>.</p>

</div>
</div>
<a id="a953f1853d57571851e0d294bf32c1d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953f1853d57571851e0d294bf32c1d6e">&#9670;&nbsp;</a></span>doSCFStructuralTypeConversionWithTensorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::doSCFStructuralTypeConversionWithTensorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a>&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do type conversion for SCF structural ops, e.g., scf.for using SCF structure type convertion patterns. </p>
<p>Since VectorType cannot carry the layout attribute, which is needed to guide the type conversion for XeGPU, they are first converted into RankedTensorType, where the layout attribute can be attached. And then upstream SCF structural type conversion patterns are applied with the provided converter. TODO: This is a temporary solution. We should refactor it when context-aware type conversion is available. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00262">262</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00161">mlir::TypeConverter::addConversion()</a>, <a class="el" href="DialectConversion_8h_source.html#l00930">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00915">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00187">mlir::TypeConverter::addSourceMaterialization()</a>, <a class="el" href="DialectConversion_8h_source.html#l00211">mlir::TypeConverter::addTargetMaterialization()</a>, <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03592">mlir::applyPartialConversion()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00029">flattenValues()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00114">getLayoutAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00397">mlir::Operation::getOperandTypes()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00420">mlir::Operation::getOpResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00428">mlir::Operation::getResultTypes()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="Value_8h_source.html#l00188">mlir::Value::getUses()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, <a class="el" href="StructuralTypeConversions_8cpp_source.html#l00242">mlir::scf::populateSCFStructuralTypeConversionsAndLegality()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01762">mlir::ConversionPatternRewriter::replaceOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01782">mlir::ConversionPatternRewriter::replaceOpWithMultiple()</a>, <a class="el" href="Value_8h_source.html#l00116">mlir::Value::setType()</a>, <a class="el" href="WalkResult_8h_source.html#l00048">mlir::WalkResult::skip()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="ac75bd4eba883b91f2a5d2d178c191b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75bd4eba883b91f2a5d2d178c191b23">&#9670;&nbsp;</a></span>extractVectorsWithShapeFromValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::xegpu::extractVectorsWithShapeFromValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a set of small vectors from a value with a given shape using vector.extract_stride_slice. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00217">217</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00117">mlir::computeShapeRatio()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="aeeae20690a58f5264daf481dbbeea718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeae20690a58f5264daf481dbbeea718">&#9670;&nbsp;</a></span>flattenValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::xegpu::flattenValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten a set of <a class="el" href="classmlir_1_1ValueRange.html" title="This class provides an abstraction over the different types of ranges over Values.">ValueRange</a> into a single <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value&gt;</a> </p>
<p>convert ArrayRef&lt;ValueRange&gt; into <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value&gt;</a> </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00029">29</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00262">doSCFStructuralTypeConversionWithTensorType()</a>.</p>

</div>
</div>
<a id="a60682a2548d69a53a19a1c5f9f1f5539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60682a2548d69a53a19a1c5f9f1f5539">&#9670;&nbsp;</a></span>getDistributedVectorType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;VectorType&gt; mlir::xegpu::getDistributedVectorType </td>
          <td>(</td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>originalType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LayoutAttr&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to get the distributed vector type for a given vector type according to a given LayoutAttr. </p>

</div>
</div>
<a id="af95421174e54b5dfc990dfb4357fa13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95421174e54b5dfc990dfb4357fa13c">&#9670;&nbsp;</a></span>getDistributedVectorType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; VectorType &gt; mlir::xegpu::getDistributedVectorType </td>
          <td>(</td>
          <td class="paramtype">xegpu::TensorDescType&#160;</td>
          <td class="paramname"><em>tdescTy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If tensor descriptor has a layout attribute it is used in SIMT mode. </p>
<p>In this mode, the distributed vector shape is determined as follows: Definitions: lane_data_size = lane_data[0] × lane_data[1] subgroup_size = lane_layout[0] × lane_layout[1] distribution_unit_size = subgroup_size × lane_data_size</p>
<p>Case 1: Regular loads/stores. The following conditions must be met:</p><ul>
<li>tensor_desc[0] == lane_layout[0] Distributed vector is a 1D vector with shape: [chunk_size]</li>
</ul>
<p>Case 2: <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a> loads/stores Additional definitions: tensor_size = tensor_desc[0] * .. * tensor_desc[r-1] * array_length n_distribution_units = tensor_size / distribution_unit_size fragment_size = n_distribution_units * lane_data_size Given above definitions, the following conditions must be met:</p><ul>
<li>tensor_desc[0] % (lane_layout[0] × lane_data[0]) == 0</li>
<li>tensor_desc[1] % (lane_layout[1] × lane_data[1]) == 0 Distributed vector is a 1D vector with shape: [fragment_size] </li>
</ul>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00037">37</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

</div>
</div>
<a id="ac8f7d322d84b8f3c4a1a02f3b5d98fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f7d322d84b8f3c4a1a02f3b5d98fc3">&#9670;&nbsp;</a></span>getLayoutAttr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xegpu::LayoutAttr mlir::xegpu::getLayoutAttr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>opr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the LayoutAttr associated with a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>. </p>
<p>It will first check the operand_layout_{id} of the owner operation. If not found, it will check the operand itself and its defining op. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00151">151</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00114">getLayoutAttr()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00103">getLayoutName()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00560">mlir::Operation::hasAttr()</a>.</p>

</div>
</div>
<a id="a2ae68d0f2a6c692c9665306ebed7e851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae68d0f2a6c692c9665306ebed7e851">&#9670;&nbsp;</a></span>getLayoutAttr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xegpu::LayoutAttr mlir::xegpu::getLayoutAttr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the LayoutAttr associated with a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>
<p>For TensorDescType values, the LayoutAttr is extracted from the TensorDescType itself. For other values, it is obtained from the attributes of the defining operation. Returns nullptr if no LayoutAttr is found. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00114">114</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00103">getLayoutName()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00560">mlir::Operation::hasAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00262">doSCFStructuralTypeConversionWithTensorType()</a>, and <a class="el" href="XeGPUUtils_8cpp_source.html#l00151">getLayoutAttr()</a>.</p>

</div>
</div>
<a id="a672ad62c985a7ae405189e62c203dd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672ad62c985a7ae405189e62c203dd64">&#9670;&nbsp;</a></span>getLayoutName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::xegpu::getLayoutName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the attribute name for the <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> to attach LayoutAttr. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00103">103</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00114">getLayoutAttr()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00192">removeLayoutAttr()</a>, and <a class="el" href="XeGPUUtils_8cpp_source.html#l00160">setLayoutAttr()</a>.</p>

</div>
</div>
<a id="ad7e16131cbf381ec91db7c11c881bccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e16131cbf381ec91db7c11c881bccc">&#9670;&nbsp;</a></span>getLayoutName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::xegpu::getLayoutName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the attribute name for the <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> to attach LayoutAttr. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00109">109</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00459">mlir::OpResult::getResultNumber()</a>.</p>

</div>
</div>
<a id="a8f243bc3a18aa8352e22706b715933d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f243bc3a18aa8352e22706b715933d4">&#9670;&nbsp;</a></span>getRankOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t mlir::xegpu::getRankOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00048">48</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="aed3dff54c5cb14963c5ca7ad0fa02d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3dff54c5cb14963c5ca7ad0fa02d1e">&#9670;&nbsp;</a></span>getShapeOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t&gt; mlir::xegpu::getShapeOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00039">39</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUOps_8cpp_source.html#l00114">isValidGatherScatterBufferParams()</a>, and <a class="el" href="XeGPUOps_8cpp_source.html#l00072">isValidGatherScatterParams()</a>.</p>

</div>
</div>
<a id="a94817be42310b4aeaa0b36ef1d4e4306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94817be42310b4aeaa0b36ef1d4e4306">&#9670;&nbsp;</a></span>isReadHintOrNone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::xegpu::isReadHintOrNone </td>
          <td>(</td>
          <td class="paramtype">const CachePolicyAttr &amp;&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00055">55</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp.html#a28955b1aca39affb65f8316b45796bfa">kind</a>.</p>

</div>
</div>
<a id="aa2ab84ef14080d230c638975cb37d7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ab84ef14080d230c638975cb37d7a5">&#9670;&nbsp;</a></span>isValidGatherScatterBufferParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::xegpu::isValidGatherScatterBufferParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>maskTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>valueTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>chunkSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00114">114</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, and <a class="el" href="XeGPUOps_8cpp_source.html#l00039">getShapeOf()</a>.</p>

</div>
</div>
<a id="aa72ba30df773294ed4ec8005328f0cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72ba30df773294ed4ec8005328f0cca">&#9670;&nbsp;</a></span>isValidGatherScatterParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LogicalResult mlir::xegpu::isValidGatherScatterParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>maskTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType&#160;</td>
          <td class="paramname"><em>valueTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TensorDescType&#160;</td>
          <td class="paramname"><em>tdescTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt;&#160;</td>
          <td class="paramname"><em>emitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00072">72</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="XeGPUOps_8cpp_source.html#l00039">getShapeOf()</a>, and <a class="el" href="XeGPUOps_8cpp_source.html#l00025">makeString()</a>.</p>

</div>
</div>
<a id="a903596de026307a95776dd25aad2c571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903596de026307a95776dd25aad2c571">&#9670;&nbsp;</a></span>isWriteHintOrNone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::xegpu::isWriteHintOrNone </td>
          <td>(</td>
          <td class="paramtype">const CachePolicyAttr &amp;&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00063">63</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp.html#a28955b1aca39affb65f8316b45796bfa">kind</a>.</p>

</div>
</div>
<a id="a37bb73c4f06f33aae170fa98f533b114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bb73c4f06f33aae170fa98f533b114">&#9670;&nbsp;</a></span>makeString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string mlir::xegpu::makeString </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>breakline</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00025">25</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUOps_8cpp_source.html#l00072">isValidGatherScatterParams()</a>.</p>

</div>
</div>
<a id="a68c96995fb17a5d43cda989190b7a317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c96995fb17a5d43cda989190b7a317">&#9670;&nbsp;</a></span>parseOptionalDynamicIndexList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::xegpu::parseOptionalDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1OpAsmParser_1_1UnresolvedOperand.html">OpAsmParser::UnresolvedOperand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a> &amp;&#160;</td>
          <td class="paramname"><em>integers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; *&#160;</td>
          <td class="paramname"><em>valueTypes</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95b">AsmParser::Delimiter</a>&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code><a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">AsmParser::Delimiter::Square</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00322">322</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00162">mlir::Builder::getDenseI64ArrayAttr()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a709cff503c00735e0a35ecd795364a2a">mlir::AsmParser::parseColonType()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2839f5b817f7fd118a6b0381da695436">mlir::AsmParser::parseCommaSeparatedList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00752">mlir::AsmParser::parseInteger()</a>, <a class="el" href="classmlir_1_1AsmParser.html#aed41da9f5ed12ea4b41136ef1b6239dd">mlir::AsmParser::parseOptionalLSquare()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a8fd765b541880aa1f11ca238ce62ad9d">mlir::OpAsmParser::parseOptionalOperand()</a>, and <a class="el" href="classmlir_1_1AsmParser.html#a3a1446df423154a41d52374b062ee1ff">mlir::AsmParser::parseRSquare()</a>.</p>

</div>
</div>
<a id="a75f0c70660bc13821493fc7c5b9ffa28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f0c70660bc13821493fc7c5b9ffa28">&#9670;&nbsp;</a></span>populateXeGPUFoldAliasOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::populateXeGPUFoldAliasOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for folding aliasing ops into XeGPU ops into <code>patterns</code>. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUFoldAliasOps_8cpp_source.html#l00063">63</a> of file <a class="el" href="XeGPUFoldAliasOps_8cpp_source.html">XeGPUFoldAliasOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="af39a7d1520005ea372b9b513a1d7b442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39a7d1520005ea372b9b513a1d7b442">&#9670;&nbsp;</a></span>populateXeGPUSubgroupDistributePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::populateXeGPUSubgroupDistributePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for XeGPU SIMT distribution into <code>patterns</code>. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUSubgroupDistribute_8cpp_source.html#l00842">842</a> of file <a class="el" href="XeGPUSubgroupDistribute_8cpp_source.html">XeGPUSubgroupDistribute.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a2a6a1b5c8f4c32cbe9c5648017a727b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6a1b5c8f4c32cbe9c5648017a727b0">&#9670;&nbsp;</a></span>populateXeGPUUnrollPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::populateXeGPUUnrollPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1xegpu_1_1UnrollOptions.html">UnrollOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to unroll xegpu operations to a smaller shapes. </p>
<p>Users can control whether an operation to be unrolled or not, as well as its target shape via <code>options</code> structure. (via setting filterConstraint and nativeShape respectively, both of them are function refs taking <code>op</code> as input). An <code>op</code> is unrolled to the <code>targetShape</code> as follows, for each of its operands:</p><ol type="1">
<li>the unrolled type <code>unrolledType</code> and number of unrolled instances <code>numUnrolledInstances</code> are computed from the <code>targetShape</code>.</li>
<li>pack each operand. ExtractStridedSlice are created to break-up the vector operands. And BuiltinUnrealizedCastop are created to break-up the TensorDesc operands.</li>
<li>the original op is cloned <code>numUnrolledInstances</code> times, once for each result.</li>
<li>unpack the results. InsertStridedSlice are inserted for VectorType result, and BuiltinUnrealizedCastOp are inserted for TensorDescType result to re-assemble the slices into the original shape. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="XeGPUUnroll_8cpp_source.html#l00687">687</a> of file <a class="el" href="XeGPUUnroll_8cpp_source.html">XeGPUUnroll.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="aafe602b848e4d20950d3b63b62be81db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe602b848e4d20950d3b63b62be81db">&#9670;&nbsp;</a></span>populateXeGPUWgToSgDistributePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::populateXeGPUWgToSgDistributePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUWgToSgDistribute_8cpp_source.html#l00656">656</a> of file <a class="el" href="XeGPUWgToSgDistribute_8cpp_source.html">XeGPUWgToSgDistribute.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a6a1e37151e7fc9f7de671c3c512e939a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1e37151e7fc9f7de671c3c512e939a">&#9670;&nbsp;</a></span>printOptionalDynamicIndexList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::printOptionalDynamicIndexList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a50858f49b4d3e313809688de651162e3">DenseI64ArrayAttr</a>&#160;</td>
          <td class="paramname"><em>integers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUOps_8cpp_source.html#l00360">360</a> of file <a class="el" href="XeGPUOps_8cpp_source.html">XeGPUOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="ViewLikeInterface_8cpp_source.html#l00195">mlir::printDynamicIndexList()</a>, and <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95baceb46ca115d05c51aa5a16a8867c3304">mlir::AsmParser::Square</a>.</p>

</div>
</div>
<a id="a92279b8b5784964666324ae2f19da636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92279b8b5784964666324ae2f19da636">&#9670;&nbsp;</a></span>removeLayoutAttr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;std::is_same_v&lt;T, OpOperand&gt; ||                                      std::is_same_v&lt;T, OpResult&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::removeLayoutAttr </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>operandOrResult</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the LayoutAttr for a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> or <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> if it exists. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00192">192</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="XeGPUUtils_8cpp_source.html#l00103">getLayoutName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00575">mlir::Operation::hasAttrOfType()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00600">mlir::Operation::removeAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00207">removeLayoutAttrs()</a>.</p>

</div>
</div>
<a id="ace8e74148db06970f9e51f8da0a7066d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8e74148db06970f9e51f8da0a7066d">&#9670;&nbsp;</a></span>removeLayoutAttrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::removeLayoutAttrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the LayoutAttr for each <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> and <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> of the given operation if they exist. </p>
<p>If the operation contains regions, it is also applied recursively to the contained operations </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00207">207</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00420">mlir::Operation::getOpResults()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00192">removeLayoutAttr()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a2d061472bfed55c12960494849bbd863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d061472bfed55c12960494849bbd863">&#9670;&nbsp;</a></span>setLayoutAttr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;std::is_same_v&lt;T, OpOperand&gt; ||                                      std::is_same_v&lt;T, OpResult&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::setLayoutAttr </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>operandOrResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LayoutAttr&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the LayoutAttr for a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> or <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> by attaching it to the owner's dictionary attributes. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00160">160</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="XeGPUUtils_8cpp_source.html#l00103">getLayoutName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00575">mlir::Operation::hasAttrOfType()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00582">mlir::Operation::setAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUPropagateLayout_8cpp_source.html#l00749">updateControlFlowOps()</a>, and <a class="el" href="XeGPUPropagateLayout_8cpp_source.html#l00692">updateOp()</a>.</p>

</div>
</div>
<a id="aa52df05ec264826691647bf27c42956f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52df05ec264826691647bf27c42956f">&#9670;&nbsp;</a></span>setLayoutAttrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::xegpu::setLayoutAttrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; LayoutAttr(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;&#160;</td>
          <td class="paramname"><em>getLayoutImpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the LayoutAttr for each <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> and <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> of the given operation. </p>
<p>If the operation contains regions, it is also applied recursively to the contained operations </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00177">177</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00420">mlir::Operation::getOpResults()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:32 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
