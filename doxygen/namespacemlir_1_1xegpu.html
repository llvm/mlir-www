<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::xegpu Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="namespacemlir_1_1xegpu.html">xegpu</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mlir::xegpu Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:impl" id="r_impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu_1_1impl.html">impl</a></td></tr>
<tr class="memitem:uArch" id="r_uArch"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1xegpu_1_1uArch.html">uArch</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:UnrollOptions" id="r_UnrollOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1xegpu_1_1UnrollOptions.html">UnrollOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to control the XeGPU unrolling.  <a href="structmlir_1_1xegpu_1_1UnrollOptions.html#details">More...</a><br /></td></tr>
<tr class="memitem:XeGPUPropagateLayoutOptions" id="r_XeGPUPropagateLayoutOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1xegpu_1_1XeGPUPropagateLayoutOptions.html">XeGPUPropagateLayoutOptions</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a07ce62acc531cdfebfc973879dc89e1b" id="r_a07ce62acc531cdfebfc973879dc89e1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07ce62acc531cdfebfc973879dc89e1b">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:aec6af0d93824b476c2cf45780580c3ad" id="r_aec6af0d93824b476c2cf45780580c3ad"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec6af0d93824b476c2cf45780580c3ad">createXeGPUBlocking</a> ()</td></tr>
<tr class="memitem:a107b2ac17ac9d677f8e4be7baa12087b" id="r_a107b2ac17ac9d677f8e4be7baa12087b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a107b2ac17ac9d677f8e4be7baa12087b">createXeGPUFoldAliasOps</a> ()</td></tr>
<tr class="memitem:a9b18ab8d4506680a9cebcba77019b391" id="r_a9b18ab8d4506680a9cebcba77019b391"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b18ab8d4506680a9cebcba77019b391">createXeGPUOptimizeBlockLoads</a> ()</td></tr>
<tr class="memitem:af151cb970a71e5e0f030af9c829580fd" id="r_af151cb970a71e5e0f030af9c829580fd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af151cb970a71e5e0f030af9c829580fd">createXeGPUPropagateLayout</a> ()</td></tr>
<tr class="memitem:a379e7abd2029bd1cae2c8e304524be08" id="r_a379e7abd2029bd1cae2c8e304524be08"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a379e7abd2029bd1cae2c8e304524be08">createXeGPUPropagateLayout</a> (<a class="el" href="structmlir_1_1xegpu_1_1XeGPUPropagateLayoutOptions.html">XeGPUPropagateLayoutOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a5b2675b3e75bfc781dae2c287e483aba" id="r_a5b2675b3e75bfc781dae2c287e483aba"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b2675b3e75bfc781dae2c287e483aba">createXeGPUSubgroupDistribute</a> ()</td></tr>
<tr class="memitem:ab3451f306d3e0b602adfd9785559ef05" id="r_ab3451f306d3e0b602adfd9785559ef05"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3451f306d3e0b602adfd9785559ef05">createXeGPUVectorLinearize</a> ()</td></tr>
<tr class="memitem:a8e585364013e34a53ee20c9e97f6743c" id="r_a8e585364013e34a53ee20c9e97f6743c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e585364013e34a53ee20c9e97f6743c">createXeGPUWgToSgDistribute</a> ()</td></tr>
<tr class="memitem:a1d6b086c6748c9daa1ecb456b4854fd8" id="r_a1d6b086c6748c9daa1ecb456b4854fd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d6b086c6748c9daa1ecb456b4854fd8">registerXeGPUBlocking</a> ()</td></tr>
<tr class="memitem:ac85425b1751f44d2c6450d5dc7f2cbd7" id="r_ac85425b1751f44d2c6450d5dc7f2cbd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac85425b1751f44d2c6450d5dc7f2cbd7">registerXeGPUBlockingPass</a> ()</td></tr>
<tr class="memitem:a8878ae224cd253642b1ca818b48227cb" id="r_a8878ae224cd253642b1ca818b48227cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8878ae224cd253642b1ca818b48227cb">registerXeGPUFoldAliasOps</a> ()</td></tr>
<tr class="memitem:ab338281d7cc0e26e2906258e936a4b40" id="r_ab338281d7cc0e26e2906258e936a4b40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab338281d7cc0e26e2906258e936a4b40">registerXeGPUFoldAliasOpsPass</a> ()</td></tr>
<tr class="memitem:a87fa609e5f081d890c4596e81b8c4291" id="r_a87fa609e5f081d890c4596e81b8c4291"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87fa609e5f081d890c4596e81b8c4291">registerXeGPUOptimizeBlockLoads</a> ()</td></tr>
<tr class="memitem:a24710424ab0218eb70982bc036211928" id="r_a24710424ab0218eb70982bc036211928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24710424ab0218eb70982bc036211928">registerXeGPUOptimizeBlockLoadsPass</a> ()</td></tr>
<tr class="memitem:a59103d9c21b3ffe2ba19023e6b256be2" id="r_a59103d9c21b3ffe2ba19023e6b256be2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59103d9c21b3ffe2ba19023e6b256be2">registerXeGPUPropagateLayout</a> ()</td></tr>
<tr class="memitem:a760af1f7125f3fb4cd3c5badfaa3ba8b" id="r_a760af1f7125f3fb4cd3c5badfaa3ba8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a760af1f7125f3fb4cd3c5badfaa3ba8b">registerXeGPUPropagateLayoutPass</a> ()</td></tr>
<tr class="memitem:a0193ac24187b69430fedb1f7fac78597" id="r_a0193ac24187b69430fedb1f7fac78597"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0193ac24187b69430fedb1f7fac78597">registerXeGPUSubgroupDistribute</a> ()</td></tr>
<tr class="memitem:a0a8b8cafd4ef007ecda9ec14cba12f34" id="r_a0a8b8cafd4ef007ecda9ec14cba12f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a8b8cafd4ef007ecda9ec14cba12f34">registerXeGPUSubgroupDistributePass</a> ()</td></tr>
<tr class="memitem:ae7616e68041e2728498843b28bedc3d5" id="r_ae7616e68041e2728498843b28bedc3d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7616e68041e2728498843b28bedc3d5">registerXeGPUVectorLinearize</a> ()</td></tr>
<tr class="memitem:a2189cd487278a604041160adbf452847" id="r_a2189cd487278a604041160adbf452847"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2189cd487278a604041160adbf452847">registerXeGPUVectorLinearizePass</a> ()</td></tr>
<tr class="memitem:af544ae99b7f5389d19d399ef9299f483" id="r_af544ae99b7f5389d19d399ef9299f483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af544ae99b7f5389d19d399ef9299f483">registerXeGPUWgToSgDistribute</a> ()</td></tr>
<tr class="memitem:a383162aa92b2b35b3b776d23d4312c6c" id="r_a383162aa92b2b35b3b776d23d4312c6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a383162aa92b2b35b3b776d23d4312c6c">registerXeGPUWgToSgDistributePass</a> ()</td></tr>
<tr class="memitem:a7a50498e0455e0f75568e5d17af7275d" id="r_a7a50498e0455e0f75568e5d17af7275d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a50498e0455e0f75568e5d17af7275d">registerXeGPUPasses</a> ()</td></tr>
<tr class="memitem:a75f0c70660bc13821493fc7c5b9ffa28" id="r_a75f0c70660bc13821493fc7c5b9ffa28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75f0c70660bc13821493fc7c5b9ffa28">populateXeGPUFoldAliasOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a75f0c70660bc13821493fc7c5b9ffa28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for folding aliasing ops into XeGPU ops into <span class="tt">patterns</span>.  <br /></td></tr>
<tr class="memitem:a0b184b002d5a8dda5245fa4d90c9603c" id="r_a0b184b002d5a8dda5245fa4d90c9603c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b184b002d5a8dda5245fa4d90c9603c">populateXeGPUOptimizeBlockLoadsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a0b184b002d5a8dda5245fa4d90c9603c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for optimizing block load operations into <span class="tt">patterns</span>.  <br /></td></tr>
<tr class="memitem:af39a7d1520005ea372b9b513a1d7b442" id="r_af39a7d1520005ea372b9b513a1d7b442"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af39a7d1520005ea372b9b513a1d7b442">populateXeGPUSubgroupDistributePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:af39a7d1520005ea372b9b513a1d7b442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for XeGPU SIMT distribution into <span class="tt">patterns</span>.  <br /></td></tr>
<tr class="memitem:a506a123e6ed9ffb45954d19d8b233f0c" id="r_a506a123e6ed9ffb45954d19d8b233f0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a506a123e6ed9ffb45954d19d8b233f0c">populateXeGPUMoveFuncBodyToWarpOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a506a123e6ed9ffb45954d19d8b233f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for moving function body into gpu.warp_execute_on_lane0 op.  <br /></td></tr>
<tr class="memitem:aafe602b848e4d20950d3b63b62be81db" id="r_aafe602b848e4d20950d3b63b62be81db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafe602b848e4d20950d3b63b62be81db">populateXeGPUWgToSgDistributePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aafe602b848e4d20950d3b63b62be81db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for XeGPU workgroup to subgroup distribution into <span class="tt">patterns</span>.  <br /></td></tr>
<tr class="memitem:a2a6a1b5c8f4c32cbe9c5648017a727b0" id="r_a2a6a1b5c8f4c32cbe9c5648017a727b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a6a1b5c8f4c32cbe9c5648017a727b0">populateXeGPUUnrollPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="structmlir_1_1xegpu_1_1UnrollOptions.html">UnrollOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:a2a6a1b5c8f4c32cbe9c5648017a727b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to unroll xegpu operations to a smaller shapes.  <br /></td></tr>
<tr class="memitem:aeeae20690a58f5264daf481dbbeea718" id="r_aeeae20690a58f5264daf481dbbeea718"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeeae20690a58f5264daf481dbbeea718">flattenValues</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> &gt; values)</td></tr>
<tr class="memdesc:aeeae20690a58f5264daf481dbbeea718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten a set of <a class="el" href="classmlir_1_1ValueRange.html" title="This class provides an abstraction over the different types of ranges over Values.">ValueRange</a> into a single <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value&gt;</a>  <br /></td></tr>
<tr class="memitem:af95421174e54b5dfc990dfb4357fa13c" id="r_af95421174e54b5dfc990dfb4357fa13c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; VectorType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af95421174e54b5dfc990dfb4357fa13c">getDistributedVectorType</a> (xegpu::TensorDescType tdescTy)</td></tr>
<tr class="memdesc:af95421174e54b5dfc990dfb4357fa13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If tensor descriptor has a layout attribute it is used in SIMT mode.  <br /></td></tr>
<tr class="memitem:ae0234bd59b48f85eda9031bd92369343" id="r_ae0234bd59b48f85eda9031bd92369343"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; VectorType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0234bd59b48f85eda9031bd92369343">getDistributedVectorType</a> (VectorType originalType, LayoutAttr layout)</td></tr>
<tr class="memdesc:ae0234bd59b48f85eda9031bd92369343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to get the distributed vector type for a given vector type according to a given LayoutAttr.  <br /></td></tr>
<tr class="memitem:a672ad62c985a7ae405189e62c203dd64" id="r_a672ad62c985a7ae405189e62c203dd64"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a672ad62c985a7ae405189e62c203dd64">getLayoutName</a> (const <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;operand)</td></tr>
<tr class="memdesc:a672ad62c985a7ae405189e62c203dd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the attribute name for the <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> to attach DistributeLayoutAttr.  <br /></td></tr>
<tr class="memitem:ad7e16131cbf381ec91db7c11c881bccc" id="r_ad7e16131cbf381ec91db7c11c881bccc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7e16131cbf381ec91db7c11c881bccc">getLayoutName</a> (const <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> <a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memdesc:ad7e16131cbf381ec91db7c11c881bccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the attribute name for the <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> to attach DistributeLayoutAttr.  <br /></td></tr>
<tr class="memitem:a9ee7c8e8e7f2b771725494bc1a03d34f" id="r_a9ee7c8e8e7f2b771725494bc1a03d34f"><td class="memItemLeft" align="right" valign="top">DistributeLayoutAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ee7c8e8e7f2b771725494bc1a03d34f">getDistributeLayoutAttr</a> (const <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a9ee7c8e8e7f2b771725494bc1a03d34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the DistributeLayoutAttr associated with a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <br /></td></tr>
<tr class="memitem:a573db04f9c0e4ad6a124ce87207211ea" id="r_a573db04f9c0e4ad6a124ce87207211ea"><td class="memTemplParams" colspan="2">template&lt;typename AttrTy&gt; </td></tr>
<tr class="memitem:a573db04f9c0e4ad6a124ce87207211ea template"><td class="memItemLeft" align="right" valign="top">AttrTy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a573db04f9c0e4ad6a124ce87207211ea">getDistributeLayoutAttrOfType</a> (const <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memitem:a78826a829c5b6d5b7e9bfb34b4c4efab" id="r_a78826a829c5b6d5b7e9bfb34b4c4efab"><td class="memItemLeft" align="right" valign="top">DistributeLayoutAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78826a829c5b6d5b7e9bfb34b4c4efab">getDistributeLayoutAttr</a> (const <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;opr)</td></tr>
<tr class="memdesc:a78826a829c5b6d5b7e9bfb34b4c4efab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the DistributeLayoutAttr associated with a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>.  <br /></td></tr>
<tr class="memitem:ad8a318151281ddbd2b97dda586faf77e" id="r_ad8a318151281ddbd2b97dda586faf77e"><td class="memTemplParams" colspan="2">template&lt;typename AttrTy&gt; </td></tr>
<tr class="memitem:ad8a318151281ddbd2b97dda586faf77e template"><td class="memItemLeft" align="right" valign="top">AttrTy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8a318151281ddbd2b97dda586faf77e">getDistributeLayoutAttrOfType</a> (const <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;opr)</td></tr>
<tr class="memitem:a92279b8b5784964666324ae2f19da636" id="r_a92279b8b5784964666324ae2f19da636"><td class="memTemplParams" colspan="2">template&lt;typename T, typename = std::enable_if_t&lt;std::is_same_v&lt;T, OpOperand&gt; ||                                      std::is_same_v&lt;T, OpResult&gt;&gt;&gt; </td></tr>
<tr class="memitem:a92279b8b5784964666324ae2f19da636 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92279b8b5784964666324ae2f19da636">removeLayoutAttr</a> (const T &amp;operandOrResult)</td></tr>
<tr class="memdesc:a92279b8b5784964666324ae2f19da636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the LayoutAttr for a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> or <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> if it exists.  <br /></td></tr>
<tr class="memitem:ace8e74148db06970f9e51f8da0a7066d" id="r_ace8e74148db06970f9e51f8da0a7066d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace8e74148db06970f9e51f8da0a7066d">removeLayoutAttrs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ace8e74148db06970f9e51f8da0a7066d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the DistributeLayoutAttr for each <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> and <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> of the given operation if they exist.  <br /></td></tr>
<tr class="memitem:aa8f81b7c2ac49b6619b74f083312e4dd" id="r_aa8f81b7c2ac49b6619b74f083312e4dd"><td class="memTemplParams" colspan="2">template&lt;typename T, typename = std::enable_if_t&lt;std::is_same_v&lt;T, OpOperand&gt; ||                                      std::is_same_v&lt;T, OpResult&gt;&gt;&gt; </td></tr>
<tr class="memitem:aa8f81b7c2ac49b6619b74f083312e4dd template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8f81b7c2ac49b6619b74f083312e4dd">setDistributeLayoutAttr</a> (const T &amp;operandOrResult, const DistributeLayoutAttr layout, <a class="el" href="classbool.html">bool</a> respectPermLayout=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:aa8f81b7c2ac49b6619b74f083312e4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the DistributeLayoutAttr for a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> or <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> by attaching it to the owner's dictionary attributes If <span class="tt">respectPermLayout</span> is true the existing permament layout attribute will be kept and assigned to the attribute dict instead of the provided layout.  <br /></td></tr>
<tr class="memitem:a397eda9b2fa84b7d3efb02e3e00a31e2" id="r_a397eda9b2fa84b7d3efb02e3e00a31e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a397eda9b2fa84b7d3efb02e3e00a31e2">setDistributeLayoutAttrs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; DistributeLayoutAttr(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; getLayoutImpl)</td></tr>
<tr class="memdesc:a397eda9b2fa84b7d3efb02e3e00a31e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the DistributeLayoutAttr for each <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> and <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> of the given operation.  <br /></td></tr>
<tr class="memitem:ac75bd4eba883b91f2a5d2d178c191b23" id="r_ac75bd4eba883b91f2a5d2d178c191b23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac75bd4eba883b91f2a5d2d178c191b23">extractVectorsWithShapeFromValue</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; shape)</td></tr>
<tr class="memdesc:ac75bd4eba883b91f2a5d2d178c191b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a set of small vectors from a value with a given shape using vector.extract_stride_slice.  <br /></td></tr>
<tr class="memitem:a1324225dbcd24fdd170015ec6ac2cbda" id="r_a1324225dbcd24fdd170015ec6ac2cbda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1324225dbcd24fdd170015ec6ac2cbda">createVectorWithShapeFromValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; shape)</td></tr>
<tr class="memdesc:a1324225dbcd24fdd170015ec6ac2cbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vector of shape from a set of values using vector.insert_stride_slice.  <br /></td></tr>
<tr class="memitem:a953f1853d57571851e0d294bf32c1d6e" id="r_a953f1853d57571851e0d294bf32c1d6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a953f1853d57571851e0d294bf32c1d6e">doSCFStructuralTypeConversionWithTensorType</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classTypeConverter.html">TypeConverter</a> converter)</td></tr>
<tr class="memdesc:a953f1853d57571851e0d294bf32c1d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do type conversion for SCF structural ops, e.g., scf.for using SCF structure type convertion patterns.  <br /></td></tr>
<tr class="memitem:abe1887aba98e226a6b84b47df63e0151" id="r_abe1887aba98e226a6b84b47df63e0151"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe1887aba98e226a6b84b47df63e0151">getChipStr</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:abe1887aba98e226a6b84b47df63e0151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the chip string from the XeVM target attribute of the parent GPU module operation.  <br /></td></tr>
<tr class="memitem:af45e69b6fe92c401ee3457f7ee6d0fc0" id="r_af45e69b6fe92c401ee3457f7ee6d0fc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af45e69b6fe92c401ee3457f7ee6d0fc0">addElementwise</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memdesc:af45e69b6fe92c401ee3457f7ee6d0fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates element-wise addition ops of two arrays with same length.  <br /></td></tr>
<tr class="memitem:af3a085b51c7714f3da8b3af332508ae2" id="r_af3a085b51c7714f3da8b3af332508ae2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3a085b51c7714f3da8b3af332508ae2">addWithRightAligned</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memdesc:af3a085b51c7714f3da8b3af332508ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates element-wise addition ops of two arrays with automatic alignment.  <br /></td></tr>
<tr class="memitem:a6d1ba02e1046164793b6618cb619b1e9" id="r_a6d1ba02e1046164793b6618cb619b1e9"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a6d1ba02e1046164793b6618cb619b1e9 template"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d1ba02e1046164793b6618cb619b1e9">getLargestDivisor</a> (T dim, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; T &gt; candidates, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; T &gt; candidateMultiples={})</td></tr>
<tr class="memdesc:a6d1ba02e1046164793b6618cb619b1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper Function to find a proper instruction multiple for the user-supplied sg-level data shape (diven by <span class="tt">dim</span>).  <br /></td></tr>
<tr class="memitem:a88cd16532600b8b905da23f8ed62638f" id="r_a88cd16532600b8b905da23f8ed62638f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88cd16532600b8b905da23f8ed62638f">genCoordinates</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; delinearizedId, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; subShapesLayout, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; subShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; srcShape)</td></tr>
<tr class="memitem:a16d6d8758d3d546c909e7f84b73a5461" id="r_a16d6d8758d3d546c909e7f84b73a5461"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16d6d8758d3d546c909e7f84b73a5461">adjustUnitDimsWithSliceDims</a> (const <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;unitDims, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; sliceDims)</td></tr>
<tr class="memitem:a682700c5cbdc508e81f26bd1a03258a7" id="r_a682700c5cbdc508e81f26bd1a03258a7"><td class="memTemplParams" colspan="2">template&lt;typename ArithOp&gt; </td></tr>
<tr class="memitem:a682700c5cbdc508e81f26bd1a03258a7 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a682700c5cbdc508e81f26bd1a03258a7">genBinOp</a> (<a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> a, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> <a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memitem:a5f3fc89d89baca80271a85f3a44fff23" id="r_a5f3fc89d89baca80271a85f3a44fff23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f3fc89d89baca80271a85f3a44fff23">getBlockedOffsets</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; blockShape)</td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="af45e69b6fe92c401ee3457f7ee6d0fc0" name="af45e69b6fe92c401ee3457f7ee6d0fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45e69b6fe92c401ee3457f7ee6d0fc0">&#9670;&#160;</a></span>addElementwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::xegpu::addElementwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates element-wise addition ops of two arrays with same length. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00520">520</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00526">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00545">addWithRightAligned()</a>.</p>

</div>
</div>
<a id="af3a085b51c7714f3da8b3af332508ae2" name="af3a085b51c7714f3da8b3af332508ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a085b51c7714f3da8b3af332508ae2">&#9670;&#160;</a></span>addWithRightAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::xegpu::addWithRightAligned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates element-wise addition ops of two arrays with automatic alignment. </p>
<p>When the input arrays have different sizes, the shorter array is right-aligned with the longer array, and the unmatched leading elements from the longer array are preserved unchanged. This is commonly used for offset computation where higher-dimensional offsets need to be added to lower-dimensional adjustments.</p>
<p>Example: lhs = [l1, l2, l3], rhs = [r1, r2] Result: [11, l2+r1, l3+r2] </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00545">545</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="XeGPUUtils_8cpp_source.html#l00520">addElementwise()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="a16d6d8758d3d546c909e7f84b73a5461" name="a16d6d8758d3d546c909e7f84b73a5461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d6d8758d3d546c909e7f84b73a5461">&#9670;&#160;</a></span>adjustUnitDimsWithSliceDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::xegpu::adjustUnitDimsWithSliceDims </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>unitDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sliceDims</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUDialect_8cpp_source.html#l00606">606</a> of file <a class="el" href="XeGPUDialect_8cpp_source.html">XeGPUDialect.cpp</a>.</p>

</div>
</div>
<a id="a1324225dbcd24fdd170015ec6ac2cbda" name="a1324225dbcd24fdd170015ec6ac2cbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1324225dbcd24fdd170015ec6ac2cbda">&#9670;&#160;</a></span>createVectorWithShapeFromValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::xegpu::createVectorWithShapeFromValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a vector of shape from a set of values using vector.insert_stride_slice. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00329">329</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>, <a class="el" href="classmlir_1_1ValueRange.html#ab8f3a1aeea4da0acfaad1bc71b072017">mlir::ValueRange::getTypes()</a>, <a class="el" href="Builders_8cpp_source.html#l00324">mlir::Builder::getZeroAttr()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUBlocking_8cpp_source.html#l00062">mlir::xegpu::impl::XeGPUBlockingBase&lt; DerivedT &gt;::clonePass()</a>.</p>

</div>
</div>
<a id="aec6af0d93824b476c2cf45780580c3ad" name="aec6af0d93824b476c2cf45780580c3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6af0d93824b476c2cf45780580c3ad">&#9670;&#160;</a></span>createXeGPUBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::xegpu::createXeGPUBlocking </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUBlocking_8cpp_source.html#l00088">88</a> of file <a class="el" href="XeGPUBlocking_8cpp_source.html">XeGPUBlocking.cpp</a>.</p>

</div>
</div>
<a id="a107b2ac17ac9d677f8e4be7baa12087b" name="a107b2ac17ac9d677f8e4be7baa12087b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107b2ac17ac9d677f8e4be7baa12087b">&#9670;&#160;</a></span>createXeGPUFoldAliasOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::xegpu::createXeGPUFoldAliasOps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUFoldAliasOps_8cpp_source.html#l00164">164</a> of file <a class="el" href="XeGPUFoldAliasOps_8cpp_source.html">XeGPUFoldAliasOps.cpp</a>.</p>

</div>
</div>
<a id="a9b18ab8d4506680a9cebcba77019b391" name="a9b18ab8d4506680a9cebcba77019b391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b18ab8d4506680a9cebcba77019b391">&#9670;&#160;</a></span>createXeGPUOptimizeBlockLoads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::xegpu::createXeGPUOptimizeBlockLoads </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUOptimizeBlockLoads_8cpp_source.html#l00241">241</a> of file <a class="el" href="XeGPUOptimizeBlockLoads_8cpp_source.html">XeGPUOptimizeBlockLoads.cpp</a>.</p>

<p class="reference">References <a class="el" href="XeGPUUtils_8cpp_source.html#l00501">getChipStr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="IntelGpuXe2_8h_source.html#l00268">mlir::xegpu::uArch::getUArch()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="af151cb970a71e5e0f030af9c829580fd" name="af151cb970a71e5e0f030af9c829580fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af151cb970a71e5e0f030af9c829580fd">&#9670;&#160;</a></span>createXeGPUPropagateLayout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::xegpu::createXeGPUPropagateLayout </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUPropagateLayout_8cpp_source.html#l00337">337</a> of file <a class="el" href="XeGPUPropagateLayout_8cpp_source.html">XeGPUPropagateLayout.cpp</a>.</p>

</div>
</div>
<a id="a379e7abd2029bd1cae2c8e304524be08" name="a379e7abd2029bd1cae2c8e304524be08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379e7abd2029bd1cae2c8e304524be08">&#9670;&#160;</a></span>createXeGPUPropagateLayout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::xegpu::createXeGPUPropagateLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1xegpu_1_1XeGPUPropagateLayoutOptions.html">XeGPUPropagateLayoutOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUPropagateLayout_8cpp_source.html#l00341">341</a> of file <a class="el" href="XeGPUPropagateLayout_8cpp_source.html">XeGPUPropagateLayout.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00148">broadcast()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01923">load</a>.</p>

</div>
</div>
<a id="a5b2675b3e75bfc781dae2c287e483aba" name="a5b2675b3e75bfc781dae2c287e483aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2675b3e75bfc781dae2c287e483aba">&#9670;&#160;</a></span>createXeGPUSubgroupDistribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::xegpu::createXeGPUSubgroupDistribute </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUSubgroupDistribute_8cpp_source.html#l00419">419</a> of file <a class="el" href="XeGPUSubgroupDistribute_8cpp_source.html">XeGPUSubgroupDistribute.cpp</a>.</p>

</div>
</div>
<a id="ab3451f306d3e0b602adfd9785559ef05" name="ab3451f306d3e0b602adfd9785559ef05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3451f306d3e0b602adfd9785559ef05">&#9670;&#160;</a></span>createXeGPUVectorLinearize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::xegpu::createXeGPUVectorLinearize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUVectorLinearize_8cpp_source.html#l00498">498</a> of file <a class="el" href="XeGPUVectorLinearize_8cpp_source.html">XeGPUVectorLinearize.cpp</a>.</p>

</div>
</div>
<a id="a8e585364013e34a53ee20c9e97f6743c" name="a8e585364013e34a53ee20c9e97f6743c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e585364013e34a53ee20c9e97f6743c">&#9670;&#160;</a></span>createXeGPUWgToSgDistribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::xegpu::createXeGPUWgToSgDistribute </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUWgToSgDistribute_8cpp_source.html#l00578">578</a> of file <a class="el" href="XeGPUWgToSgDistribute_8cpp_source.html">XeGPUWgToSgDistribute.cpp</a>.</p>

</div>
</div>
<a id="a953f1853d57571851e0d294bf32c1d6e" name="a953f1853d57571851e0d294bf32c1d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953f1853d57571851e0d294bf32c1d6e">&#9670;&#160;</a></span>doSCFStructuralTypeConversionWithTensorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::doSCFStructuralTypeConversionWithTensorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypeConverter.html">TypeConverter</a></td>          <td class="paramname"><span class="paramname"><em>converter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do type conversion for SCF structural ops, e.g., scf.for using SCF structure type convertion patterns. </p>
<p>Since VectorType cannot carry the layout attribute, which is needed to guide the type conversion for XeGPU, they are first converted into RankedTensorType, where the layout attribute can be attached. And then upstream SCF structural type conversion patterns are applied with the provided converter. TODO: This is a temporary solution. We should refactor it when context-aware type conversion is available. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00354">354</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00031">flattenValues()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00115">getDistributeLayoutAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00397">mlir::Operation::getOperandTypes()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00420">mlir::Operation::getOpResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00428">mlir::Operation::getResultTypes()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, <a class="el" href="SCF_2Transforms_2StructuralTypeConversions_8cpp_source.html#l00267">mlir::scf::populateSCFStructuralTypeConversionsAndLegality()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, <a class="el" href="Value_8h_source.html#l00116">mlir::Value::setType()</a>, <a class="el" href="WalkResult_8h_source.html#l00048">mlir::WalkResult::skip()</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="ac75bd4eba883b91f2a5d2d178c191b23" name="ac75bd4eba883b91f2a5d2d178c191b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75bd4eba883b91f2a5d2d178c191b23">&#9670;&#160;</a></span>extractVectorsWithShapeFromValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::xegpu::extractVectorsWithShapeFromValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a set of small vectors from a value with a given shape using vector.extract_stride_slice. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00292">292</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00106">mlir::computeShapeRatio()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="aeeae20690a58f5264daf481dbbeea718" name="aeeae20690a58f5264daf481dbbeea718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeae20690a58f5264daf481dbbeea718">&#9670;&#160;</a></span>flattenValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::xegpu::flattenValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten a set of <a class="el" href="classmlir_1_1ValueRange.html" title="This class provides an abstraction over the different types of ranges over Values.">ValueRange</a> into a single <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value&gt;</a> </p>
<p>convert <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;ValueRange&gt;</a> into <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value&gt;</a> </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00031">31</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00354">doSCFStructuralTypeConversionWithTensorType()</a>.</p>

</div>
</div>
<a id="a682700c5cbdc508e81f26bd1a03258a7" name="a682700c5cbdc508e81f26bd1a03258a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682700c5cbdc508e81f26bd1a03258a7">&#9670;&#160;</a></span>genBinOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArithOp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::xegpu::genBinOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUDialect_8cpp_source.html#l00956">956</a> of file <a class="el" href="XeGPUDialect_8cpp_source.html">XeGPUDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>.</p>

</div>
</div>
<a id="a88cd16532600b8b905da23f8ed62638f" name="a88cd16532600b8b905da23f8ed62638f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cd16532600b8b905da23f8ed62638f">&#9670;&#160;</a></span>genCoordinates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; mlir::xegpu::genCoordinates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>delinearizedId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>subShapesLayout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>subShape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>srcShape</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUDialect_8cpp_source.html#l00048">48</a> of file <a class="el" href="XeGPUDialect_8cpp_source.html">XeGPUDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00079">mlir::computeElementwiseMul()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, and <a class="el" href="Builders_8h_source.html#l00526">mlir::OpBuilder::createOrFold()</a>.</p>

</div>
</div>
<a id="a5f3fc89d89baca80271a85f3a44fff23" name="a5f3fc89d89baca80271a85f3a44fff23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3fc89d89baca80271a85f3a44fff23">&#9670;&#160;</a></span>getBlockedOffsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::xegpu::getBlockedOffsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>blockShape</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUDialect_8cpp_source.html#l00981">981</a> of file <a class="el" href="XeGPUDialect_8cpp_source.html">XeGPUDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="XeGPUDialect_8cpp_source.html#l00964">div</a>, and <a class="el" href="XeGPUDialect_8cpp_source.html#l00968">rem</a>.</p>

</div>
</div>
<a id="abe1887aba98e226a6b84b47df63e0151" name="abe1887aba98e226a6b84b47df63e0151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1887aba98e226a6b84b47df63e0151">&#9670;&#160;</a></span>getChipStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::string &gt; mlir::xegpu::getChipStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the chip string from the XeVM target attribute of the parent GPU module operation. </p>
<p>Returns the chip identifier if found, or nullopt if no GPU module parent or XeVM target attribute exists. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00501">501</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00238">mlir::Operation::getParentOfType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUOptimizeBlockLoads_8cpp_source.html#l00241">createXeGPUOptimizeBlockLoads()</a>.</p>

</div>
</div>
<a id="ae0234bd59b48f85eda9031bd92369343" name="ae0234bd59b48f85eda9031bd92369343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0234bd59b48f85eda9031bd92369343">&#9670;&#160;</a></span>getDistributedVectorType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; VectorType &gt; mlir::xegpu::getDistributedVectorType </td>
          <td>(</td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>originalType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LayoutAttr</td>          <td class="paramname"><span class="paramname"><em>layout</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to get the distributed vector type for a given vector type according to a given LayoutAttr. </p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="af95421174e54b5dfc990dfb4357fa13c" name="af95421174e54b5dfc990dfb4357fa13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95421174e54b5dfc990dfb4357fa13c">&#9670;&#160;</a></span>getDistributedVectorType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; VectorType &gt; mlir::xegpu::getDistributedVectorType </td>
          <td>(</td>
          <td class="paramtype">xegpu::TensorDescType</td>          <td class="paramname"><span class="paramname"><em>tdescTy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If tensor descriptor has a layout attribute it is used in SIMT mode. </p>
<p>In this mode, the distributed vector shape is determined as follows: Definitions: lane_data_size = lane_data[0]  lane_data[1] subgroup_size = lane_layout[0]  lane_layout[1] distribution_unit_size = subgroup_size  lane_data_size</p>
<p>Case 1: Regular loads/stores. The following conditions must be met:</p><ul>
<li>tensor_desc[0] == lane_layout[0] Distributed vector is a 1D vector with shape: [chunk_size]</li>
</ul>
<p>Case 2: <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a> loads/stores Additional definitions: tensor_size = tensor_desc[0] * .. * tensor_desc[r-1] * array_length n_distribution_units = tensor_size / distribution_unit_size fragment_size = n_distribution_units * lane_data_size Given above definitions, the following conditions must be met:</p><ul>
<li>tensor_desc[0] % (lane_layout[0]  lane_data[0]) == 0</li>
<li>tensor_desc[1] % (lane_layout[1]  lane_data[1]) == 0 Distributed vector is a 1D vector with shape: [fragment_size] </li>
</ul>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00039">39</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

</div>
</div>
<a id="a78826a829c5b6d5b7e9bfb34b4c4efab" name="a78826a829c5b6d5b7e9bfb34b4c4efab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78826a829c5b6d5b7e9bfb34b4c4efab">&#9670;&#160;</a></span>getDistributeLayoutAttr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xegpu::DistributeLayoutAttr mlir::xegpu::getDistributeLayoutAttr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the DistributeLayoutAttr associated with a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>. </p>
<p>It will first check the operand_layout_{id} of the owner operation. If not found, it will check the operand itself and its defining op. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00165">165</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00115">getDistributeLayoutAttr()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00104">getLayoutName()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00560">mlir::Operation::hasAttr()</a>.</p>

</div>
</div>
<a id="a9ee7c8e8e7f2b771725494bc1a03d34f" name="a9ee7c8e8e7f2b771725494bc1a03d34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee7c8e8e7f2b771725494bc1a03d34f">&#9670;&#160;</a></span>getDistributeLayoutAttr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xegpu::DistributeLayoutAttr mlir::xegpu::getDistributeLayoutAttr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the DistributeLayoutAttr associated with a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>
<p>For TensorDescType values, the DistributeLayoutAttr is extracted from the TensorDescType itself. For other values, it is obtained from the attributes of the defining operation. Returns nullptr if no DistributeLayoutAttr is found. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00115">115</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00550">mlir::Operation::getAttrOfType()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00115">getDistributeLayoutAttr()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00104">getLayoutName()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00560">mlir::Operation::hasAttr()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00354">doSCFStructuralTypeConversionWithTensorType()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00165">getDistributeLayoutAttr()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00115">getDistributeLayoutAttr()</a>, <a class="el" href="XeGPUUtils_8h_source.html#l00090">getDistributeLayoutAttrOfType()</a>, and <a class="el" href="XeGPUUtils_8h_source.html#l00080">getDistributeLayoutAttrOfType()</a>.</p>

</div>
</div>
<a id="ad8a318151281ddbd2b97dda586faf77e" name="ad8a318151281ddbd2b97dda586faf77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a318151281ddbd2b97dda586faf77e">&#9670;&#160;</a></span>getDistributeLayoutAttrOfType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AttrTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">AttrTy mlir::xegpu::getDistributeLayoutAttrOfType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8h_source.html#l00090">90</a> of file <a class="el" href="XeGPUUtils_8h_source.html">XeGPUUtils.h</a>.</p>

<p class="reference">References <a class="el" href="XeGPUUtils_8cpp_source.html#l00115">getDistributeLayoutAttr()</a>.</p>

</div>
</div>
<a id="a573db04f9c0e4ad6a124ce87207211ea" name="a573db04f9c0e4ad6a124ce87207211ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573db04f9c0e4ad6a124ce87207211ea">&#9670;&#160;</a></span>getDistributeLayoutAttrOfType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AttrTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">AttrTy mlir::xegpu::getDistributeLayoutAttrOfType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8h_source.html#l00080">80</a> of file <a class="el" href="XeGPUUtils_8h_source.html">XeGPUUtils.h</a>.</p>

<p class="reference">References <a class="el" href="XeGPUUtils_8cpp_source.html#l00115">getDistributeLayoutAttr()</a>.</p>

</div>
</div>
<a id="a6d1ba02e1046164793b6618cb619b1e9" name="a6d1ba02e1046164793b6618cb619b1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1ba02e1046164793b6618cb619b1e9">&#9670;&#160;</a></span>getLargestDivisor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int mlir::xegpu::getLargestDivisor </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>candidates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>candidateMultiples</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper Function to find a proper instruction multiple for the user-supplied sg-level data shape (diven by <span class="tt">dim</span>). </p>
<p><span class="tt">candidates</span> are <a class="el" href="namespacemlir_1_1xegpu_1_1uArch.html">uArch</a> allowed shapes. <span class="tt">candidateMultiples</span> are <a class="el" href="namespacemlir_1_1xegpu_1_1uArch.html">uArch</a> multiples of such shapes (i.e. block count or array length). </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00558">558</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

</div>
</div>
<a id="a672ad62c985a7ae405189e62c203dd64" name="a672ad62c985a7ae405189e62c203dd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672ad62c985a7ae405189e62c203dd64">&#9670;&#160;</a></span>getLayoutName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::xegpu::getLayoutName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>operand</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the attribute name for the <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> to attach DistributeLayoutAttr. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00104">104</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00165">getDistributeLayoutAttr()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00115">getDistributeLayoutAttr()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00267">removeLayoutAttr()</a>, and <a class="el" href="XeGPUUtils_8cpp_source.html#l00222">setDistributeLayoutAttr()</a>.</p>

</div>
</div>
<a id="ad7e16131cbf381ec91db7c11c881bccc" name="ad7e16131cbf381ec91db7c11c881bccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e16131cbf381ec91db7c11c881bccc">&#9670;&#160;</a></span>getLayoutName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::xegpu::getLayoutName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OpResult.html">OpResult</a></td>          <td class="paramname"><span class="paramname"><em>result</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the attribute name for the <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> to attach DistributeLayoutAttr. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00110">110</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="a75f0c70660bc13821493fc7c5b9ffa28" name="a75f0c70660bc13821493fc7c5b9ffa28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f0c70660bc13821493fc7c5b9ffa28">&#9670;&#160;</a></span>populateXeGPUFoldAliasOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::populateXeGPUFoldAliasOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for folding aliasing ops into XeGPU ops into <span class="tt">patterns</span>. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUFoldAliasOps_8cpp_source.html#l00063">63</a> of file <a class="el" href="XeGPUFoldAliasOps_8cpp_source.html">XeGPUFoldAliasOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a506a123e6ed9ffb45954d19d8b233f0c" name="a506a123e6ed9ffb45954d19d8b233f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506a123e6ed9ffb45954d19d8b233f0c">&#9670;&#160;</a></span>populateXeGPUMoveFuncBodyToWarpOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::populateXeGPUMoveFuncBodyToWarpOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for moving function body into gpu.warp_execute_on_lane0 op. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUSubgroupDistribute_8cpp_source.html#l02045">2045</a> of file <a class="el" href="XeGPUSubgroupDistribute_8cpp_source.html">XeGPUSubgroupDistribute.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a0b184b002d5a8dda5245fa4d90c9603c" name="a0b184b002d5a8dda5245fa4d90c9603c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b184b002d5a8dda5245fa4d90c9603c">&#9670;&#160;</a></span>populateXeGPUOptimizeBlockLoadsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::populateXeGPUOptimizeBlockLoadsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for optimizing block load operations into <span class="tt">patterns</span>. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUOptimizeBlockLoads_8cpp_source.html#l00421">421</a> of file <a class="el" href="XeGPUOptimizeBlockLoads_8cpp_source.html">XeGPUOptimizeBlockLoads.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="af39a7d1520005ea372b9b513a1d7b442" name="af39a7d1520005ea372b9b513a1d7b442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39a7d1520005ea372b9b513a1d7b442">&#9670;&#160;</a></span>populateXeGPUSubgroupDistributePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::populateXeGPUSubgroupDistributePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for XeGPU SIMT distribution into <span class="tt">patterns</span>. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUSubgroupDistribute_8cpp_source.html#l02025">2025</a> of file <a class="el" href="XeGPUSubgroupDistribute_8cpp_source.html">XeGPUSubgroupDistribute.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a2a6a1b5c8f4c32cbe9c5648017a727b0" name="a2a6a1b5c8f4c32cbe9c5648017a727b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6a1b5c8f4c32cbe9c5648017a727b0">&#9670;&#160;</a></span>populateXeGPUUnrollPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::populateXeGPUUnrollPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1xegpu_1_1UnrollOptions.html">UnrollOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to unroll xegpu operations to a smaller shapes. </p>
<p>Users can control whether an operation to be unrolled or not, as well as its target shape via <span class="tt">options</span> structure. (via setting filterConstraint and nativeShape respectively, both of them are function refs taking <span class="tt">op</span> as input). An <span class="tt">op</span> is unrolled to the <span class="tt">targetShape</span> as follows, for each of its operands:</p><ol type="1">
<li>the unrolled type <span class="tt">unrolledType</span> and number of unrolled instances <span class="tt">numUnrolledInstances</span> are computed from the <span class="tt">targetShape</span>.</li>
<li>pack each operand. ExtractStridedSlice are created to break-up the vector operands. And BuiltinUnrealizedCastop are created to break-up the TensorDesc operands.</li>
<li>the original op is cloned <span class="tt">numUnrolledInstances</span> times, once for each result.</li>
<li>unpack the results. InsertStridedSlice are inserted for VectorType result, and BuiltinUnrealizedCastOp are inserted for TensorDescType result to re-assemble the slices into the original shape. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="XeGPUUnroll_8cpp_source.html#l01033">1033</a> of file <a class="el" href="XeGPUUnroll_8cpp_source.html">XeGPUUnroll.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="aafe602b848e4d20950d3b63b62be81db" name="aafe602b848e4d20950d3b63b62be81db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe602b848e4d20950d3b63b62be81db">&#9670;&#160;</a></span>populateXeGPUWgToSgDistributePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::populateXeGPUWgToSgDistributePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for XeGPU workgroup to subgroup distribution into <span class="tt">patterns</span>. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUWgToSgDistribute_8cpp_source.html#l01366">1366</a> of file <a class="el" href="XeGPUWgToSgDistribute_8cpp_source.html">XeGPUWgToSgDistribute.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a07ce62acc531cdfebfc973879dc89e1b" name="a07ce62acc531cdfebfc973879dc89e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ce62acc531cdfebfc973879dc89e1b">&#9670;&#160;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="XeGPUTransformOps_8cpp_source.html#l00693">693</a> of file <a class="el" href="XeGPUTransformOps_8cpp_source.html">XeGPUTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00222">mlir::DialectRegistry::addExtensions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a1d6b086c6748c9daa1ecb456b4854fd8" name="a1d6b086c6748c9daa1ecb456b4854fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6b086c6748c9daa1ecb456b4854fd8">&#9670;&#160;</a></span>registerXeGPUBlocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::registerXeGPUBlocking </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html#l00599">599</a> of file <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ac85425b1751f44d2c6450d5dc7f2cbd7" name="ac85425b1751f44d2c6450d5dc7f2cbd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85425b1751f44d2c6450d5dc7f2cbd7">&#9670;&#160;</a></span>registerXeGPUBlockingPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::registerXeGPUBlockingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html#l00606">606</a> of file <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a8878ae224cd253642b1ca818b48227cb" name="a8878ae224cd253642b1ca818b48227cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8878ae224cd253642b1ca818b48227cb">&#9670;&#160;</a></span>registerXeGPUFoldAliasOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::registerXeGPUFoldAliasOps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html#l00620">620</a> of file <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ab338281d7cc0e26e2906258e936a4b40" name="ab338281d7cc0e26e2906258e936a4b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab338281d7cc0e26e2906258e936a4b40">&#9670;&#160;</a></span>registerXeGPUFoldAliasOpsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::registerXeGPUFoldAliasOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html#l00627">627</a> of file <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a87fa609e5f081d890c4596e81b8c4291" name="a87fa609e5f081d890c4596e81b8c4291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fa609e5f081d890c4596e81b8c4291">&#9670;&#160;</a></span>registerXeGPUOptimizeBlockLoads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::registerXeGPUOptimizeBlockLoads </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html#l00641">641</a> of file <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a24710424ab0218eb70982bc036211928" name="a24710424ab0218eb70982bc036211928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24710424ab0218eb70982bc036211928">&#9670;&#160;</a></span>registerXeGPUOptimizeBlockLoadsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::registerXeGPUOptimizeBlockLoadsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html#l00648">648</a> of file <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a7a50498e0455e0f75568e5d17af7275d" name="a7a50498e0455e0f75568e5d17af7275d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a50498e0455e0f75568e5d17af7275d">&#9670;&#160;</a></span>registerXeGPUPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::registerXeGPUPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html#l00746">746</a> of file <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllPasses_8cpp_source.html#l00059">mlir::registerAllPasses()</a>.</p>

</div>
</div>
<a id="a59103d9c21b3ffe2ba19023e6b256be2" name="a59103d9c21b3ffe2ba19023e6b256be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59103d9c21b3ffe2ba19023e6b256be2">&#9670;&#160;</a></span>registerXeGPUPropagateLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::registerXeGPUPropagateLayout </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html#l00662">662</a> of file <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a760af1f7125f3fb4cd3c5badfaa3ba8b" name="a760af1f7125f3fb4cd3c5badfaa3ba8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760af1f7125f3fb4cd3c5badfaa3ba8b">&#9670;&#160;</a></span>registerXeGPUPropagateLayoutPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::registerXeGPUPropagateLayoutPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html#l00669">669</a> of file <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a0193ac24187b69430fedb1f7fac78597" name="a0193ac24187b69430fedb1f7fac78597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0193ac24187b69430fedb1f7fac78597">&#9670;&#160;</a></span>registerXeGPUSubgroupDistribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::registerXeGPUSubgroupDistribute </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html#l00683">683</a> of file <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a0a8b8cafd4ef007ecda9ec14cba12f34" name="a0a8b8cafd4ef007ecda9ec14cba12f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8b8cafd4ef007ecda9ec14cba12f34">&#9670;&#160;</a></span>registerXeGPUSubgroupDistributePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::registerXeGPUSubgroupDistributePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html#l00690">690</a> of file <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ae7616e68041e2728498843b28bedc3d5" name="ae7616e68041e2728498843b28bedc3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7616e68041e2728498843b28bedc3d5">&#9670;&#160;</a></span>registerXeGPUVectorLinearize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::registerXeGPUVectorLinearize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html#l00704">704</a> of file <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a2189cd487278a604041160adbf452847" name="a2189cd487278a604041160adbf452847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2189cd487278a604041160adbf452847">&#9670;&#160;</a></span>registerXeGPUVectorLinearizePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::registerXeGPUVectorLinearizePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html#l00711">711</a> of file <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="af544ae99b7f5389d19d399ef9299f483" name="af544ae99b7f5389d19d399ef9299f483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af544ae99b7f5389d19d399ef9299f483">&#9670;&#160;</a></span>registerXeGPUWgToSgDistribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::registerXeGPUWgToSgDistribute </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html#l00725">725</a> of file <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a383162aa92b2b35b3b776d23d4312c6c" name="a383162aa92b2b35b3b776d23d4312c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383162aa92b2b35b3b776d23d4312c6c">&#9670;&#160;</a></span>registerXeGPUWgToSgDistributePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::registerXeGPUWgToSgDistributePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html#l00732">732</a> of file <a class="el" href="Dialect_2XeGPU_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a92279b8b5784964666324ae2f19da636" name="a92279b8b5784964666324ae2f19da636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92279b8b5784964666324ae2f19da636">&#9670;&#160;</a></span>removeLayoutAttr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename = std::enable_if_t&lt;std::is_same_v&lt;T, OpOperand&gt; ||                                      std::is_same_v&lt;T, OpResult&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::removeLayoutAttr </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>operandOrResult</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the LayoutAttr for a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> or <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> if it exists. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00267">267</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="XeGPUUtils_8cpp_source.html#l00104">getLayoutName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00575">mlir::Operation::hasAttrOfType()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00600">mlir::Operation::removeAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00282">removeLayoutAttrs()</a>, <a class="el" href="XeGPUUtils_8cpp.html#a9826b0d043ee3e7b653fff24c279b1a7">xegpu::removeLayoutAttr&lt; mlir::OpOperand &gt;()</a>, and <a class="el" href="XeGPUUtils_8cpp.html#ac20ad44269aa7da96a70595d278dcb59">xegpu::removeLayoutAttr&lt; mlir::OpResult &gt;()</a>.</p>

</div>
</div>
<a id="ace8e74148db06970f9e51f8da0a7066d" name="ace8e74148db06970f9e51f8da0a7066d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8e74148db06970f9e51f8da0a7066d">&#9670;&#160;</a></span>removeLayoutAttrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::removeLayoutAttrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the DistributeLayoutAttr for each <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> and <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> of the given operation if they exist. </p>
<p>If the operation contains regions, it is also applied recursively to the contained operations </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00282">282</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00420">mlir::Operation::getOpResults()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00267">removeLayoutAttr()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="aa8f81b7c2ac49b6619b74f083312e4dd" name="aa8f81b7c2ac49b6619b74f083312e4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f81b7c2ac49b6619b74f083312e4dd">&#9670;&#160;</a></span>setDistributeLayoutAttr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename = std::enable_if_t&lt;std::is_same_v&lt;T, OpOperand&gt; ||                                      std::is_same_v&lt;T, OpResult&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::setDistributeLayoutAttr </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>operandOrResult</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DistributeLayoutAttr</td>          <td class="paramname"><span class="paramname"><em>layout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>respectPermLayout</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the DistributeLayoutAttr for a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> or <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> by attaching it to the owner's dictionary attributes If <span class="tt">respectPermLayout</span> is true the existing permament layout attribute will be kept and assigned to the attribute dict instead of the provided layout. </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00222">222</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="XeGPUUtils_8cpp_source.html#l00104">getLayoutName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00575">mlir::Operation::hasAttrOfType()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00189">maybePickPermanentLayout()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00582">mlir::Operation::setAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00249">setDistributeLayoutAttrs()</a>, <a class="el" href="XeGPUPropagateLayout_8cpp_source.html#l01204">updateControlFlowOps()</a>, <a class="el" href="XeGPUPropagateLayout_8cpp_source.html#l01146">updateOp()</a>, <a class="el" href="XeGPUUtils_8cpp.html#a8a545a417140d0c3598b68784e9c54b7">xegpu::setDistributeLayoutAttr&lt; mlir::OpOperand &gt;()</a>, and <a class="el" href="XeGPUUtils_8cpp.html#abeb31951a0bc33a299b6ffb3b15a352e">xegpu::setDistributeLayoutAttr&lt; mlir::OpResult &gt;()</a>.</p>

</div>
</div>
<a id="a397eda9b2fa84b7d3efb02e3e00a31e2" name="a397eda9b2fa84b7d3efb02e3e00a31e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397eda9b2fa84b7d3efb02e3e00a31e2">&#9670;&#160;</a></span>setDistributeLayoutAttrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::xegpu::setDistributeLayoutAttrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; DistributeLayoutAttr(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>getLayoutImpl</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the DistributeLayoutAttr for each <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> and <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> of the given operation. </p>
<p>If the operation contains regions, it is also applied recursively to the contained operations </p>

<p class="definition">Definition at line <a class="el" href="XeGPUUtils_8cpp_source.html#l00249">249</a> of file <a class="el" href="XeGPUUtils_8cpp_source.html">XeGPUUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00383">mlir::Operation::getOpOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00420">mlir::Operation::getOpResults()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00222">setDistributeLayoutAttr()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
