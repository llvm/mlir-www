<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::bufferization Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1bufferization.html">bufferization</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::bufferization Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1bufferization_1_1deallocation__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization_1_1deallocation__impl.html">deallocation_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1bufferization_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1bufferization_1_1func__ext"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization_1_1func__ext.html">func_ext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1ValueComparator.html">ValueComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two SSA values in a deterministic manner.  <a href="structmlir_1_1bufferization_1_1ValueComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1Ownership.html">Ownership</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to track the ownership of values.  <a href="classmlir_1_1bufferization_1_1Ownership.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1DeallocationOptions.html">DeallocationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for BufferDeallocationOpInterface-based buffer deallocation.  <a href="structmlir_1_1bufferization_1_1DeallocationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html">DeallocationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class collects all the state that we need to perform the buffer deallocation pass with associated helper functions such that we have easy access to it in the BufferDeallocationOpInterface implementations and the BufferDeallocation pass.  <a href="classmlir_1_1bufferization_1_1DeallocationState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1AliasingOpOperand.html">AliasingOpOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A maybe aliasing <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>.  <a href="structmlir_1_1bufferization_1_1AliasingOpOperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1AliasingValue.html">AliasingValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A maybe aliasing <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="structmlir_1_1bufferization_1_1AliasingValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1AliasList.html">AliasList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1OpFilter.html">OpFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for BufferizableOpInterface-based bufferization.  <a href="structmlir_1_1bufferization_1_1BufferizationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1TraversalConfig.html">TraversalConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traversal parameters for <code>findValueInReverseUseDefChain</code>.  <a href="structmlir_1_1bufferization_1_1TraversalConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">AnalysisState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html" title="AnalysisState provides a variety of helper functions for dealing with tensor values.">AnalysisState</a> provides a variety of helper functions for dealing with tensor values.  <a href="classmlir_1_1bufferization_1_1AnalysisState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html" title="BufferizationState provides information about the state of the IR during the bufferization process.">BufferizationState</a> provides information about the state of the IR during the bufferization process.  <a href="classmlir_1_1bufferization_1_1BufferizationState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1DstBufferizableOpInterfaceExternalModel.html">DstBufferizableOpInterfaceExternalModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferizable ops that implement the DestinationStyleOpInterface can use this external model base class.  <a href="structmlir_1_1bufferization_1_1DstBufferizableOpInterfaceExternalModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1OpWithUnstructuredControlFlowBufferizableOpInterfaceExternalModel.html">OpWithUnstructuredControlFlowBufferizableOpInterfaceExternalModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template that provides a default implementation of <code>getAliasingOpOperands</code> for ops that support unstructured control flow within their regions.  <a href="structmlir_1_1bufferization_1_1OpWithUnstructuredControlFlowBufferizableOpInterfaceExternalModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BranchOpBufferizableOpInterfaceExternalModel.html">BranchOpBufferizableOpInterfaceExternalModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template that provides a default implementation of <code>getAliasingValues</code> for ops that implement the <code>BranchOpInterface</code>.  <a href="structmlir_1_1bufferization_1_1BranchOpBufferizableOpInterfaceExternalModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BufferDeallocationPipelineOptions.html">BufferDeallocationPipelineOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the buffer deallocation pipeline.  <a href="structmlir_1_1bufferization_1_1BufferDeallocationPipelineOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferization statistics for debugging.  <a href="structmlir_1_1bufferization_1_1BufferizationStatistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferPlacementAllocs.html">BufferPlacementAllocs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple analysis that detects allocation operations.  <a href="classmlir_1_1bufferization_1_1BufferPlacementAllocs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferPlacementTransformationBase.html">BufferPlacementTransformationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all BufferPlacement transformations.  <a href="classmlir_1_1bufferization_1_1BufferPlacementTransformationBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for analysis-enabled bufferization.  <a href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State for analysis-enabled bufferization.  <a href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOpts.html">BufferResultsToOutParamsOpts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a976af01e3a00f974529232f7e611233c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a976af01e3a00f974529232f7e611233c">AliasingOpOperandList</a> = <a class="el" href="classmlir_1_1bufferization_1_1AliasList.html">AliasList</a>&lt; <a class="el" href="structmlir_1_1bufferization_1_1AliasingOpOperand.html">AliasingOpOperand</a> &gt;</td></tr>
<tr class="memdesc:a976af01e3a00f974529232f7e611233c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of possible aliasing OpOperands.  <a href="namespacemlir_1_1bufferization.html#a976af01e3a00f974529232f7e611233c">More...</a><br /></td></tr>
<tr class="separator:a976af01e3a00f974529232f7e611233c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4492dc8080792451e4432c4b014544"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a3d4492dc8080792451e4432c4b014544">AliasingValueList</a> = <a class="el" href="classmlir_1_1bufferization_1_1AliasList.html">AliasList</a>&lt; <a class="el" href="structmlir_1_1bufferization_1_1AliasingValue.html">AliasingValue</a> &gt;</td></tr>
<tr class="memdesc:a3d4492dc8080792451e4432c4b014544"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of possible aliasing Values.  <a href="namespacemlir_1_1bufferization.html#a3d4492dc8080792451e4432c4b014544">More...</a><br /></td></tr>
<tr class="separator:a3d4492dc8080792451e4432c4b014544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8ce1066619c9152afa16b4ec7286dc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a3f8ce1066619c9152afa16b4ec7286dc">RegisterDependenciesFn</a> = std::function&lt; void(<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;</td></tr>
<tr class="separator:a3f8ce1066619c9152afa16b4ec7286dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fe5cbf8af77269764f32ac8bf566ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a76fe5cbf8af77269764f32ac8bf566ea">DeallocHelperMap</a> = <a class="el" href="classllvm_1_1DenseMap.html">llvm::DenseMap</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, func::FuncOp &gt;</td></tr>
<tr class="memdesc:a76fe5cbf8af77269764f32ac8bf566ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps from symbol table to its corresponding dealloc helper function.  <a href="namespacemlir_1_1bufferization.html#a76fe5cbf8af77269764f32ac8bf566ea">More...</a><br /></td></tr>
<tr class="separator:a76fe5cbf8af77269764f32ac8bf566ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c1ccb50d4560951e91eb4ccd3ac4e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a09c1ccb50d4560951e91eb4ccd3ac4e8">ControlBuildSubsetExtractionFn</a> = std::function&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>(<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;, SubsetInsertionOpInterface, tensor::EmptyOp emptyTensorOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *user)&gt;</td></tr>
<tr class="memdesc:a09c1ccb50d4560951e91eb4ccd3ac4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function type that defines a callback to control the construction of the subset extraction of the <code>SubsetInsertionOpInterface</code>.  <a href="namespacemlir_1_1bufferization.html#a09c1ccb50d4560951e91eb4ccd3ac4e8">More...</a><br /></td></tr>
<tr class="separator:a09c1ccb50d4560951e91eb4ccd3ac4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">BufferRelation</a> { <a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bfa88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a>
, <a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bfaafd102579f64c98e96d92a7424130605">Equivalent</a>
 }</td></tr>
<tr class="memdesc:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a fine-grain relationship between buffers to enable more analysis.  <a href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">More...</a><br /></td></tr>
<tr class="separator:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adb9d5266b542c2d036dfe7477ba7b622"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#adb9d5266b542c2d036dfe7477ba7b622">allocateTensorForShapedValue</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> shapedValue, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, const <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;state, bool <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp.html#a6ca5ef47ce8bbced1c354e95e188f2e2">copy</a>=true)</td></tr>
<tr class="memdesc:adb9d5266b542c2d036dfe7477ba7b622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an AllocTensorOp for the given shaped value (memref or tensor).  <a href="namespacemlir_1_1bufferization.html#adb9d5266b542c2d036dfe7477ba7b622">More...</a><br /></td></tr>
<tr class="separator:adb9d5266b542c2d036dfe7477ba7b622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a810f8c8918ebef155a2b3acbdc891"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a82a810f8c8918ebef155a2b3acbdc891">getBuffer</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, const <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;state)</td></tr>
<tr class="memdesc:a82a810f8c8918ebef155a2b3acbdc891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup the buffer for the given value.  <a href="namespacemlir_1_1bufferization.html#a82a810f8c8918ebef155a2b3acbdc891">More...</a><br /></td></tr>
<tr class="separator:a82a810f8c8918ebef155a2b3acbdc891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca6108d78bfba4a3bc59794b3cab9e0"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; BufferLikeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a8ca6108d78bfba4a3bc59794b3cab9e0">getBufferType</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, const <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;state)</td></tr>
<tr class="memdesc:a8ca6108d78bfba4a3bc59794b3cab9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization without bufferizing any IR.  <a href="namespacemlir_1_1bufferization.html#a8ca6108d78bfba4a3bc59794b3cab9e0">More...</a><br /></td></tr>
<tr class="separator:a8ca6108d78bfba4a3bc59794b3cab9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4d4dc1213f466ac8131d791bdd6b9c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; BufferLikeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a4d4d4dc1213f466ac8131d791bdd6b9c">getBufferType</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, const <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;state, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;invocationStack)</td></tr>
<tr class="memdesc:a4d4d4dc1213f466ac8131d791bdd6b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization without bufferizing any IR.  <a href="namespacemlir_1_1bufferization.html#a4d4d4dc1213f466ac8131d791bdd6b9c">More...</a><br /></td></tr>
<tr class="separator:a4d4d4dc1213f466ac8131d791bdd6b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba911c4f4c1cf1ef5cc1eed1f5cebdc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#afba911c4f4c1cf1ef5cc1eed1f5cebdc">hasTensorSemantics</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:afba911c4f4c1cf1ef5cc1eed1f5cebdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return "true" if the given op has tensor semantics and should be bufferized.  <a href="namespacemlir_1_1bufferization.html#afba911c4f4c1cf1ef5cc1eed1f5cebdc">More...</a><br /></td></tr>
<tr class="separator:afba911c4f4c1cf1ef5cc1eed1f5cebdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05561ae5b9cceea1c45832340484ad6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a05561ae5b9cceea1c45832340484ad6b">replaceOpWithBufferizedValues</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:a05561ae5b9cceea1c45832340484ad6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an op with replacement values.  <a href="namespacemlir_1_1bufferization.html#a05561ae5b9cceea1c45832340484ad6b">More...</a><br /></td></tr>
<tr class="separator:a05561ae5b9cceea1c45832340484ad6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91366abfb8d491ea5701260487518959"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:a91366abfb8d491ea5701260487518959"><td class="memTemplItemLeft" align="right" valign="top">OpTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a91366abfb8d491ea5701260487518959">replaceOpWithNewBufferizedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a91366abfb8d491ea5701260487518959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an op with a new op.  <a href="namespacemlir_1_1bufferization.html#a91366abfb8d491ea5701260487518959">More...</a><br /></td></tr>
<tr class="separator:a91366abfb8d491ea5701260487518959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d6a035289939e20abc9e248636a1ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a00d6a035289939e20abc9e248636a1ae">getMemRefType</a> (<a class="el" href="classmlir_1_1TensorType.html">TensorType</a> tensorType, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, MemRefLayoutAttrInterface layout={}, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace=nullptr)</td></tr>
<tr class="memdesc:a00d6a035289939e20abc9e248636a1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemRefType to which the <a class="el" href="classmlir_1_1TensorType.html" title="Tensor types represent multi-dimensional arrays, and have two variants: RankedTensorType and Unranked...">TensorType</a> can be bufferized.  <a href="namespacemlir_1_1bufferization.html#a00d6a035289939e20abc9e248636a1ae">More...</a><br /></td></tr>
<tr class="separator:a00d6a035289939e20abc9e248636a1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4daaf086abd1c64e90dc9529f76e1d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#af4daaf086abd1c64e90dc9529f76e1d4">getMemRefTypeWithFullyDynamicLayout</a> (<a class="el" href="classmlir_1_1TensorType.html">TensorType</a> tensorType, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace=nullptr)</td></tr>
<tr class="memdesc:af4daaf086abd1c64e90dc9529f76e1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemRef type with fully dynamic layout.  <a href="namespacemlir_1_1bufferization.html#af4daaf086abd1c64e90dc9529f76e1d4">More...</a><br /></td></tr>
<tr class="separator:af4daaf086abd1c64e90dc9529f76e1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d01c9f4f43c19b51520658e24853d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a05d01c9f4f43c19b51520658e24853d6">getMemRefTypeWithStaticIdentityLayout</a> (<a class="el" href="classmlir_1_1TensorType.html">TensorType</a> tensorType, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace=nullptr)</td></tr>
<tr class="memdesc:a05d01c9f4f43c19b51520658e24853d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemRef type with a static identity layout (i.e., no layout map).  <a href="namespacemlir_1_1bufferization.html#a05d01c9f4f43c19b51520658e24853d6">More...</a><br /></td></tr>
<tr class="separator:a05d01c9f4f43c19b51520658e24853d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ed0ccb4e307d98675ecab129feddf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a25ed0ccb4e307d98675ecab129feddf5">getOwnerOfValue</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a25ed0ccb4e307d98675ecab129feddf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the owner of the given value.  <a href="namespacemlir_1_1bufferization.html#a25ed0ccb4e307d98675ecab129feddf5">More...</a><br /></td></tr>
<tr class="separator:a25ed0ccb4e307d98675ecab129feddf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab812aaab64b7b9fb0416797db2e146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a8ab812aaab64b7b9fb0416797db2e146">getNextEnclosingRepetitiveRegion</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> *region, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a8ab812aaab64b7b9fb0416797db2e146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that the given region is repetitive, find the next enclosing repetitive region.  <a href="namespacemlir_1_1bufferization.html#a8ab812aaab64b7b9fb0416797db2e146">More...</a><br /></td></tr>
<tr class="separator:a8ab812aaab64b7b9fb0416797db2e146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8aa5c17d21cdf7873eed41fc2c9b24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a7a8aa5c17d21cdf7873eed41fc2c9b24">getParallelRegion</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> *region, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a7a8aa5c17d21cdf7873eed41fc2c9b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>region</code> is a parallel region, return <code>region</code>.  <a href="namespacemlir_1_1bufferization.html#a7a8aa5c17d21cdf7873eed41fc2c9b24">More...</a><br /></td></tr>
<tr class="separator:a7a8aa5c17d21cdf7873eed41fc2c9b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7726e480700dfb860214b275d6a396d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#af7726e480700dfb860214b275d6a396d">populateDynamicDimSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> shapedValue, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dynamicDims)</td></tr>
<tr class="memdesc:af7726e480700dfb860214b275d6a396d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate <code>dynamicDims</code> with tensor::DimOp / memref::DimOp results for all dynamic dimensions of the given shaped value.  <a href="namespacemlir_1_1bufferization.html#af7726e480700dfb860214b275d6a396d">More...</a><br /></td></tr>
<tr class="separator:af7726e480700dfb860214b275d6a396d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d27e15fb5438e5f331ac1da1bf424c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a15d27e15fb5438e5f331ac1da1bf424c">castOrReallocMemRefValue</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> value, MemRefType type, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a15d27e15fb5438e5f331ac1da1bf424c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to cast the given ranked MemRef-typed value to the given ranked MemRef type.  <a href="namespacemlir_1_1bufferization.html#a15d27e15fb5438e5f331ac1da1bf424c">More...</a><br /></td></tr>
<tr class="separator:a15d27e15fb5438e5f331ac1da1bf424c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9c453cee7a42d9d7fc0dcb7bfda74a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a6a9c453cee7a42d9d7fc0dcb7bfda74a">foldToBufferToTensorPair</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, ToBufferOp toBuffer, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a6a9c453cee7a42d9d7fc0dcb7bfda74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to fold to_buffer(to_tensor(x)).  <a href="namespacemlir_1_1bufferization.html#a6a9c453cee7a42d9d7fc0dcb7bfda74a">More...</a><br /></td></tr>
<tr class="separator:a6a9c453cee7a42d9d7fc0dcb7bfda74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046f6b3f96cd60275f3bf03f0b17cdae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a046f6b3f96cd60275f3bf03f0b17cdae">populateDeallocOpCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a046f6b3f96cd60275f3bf03f0b17cdae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the canonicalization patterns for bufferization.dealloc to the given pattern set to make them available to other passes (such as BufferDeallocationSimplification).  <a href="namespacemlir_1_1bufferization.html#a046f6b3f96cd60275f3bf03f0b17cdae">More...</a><br /></td></tr>
<tr class="separator:a046f6b3f96cd60275f3bf03f0b17cdae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49b581e6a12f245db92fa4da2d8fd9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#af49b581e6a12f245db92fa4da2d8fd9f">buildBufferDeallocationPipeline</a> (<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;pm, const <a class="el" href="structmlir_1_1bufferization_1_1BufferDeallocationPipelineOptions.html">BufferDeallocationPipelineOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:af49b581e6a12f245db92fa4da2d8fd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the buffer deallocation pipeline to the <code><a class="el" href="classmlir_1_1OpPassManager.html" title="This class represents a pass manager that runs passes on either a specific operation type,...">OpPassManager</a></code>.  <a href="namespacemlir_1_1bufferization.html#af49b581e6a12f245db92fa4da2d8fd9f">More...</a><br /></td></tr>
<tr class="separator:af49b581e6a12f245db92fa4da2d8fd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65df8ad92a46defb2d80d780f26bc12e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a65df8ad92a46defb2d80d780f26bc12e">registerBufferizationPipelines</a> ()</td></tr>
<tr class="memdesc:a65df8ad92a46defb2d80d780f26bc12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers all pipelines for the <code>bufferization</code> dialect.  <a href="namespacemlir_1_1bufferization.html#a65df8ad92a46defb2d80d780f26bc12e">More...</a><br /></td></tr>
<tr class="separator:a65df8ad92a46defb2d80d780f26bc12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2d5a6d2e5ab89ec76a879d71e32a36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a2b2d5a6d2e5ab89ec76a879d71e32a36">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a2b2d5a6d2e5ab89ec76a879d71e32a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179a8ce3b6188cc17cf59edd12425251"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a179a8ce3b6188cc17cf59edd12425251">bufferizeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;bufferizationState, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a179a8ce3b6188cc17cf59edd12425251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>.  <a href="namespacemlir_1_1bufferization.html#a179a8ce3b6188cc17cf59edd12425251">More...</a><br /></td></tr>
<tr class="separator:a179a8ce3b6188cc17cf59edd12425251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cee4c03586f52e4739444e148bf302"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a48cee4c03586f52e4739444e148bf302">bufferizeBlockSignature</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;state)</td></tr>
<tr class="memdesc:a48cee4c03586f52e4739444e148bf302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize the signature of <code>block</code> and its callers (i.e., ops that have the given block as a successor).  <a href="namespacemlir_1_1bufferization.html#a48cee4c03586f52e4739444e148bf302">More...</a><br /></td></tr>
<tr class="separator:a48cee4c03586f52e4739444e148bf302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8139947c1966e87061f1e4e5c184c404"><td class="memTemplParams" colspan="2">template&lt;typename DominatorT &gt; </td></tr>
<tr class="memitem:a8139947c1966e87061f1e4e5c184c404"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a8139947c1966e87061f1e4e5c184c404">findCommonDominator</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="classmlir_1_1BufferViewFlowAnalysis.html#a1602ce2a7a7c54bea6b736faa4cfcd29">BufferViewFlowAnalysis::ValueSetT</a> &amp;values, const DominatorT &amp;doms)</td></tr>
<tr class="memdesc:a8139947c1966e87061f1e4e5c184c404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a common dominator for the given value while taking the positions of the values in the value set into account.  <a href="namespacemlir_1_1bufferization.html#a8139947c1966e87061f1e4e5c184c404">More...</a><br /></td></tr>
<tr class="separator:a8139947c1966e87061f1e4e5c184c404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a622f7d6aaebf47c618abb1ae75f664"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; memref::GlobalOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a9a622f7d6aaebf47c618abb1ae75f664">getGlobalFor</a> (arith::ConstantOp constantOp, <a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> &amp;symbolTables, uint64_t alignment, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={})</td></tr>
<tr class="separator:a9a622f7d6aaebf47c618abb1ae75f664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bcaba1ee24f05d97f557672c2f1655"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ad2bcaba1ee24f05d97f557672c2f1655">removeSymbol</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;state)</td></tr>
<tr class="separator:ad2bcaba1ee24f05d97f557672c2f1655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f018614a956e8aa567bca4ce77a22a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a32f018614a956e8aa567bca4ce77a22a">insertSymbol</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;state)</td></tr>
<tr class="separator:a32f018614a956e8aa567bca4ce77a22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d4a4049fccf821b26cb0bef1f48f53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; func::ReturnOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a24d4a4049fccf821b26cb0bef1f48f53">getReturnOps</a> (func::FuncOp funcOp)</td></tr>
<tr class="memdesc:a24d4a4049fccf821b26cb0bef1f48f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that returns all func.return ops in the given function.  <a href="namespacemlir_1_1bufferization.html#a24d4a4049fccf821b26cb0bef1f48f53">More...</a><br /></td></tr>
<tr class="separator:a24d4a4049fccf821b26cb0bef1f48f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec3ce210ab7a2c1c1e82a266bfb9e3f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a1ec3ce210ab7a2c1c1e82a266bfb9e3f">analyzeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;state, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a1ec3ce210ab7a2c1c1e82a266bfb9e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze <code>op</code> and its nested ops.  <a href="namespacemlir_1_1bufferization.html#a1ec3ce210ab7a2c1c1e82a266bfb9e3f">More...</a><br /></td></tr>
<tr class="separator:a1ec3ce210ab7a2c1c1e82a266bfb9e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdcc74d8e9851ac1c043d88a8818ad6"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a5cdcc74d8e9851ac1c043d88a8818ad6">runOneShotBufferize</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;state, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a5cdcc74d8e9851ac1c043d88a8818ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run One-Shot Bufferize on the given op: Analysis + Bufferization.  <a href="namespacemlir_1_1bufferization.html#a5cdcc74d8e9851ac1c043d88a8818ad6">More...</a><br /></td></tr>
<tr class="separator:a5cdcc74d8e9851ac1c043d88a8818ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac81202fb120a94b740c4da6c60268c4"><td class="memItemLeft" align="right" valign="top">llvm::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aac81202fb120a94b740c4da6c60268c4">analyzeModuleOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *moduleOp, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;state, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:aac81202fb120a94b740c4da6c60268c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze <code>moduleOp</code> and its nested ops.  <a href="namespacemlir_1_1bufferization.html#aac81202fb120a94b740c4da6c60268c4">More...</a><br /></td></tr>
<tr class="separator:aac81202fb120a94b740c4da6c60268c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a18128a731fb9f33811aa1f5bb6498e"><td class="memItemLeft" align="right" valign="top">llvm::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a1a18128a731fb9f33811aa1f5bb6498e">bufferizeModuleOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *moduleOp, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;state, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a1a18128a731fb9f33811aa1f5bb6498e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize an <code>op</code>s nested ops that implement <code>BufferizableOpInterface</code>.  <a href="namespacemlir_1_1bufferization.html#a1a18128a731fb9f33811aa1f5bb6498e">More...</a><br /></td></tr>
<tr class="separator:a1a18128a731fb9f33811aa1f5bb6498e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e900ee791c5c8da0a9b7d86dfd50ddb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a1e900ee791c5c8da0a9b7d86dfd50ddb">removeBufferizationAttributesInModule</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *moduleOp)</td></tr>
<tr class="memdesc:a1e900ee791c5c8da0a9b7d86dfd50ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove bufferization attributes on every FuncOp arguments in the <a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a> op.  <a href="namespacemlir_1_1bufferization.html#a1e900ee791c5c8da0a9b7d86dfd50ddb">More...</a><br /></td></tr>
<tr class="separator:a1e900ee791c5c8da0a9b7d86dfd50ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec29323a856e1ed426652ede7649e3d2"><td class="memItemLeft" align="right" valign="top">llvm::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aec29323a856e1ed426652ede7649e3d2">runOneShotModuleBufferize</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *moduleOp, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;state, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:aec29323a856e1ed426652ede7649e3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run One-Shot Module Bufferization on the given <a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a>.  <a href="namespacemlir_1_1bufferization.html#aec29323a856e1ed426652ede7649e3d2">More...</a><br /></td></tr>
<tr class="separator:aec29323a856e1ed426652ede7649e3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27faa0cefe57ae46dfee1e25392c0d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aa27faa0cefe57ae46dfee1e25392c0d4">populateBufferizationDeallocLoweringPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1bufferization.html#a76fe5cbf8af77269764f32ac8bf566ea">DeallocHelperMap</a> &amp;deallocHelperFuncMap)</td></tr>
<tr class="memdesc:aa27faa0cefe57ae46dfee1e25392c0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the conversion pattern of the <code>bufferization.dealloc</code> operation to the given pattern set for use in other transformation passes.  <a href="namespacemlir_1_1bufferization.html#aa27faa0cefe57ae46dfee1e25392c0d4">More...</a><br /></td></tr>
<tr class="separator:aa27faa0cefe57ae46dfee1e25392c0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addca2ef035b8c6b2f60fac72c2b9f7e7"><td class="memItemLeft" align="right" valign="top">func::FuncOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#addca2ef035b8c6b2f60fac72c2b9f7e7">buildDeallocationLibraryFunction</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1SymbolTable.html">SymbolTable</a> &amp;symbolTable)</td></tr>
<tr class="memdesc:addca2ef035b8c6b2f60fac72c2b9f7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the library function needed for the fully generic <code>bufferization.dealloc</code> lowering implemented in the LowerDeallocations pass.  <a href="namespacemlir_1_1bufferization.html#addca2ef035b8c6b2f60fac72c2b9f7e7">More...</a><br /></td></tr>
<tr class="separator:addca2ef035b8c6b2f60fac72c2b9f7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b9edc151c9e0b8cec2026669cd44a8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a16b9edc151c9e0b8cec2026669cd44a8">deallocateBuffersOwnershipBased</a> (FunctionOpInterface op, <a class="el" href="structmlir_1_1bufferization_1_1DeallocationOptions.html">DeallocationOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> &amp;symbolTables)</td></tr>
<tr class="memdesc:a16b9edc151c9e0b8cec2026669cd44a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the ownership-based buffer deallocation.  <a href="namespacemlir_1_1bufferization.html#a16b9edc151c9e0b8cec2026669cd44a8">More...</a><br /></td></tr>
<tr class="separator:a16b9edc151c9e0b8cec2026669cd44a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a977a84049ece28cbc92bf2c1337f7"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a67a977a84049ece28cbc92bf2c1337f7">promoteBufferResultsToOutParams</a> (ModuleOp module, const <a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOpts.html">BufferResultsToOutParamsOpts</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a67a977a84049ece28cbc92bf2c1337f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace buffers that are returned from a function with an out parameter.  <a href="namespacemlir_1_1bufferization.html#a67a977a84049ece28cbc92bf2c1337f7">More...</a><br /></td></tr>
<tr class="separator:a67a977a84049ece28cbc92bf2c1337f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae342871cac8184abb98eb585dc44bf7e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ae342871cac8184abb98eb585dc44bf7e">dropEquivalentBufferResults</a> (ModuleOp module)</td></tr>
<tr class="memdesc:ae342871cac8184abb98eb585dc44bf7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop all memref function results that are equivalent to a function argument.  <a href="namespacemlir_1_1bufferization.html#ae342871cac8184abb98eb585dc44bf7e">More...</a><br /></td></tr>
<tr class="separator:ae342871cac8184abb98eb585dc44bf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a62a9fdbeb428d3911ee0fbfbc3854283">createPromoteBuffersToStackPass</a> (std::function&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; isSmallAlloc)</td></tr>
<tr class="memdesc:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that promotes heap-based allocations to stack-based ones.  <a href="namespacemlir_1_1bufferization.html#a62a9fdbeb428d3911ee0fbfbc3854283">More...</a><br /></td></tr>
<tr class="separator:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d65c46b9c79a6965bea2b62ef26a649"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a7d65c46b9c79a6965bea2b62ef26a649">eliminateEmptyTensors</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a7d65c46b9c79a6965bea2b62ef26a649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to eliminate "tensor.empty" ops inside <code>op</code>.  <a href="namespacemlir_1_1bufferization.html#a7d65c46b9c79a6965bea2b62ef26a649">More...</a><br /></td></tr>
<tr class="separator:a7d65c46b9c79a6965bea2b62ef26a649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748fb56a9f568d48b21abe15fe7e90b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a748fb56a9f568d48b21abe15fe7e90b6">buildSubsetExtraction</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, SubsetInsertionOpInterface op, tensor::EmptyOp emptyTensorOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *user)</td></tr>
<tr class="memdesc:a748fb56a9f568d48b21abe15fe7e90b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method builds and returns a subset extraction value for the destination tensor that the given <code>op</code> inserts into.  <a href="namespacemlir_1_1bufferization.html#a748fb56a9f568d48b21abe15fe7e90b6">More...</a><br /></td></tr>
<tr class="separator:a748fb56a9f568d48b21abe15fe7e90b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5c79a509fe06bc0c3d1ae5aa1180e5"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a0d5c79a509fe06bc0c3d1ae5aa1180e5">eliminateEmptyTensors</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;state, <a class="el" href="namespacemlir_1_1bufferization.html#a09c1ccb50d4560951e91eb4ccd3ac4e8">ControlBuildSubsetExtractionFn</a> subsetsExtractionFn=<a class="el" href="namespacemlir_1_1bufferization.html#a748fb56a9f568d48b21abe15fe7e90b6">buildSubsetExtraction</a>)</td></tr>
<tr class="memdesc:a0d5c79a509fe06bc0c3d1ae5aa1180e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to eliminate "tensor.empty" ops inside <code>op</code>.  <a href="namespacemlir_1_1bufferization.html#a0d5c79a509fe06bc0c3d1ae5aa1180e5">More...</a><br /></td></tr>
<tr class="separator:a0d5c79a509fe06bc0c3d1ae5aa1180e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6660fcb71a7865869c899d7bd3577e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a2e6660fcb71a7865869c899d7bd3577e">hoistBuffersFromLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a2e6660fcb71a7865869c899d7bd3577e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Within the given operation, hoist buffers from loops where possible.  <a href="namespacemlir_1_1bufferization.html#a2e6660fcb71a7865869c899d7bd3577e">More...</a><br /></td></tr>
<tr class="separator:a2e6660fcb71a7865869c899d7bd3577e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548a7f668a756ed811c1522c2f5cf695"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a548a7f668a756ed811c1522c2f5cf695">insertTensorCopies</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, const <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;bufferizationState, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *statistics=nullptr)</td></tr>
<tr class="memdesc:a548a7f668a756ed811c1522c2f5cf695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve RaW and other conflicts by inserting bufferization.alloc_tensor ops.  <a href="namespacemlir_1_1bufferization.html#a548a7f668a756ed811c1522c2f5cf695">More...</a><br /></td></tr>
<tr class="separator:a548a7f668a756ed811c1522c2f5cf695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bec026e81825ea454470f8878a0a5a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aa6bec026e81825ea454470f8878a0a5a">insertTensorCopies</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">AnalysisState</a> &amp;analysisState, const <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;bufferizationState)</td></tr>
<tr class="memdesc:aa6bec026e81825ea454470f8878a0a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve RaW and other conflicts by inserting bufferization.alloc_tensor ops.  <a href="namespacemlir_1_1bufferization.html#aa6bec026e81825ea454470f8878a0a5a">More...</a><br /></td></tr>
<tr class="separator:aa6bec026e81825ea454470f8878a0a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41285ff4926c59c44f84d013df399b83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a41285ff4926c59c44f84d013df399b83">populateEmptyTensorToAllocTensorPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a41285ff4926c59c44f84d013df399b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns to lower tensor.empty ops to bufferization.alloc_tensor ops.  <a href="namespacemlir_1_1bufferization.html#a41285ff4926c59c44f84d013df399b83">More...</a><br /></td></tr>
<tr class="separator:a41285ff4926c59c44f84d013df399b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a976af01e3a00f974529232f7e611233c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976af01e3a00f974529232f7e611233c">&#9670;&nbsp;</a></span>AliasingOpOperandList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#a976af01e3a00f974529232f7e611233c">mlir::bufferization::AliasingOpOperandList</a> = typedef <a class="el" href="classmlir_1_1bufferization_1_1AliasList.html">AliasList</a>&lt;<a class="el" href="structmlir_1_1bufferization_1_1AliasingOpOperand.html">AliasingOpOperand</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of possible aliasing OpOperands. </p>
<p>This list models the runtime aliasing relationship for a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00095">95</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

</div>
</div>
<a id="a3d4492dc8080792451e4432c4b014544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4492dc8080792451e4432c4b014544">&#9670;&nbsp;</a></span>AliasingValueList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#a3d4492dc8080792451e4432c4b014544">mlir::bufferization::AliasingValueList</a> = typedef <a class="el" href="classmlir_1_1bufferization_1_1AliasList.html">AliasList</a>&lt;<a class="el" href="structmlir_1_1bufferization_1_1AliasingValue.html">AliasingValue</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of possible aliasing Values. </p>
<p>This list models the runtime aliasing relationship for an <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a>. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00099">99</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

</div>
</div>
<a id="a09c1ccb50d4560951e91eb4ccd3ac4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c1ccb50d4560951e91eb4ccd3ac4e8">&#9670;&nbsp;</a></span>ControlBuildSubsetExtractionFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#a09c1ccb50d4560951e91eb4ccd3ac4e8">mlir::bufferization::ControlBuildSubsetExtractionFn</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>(<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;, SubsetInsertionOpInterface, tensor::EmptyOp emptyTensorOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *user)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function type that defines a callback to control the construction of the subset extraction of the <code>SubsetInsertionOpInterface</code>. </p>
<p>The subset extraction value can be used as a replacement for the <code>emptyTensorOp</code> value which is being consumed by <code>user</code>, failing of building such a value should be indicated with an empty value. This function should guarantee the legality of the replacement, i.e. the replacement should dominate the user of the <code>emptyTensorOp</code> being eliminated. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2Bufferization_2Transforms_2Transforms_8h_source.html#l00047">47</a> of file <a class="el" href="mlir_2Dialect_2Bufferization_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a76fe5cbf8af77269764f32ac8bf566ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fe5cbf8af77269764f32ac8bf566ea">&#9670;&nbsp;</a></span>DeallocHelperMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#a76fe5cbf8af77269764f32ac8bf566ea">mlir::bufferization::DeallocHelperMap</a> = typedef <a class="el" href="classllvm_1_1DenseMap.html">llvm::DenseMap</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, func::FuncOp&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps from symbol table to its corresponding dealloc helper function. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Bufferization_2Transforms_2Passes_8h_source.html#l00025">25</a> of file <a class="el" href="Dialect_2Bufferization_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a3f8ce1066619c9152afa16b4ec7286dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8ce1066619c9152afa16b4ec7286dc">&#9670;&nbsp;</a></span>RegisterDependenciesFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#a3f8ce1066619c9152afa16b4ec7286dc">mlir::bufferization::RegisterDependenciesFn</a> = typedef std::function&lt;void(<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferViewFlowOpInterface_8h_source.html#l00020">20</a> of file <a class="el" href="BufferViewFlowOpInterface_8h_source.html">BufferViewFlowOpInterface.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afbf6d54f9e3c10b9003b66b6224b28bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf6d54f9e3c10b9003b66b6224b28bf">&#9670;&nbsp;</a></span>BufferRelation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">mlir::bufferization::BufferRelation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies a fine-grain relationship between buffers to enable more analysis. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afbf6d54f9e3c10b9003b66b6224b28bfa88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afbf6d54f9e3c10b9003b66b6224b28bfaafd102579f64c98e96d92a7424130605"></a>Equivalent&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00034">34</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adb9d5266b542c2d036dfe7477ba7b622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9d5266b542c2d036dfe7477ba7b622">&#9670;&nbsp;</a></span>allocateTensorForShapedValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::bufferization::allocateTensorForShapedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>shapedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an AllocTensorOp for the given shaped value (memref or tensor). </p>
<p>Create an AllocTensorOp for the given shaped value.</p>
<p>If <code>copy</code> is set, the shaped value is copied. Otherwise, a tensor with undefined contents is allocated. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00162">162</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

</div>
</div>
<a id="aac81202fb120a94b740c4da6c60268c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac81202fb120a94b740c4da6c60268c4">&#9670;&nbsp;</a></span>analyzeModuleOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::analyzeModuleOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>moduleOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze <code>moduleOp</code> and its nested ops. </p>
<p>Bufferization decisions are stored in <code>state</code>. This operates on any <code><a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a></code> op. </p>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00455">455</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00027">insertTensorCopies()</a>.</p>

</div>
</div>
<a id="a1ec3ce210ab7a2c1c1e82a266bfb9e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec3ce210ab7a2c1c1e82a266bfb9e3f">&#9670;&nbsp;</a></span>analyzeOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::analyzeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze <code>op</code> and its nested ops. </p>
<p>Bufferization decisions are stored in <code>state</code>. </p>

<p class="definition">Definition at line <a class="el" href="OneShotAnalysis_8cpp_source.html#l01325">1325</a> of file <a class="el" href="OneShotAnalysis_8cpp_source.html">OneShotAnalysis.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00027">insertTensorCopies()</a>.</p>

</div>
</div>
<a id="a48cee4c03586f52e4739444e148bf302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cee4c03586f52e4739444e148bf302">&#9670;&nbsp;</a></span>bufferizeBlockSignature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::bufferizeBlockSignature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize the signature of <code>block</code> and its callers (i.e., ops that have the given block as a successor). </p>
<p>All block argument types are changed to memref types. All corresponding operands of all callers are wrapped in bufferization.to_buffer ops. All uses of bufferized tensor block arguments are wrapped in bufferization.to_tensor ops.</p>
<p>It is expected that all callers implement the <code>BranchOpInterface</code>. Otherwise, this function will fail. The <code>BranchOpInterface</code> is used to query the range of operands that are forwarded to this block.</p>
<p>It is expected that the parent op of this block implements the <code>BufferizableOpInterface</code>. The buffer types of tensor block arguments are computed with <code>BufferizableOpIntercace::getBufferType</code>. </p>

<p class="definition">Definition at line <a class="el" href="Bufferize_8cpp_source.html#l00396">396</a> of file <a class="el" href="Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="a1a18128a731fb9f33811aa1f5bb6498e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a18128a731fb9f33811aa1f5bb6498e">&#9670;&nbsp;</a></span>bufferizeModuleOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::bufferizeModuleOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>moduleOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize an <code>op</code>s nested ops that implement <code>BufferizableOpInterface</code>. </p>
<p>This operates on any <code><a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a></code> op.</p>
<p>Note: This function does not run One-Shot Analysis. No buffer copies are inserted except two cases:</p><ul>
<li><code>options.copyBeforeWrite</code> is set, in which case buffers are copied before every write.</li>
<li><code>options.copyBeforeWrite</code> is not set and <code>options.noAnalysisFuncFilter</code> is not empty. The FuncOps it contains were not analyzed. Buffer copies will be inserted only to these FuncOps. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00531">531</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00099">mlir::sparse_tensor::SparsificationAndBufferizationPass::runDenseBufferization()</a>.</p>

</div>
</div>
<a id="a179a8ce3b6188cc17cf59edd12425251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179a8ce3b6188cc17cf59edd12425251">&#9670;&nbsp;</a></span>bufferizeOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::bufferizeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>bufferizationState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>. </p>
<p>Note: This function does not resolve read-after-write conflicts. Use this function only if it is guaranteed that the input IR can bufferize without additional buffer copies or set "options.copyBeforeWrite = true". The general bufferization entry point is <code>runOneShotBufferize</code>. </p>
<p>Check the result of bufferization. Return an error if an op was not bufferized, unless partial bufferization is allowed.</p>

<p class="definition">Definition at line <a class="el" href="Bufferize_8cpp_source.html#l00276">276</a> of file <a class="el" href="Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00267">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00672">mlir::Operation::emitOpError()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00085">foldToBufferToTensorPair()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00846">mlir::Operation::getUses()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00727">hasTensorSemantics()</a>, <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00027">insertTensorCopies()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00315">mlir::isMemoryEffectFree()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca22e80e4e88a340d28d3f27ee3d9d7163">mlir::PostOrder</a>, <a class="el" href="WalkResult_8h_source.html#l00048">mlir::WalkResult::skip()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="af49b581e6a12f245db92fa4da2d8fd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49b581e6a12f245db92fa4da2d8fd9f">&#9670;&nbsp;</a></span>buildBufferDeallocationPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::buildBufferDeallocationPipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferDeallocationPipelineOptions.html">BufferDeallocationPipelineOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the buffer deallocation pipeline to the <code><a class="el" href="classmlir_1_1OpPassManager.html" title="This class represents a pass manager that runs passes on either a specific operation type,...">OpPassManager</a></code>. </p>
<p>This is the standard pipeline for deallocating the MemRefs introduced by the One-Shot bufferization pass. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationPipelines_8cpp_source.html#l00020">20</a> of file <a class="el" href="BufferizationPipelines_8cpp_source.html">BufferizationPipelines.cpp</a>.</p>

<p class="reference">References <a class="el" href="Pass_2Pass_8cpp_source.html#l00367">mlir::OpPassManager::addPass()</a>, <a class="el" href="Canonicalizer_8cpp_source.html#l00074">mlir::createCanonicalizerPass()</a>, <a class="el" href="CSE_8cpp_source.html#l00414">mlir::createCSEPass()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizationPipelines_8cpp_source.html#l00041">registerBufferizationPipelines()</a>.</p>

</div>
</div>
<a id="addca2ef035b8c6b2f60fac72c2b9f7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addca2ef035b8c6b2f60fac72c2b9f7e7">&#9670;&nbsp;</a></span>buildDeallocationLibraryFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">func::FuncOp mlir::bufferization::buildDeallocationLibraryFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTable.html">SymbolTable</a> &amp;&#160;</td>
          <td class="paramname"><em>symbolTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the library function needed for the fully generic <code>bufferization.dealloc</code> lowering implemented in the LowerDeallocations pass. </p>
<p>The function can then be called at bufferization dealloc sites to determine aliasing and ownership.</p>
<p>The generated function takes two memrefs of indices and three memrefs of booleans as arguments:</p><ul>
<li>The first argument A should contain the result of the extract_aligned_pointer_as_index operation applied to the memrefs to be deallocated</li>
<li>The second argument B should contain the result of the extract_aligned_pointer_as_index operation applied to the memrefs to be retained</li>
<li>The third argument C should contain the conditions as passed directly to the deallocation operation.</li>
<li>The fourth argument D is used to pass results to the caller. Those represent the condition under which the memref at the corresponding position in A should be deallocated.</li>
<li>The fifth argument E is used to pass results to the caller. It provides the ownership value corresponding the the memref at the same position in B</li>
</ul>
<p>This helper function is supposed to be called once for each <code>bufferization.dealloc</code> operation to determine the deallocation need and new ownership indicator for the retained values, but does not perform the deallocation itself.</p>
<p>Generated code: </p><div class="fragment"><div class="line">func.func @dealloc_helper(</div>
<div class="line">    %dyn_dealloc_base_pointer_list: memref&lt;?xindex&gt;,</div>
<div class="line">    %dyn_retain_base_pointer_list: memref&lt;?xindex&gt;,</div>
<div class="line">    %dyn_cond_list: memref&lt;?xi1&gt;,</div>
<div class="line">    %dyn_dealloc_cond_out: memref&lt;?xi1&gt;,</div>
<div class="line">    %dyn_ownership_out: memref&lt;?xi1&gt;) {</div>
<div class="line">  %c0 = arith.constant 0 : index</div>
<div class="line">  %c1 = arith.constant 1 : index</div>
<div class="line">  %<span class="keyword">true</span> = arith.constant <span class="keyword">true</span></div>
<div class="line">  %<span class="keyword">false</span> = arith.constant <span class="keyword">false</span></div>
<div class="line">  %num_dealloc_memrefs = memref.dim %dyn_dealloc_base_pointer_list, %c0</div>
<div class="line">  %num_retain_memrefs = memref.dim %dyn_retain_base_pointer_list, %c0</div>
<div class="line">  <span class="comment">// Zero initialize result buffer.</span></div>
<div class="line">  scf.for %i = %c0 to %num_retain_memrefs step %c1 {</div>
<div class="line">    memref.store %<span class="keyword">false</span>, %dyn_ownership_out[%i] : memref&lt;?xi1&gt;</div>
<div class="line">  }</div>
<div class="line">  scf.for %i = %c0 to %num_dealloc_memrefs step %c1 {</div>
<div class="line">    %dealloc_bp = memref.load %dyn_dealloc_base_pointer_list[%i]</div>
<div class="line">    %cond = memref.load %dyn_cond_list[%i]</div>
<div class="line">    <span class="comment">// Check for aliasing with retained memrefs.</span></div>
<div class="line">    %does_not_alias_retained = scf.for %<a class="code" href="unionj.html">j</a> = %c0 to %num_retain_memrefs</div>
<div class="line">        step %c1 iter_args(%does_not_alias_aggregated = %<span class="keyword">true</span>) -&gt; (i1) {</div>
<div class="line">      %retain_bp = memref.load %dyn_retain_base_pointer_list[%<a class="code" href="unionj.html">j</a>]</div>
<div class="line">      %does_alias = arith.cmpi <a class="code" href="namespacemlir_1_1intrange.html#a781c30a009f6baedd903c15496b9ac31adf22f17124884fc51f1ac69d610096ac">eq</a>, %retain_bp, %dealloc_bp : index</div>
<div class="line">      scf.if %does_alias {</div>
<div class="line">        %curr_ownership = memref.load %dyn_ownership_out[%<a class="code" href="unionj.html">j</a>]</div>
<div class="line">        %updated_ownership = arith.ori %curr_ownership, %cond : i1</div>
<div class="line">        memref.store %updated_ownership, %dyn_ownership_out[%<a class="code" href="unionj.html">j</a>]</div>
<div class="line">      }</div>
<div class="line">      %does_not_alias = arith.cmpi <a class="code" href="namespacemlir_1_1intrange.html#a781c30a009f6baedd903c15496b9ac31ad4f917633649a3c47c7ab917fa990146">ne</a>, %retain_bp, %dealloc_bp : index</div>
<div class="line">      %updated_aggregate = arith.andi %does_not_alias_aggregated,</div>
<div class="line">                                      %does_not_alias : i1</div>
<div class="line">      scf.yield %updated_aggregate : i1</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Check for aliasing with dealloc memrefs in the list before the</span></div>
<div class="line">    <span class="comment">// current one, i.e.,</span></div>
<div class="line">    <span class="comment">// `fix i, forall j &lt; i: check_aliasing(%dyn_dealloc_base_pointer[j],</span></div>
<div class="line">    <span class="comment">// %dyn_dealloc_base_pointer[i])`</span></div>
<div class="line">    %does_not_alias_any = scf.for %<a class="code" href="unionj.html">j</a> = %c0 to %i step %c1</div>
<div class="line">       iter_args(%does_not_alias_agg = %does_not_alias_retained) -&gt; (i1) {</div>
<div class="line">      %prev_dealloc_bp = memref.load %dyn_dealloc_base_pointer_list[%<a class="code" href="unionj.html">j</a>]</div>
<div class="line">      %does_not_alias = arith.cmpi <a class="code" href="namespacemlir_1_1intrange.html#a781c30a009f6baedd903c15496b9ac31ad4f917633649a3c47c7ab917fa990146">ne</a>, %prev_dealloc_bp, %dealloc_bp</div>
<div class="line">      %updated_alias_agg = arith.andi %does_not_alias_agg, %does_not_alias</div>
<div class="line">      scf.yield %updated_alias_agg : i1</div>
<div class="line">    }</div>
<div class="line">    %dealloc_cond = arith.andi %does_not_alias_any, %cond : i1</div>
<div class="line">    memref.store %dealloc_cond, %dyn_dealloc_cond_out[%i] : memref&lt;?xi1&gt;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacemlir_1_1intrange_html_a781c30a009f6baedd903c15496b9ac31ad4f917633649a3c47c7ab917fa990146"><div class="ttname"><a href="namespacemlir_1_1intrange.html#a781c30a009f6baedd903c15496b9ac31ad4f917633649a3c47c7ab917fa990146">mlir::intrange::CmpPredicate::ne</a></div><div class="ttdeci">@ ne</div></div>
<div class="ttc" id="anamespacemlir_1_1intrange_html_a781c30a009f6baedd903c15496b9ac31adf22f17124884fc51f1ac69d610096ac"><div class="ttname"><a href="namespacemlir_1_1intrange.html#a781c30a009f6baedd903c15496b9ac31adf22f17124884fc51f1ac69d610096ac">mlir::intrange::CmpPredicate::eq</a></div><div class="ttdeci">@ eq</div></div>
<div class="ttc" id="aunionj_html"><div class="ttname"><a href="unionj.html">j</a></div><div class="ttdoc">Eliminates variable at the specified position using Fourier-Motzkin variable elimination.</div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="LowerDeallocations_8cpp_source.html#l00431">431</a> of file <a class="el" href="LowerDeallocations_8cpp_source.html">LowerDeallocations.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00377">mlir::OpBuilder::clearInsertionPoint()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00095">mlir::Builder::getBoolAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00075">mlir::Builder::getFunctionType()</a>, <a class="el" href="Builders_8cpp_source.html#l00052">mlir::Builder::getI1Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00050">mlir::Builder::getIndexType()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00170">mlir::SymbolTable::insert()</a>, <a class="el" href="classmlir_1_1SymbolTable.html#a4f1a6f39b93a08abe4e80a5c15fe32b8a47f9082fc380ca62d531096aa1d110f1">mlir::SymbolTable::Private</a>, and <a class="el" href="Builders_8h_source.html#l00429">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="a748fb56a9f568d48b21abe15fe7e90b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748fb56a9f568d48b21abe15fe7e90b6">&#9670;&nbsp;</a></span>buildSubsetExtraction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::bufferization::buildSubsetExtraction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubsetInsertionOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::EmptyOp&#160;</td>
          <td class="paramname"><em>emptyTensorOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method builds and returns a subset extraction value for the destination tensor that the given <code>op</code> inserts into. </p>
<p>It returns a value which should replace the <code>emptyTensorOp</code> use that is being consumed by <code>user</code>. If no such a value found it will return an empty <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00095">95</a> of file <a class="el" href="EmptyTensorElimination_8cpp_source.html">EmptyTensorElimination.cpp</a>.</p>

<p class="reference">References <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00054">findValidInsertionPoint()</a>, and <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a15d27e15fb5438e5f331ac1da1bf424c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d27e15fb5438e5f331ac1da1bf424c">&#9670;&nbsp;</a></span>castOrReallocMemRefValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::bufferization::castOrReallocMemRefValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to cast the given ranked MemRef-typed value to the given ranked MemRef type. </p>
<p>Insert a reallocation + copy if it cannot be statically guaranteed that a direct cast would be valid.</p>
<p>E.g., when casting from a ranked MemRef type with dynamic layout to a ranked MemRef type with static layout, it is not statically known whether the cast will succeed or not. Such <code>memref.cast</code> ops may fail at runtime. This function never generates such casts and conservatively inserts a copy.</p>
<p>This function returns <code>failure()</code> in case of unsupported casts. E.g., casts with differing element types or memory spaces. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationOps_8cpp_source.html#l00025">25</a> of file <a class="el" href="BufferizationOps_8cpp_source.html">BufferizationOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00069">copy()</a>, <a class="el" href="Value_8cpp_source.html#l00024">mlir::Value::getLoc()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizationOps_8cpp_source.html#l00085">foldToBufferToTensorPair()</a>.</p>

</div>
</div>
<a id="a62a9fdbeb428d3911ee0fbfbc3854283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a9fdbeb428d3911ee0fbfbc3854283">&#9670;&nbsp;</a></span>createPromoteBuffersToStackPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createPromoteBuffersToStackPass </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;&#160;</td>
          <td class="paramname"><em>isSmallAlloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that promotes heap-based allocations to stack-based ones. </p>
<p>Only buffers smaller with <code>isSmallAlloc(alloc) == true</code> are promoted. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00478">478</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="a16b9edc151c9e0b8cec2026669cd44a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b9edc151c9e0b8cec2026669cd44a8">&#9670;&nbsp;</a></span>deallocateBuffersOwnershipBased()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::deallocateBuffersOwnershipBased </td>
          <td>(</td>
          <td class="paramtype">FunctionOpInterface&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1DeallocationOptions.html">DeallocationOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> &amp;&#160;</td>
          <td class="paramname"><em>symbolTables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the ownership-based buffer deallocation. </p>

<p class="definition">Definition at line <a class="el" href="OwnershipBasedBufferDeallocation_8cpp_source.html#l01050">1050</a> of file <a class="el" href="OwnershipBasedBufferDeallocation_8cpp_source.html">OwnershipBasedBufferDeallocation.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="ae342871cac8184abb98eb585dc44bf7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae342871cac8184abb98eb585dc44bf7e">&#9670;&nbsp;</a></span>dropEquivalentBufferResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::dropEquivalentBufferResults </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop all memref function results that are equivalent to a function argument. </p>

<p class="definition">Definition at line <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00069">69</a> of file <a class="el" href="DropEquivalentBufferResults_8cpp_source.html">DropEquivalentBufferResults.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00046">getAssumedUniqueReturnOp()</a>, <a class="el" href="DropEquivalentBufferResults_8cpp_source.html#l00059">getCalledFunction()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a7d65c46b9c79a6965bea2b62ef26a649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d65c46b9c79a6965bea2b62ef26a649">&#9670;&nbsp;</a></span>eliminateEmptyTensors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::eliminateEmptyTensors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to eliminate "tensor.empty" ops inside <code>op</code>. </p>
<p>This transformation looks for subset ops that insert a tensor that originates from a "tensor.empty" (as per the reverse use-def chain). Such "tensor.empty" ops are replaced with the destination subset.</p>
<p>E.g.: %0 = tensor.empty() : tensor&lt;10xf32&gt; %1 = linalg.fill ... outs(%0 : tensor&lt;10xf32&gt;) %2 = tensor.insert_slice %0 into t ...</p>
<p>In the above example, the subset op is "tensor.insert_slice". When tracing back the reverse use-def chain of a the source, we end up at a "tensor.empty" op. </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00202">202</a> of file <a class="el" href="EmptyTensorElimination_8cpp_source.html">EmptyTensorElimination.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a0d5c79a509fe06bc0c3d1ae5aa1180e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5c79a509fe06bc0c3d1ae5aa1180e5">&#9670;&nbsp;</a></span>eliminateEmptyTensors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::eliminateEmptyTensors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1bufferization.html#a09c1ccb50d4560951e91eb4ccd3ac4e8">ControlBuildSubsetExtractionFn</a>&#160;</td>
          <td class="paramname"><em>subsetsExtractionFn</em> = <code><a class="el" href="namespacemlir_1_1bufferization.html#a748fb56a9f568d48b21abe15fe7e90b6">buildSubsetExtraction</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to eliminate "tensor.empty" ops inside <code>op</code>. </p>
<p>This function overload accepts an existing <code><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html" title="State for analysis-enabled bufferization.">OneShotAnalysisState</a></code>, which contains in-place bufferization decisions. This overload is useful if an existing analysis should be reused for empty tensor elimination. </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorElimination_8cpp_source.html#l00117">117</a> of file <a class="el" href="EmptyTensorElimination_8cpp_source.html">EmptyTensorElimination.cpp</a>.</p>

</div>
</div>
<a id="a8139947c1966e87061f1e4e5c184c404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8139947c1966e87061f1e4e5c184c404">&#9670;&nbsp;</a></span>findCommonDominator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DominatorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Block.html">Block</a>* mlir::bufferization::findCommonDominator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1BufferViewFlowAnalysis.html#a1602ce2a7a7c54bea6b736faa4cfcd29">BufferViewFlowAnalysis::ValueSetT</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DominatorT &amp;&#160;</td>
          <td class="paramname"><em>doms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a common dominator for the given value while taking the positions of the values in the value set into account. </p>
<p>It supports dominator and post-dominator analyses via template arguments. If no common dominator can be found, this function will return "nullptr". </p>

<p class="definition">Definition at line <a class="el" href="BufferUtils_8h_source.html#l00082">82</a> of file <a class="el" href="BufferUtils_8h_source.html">BufferUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00046">mlir::Value::getParentBlock()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00873">mlir::Operation::getUsers()</a>.</p>

</div>
</div>
<a id="a6a9c453cee7a42d9d7fc0dcb7bfda74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9c453cee7a42d9d7fc0dcb7bfda74a">&#9670;&nbsp;</a></span>foldToBufferToTensorPair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::foldToBufferToTensorPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ToBufferOp&#160;</td>
          <td class="paramname"><em>toBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to fold to_buffer(to_tensor(x)). </p>
<p>If x's type and the result type of the to_buffer op are different, a memref.cast is needed. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationOps_8cpp_source.html#l00085">85</a> of file <a class="el" href="BufferizationOps_8cpp_source.html">BufferizationOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizationOps_8cpp_source.html#l00025">castOrReallocMemRefValue()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00519">mlir::RewriterBase::replaceOpWithNewOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferize_8cpp_source.html#l00276">bufferizeOp()</a>.</p>

</div>
</div>
<a id="a82a810f8c8918ebef155a2b3acbdc891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a810f8c8918ebef155a2b3acbdc891">&#9670;&nbsp;</a></span>getBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::bufferization::getBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup the buffer for the given value. </p>
<p>If the value was not bufferized yet, wrap it in a ToBufferOp. Otherwise, it is the result of a ToTensorOp, from which the memref operand is returned. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00672">672</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

</div>
</div>
<a id="a8ca6108d78bfba4a3bc59794b3cab9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca6108d78bfba4a3bc59794b3cab9e0">&#9670;&nbsp;</a></span>getBufferType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; BufferLikeType &gt; mlir::bufferization::getBufferType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization without bufferizing any IR. </p>
<p>Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization.</p>
<p>Note: It should be sufficient to call <code><a class="el" href="namespacemlir_1_1bufferization.html#a82a810f8c8918ebef155a2b3acbdc891" title="Lookup the buffer for the given value.">getBuffer()</a>-&gt;<a class="el" href="namespacemlir.html#a348ed9fcbefe1f5094cc571c346c7080" title="Returns the int type of the integer in ofr.">getType()</a></code> in most cases. However, when a buffer type should be predicted without modifying any IR, this function can be used.</p>
<p>This function is a wrapper around BufferizableOpInterface::getBufferType. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00698">698</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00946">mlir::bufferization::detail::defaultGetBufferType()</a>.</p>

</div>
</div>
<a id="a4d4d4dc1213f466ac8131d791bdd6b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4d4dc1213f466ac8131d791bdd6b9c">&#9670;&nbsp;</a></span>getBufferType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; BufferLikeType &gt; mlir::bufferization::getBufferType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>invocationStack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization without bufferizing any IR. </p>
<p>Return the buffer type for a given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> (tensor) after bufferization.</p>
<p>This function (and not the other overload without <code>invocationStack</code>) can be used from <code>getBufferType</code> implementations of the <code>BufferizableOpInterface</code>.</p>
<p>Note: It should be sufficient to call <code><a class="el" href="namespacemlir_1_1bufferization.html#a82a810f8c8918ebef155a2b3acbdc891" title="Lookup the buffer for the given value.">getBuffer()</a>-&gt;<a class="el" href="namespacemlir.html#a348ed9fcbefe1f5094cc571c346c7080" title="Returns the int type of the integer in ofr.">getType()</a></code> in most cases. However, when a buffer type should be predicted without modifying any IR, this function can be used.</p>
<p>This function is a wrapper around <code>BufferizableOpInterface::getBufferType</code>. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00706">706</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

</div>
</div>
<a id="a9a622f7d6aaebf47c618abb1ae75f664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a622f7d6aaebf47c618abb1ae75f664">&#9670;&nbsp;</a></span>getGlobalFor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; memref::GlobalOp &gt; mlir::bufferization::getGlobalFor </td>
          <td>(</td>
          <td class="paramtype">arith::ConstantOp&#160;</td>
          <td class="paramname"><em>constantOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> &amp;&#160;</td>
          <td class="paramname"><em>symbolTables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferUtils_8cpp_source.html#l00101">101</a> of file <a class="el" href="BufferUtils_8cpp_source.html">BufferUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00064">mlir::Builder::getI64Type()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00843">getMemRefTypeWithStaticIdentityLayout()</a>, <a class="el" href="IR_2Region_8h_source.html#l00172">mlir::Region::getOps()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00686">mlir::Operation::getRegion()</a>, <a class="el" href="Builders_8cpp_source.html#l00257">mlir::Builder::getStringAttr()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00993">mlir::SymbolTableCollection::getSymbolTable()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00170">mlir::SymbolTable::insert()</a>, and <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00208">mlir::MemRefType::Builder::setMemorySpace()</a>.</p>

</div>
</div>
<a id="a00d6a035289939e20abc9e248636a1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d6a035289939e20abc9e248636a1ae">&#9670;&nbsp;</a></span>getMemRefType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> mlir::bufferization::getMemRefType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a>&#160;</td>
          <td class="paramname"><em>tensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefLayoutAttrInterface&#160;</td>
          <td class="paramname"><em>layout</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a MemRefType to which the <a class="el" href="classmlir_1_1TensorType.html" title="Tensor types represent multi-dimensional arrays, and have two variants: RankedTensorType and Unranked...">TensorType</a> can be bufferized. </p>
<p>If possible, op bufferization implementations should not use this function and instead infer precise memref types for tensor results by themselves.</p>
<p>Unless a layout map was specified, <code>options.unknownTypeConverterFn</code> determines what kind of layout map will be used. For best composability (without copies), the fully dynamic layout map is used by default.</p>
<p>Note: Canonicalization patterns could clean up layout maps and infer more precise layout maps after bufferization. However, many possible canonicalizations are currently not implemented. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00795">795</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00946">mlir::bufferization::detail::defaultGetBufferType()</a>.</p>

</div>
</div>
<a id="af4daaf086abd1c64e90dc9529f76e1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4daaf086abd1c64e90dc9529f76e1d4">&#9670;&nbsp;</a></span>getMemRefTypeWithFullyDynamicLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> mlir::bufferization::getMemRefTypeWithFullyDynamicLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a>&#160;</td>
          <td class="paramname"><em>tensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a MemRef type with fully dynamic layout. </p>
<p>If the given tensor type is unranked, return an unranked MemRef type. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00819">819</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertToDestinationStyle_8cpp_source.html#l00056">createMemcpy()</a>, <a class="el" href="LoopEmitter_8cpp_source.html#l00229">mlir::sparse_tensor::LoopEmitter::initializeLoopEmit()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00386">mlir::bufferization::BufferizationOptions::setFunctionBoundaryTypeConversion()</a>.</p>

</div>
</div>
<a id="a05d01c9f4f43c19b51520658e24853d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d01c9f4f43c19b51520658e24853d6">&#9670;&nbsp;</a></span>getMemRefTypeWithStaticIdentityLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> mlir::bufferization::getMemRefTypeWithStaticIdentityLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a>&#160;</td>
          <td class="paramname"><em>tensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a MemRef type with a static identity layout (i.e., no layout map). </p>
<p>If the given tensor type is unranked, return an unranked MemRef type. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00843">843</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00219">mlir::getBufferizationOptionsForSparsification()</a>, <a class="el" href="BufferUtils_8cpp_source.html#l00101">getGlobalFor()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00386">mlir::bufferization::BufferizationOptions::setFunctionBoundaryTypeConversion()</a>.</p>

</div>
</div>
<a id="a8ab812aaab64b7b9fb0416797db2e146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab812aaab64b7b9fb0416797db2e146">&#9670;&nbsp;</a></span>getNextEnclosingRepetitiveRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::bufferization::getNextEnclosingRepetitiveRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assuming that the given region is repetitive, find the next enclosing repetitive region. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00128">128</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8cpp_source.html#l00045">mlir::Region::getParentRegion()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00041">isRepetitiveRegion()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a25ed0ccb4e307d98675ecab129feddf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ed0ccb4e307d98675ecab129feddf5">&#9670;&nbsp;</a></span>getOwnerOfValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::bufferization::getOwnerOfValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the owner of the given value. </p>
<p>In case of a <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block.">BlockArgument</a> that is the owner of the block. In case of an <a class="el" href="classmlir_1_1OpResult.html" title="This is a value defined by a result of an operation.">OpResult</a> that is the defining op. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00153">153</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00946">mlir::bufferization::detail::defaultGetBufferType()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00382">mlir::bufferization::BufferizationOptions::dynCastBufferizableOp()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00415">mlir::bufferization::AnalysisState::getAliasingOpOperands()</a>, and <a class="el" href="OneShotAnalysis_8cpp_source.html#l00229">mlir::bufferization::OneShotAnalysisState::isWritable()</a>.</p>

</div>
</div>
<a id="a7a8aa5c17d21cdf7873eed41fc2c9b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8aa5c17d21cdf7873eed41fc2c9b24">&#9670;&nbsp;</a></span>getParallelRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::bufferization::getParallelRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>region</code> is a parallel region, return <code>region</code>. </p>
<p>Otherwise, find the first enclosing parallel region of <code>region</code>. If there is no such region, return "nullptr".</p>
<p>Note: Whether a region is parallel or sequential is queried from the <code>BufferizableOpInterface</code>. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00138">138</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00045">mlir::Region::getParentRegion()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00062">mlir::Region::getRegionNumber()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00041">isRepetitiveRegion()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

</div>
</div>
<a id="a24d4a4049fccf821b26cb0bef1f48f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d4a4049fccf821b26cb0bef1f48f53">&#9670;&nbsp;</a></span>getReturnOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; func::ReturnOp &gt; mlir::bufferization::getReturnOps </td>
          <td>(</td>
          <td class="paramtype">func::FuncOp&#160;</td>
          <td class="paramname"><em>funcOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function that returns all func.return ops in the given function. </p>
<p>Return all func.return ops in the given function. </p>

<p class="definition">Definition at line <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00022">22</a> of file <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html">FuncBufferizableOpInterfaceImpl.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00421">foldMemRefCasts()</a>.</p>

</div>
</div>
<a id="afba911c4f4c1cf1ef5cc1eed1f5cebdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba911c4f4c1cf1ef5cc1eed1f5cebdc">&#9670;&nbsp;</a></span>hasTensorSemantics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::bufferization::hasTensorSemantics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return "true" if the given op has tensor semantics and should be bufferized. </p>
<p>If the op is bufferizable, the BufferizableOpInterface is queried. Otherwise, an op has tensor semantics if it has tensor operands, tensor op results and/or tensor block arguments. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00727">727</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizableOpInterface_8cpp_source.html#l01030">mlir::bufferization::detail::defaultHasTensorSemantics()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotAnalysis_8cpp_source.html#l01133">mlir::bufferization::OneShotAnalysisState::analyzeOp()</a>, <a class="el" href="Bufferize_8cpp_source.html#l00276">bufferizeOp()</a>, and <a class="el" href="VectorUtils_8cpp_source.html#l00296">mlir::vector::getMixedSizesXfer()</a>.</p>

</div>
</div>
<a id="a2e6660fcb71a7865869c899d7bd3577e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6660fcb71a7865869c899d7bd3577e">&#9670;&nbsp;</a></span>hoistBuffersFromLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::hoistBuffersFromLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Within the given operation, hoist buffers from loops where possible. </p>
<p>See "BufferLoopHoistingPass" for more information. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00473">473</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="a32f018614a956e8aa567bca4ce77a22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f018614a956e8aa567bca4ce77a22a">&#9670;&nbsp;</a></span>insertSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::insertSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferUtils_8cpp_source.html#l00167">167</a> of file <a class="el" href="BufferUtils_8cpp_source.html">BufferUtils.cpp</a>.</p>

</div>
</div>
<a id="aa6bec026e81825ea454470f8878a0a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6bec026e81825ea454470f8878a0a5a">&#9670;&nbsp;</a></span>insertTensorCopies() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::insertTensorCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">AnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>analysisState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>bufferizationState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve RaW and other conflicts by inserting bufferization.alloc_tensor ops. </p>
<p>After applying this transform, the IR can be bufferized without inserting additional buffer allocations. </p>

<p class="definition">Definition at line <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00049">49</a> of file <a class="el" href="TensorCopyInsertion_8cpp_source.html">TensorCopyInsertion.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00372">mlir::bufferization::BufferizationOptions::dynCastBufferizableOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00529">mlir::bufferization::AnalysisState::getOptions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00248">mlir::Operation::getParentWithTrait()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="WalkResult_8h_source.html#l00048">mlir::WalkResult::skip()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>, and <a class="el" href="WalkResult_8h_source.html#l00051">mlir::WalkResult::wasInterrupted()</a>.</p>

</div>
</div>
<a id="a548a7f668a756ed811c1522c2f5cf695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548a7f668a756ed811c1522c2f5cf695">&#9670;&nbsp;</a></span>insertTensorCopies() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::insertTensorCopies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>bufferizationState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve RaW and other conflicts by inserting bufferization.alloc_tensor ops. </p>
<p>After applying this transform, the IR can be bufferized without inserting additional buffer allocations. </p>

<p class="definition">Definition at line <a class="el" href="TensorCopyInsertion_8cpp_source.html#l00027">27</a> of file <a class="el" href="TensorCopyInsertion_8cpp_source.html">TensorCopyInsertion.cpp</a>.</p>

<p class="reference">References <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00455">analyzeModuleOp()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l01325">analyzeOp()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferize_8cpp_source.html#l00276">bufferizeOp()</a>, and <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00126">mlir::sparse_tensor::SparsificationAndBufferizationPass::runOnOperation()</a>.</p>

</div>
</div>
<a id="aa27faa0cefe57ae46dfee1e25392c0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27faa0cefe57ae46dfee1e25392c0d4">&#9670;&nbsp;</a></span>populateBufferizationDeallocLoweringPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateBufferizationDeallocLoweringPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1bufferization.html#a76fe5cbf8af77269764f32ac8bf566ea">DeallocHelperMap</a> &amp;&#160;</td>
          <td class="paramname"><em>deallocHelperFuncMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the conversion pattern of the <code>bufferization.dealloc</code> operation to the given pattern set for use in other transformation passes. </p>

<p class="definition">Definition at line <a class="el" href="LowerDeallocations_8cpp_source.html#l00546">546</a> of file <a class="el" href="LowerDeallocations_8cpp_source.html">LowerDeallocations.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a046f6b3f96cd60275f3bf03f0b17cdae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046f6b3f96cd60275f3bf03f0b17cdae">&#9670;&nbsp;</a></span>populateDeallocOpCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateDeallocOpCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the canonicalization patterns for bufferization.dealloc to the given pattern set to make them available to other passes (such as BufferDeallocationSimplification). </p>

<p class="definition">Definition at line <a class="el" href="BufferizationOps_8cpp_source.html#l01191">1191</a> of file <a class="el" href="BufferizationOps_8cpp_source.html">BufferizationOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="af7726e480700dfb860214b275d6a396d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7726e480700dfb860214b275d6a396d">&#9670;&nbsp;</a></span>populateDynamicDimSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateDynamicDimSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>shapedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dynamicDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate <code>dynamicDims</code> with tensor::DimOp / memref::DimOp results for all dynamic dimensions of the given shaped value. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationOps_8cpp_source.html#l00130">130</a> of file <a class="el" href="BufferizationOps_8cpp_source.html">BufferizationOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a41285ff4926c59c44f84d013df399b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41285ff4926c59c44f84d013df399b83">&#9670;&nbsp;</a></span>populateEmptyTensorToAllocTensorPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::populateEmptyTensorToAllocTensorPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns to lower tensor.empty ops to bufferization.alloc_tensor ops. </p>

<p class="definition">Definition at line <a class="el" href="EmptyTensorToAllocTensor_8cpp_source.html#l00051">51</a> of file <a class="el" href="EmptyTensorToAllocTensor_8cpp_source.html">EmptyTensorToAllocTensor.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a67a977a84049ece28cbc92bf2c1337f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a977a84049ece28cbc92bf2c1337f7">&#9670;&nbsp;</a></span>promoteBufferResultsToOutParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::promoteBufferResultsToOutParams </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferResultsToOutParamsOpts.html">BufferResultsToOutParamsOpts</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace buffers that are returned from a function with an out parameter. </p>
<p>Also update all call sites. </p>

<p class="definition">Definition at line <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00213">213</a> of file <a class="el" href="BufferResultsToOutParams_8cpp_source.html">BufferResultsToOutParams.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00145">updateCalls()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00052">updateFuncOp()</a>, and <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00111">updateReturnOps()</a>.</p>

</div>
</div>
<a id="a65df8ad92a46defb2d80d780f26bc12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65df8ad92a46defb2d80d780f26bc12e">&#9670;&nbsp;</a></span>registerBufferizationPipelines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::registerBufferizationPipelines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers all pipelines for the <code>bufferization</code> dialect. </p>
<p>Currently, this includes only the "buffer-deallocation-pipeline". </p>

<p class="definition">Definition at line <a class="el" href="BufferizationPipelines_8cpp_source.html#l00041">41</a> of file <a class="el" href="BufferizationPipelines_8cpp_source.html">BufferizationPipelines.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizationPipelines_8cpp_source.html#l00020">buildBufferDeallocationPipeline()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllPasses_8cpp_source.html#l00057">mlir::registerAllPasses()</a>.</p>

</div>
</div>
<a id="a2b2d5a6d2e5ab89ec76a879d71e32a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2d5a6d2e5ab89ec76a879d71e32a36">&#9670;&nbsp;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferizationTransformOps_8cpp_source.html#l00180">180</a> of file <a class="el" href="BufferizationTransformOps_8cpp_source.html">BufferizationTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00222">mlir::DialectRegistry::addExtensions()</a>.</p>

</div>
</div>
<a id="a1e900ee791c5c8da0a9b7d86dfd50ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e900ee791c5c8da0a9b7d86dfd50ddb">&#9670;&nbsp;</a></span>removeBufferizationAttributesInModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::removeBufferizationAttributesInModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>moduleOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove bufferization attributes on every FuncOp arguments in the <a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a> op. </p>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00519">519</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>, and <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00276">removeBufferizationAttributes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparsificationAndBufferizationPass_8cpp_source.html#l00099">mlir::sparse_tensor::SparsificationAndBufferizationPass::runDenseBufferization()</a>.</p>

</div>
</div>
<a id="ad2bcaba1ee24f05d97f557672c2f1655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2bcaba1ee24f05d97f557672c2f1655">&#9670;&nbsp;</a></span>removeSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::removeSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferUtils_8cpp_source.html#l00160">160</a> of file <a class="el" href="BufferUtils_8cpp_source.html">BufferUtils.cpp</a>.</p>

</div>
</div>
<a id="a05561ae5b9cceea1c45832340484ad6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05561ae5b9cceea1c45832340484ad6b">&#9670;&nbsp;</a></span>replaceOpWithBufferizedValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bufferization::replaceOpWithBufferizedValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace an op with replacement values. </p>
<p>The op is deleted. Tensor OpResults must be replaced with memref values. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00733">733</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00024">mlir::Value::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00404">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00420">mlir::Operation::getOpResults()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Builders_8h_source.html#l00410">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8h_source.html#l00652">replaceOpWithNewBufferizedOp()</a>.</p>

</div>
</div>
<a id="a91366abfb8d491ea5701260487518959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91366abfb8d491ea5701260487518959">&#9670;&nbsp;</a></span>replaceOpWithNewBufferizedOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpTy mlir::bufferization::replaceOpWithNewBufferizedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace an op with a new op. </p>
<p>The new op must have the same number of results as the replaced op. The new op may not return any tensor values. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00652">652</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00733">replaceOpWithBufferizedValues()</a>.</p>

</div>
</div>
<a id="a5cdcc74d8e9851ac1c043d88a8818ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdcc74d8e9851ac1c043d88a8818ad6">&#9670;&nbsp;</a></span>runOneShotBufferize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::runOneShotBufferize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run One-Shot Bufferize on the given op: Analysis + Bufferization. </p>

<p class="definition">Definition at line <a class="el" href="OneShotAnalysis_8cpp_source.html#l01366">1366</a> of file <a class="el" href="OneShotAnalysis_8cpp_source.html">OneShotAnalysis.cpp</a>.</p>

</div>
</div>
<a id="aec29323a856e1ed426652ede7649e3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec29323a856e1ed426652ede7649e3d2">&#9670;&nbsp;</a></span>runOneShotModuleBufferize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::bufferization::runOneShotModuleBufferize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>moduleOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationStatistics.html">BufferizationStatistics</a> *&#160;</td>
          <td class="paramname"><em>statistics</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run One-Shot Module Bufferization on the given <a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a>. </p>
<p>Performs a simple function call analysis to determine which function arguments are inplaceable. Then analyzes and bufferizes FuncOps one-by-one with One-Shot Bufferize. </p>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00602">602</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:30 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
