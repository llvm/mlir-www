<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::scf Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="namespacemlir_1_1scf.html">scf</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mlir::scf Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:ForLoopPipeliningPattern" id="r_ForLoopPipeliningPattern"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1scf_1_1ForLoopPipeliningPattern.html">ForLoopPipeliningPattern</a></td></tr>
<tr class="memitem:LoopNest" id="r_LoopNest"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a></td></tr>
<tr class="memitem:PipeliningOption" id="r_PipeliningOption"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1PipeliningOption.html">PipeliningOption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to dictate how loops should be pipelined.  <a href="structmlir_1_1scf_1_1PipeliningOption.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a816326c90f6e3b8f23459f60c3b87ba2" id="r_a816326c90f6e3b8f23459f60c3b87ba2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a816326c90f6e3b8f23459f60c3b87ba2">ValueVector</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;</td></tr>
<tr class="memdesc:a816326c90f6e3b8f23459f60c3b87ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning vector of values, handy to return from functions.  <br /></td></tr>
<tr class="memitem:a072f0657764921655c2a1917d5c2f1f3" id="r_a072f0657764921655c2a1917d5c2f1f3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a072f0657764921655c2a1917d5c2f1f3">LoopVector</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;scf::ForOp&gt;</td></tr>
<tr class="memitem:aa39c5b996e9c4cd633a5e6f41fc9f700" id="r_aa39c5b996e9c4cd633a5e6f41fc9f700"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa39c5b996e9c4cd633a5e6f41fc9f700">ValueTypeCastFnTy</a></td></tr>
<tr class="memdesc:aa39c5b996e9c4cd633a5e6f41fc9f700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a replacement of one iter <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> of an scf.for to the <span class="tt">replacement</span> value with a different type.  <br /></td></tr>
<tr class="memitem:a3d5fe8a0e9cd8aff7e7d34a7c0e2c582" id="r_a3d5fe8a0e9cd8aff7e7d34a7c0e2c582"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d5fe8a0e9cd8aff7e7d34a7c0e2c582">LoopMatcherFn</a></td></tr>
<tr class="memdesc:a3d5fe8a0e9cd8aff7e7d34a7c0e2c582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match "for loop"-like operations: If the first parameter is an iteration variable, return lower/upper bounds via the second/third parameter and the step size via the last parameter.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a601f846f06f5959b1a052e975eae8ec1" id="r_a601f846f06f5959b1a052e975eae8ec1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a601f846f06f5959b1a052e975eae8ec1">buildTerminatedBody</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a601f846f06f5959b1a052e975eae8ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callback for IfOp builders. Inserts a yield without arguments.  <br /></td></tr>
<tr class="memitem:a7e4957ac11a0c4d95f6a1494c808b392" id="r_a7e4957ac11a0c4d95f6a1494c808b392"><td class="memItemLeft" align="right" valign="top">ForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e4957ac11a0c4d95f6a1494c808b392">getForInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a7e4957ac11a0c4d95f6a1494c808b392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the loop parent of an induction variable.  <br /></td></tr>
<tr class="memitem:a13caec83d2c9665221580ea507c6e68b" id="r_a13caec83d2c9665221580ea507c6e68b"><td class="memItemLeft" align="right" valign="top">ParallelOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13caec83d2c9665221580ea507c6e68b">getParallelForInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a13caec83d2c9665221580ea507c6e68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parallel loop parent of an induction variable.  <br /></td></tr>
<tr class="memitem:acc06395336be1b229e2eb4198aed9790" id="r_acc06395336be1b229e2eb4198aed9790"><td class="memItemLeft" align="right" valign="top">ForallOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc06395336be1b229e2eb4198aed9790">getForallOpThreadIndexOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:acc06395336be1b229e2eb4198aed9790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ForallOp parent of an thread index variable.  <br /></td></tr>
<tr class="memitem:a68717bb14a63ffb8d9266322283d253f" id="r_a68717bb14a63ffb8d9266322283d253f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68717bb14a63ffb8d9266322283d253f">insideMutuallyExclusiveBranches</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *a, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>)</td></tr>
<tr class="memdesc:a68717bb14a63ffb8d9266322283d253f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if ops a and b (or their ancestors) are in mutually exclusive regions/blocks of an IfOp.  <br /></td></tr>
<tr class="memitem:a797e5365dbe74c07bf61e43ff8e6a796" id="r_a797e5365dbe74c07bf61e43ff8e6a796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a797e5365dbe74c07bf61e43ff8e6a796">promote</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, scf::ForallOp forallOp)</td></tr>
<tr class="memdesc:a797e5365dbe74c07bf61e43ff8e6a796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the loop body of a scf::ForallOp to its containing block.  <br /></td></tr>
<tr class="memitem:a63d89db573aefd9edf2c31fe8e7d5fe1" id="r_a63d89db573aefd9edf2c31fe8e7d5fe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63d89db573aefd9edf2c31fe8e7d5fe1">buildLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> iterArgs, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="#a816326c90f6e3b8f23459f60c3b87ba2">ValueVector</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilder=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a63d89db573aefd9edf2c31fe8e7d5fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a perfect nest of "for" loops, i.e.  <br /></td></tr>
<tr class="memitem:a6304a6715d1cc43d3035323cfb4cd78a" id="r_a6304a6715d1cc43d3035323cfb4cd78a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6304a6715d1cc43d3035323cfb4cd78a">buildLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilder=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a6304a6715d1cc43d3035323cfb4cd78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience version for building loop nests without iteration arguments (like for reductions).  <br /></td></tr>
<tr class="memitem:af63c05f1e097b490b8b8a8bd4919c9dd" id="r_af63c05f1e097b490b8b8a8bd4919c9dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af63c05f1e097b490b8b8a8bd4919c9dd">replaceAndCastForOpIterArg</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, scf::ForOp forOp, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;operand, <a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="LoopUtils_8cpp.html#af34d730a7920f1ae277f8c166146132d">replacement</a>, const <a class="el" href="#aa39c5b996e9c4cd633a5e6f41fc9f700">ValueTypeCastFnTy</a> &amp;castFn)</td></tr>
<tr class="memitem:a7d6c137859ac20767c57f03d04a34d70" id="r_a7d6c137859ac20767c57f03d04a34d70"><td class="memItemLeft" align="right" valign="top">std::optional&lt; llvm::APSInt &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d6c137859ac20767c57f03d04a34d70">computeUbMinusLb</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> lb, <a class="el" href="classmlir_1_1Value.html">Value</a> ub, <a class="el" href="classbool.html">bool</a> isSigned)</td></tr>
<tr class="memdesc:a7d6c137859ac20767c57f03d04a34d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to compute the difference between two values.  <br /></td></tr>
<tr class="memitem:ad68ad1a4a71bfedc1d4ebd46101cd31e" id="r_ad68ad1a4a71bfedc1d4ebd46101cd31e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad68ad1a4a71bfedc1d4ebd46101cd31e">registerValueBoundsOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a131df27a14db6c8a12e643fa2a0a5603" id="r_a131df27a14db6c8a12e643fa2a0a5603"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a131df27a14db6c8a12e643fa2a0a5603">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a842716ab488c11d997f15e8baae2521d" id="r_a842716ab488c11d997f15e8baae2521d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a842716ab488c11d997f15e8baae2521d">registerBufferDeallocationOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:af30aa77e8423a12af795fd7c5fcbc562" id="r_af30aa77e8423a12af795fd7c5fcbc562"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af30aa77e8423a12af795fd7c5fcbc562">registerBufferizableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:acad7e2a510c834ed4d299cb1152decef" id="r_acad7e2a510c834ed4d299cb1152decef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acad7e2a510c834ed4d299cb1152decef">populateSCFStructuralTypeConversionsAndLegality</a> (const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:acad7e2a510c834ed4d299cb1152decef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for SCF structural type conversions and sets up the provided <a class="el" href="classConversionTarget.html">ConversionTarget</a> with the appropriate legality configuration for the ops to get converted properly.  <br /></td></tr>
<tr class="memitem:a1bcccbca7dbf0315293263ee49c9694c" id="r_a1bcccbca7dbf0315293263ee49c9694c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bcccbca7dbf0315293263ee49c9694c">populateSCFStructuralTypeConversions</a> (const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a1bcccbca7dbf0315293263ee49c9694c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <span class="tt">populateSCFStructuralTypeConversionsAndLegality</span> but does not populate the conversion target.  <br /></td></tr>
<tr class="memitem:af195b4f79e283e6fbba9ea92f30f6bbe" id="r_af195b4f79e283e6fbba9ea92f30f6bbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af195b4f79e283e6fbba9ea92f30f6bbe">populateSCFStructuralTypeConversionTarget</a> (const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;typeConverter, <a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>)</td></tr>
<tr class="memdesc:af195b4f79e283e6fbba9ea92f30f6bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the <a class="el" href="classConversionTarget.html">ConversionTarget</a> with dynamic legality of SCF operations based on the provided type converter.  <br /></td></tr>
<tr class="memitem:a331c5d2ebecbdc149e0d0637ce2a65c7" id="r_a331c5d2ebecbdc149e0d0637ce2a65c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a331c5d2ebecbdc149e0d0637ce2a65c7">populateSCFLoopPipeliningPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="structmlir_1_1scf_1_1PipeliningOption.html">PipeliningOption</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:a331c5d2ebecbdc149e0d0637ce2a65c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for SCF software pipelining transformation.  <br /></td></tr>
<tr class="memitem:acbd982adcd3c785d3417107be92fee3a" id="r_acbd982adcd3c785d3417107be92fee3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbd982adcd3c785d3417107be92fee3a">populateSCFForLoopCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:acbd982adcd3c785d3417107be92fee3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for canonicalizing operations inside SCF loop bodies.  <br /></td></tr>
<tr class="memitem:aab7c278c81c25556d972e33c5b585c10" id="r_aab7c278c81c25556d972e33c5b585c10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab7c278c81c25556d972e33c5b585c10">populateUpliftWhileToForPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aab7c278c81c25556d972e33c5b585c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns to uplift <span class="tt">scf.while</span> ops to <span class="tt">scf.for</span>.  <br /></td></tr>
<tr class="memitem:a982a5d642793ae1124bb28addea486f1" id="r_a982a5d642793ae1124bb28addea486f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a982a5d642793ae1124bb28addea486f1">populateSCFRotateWhileLoopPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a982a5d642793ae1124bb28addea486f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns to rotate <span class="tt">scf.while</span> ops, constructing <span class="tt">do-while</span> loops from <span class="tt">while</span> loops.  <br /></td></tr>
<tr class="memitem:a59cea52d1eb02b4c18144d3882b9ba92" id="r_a59cea52d1eb02b4c18144d3882b9ba92"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59cea52d1eb02b4c18144d3882b9ba92">forallToForLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, ForallOp forallOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *results=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a59cea52d1eb02b4c18144d3882b9ba92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try converting scf.forall into a set of nested scf.for loops.  <br /></td></tr>
<tr class="memitem:a7513f476916dc73bae4761fb1a299066" id="r_a7513f476916dc73bae4761fb1a299066"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7513f476916dc73bae4761fb1a299066">forallToParallelLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, ForallOp forallOp, ParallelOp *<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a7513f476916dc73bae4761fb1a299066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try converting scf.forall into an scf.parallel loop.  <br /></td></tr>
<tr class="memitem:a85d10052a04cfd5ce9df027933bbd3e0" id="r_a85d10052a04cfd5ce9df027933bbd3e0"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1scf_1_1LoopNest.html">scf::LoopNest</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85d10052a04cfd5ce9df027933bbd3e0">parallelForToNestedFors</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, ParallelOp parallelOp)</td></tr>
<tr class="memdesc:a85d10052a04cfd5ce9df027933bbd3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try converting scf.forall into an scf.parallel loop.  <br /></td></tr>
<tr class="memitem:a46e1bfdfb0d60e264ebac4489bba616e" id="r_a46e1bfdfb0d60e264ebac4489bba616e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46e1bfdfb0d60e264ebac4489bba616e">naivelyFuseParallelOps</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; <a class="el" href="EliminateBarriers_8cpp.html#a769670962602294d6480466fb4c81d16">mayAlias</a>)</td></tr>
<tr class="memdesc:a46e1bfdfb0d60e264ebac4489bba616e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuses all adjacent scf.parallel operations with identical bounds and step into one scf.parallel operations.  <br /></td></tr>
<tr class="memitem:a55e793e622ecb45a3c5ff79b66939191" id="r_a55e793e622ecb45a3c5ff79b66939191"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55e793e622ecb45a3c5ff79b66939191">peelForLoopAndSimplifyBounds</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, ForOp forOp, scf::ForOp &amp;partialIteration)</td></tr>
<tr class="memdesc:a55e793e622ecb45a3c5ff79b66939191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a for loop with bounds/step that potentially do not divide evenly into a for loop where the step divides the iteration space evenly, followed by another scf.for for the last (partial) iteration (if any; returned via <span class="tt">partialIteration</span>).  <br /></td></tr>
<tr class="memitem:a5c57c456b2690971c53a73da26503859" id="r_a5c57c456b2690971c53a73da26503859"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c57c456b2690971c53a73da26503859">peelForLoopFirstIteration</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, ForOp forOp, scf::ForOp &amp;partialIteration)</td></tr>
<tr class="memdesc:a5c57c456b2690971c53a73da26503859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peel the first iteration out of the scf.for loop.  <br /></td></tr>
<tr class="memitem:aac87521511b3088f00423de46226c32c" id="r_aac87521511b3088f00423de46226c32c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; ParallelOp, ParallelOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac87521511b3088f00423de46226c32c">tileParallelLoop</a> (ParallelOp op, <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; tileSizes, <a class="el" href="classbool.html">bool</a> noMinMaxBounds)</td></tr>
<tr class="memdesc:aac87521511b3088f00423de46226c32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a parallel loop of the form scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4, arg5)  <br /></td></tr>
<tr class="memitem:adaec1b3505476981babe00468d32ac35" id="r_adaec1b3505476981babe00468d32ac35"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; ForOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaec1b3505476981babe00468d32ac35">pipelineForLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, ForOp forOp, const <a class="el" href="structmlir_1_1scf_1_1PipeliningOption.html">PipeliningOption</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, <a class="el" href="classbool.html">bool</a> *modifiedIR=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:adaec1b3505476981babe00468d32ac35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a pipelined version of the scf.for loop based on the schedule given as option.  <br /></td></tr>
<tr class="memitem:a1e9472eddc62665f04a9662521df3042" id="r_a1e9472eddc62665f04a9662521df3042"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; WhileOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e9472eddc62665f04a9662521df3042">wrapWhileLoopInZeroTripCheck</a> (WhileOp whileOp, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classbool.html">bool</a> forceCreateCheck=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a1e9472eddc62665f04a9662521df3042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create zero-trip-check around a <span class="tt">while</span> op and return the new loop op in the check.  <br /></td></tr>
<tr class="memitem:a65670cb065175149d16cdca3f5d1733b" id="r_a65670cb065175149d16cdca3f5d1733b"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; ForOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65670cb065175149d16cdca3f5d1733b">upliftWhileToForLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, WhileOp loop)</td></tr>
<tr class="memdesc:a65670cb065175149d16cdca3f5d1733b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to uplift <span class="tt">scf.while</span> op to <span class="tt">scf.for</span>.  <br /></td></tr>
<tr class="memitem:a37b7bd4317bfc1ab0b1852783218019c" id="r_a37b7bd4317bfc1ab0b1852783218019c"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37b7bd4317bfc1ab0b1852783218019c">matchForLikeLoop</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> iv, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;lb, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;ub, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;step)</td></tr>
<tr class="memdesc:a37b7bd4317bfc1ab0b1852783218019c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match "for loop"-like operations from the SCF dialect.  <br /></td></tr>
<tr class="memitem:a6eb8274cb04c9dffedfc6a3a7a9da758" id="r_a6eb8274cb04c9dffedfc6a3a7a9da758"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eb8274cb04c9dffedfc6a3a7a9da758">addLoopRangeConstraints</a> (<a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">affine::FlatAffineValueConstraints</a> &amp;cstr, <a class="el" href="classmlir_1_1Value.html">Value</a> iv, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> lb, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ub, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> step)</td></tr>
<tr class="memdesc:a6eb8274cb04c9dffedfc6a3a7a9da758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given constraint set with induction variable constraints of a "for" loop with the given range and step.  <br /></td></tr>
<tr class="memitem:a3e23c408a018f8aa464d703cd7d2ed3a" id="r_a3e23c408a018f8aa464d703cd7d2ed3a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e23c408a018f8aa464d703cd7d2ed3a">canonicalizeMinMaxOpInLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="#a3d5fe8a0e9cd8aff7e7d34a7c0e2c582">LoopMatcherFn</a> loopMatcher)</td></tr>
<tr class="memdesc:a3e23c408a018f8aa464d703cd7d2ed3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to canonicalize the given affine.min/max operation in the context of for <span class="tt">loops</span> with a known range.  <br /></td></tr>
<tr class="memitem:a673d966447761363e8583d22bbf08169" id="r_a673d966447761363e8583d22bbf08169"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a673d966447761363e8583d22bbf08169">rewritePeeledMinMaxOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> iv, <a class="el" href="classmlir_1_1Value.html">Value</a> ub, <a class="el" href="classmlir_1_1Value.html">Value</a> step, <a class="el" href="classbool.html">bool</a> insideLoop)</td></tr>
<tr class="memdesc:a673d966447761363e8583d22bbf08169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to simplify the given affine.min/max operation <span class="tt">op</span> after loop peeling.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a3d5fe8a0e9cd8aff7e7d34a7c0e2c582" name="a3d5fe8a0e9cd8aff7e7d34a7c0e2c582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5fe8a0e9cd8aff7e7d34a7c0e2c582">&#9670;&#160;</a></span>LoopMatcherFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3d5fe8a0e9cd8aff7e7d34a7c0e2c582">mlir::scf::LoopMatcherFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_typedef" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt;LogicalResult(</div>
<div class="line">    <a class="code hl_class" href="classmlir_1_1Value.html">Value</a>, <a class="code hl_class" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;, <a class="code hl_class" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;, <a class="code hl_class" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;)&gt;</div>
<div class="ttc" id="aclassmlir_1_1OpFoldResult_html"><div class="ttname"><a href="classmlir_1_1OpFoldResult.html">mlir::OpFoldResult</a></div><div class="ttdoc">This class represents a single result from folding an operation.</div><div class="ttdef"><b>Definition</b> <a href="OpDefinition_8h_source.html#l00272">OpDefinition.h:272</a></div></div>
<div class="ttc" id="aclassmlir_1_1Value_html"><div class="ttname"><a href="classmlir_1_1Value.html">mlir::Value</a></div><div class="ttdoc">This class represents an instance of an SSA value in the MLIR system, representing a computable value...</div><div class="ttdef"><b>Definition</b> <a href="Value_8h_source.html#l00096">Value.h:96</a></div></div>
<div class="ttc" id="anamespacemlir_html_aeb139bbbd94ce3525f61d508772f5d69"><div class="ttname"><a href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">mlir::function_ref</a></div><div class="ttdeci">llvm::function_ref&lt; Fn &gt; function_ref</div><div class="ttdef"><b>Definition</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00152">LLVM.h:152</a></div></div>
</div><!-- fragment -->
<p>Match "for loop"-like operations: If the first parameter is an iteration variable, return lower/upper bounds via the second/third parameter and the step size via the last parameter. </p>
<p>The function should return <span class="tt">success</span> in that case. If the first parameter is not an iteration variable, return <span class="tt">failure</span>. </p>

<p class="definition">Definition at line <a class="el" href="AffineCanonicalizationUtils_8h_source.html#l00039">39</a> of file <a class="el" href="AffineCanonicalizationUtils_8h_source.html">AffineCanonicalizationUtils.h</a>.</p>

</div>
</div>
<a id="a072f0657764921655c2a1917d5c2f1f3" name="a072f0657764921655c2a1917d5c2f1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072f0657764921655c2a1917d5c2f1f3">&#9670;&#160;</a></span>LoopVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a072f0657764921655c2a1917d5c2f1f3">mlir::scf::LoopVector</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;scf::ForOp&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html#l00065">65</a> of file <a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html">SCF.h</a>.</p>

</div>
</div>
<a id="aa39c5b996e9c4cd633a5e6f41fc9f700" name="aa39c5b996e9c4cd633a5e6f41fc9f700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39c5b996e9c4cd633a5e6f41fc9f700">&#9670;&#160;</a></span>ValueTypeCastFnTy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa39c5b996e9c4cd633a5e6f41fc9f700">mlir::scf::ValueTypeCastFnTy</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;<a class="code hl_class" href="classmlir_1_1Value.html">Value</a>(<a class="code hl_class" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="code hl_class" href="classmlir_1_1Location.html">Location</a> loc, <a class="code hl_class" href="classmlir_1_1Type.html">Type</a>, <a class="code hl_class" href="classmlir_1_1Value.html">Value</a>)&gt;</div>
<div class="ttc" id="aclassllvm_1_1function__ref_html"><div class="ttname"><a href="classllvm_1_1function__ref.html">llvm::function_ref</a></div><div class="ttdef"><b>Definition</b> <a href="mlir_2Support_2LLVM_8h_source.html#l00090">LLVM.h:90</a></div></div>
<div class="ttc" id="aclassmlir_1_1Location_html"><div class="ttname"><a href="classmlir_1_1Location.html">mlir::Location</a></div><div class="ttdoc">This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...</div><div class="ttdef"><b>Definition</b> <a href="Location_8h_source.html#l00076">Location.h:76</a></div></div>
<div class="ttc" id="aclassmlir_1_1OpBuilder_html"><div class="ttname"><a href="classmlir_1_1OpBuilder.html">mlir::OpBuilder</a></div><div class="ttdoc">This class helps build Operations.</div><div class="ttdef"><b>Definition</b> <a href="Builders_8h_source.html#l00207">Builders.h:207</a></div></div>
<div class="ttc" id="aclassmlir_1_1Type_html"><div class="ttname"><a href="classmlir_1_1Type.html">mlir::Type</a></div><div class="ttdoc">Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...</div><div class="ttdef"><b>Definition</b> <a href="IR_2Types_8h_source.html#l00074">Types.h:74</a></div></div>
</div><!-- fragment -->
<p>Perform a replacement of one iter <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation.">OpOperand</a> of an scf.for to the <span class="tt">replacement</span> value with a different type. </p>
<p>A callback is used to insert cast ops inside the block to account for type differences. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html#l00107">107</a> of file <a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html">SCF.h</a>.</p>

</div>
</div>
<a id="a816326c90f6e3b8f23459f60c3b87ba2" name="a816326c90f6e3b8f23459f60c3b87ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816326c90f6e3b8f23459f60c3b87ba2">&#9670;&#160;</a></span>ValueVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a816326c90f6e3b8f23459f60c3b87ba2">mlir::scf::ValueVector</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An owning vector of values, handy to return from functions. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html#l00064">64</a> of file <a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html">SCF.h</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a6eb8274cb04c9dffedfc6a3a7a9da758" name="a6eb8274cb04c9dffedfc6a3a7a9da758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb8274cb04c9dffedfc6a3a7a9da758">&#9670;&#160;</a></span>addLoopRangeConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::scf::addLoopRangeConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">affine::FlatAffineValueConstraints</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cstr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>iv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>step</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given constraint set with induction variable constraints of a "for" loop with the given range and step. </p>

<p class="definition">Definition at line <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00077">77</a> of file <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html">AffineCanonicalizationUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::affine::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00371">mlir::presburger::IntegerRelation::addInequality()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01181">mlir::FlatLinearValueConstraints::appendDimVar()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01186">mlir::FlatLinearValueConstraints::appendSymbolVar()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="Value_8h_source.html#l00108">mlir::Value::getContext()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00238">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00231">mlir::presburger::IntegerRelation::getNumDimVars()</a>, and <a class="el" href="IntegerRelation_8h_source.html#l00228">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00145">canonicalizeMinMaxOpInLoop()</a>.</p>

</div>
</div>
<a id="a6304a6715d1cc43d3035323cfb4cd78a" name="a6304a6715d1cc43d3035323cfb4cd78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6304a6715d1cc43d3035323cfb4cd78a">&#9670;&#160;</a></span>buildLoopNest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a> mlir::scf::buildLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>lbs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>ubs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>steps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>bodyBuilder</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience version for building loop nests without iteration arguments (like for reductions). </p>
<p>Does not take the initial value of reductions or expect the body building functions to return their current value. The built nested scf::For are captured in <span class="tt">capturedLoops</span> when non-null. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00911">911</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00838">buildLoopNest()</a>.</p>

</div>
</div>
<a id="a63d89db573aefd9edf2c31fe8e7d5fe1" name="a63d89db573aefd9edf2c31fe8e7d5fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d89db573aefd9edf2c31fe8e7d5fe1">&#9670;&#160;</a></span>buildLoopNest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a> mlir::scf::buildLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>lbs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>ubs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>steps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>iterArgs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="#a816326c90f6e3b8f23459f60c3b87ba2">ValueVector</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>bodyBuilder</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a perfect nest of "for" loops, i.e. </p>
<p>all loops but the innermost contain only another loop and a terminator. The lower, upper bounds and steps are provided as <span class="tt">lbs</span>, <span class="tt">ubs</span> and <span class="tt">steps</span>, which are expected to be of the same size. <span class="tt">iterArgs</span> points to the initial values of the loop iteration arguments, which will be forwarded through the nest to the innermost loop. The body of the loop is populated using <span class="tt">bodyBuilder</span>, which accepts an ordered list of induction variables of all loops, followed by a list of iteration arguments of the innermost loop, in the same order as provided to <span class="tt">iterArgs</span>. This function is expected to return as many values as <span class="tt">iterArgs</span>, of the same type and in the same order, that will be treated as yielded from the loop body and forwarded back through the loop nest. If the function is not provided, the loop nest is not expected to have iteration arguments, the body of the innermost loop will be left empty, containing only the zero-operand terminator. Returns the <a class="el" href="structmlir_1_1scf_1_1LoopNest.html">LoopNest</a> containing the list of perfectly nest scf::ForOp build during the call. If bound arrays are empty, the body builder will be called once to construct the IR outside of the loop with an empty list of induction variables. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00838">838</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00436">mlir::OpBuilder::setInsertionPointToEnd()</a>, <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02103">ValueRange</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00911">buildLoopNest()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01603">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01698">mlir::linalg::generateParallelLoopNest()</a>, and <a class="el" href="MemoryPromotion_8cpp_source.html#l00030">insertCopyLoops()</a>.</p>

</div>
</div>
<a id="a601f846f06f5959b1a052e975eae8ec1" name="a601f846f06f5959b1a052e975eae8ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601f846f06f5959b1a052e975eae8ec1">&#9670;&#160;</a></span>buildTerminatedBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::buildTerminatedBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default callback for IfOp builders. Inserts a yield without arguments. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00094">94</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

</div>
</div>
<a id="a3e23c408a018f8aa464d703cd7d2ed3a" name="a3e23c408a018f8aa464d703cd7d2ed3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e23c408a018f8aa464d703cd7d2ed3a">&#9670;&#160;</a></span>canonicalizeMinMaxOpInLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::scf::canonicalizeMinMaxOpInLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3d5fe8a0e9cd8aff7e7d34a7c0e2c582">LoopMatcherFn</a></td>          <td class="paramname"><span class="paramname"><em>loopMatcher</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to canonicalize the given affine.min/max operation in the context of for <span class="tt">loops</span> with a known range. </p>
<p>Canonicalize min/max operations in the context of for loops with a known range.</p>
<p><span class="tt">loopMatcher</span> is used to retrieve loop bounds and the step size for a given iteration variable.</p>
<p>Note: <span class="tt">loopMatcher</span> allows this function to be used with any "for loop"-like operation (scf.for, scf.parallel and even ops defined in other dialects).</p>
<p>Call <span class="tt">canonicalizeMinMaxOp</span> and add the following constraints to the constraint system (along with the missing dimensions):</p>
<ul>
<li>iv &gt;= lb</li>
<li>iv &lt; lb + step * ((ub - lb - 1) floorDiv step) + 1</li>
</ul>
<p>Note: Due to limitations of <a class="el" href="classmlir_1_1presburger_1_1IntegerPolyhedron.html" title="An IntegerPolyhedron represents the set of points from a PresburgerSpace that satisfy a list of affin...">IntegerPolyhedron</a>, only constant step sizes are currently supported. </p>

<p class="definition">Definition at line <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00145">145</a> of file <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html">AffineCanonicalizationUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00077">addLoopRangeConstraints()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00065">canonicalizeMinMaxOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>.</p>

</div>
</div>
<a id="a7d6c137859ac20767c57f03d04a34d70" name="a7d6c137859ac20767c57f03d04a34d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6c137859ac20767c57f03d04a34d70">&#9670;&#160;</a></span>computeUbMinusLb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; llvm::APSInt &gt; mlir::scf::computeUbMinusLb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isSigned</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to compute the difference between two values. </p>
<p>This is used by the loop implementations to compute the trip count. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00115">115</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00527">mlir::m_ConstantInt()</a>, and <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01563">mlir::getConstLoopTripCounts()</a>.</p>

</div>
</div>
<a id="a59cea52d1eb02b4c18144d3882b9ba92" name="a59cea52d1eb02b4c18144d3882b9ba92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59cea52d1eb02b4c18144d3882b9ba92">&#9670;&#160;</a></span>forallToForLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::scf::forallToForLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForallOp</td>          <td class="paramname"><span class="paramname"><em>forallOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>results</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try converting scf.forall into a set of nested scf.for loops. </p>
<p>The newly created scf.for ops will be returned through the <span class="tt">results</span> vector if provided. </p>

</div>
</div>
<a id="a7513f476916dc73bae4761fb1a299066" name="a7513f476916dc73bae4761fb1a299066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7513f476916dc73bae4761fb1a299066">&#9670;&#160;</a></span>forallToParallelLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::scf::forallToParallelLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForallOp</td>          <td class="paramname"><span class="paramname"><em>forallOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParallelOp *</td>          <td class="paramname"><span class="paramname"><em>result</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try converting scf.forall into an scf.parallel loop. </p>
<p>The conversion is only supported for forall operations with no results. </p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="acc06395336be1b229e2eb4198aed9790" name="acc06395336be1b229e2eb4198aed9790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc06395336be1b229e2eb4198aed9790">&#9670;&#160;</a></span>getForallOpThreadIndexOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForallOp mlir::scf::getForallOpThreadIndexOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ForallOp parent of an thread index variable. </p>
<p>If the provided value is not a thread index variable, then return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l01610">1610</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00031">matchForLikeLoop()</a>.</p>

</div>
</div>
<a id="a7e4957ac11a0c4d95f6a1494c808b392" name="a7e4957ac11a0c4d95f6a1494c808b392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4957ac11a0c4d95f6a1494c808b392">&#9670;&#160;</a></span>getForInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForOp mlir::scf::getForInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the loop parent of an induction variable. </p>
<p>If the provided value is not an induction variable, then return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00745">745</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="HoistPadding_8cpp_source.html#l00545">buildPackingLoopNestImpl()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00031">matchForLikeLoop()</a>, and <a class="el" href="HoistPadding_8cpp_source.html#l00880">replaceByPackingResult()</a>.</p>

</div>
</div>
<a id="a13caec83d2c9665221580ea507c6e68b" name="a13caec83d2c9665221580ea507c6e68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13caec83d2c9665221580ea507c6e68b">&#9670;&#160;</a></span>getParallelForInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParallelOp mlir::scf::getParallelForInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the parallel loop parent of an induction variable. </p>
<p>If the provided value is not an induction variable, then return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l03271">3271</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00031">matchForLikeLoop()</a>.</p>

</div>
</div>
<a id="a68717bb14a63ffb8d9266322283d253f" name="a68717bb14a63ffb8d9266322283d253f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68717bb14a63ffb8d9266322283d253f">&#9670;&#160;</a></span>insideMutuallyExclusiveBranches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::scf::insideMutuallyExclusiveBranches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if ops a and b (or their ancestors) are in mutually exclusive regions/blocks of an IfOp. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l02152">2152</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00238">mlir::Operation::getParentOfType()</a>.</p>

</div>
</div>
<a id="a37b7bd4317bfc1ab0b1852783218019c" name="a37b7bd4317bfc1ab0b1852783218019c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b7bd4317bfc1ab0b1852783218019c">&#9670;&#160;</a></span>matchForLikeLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::scf::matchForLikeLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>iv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>step</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match "for loop"-like operations from the SCF dialect. </p>

<p class="definition">Definition at line <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00031">31</a> of file <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html">AffineCanonicalizationUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l01610">getForallOpThreadIndexOwner()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00745">getForInductionVarOwner()</a>, <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l03271">getParallelForInductionVarOwner()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a46e1bfdfb0d60e264ebac4489bba616e" name="a46e1bfdfb0d60e264ebac4489bba616e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e1bfdfb0d60e264ebac4489bba616e">&#9670;&#160;</a></span>naivelyFuseParallelOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::naivelyFuseParallelOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>mayAlias</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuses all adjacent scf.parallel operations with identical bounds and step into one scf.parallel operations. </p>
<p>Uses a naive aliasing and dependency analysis. User can additionally customize alias checking with <span class="tt">mayAlias</span> hook. <span class="tt">mayAlias</span> must return false if 2 values are guaranteed to not alias. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00235">235</a> of file <a class="el" href="ParallelLoopFusion_8cpp_source.html">ParallelLoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00166">fuseIfLegal()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00320">mlir::isMemoryEffectFree()</a>, and <a class="el" href="EliminateBarriers_8cpp_source.html#l00424">mayAlias()</a>.</p>

</div>
</div>
<a id="a85d10052a04cfd5ce9df027933bbd3e0" name="a85d10052a04cfd5ce9df027933bbd3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d10052a04cfd5ce9df027933bbd3e0">&#9670;&#160;</a></span>parallelForToNestedFors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="structmlir_1_1scf_1_1LoopNest.html">scf::LoopNest</a> &gt; mlir::scf::parallelForToNestedFors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParallelOp</td>          <td class="paramname"><span class="paramname"><em>parallelOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try converting scf.forall into an scf.parallel loop. </p>
<p>The conversion is only supported for parallel operations with no results. </p>

<p class="reference">References <a class="el" href="EliminateBarriers_8cpp_source.html#l00424">mayAlias()</a>.</p>

</div>
</div>
<a id="a55e793e622ecb45a3c5ff79b66939191" name="a55e793e622ecb45a3c5ff79b66939191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e793e622ecb45a3c5ff79b66939191">&#9670;&#160;</a></span>peelForLoopAndSimplifyBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::scf::peelForLoopAndSimplifyBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp &amp;</td>          <td class="paramname"><span class="paramname"><em>partialIteration</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a for loop with bounds/step that potentially do not divide evenly into a for loop where the step divides the iteration space evenly, followed by another scf.for for the last (partial) iteration (if any; returned via <span class="tt">partialIteration</span>). </p>
<p>This transformation is called "loop peeling".</p>
<p>This transformation is beneficial for a wide range of transformations such as vectorization or loop tiling: It enables additional canonicalizations inside the peeled loop body such as rewriting masked loads into unmaked loads.</p>
<p>E.g., assuming a lower bound of 0 (for illustration purposes): </p><div class="fragment"><div class="line"><a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for %iv = %c0 to %<a class="code hl_namespace" href="namespacemlir_1_1ub.html">ub</a> step %c4 {</div>
<div class="line">  (loop body)</div>
<div class="line">}</div>
<div class="ttc" id="anamespacemlir_1_1scf_html"><div class="ttname"><a href="namespacemlir_1_1scf.html">mlir::scf</a></div><div class="ttdef"><b>Definition</b> <a href="SCFToGPU_8h_source.html#l00024">SCFToGPU.h:24</a></div></div>
<div class="ttc" id="anamespacemlir_1_1ub_html"><div class="ttname"><a href="namespacemlir_1_1ub.html">mlir::ub</a></div><div class="ttdef"><b>Definition</b> <a href="UBToLLVM_8h_source.html#l00024">UBToLLVM.h:24</a></div></div>
</div><!-- fragment --><p> is rewritten into the following pseudo IR: </p><div class="fragment"><div class="line">%newUb = %<a class="code hl_namespace" href="namespacemlir_1_1ub.html">ub</a> - (%<a class="code hl_namespace" href="namespacemlir_1_1ub.html">ub</a> mod %c4)</div>
<div class="line"><a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for %iv = %c0 to %newUb step %c4 {</div>
<div class="line">  (loop body)</div>
<div class="line">}</div>
<div class="line"><a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for %iv2 = %newUb to %<a class="code hl_namespace" href="namespacemlir_1_1ub.html">ub</a> {</div>
<div class="line">  (loop body)</div>
<div class="line">}</div>
</div><!-- fragment --><p>After loop peeling, this function tries to simplify affine.min and affine.max ops in the body of the peeled loop and in the body of the partial iteration loop, taking advantage of the fact that the peeled loop has only "full" iterations. This simplification is expected to enable further canonicalization opportunities through other patterns.</p>
<p>The return value indicates whether the loop was rewritten or not. <a class="el" href="namespacemlir.html#aed48aeaaa3484827b729cced4fb0dfb6" title="Tile a nest of standard for loops rooted at rootForOp by finding such parametric tile sizes that the ...">Loops</a> are not rewritten if:</p><ul>
<li>Loop step size is 1 or</li>
<li>Loop bounds and step size are static, and step already divides the iteration space evenly.</li>
</ul>
<p>Note: This function rewrites the given scf.for loop in-place and creates a new scf.for operation for the last iteration. It replaces all uses of the unpeeled loop with the results of the newly generated scf.for. </p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00053">mlir::linalg::peelLoop()</a>.</p>

</div>
</div>
<a id="a5c57c456b2690971c53a73da26503859" name="a5c57c456b2690971c53a73da26503859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c57c456b2690971c53a73da26503859">&#9670;&#160;</a></span>peelForLoopFirstIteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::scf::peelForLoopFirstIteration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp &amp;</td>          <td class="paramname"><span class="paramname"><em>partialIteration</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peel the first iteration out of the scf.for loop. </p>
<p>If there is only one iteration, return the original loop. </p>

</div>
</div>
<a id="adaec1b3505476981babe00468d32ac35" name="adaec1b3505476981babe00468d32ac35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaec1b3505476981babe00468d32ac35">&#9670;&#160;</a></span>pipelineForLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; ForOp &gt; mlir::scf::pipelineForLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1scf_1_1PipeliningOption.html">PipeliningOption</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *</td>          <td class="paramname"><span class="paramname"><em>modifiedIR</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a pipelined version of the scf.for loop based on the schedule given as option. </p>
<p>This applies the mechanical transformation of changing the loop and generating the prologue/epilogue for the pipelining and doesn't make any decision regarding the schedule. Based on the options the loop is split into several stages. The transformation assumes that the scheduling given by user is valid. For example if we break a loop into 3 stages named S0, S1, S2 we would generate the following code with the number in parenthesis as the iteration index:</p>
<p>S0(0) // Prologue S0(1) S1(0) // Prologue scf.for I = C0 to N - 2 { S0(I+2) S1(I+1) S2(I) // Pipelined kernel } S1(N) S2(N-1) // Epilogue S2(N) // Epilogue</p>
<p>If <span class="tt">modifiedIR</span> is provided, it will be set to a value that indicates whether pipelining modified the IR before failing, signaling to the caller whether they can proceed with different transformations. </p>

<p class="definition">Definition at line <a class="el" href="LoopPipelining_8cpp_source.html#l00789">789</a> of file <a class="el" href="LoopPipelining_8cpp_source.html">LoopPipelining.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Patterns_8h_source.html#l00034">mlir::scf::ForLoopPipeliningPattern::returningMatchAndRewrite()</a>.</p>

</div>
</div>
<a id="acbd982adcd3c785d3417107be92fee3a" name="acbd982adcd3c785d3417107be92fee3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd982adcd3c785d3417107be92fee3a">&#9670;&#160;</a></span>populateSCFForLoopCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::populateSCFForLoopCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns for canonicalizing operations inside SCF loop bodies. </p>
<p>At the moment, only affine.min/max computations with iteration variables, loop bounds and loop steps are canonicalized. </p>

<p class="definition">Definition at line <a class="el" href="LoopCanonicalization_8cpp_source.html#l00176">176</a> of file <a class="el" href="LoopCanonicalization_8cpp_source.html">LoopCanonicalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a331c5d2ebecbdc149e0d0637ce2a65c7" name="a331c5d2ebecbdc149e0d0637ce2a65c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331c5d2ebecbdc149e0d0637ce2a65c7">&#9670;&#160;</a></span>populateSCFLoopPipeliningPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::populateSCFLoopPipeliningPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1scf_1_1PipeliningOption.html">PipeliningOption</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns for SCF software pipelining transformation. </p>
<p>See the <a class="el" href="classmlir_1_1scf_1_1ForLoopPipeliningPattern.html">ForLoopPipeliningPattern</a> for the transformation details. </p>

<p class="definition">Definition at line <a class="el" href="LoopPipelining_8cpp_source.html#l00847">847</a> of file <a class="el" href="LoopPipelining_8cpp_source.html">LoopPipelining.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00089">options</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a982a5d642793ae1124bb28addea486f1" name="a982a5d642793ae1124bb28addea486f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982a5d642793ae1124bb28addea486f1">&#9670;&#160;</a></span>populateSCFRotateWhileLoopPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::populateSCFRotateWhileLoopPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns to rotate <span class="tt">scf.while</span> ops, constructing <span class="tt">do-while</span> loops from <span class="tt">while</span> loops. </p>

<p class="definition">Definition at line <a class="el" href="RotateWhileLoop_8cpp_source.html#l00040">40</a> of file <a class="el" href="RotateWhileLoop_8cpp_source.html">RotateWhileLoop.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a1bcccbca7dbf0315293263ee49c9694c" name="a1bcccbca7dbf0315293263ee49c9694c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bcccbca7dbf0315293263ee49c9694c">&#9670;&#160;</a></span>populateSCFStructuralTypeConversions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::populateSCFStructuralTypeConversions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <span class="tt">populateSCFStructuralTypeConversionsAndLegality</span> but does not populate the conversion target. </p>

<p class="definition">Definition at line <a class="el" href="SCF_2Transforms_2StructuralTypeConversions_8cpp_source.html#l00243">243</a> of file <a class="el" href="SCF_2Transforms_2StructuralTypeConversions_8cpp_source.html">StructuralTypeConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCF_2Transforms_2StructuralTypeConversions_8cpp_source.html#l00267">populateSCFStructuralTypeConversionsAndLegality()</a>.</p>

</div>
</div>
<a id="acad7e2a510c834ed4d299cb1152decef" name="acad7e2a510c834ed4d299cb1152decef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad7e2a510c834ed4d299cb1152decef">&#9670;&#160;</a></span>populateSCFStructuralTypeConversionsAndLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::populateSCFStructuralTypeConversionsAndLegality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td>          <td class="paramname"><span class="paramname"><em>benefit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for SCF structural type conversions and sets up the provided <a class="el" href="classConversionTarget.html">ConversionTarget</a> with the appropriate legality configuration for the ops to get converted properly. </p>
<p>A "structural" type conversion is one where the underlying ops are completely agnostic to the actual types involved and simply need to update their types. An example of this is scf.if &ndash; the scf.if op and the corresponding scf.yield ops need to update their types accordingly to the <a class="el" href="classTypeConverter.html">TypeConverter</a>, but otherwise don't care what type conversions are happening. </p>

<p class="definition">Definition at line <a class="el" href="SCF_2Transforms_2StructuralTypeConversions_8cpp_source.html#l00267">267</a> of file <a class="el" href="SCF_2Transforms_2StructuralTypeConversions_8cpp_source.html">StructuralTypeConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, <a class="el" href="SCF_2Transforms_2StructuralTypeConversions_8cpp_source.html#l00243">populateSCFStructuralTypeConversions()</a>, <a class="el" href="SCF_2Transforms_2StructuralTypeConversions_8cpp_source.html#l00252">populateSCFStructuralTypeConversionTarget()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00354">mlir::xegpu::doSCFStructuralTypeConversionWithTensorType()</a>.</p>

</div>
</div>
<a id="af195b4f79e283e6fbba9ea92f30f6bbe" name="af195b4f79e283e6fbba9ea92f30f6bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af195b4f79e283e6fbba9ea92f30f6bbe">&#9670;&#160;</a></span>populateSCFStructuralTypeConversionTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::populateSCFStructuralTypeConversionTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTypeConverter.html">TypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typeConverter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConversionTarget.html">ConversionTarget</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the <a class="el" href="classConversionTarget.html">ConversionTarget</a> with dynamic legality of SCF operations based on the provided type converter. </p>

<p class="definition">Definition at line <a class="el" href="SCF_2Transforms_2StructuralTypeConversions_8cpp_source.html#l00252">252</a> of file <a class="el" href="SCF_2Transforms_2StructuralTypeConversions_8cpp_source.html">StructuralTypeConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCF_2Transforms_2StructuralTypeConversions_8cpp_source.html#l00267">populateSCFStructuralTypeConversionsAndLegality()</a>.</p>

</div>
</div>
<a id="aab7c278c81c25556d972e33c5b585c10" name="aab7c278c81c25556d972e33c5b585c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7c278c81c25556d972e33c5b585c10">&#9670;&#160;</a></span>populateUpliftWhileToForPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::populateUpliftWhileToForPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns to uplift <span class="tt">scf.while</span> ops to <span class="tt">scf.for</span>. </p>
<p>Uplifitng expects a specific ops pattern:</p><ul>
<li><span class="tt">before</span> block consisting of single arith.cmp op</li>
<li><span class="tt">after</span> block containing arith.addi </li>
</ul>

<p class="definition">Definition at line <a class="el" href="UpliftWhileToFor_8cpp_source.html#l00269">269</a> of file <a class="el" href="UpliftWhileToFor_8cpp_source.html">UpliftWhileToFor.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a797e5365dbe74c07bf61e43ff8e6a796" name="a797e5365dbe74c07bf61e43ff8e6a796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797e5365dbe74c07bf61e43ff8e6a796">&#9670;&#160;</a></span>promote()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::promote </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForallOp</td>          <td class="paramname"><span class="paramname"><em>forallOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes the loop body of a scf::ForallOp to its containing block. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00793">793</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00290">mlir::RewriterBase::inlineBlockBefore()</a>, <a class="el" href="PatternMatch_8h_source.html#l00646">mlir::RewriterBase::replaceAllUsesWith()</a>, and <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

</div>
</div>
<a id="a842716ab488c11d997f15e8baae2521d" name="a842716ab488c11d997f15e8baae2521d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842716ab488c11d997f15e8baae2521d">&#9670;&#160;</a></span>registerBufferDeallocationOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::registerBufferDeallocationOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCF_2Transforms_2BufferDeallocationOpInterfaceImpl_8cpp_source.html#l00075">75</a> of file <a class="el" href="SCF_2Transforms_2BufferDeallocationOpInterfaceImpl_8cpp_source.html">BufferDeallocationOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="af30aa77e8423a12af795fd7c5fcbc562" name="af30aa77e8423a12af795fd7c5fcbc562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30aa77e8423a12af795fd7c5fcbc562">&#9670;&#160;</a></span>registerBufferizableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::registerBufferizableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCF_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html#l01367">1367</a> of file <a class="el" href="SCF_2Transforms_2BufferizableOpInterfaceImpl_8cpp_source.html">BufferizableOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a131df27a14db6c8a12e643fa2a0a5603" name="a131df27a14db6c8a12e643fa2a0a5603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131df27a14db6c8a12e643fa2a0a5603">&#9670;&#160;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="ad68ad1a4a71bfedc1d4ebd46101cd31e" name="ad68ad1a4a71bfedc1d4ebd46101cd31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68ad1a4a71bfedc1d4ebd46101cd31e">&#9670;&#160;</a></span>registerValueBoundsOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::registerValueBoundsOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SCF_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00237">237</a> of file <a class="el" href="SCF_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="af63c05f1e097b490b8b8a8bd4919c9dd" name="af63c05f1e097b490b8b8a8bd4919c9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63c05f1e097b490b8b8a8bd4919c9dd">&#9670;&#160;</a></span>replaceAndCastForOpIterArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::scf::replaceAndCastForOpIterArg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::ForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>operand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa39c5b996e9c4cd633a5e6f41fc9f700">ValueTypeCastFnTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>castFn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html#l00927">927</a> of file <a class="el" href="Dialect_2SCF_2IR_2SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00155">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="Block_8h_source.html#l00153">mlir::Block::front()</a>, <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8h_source.html#l00321">mlir::BlockArgument::getArgNumber()</a>, <a class="el" href="Block_8h_source.html#l00087">mlir::Block::getArguments()</a>, <a class="el" href="Value_8cpp_source.html#l00226">mlir::OpOperand::getOperandNumber()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Block_8cpp_source.html#l00244">mlir::Block::getTerminator()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00343">mlir::RewriterBase::mergeBlocks()</a>, <a class="el" href="LoopUtils_8cpp.html#af34d730a7920f1ae277f8c166146132d">replacement()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointAfter()</a>, and <a class="el" href="Builders_8h_source.html#l00431">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="a673d966447761363e8583d22bbf08169" name="a673d966447761363e8583d22bbf08169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673d966447761363e8583d22bbf08169">&#9670;&#160;</a></span>rewritePeeledMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::scf::rewritePeeledMinMaxOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>iv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>step</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>insideLoop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to simplify the given affine.min/max operation <span class="tt">op</span> after loop peeling. </p>
<p>This function can simplify min/max operations such as (ub is the previous upper bound of the unpeeled loop): </p><div class="fragment"><div class="line"><span class="preprocessor">#map = affine_map&lt;(d0)[s0, s1] -&gt; (s0, -d0 + s1)&gt;</span></div>
<div class="line">%r = <a class="code hl_namespace" href="namespacemlir_1_1affine.html">affine</a>.min #map(%iv)[%step, %<a class="code hl_namespace" href="namespacemlir_1_1ub.html">ub</a>]</div>
<div class="ttc" id="anamespacemlir_1_1affine_html"><div class="ttname"><a href="namespacemlir_1_1affine.html">mlir::affine</a></div><div class="ttdef"><b>Definition</b> <a href="AffineToStandard_8h_source.html#l00023">AffineToStandard.h:23</a></div></div>
</div><!-- fragment --><p> and rewrites them into (in the case the peeled loop): </p><div class="fragment"><div class="line">%r = %step</div>
</div><!-- fragment --><p> min/max operations inside the partial iteration are rewritten in a similar way.</p>
<p>This function can simplify min/max operations such as (ub is the previous upper bound of the unpeeled loop): </p><div class="fragment"><div class="line"><span class="preprocessor">#map = affine_map&lt;(d0)[s0, s1] -&gt; (s0, -d0 + s1)&gt;</span></div>
<div class="line">%r = <a class="code hl_namespace" href="namespacemlir_1_1affine.html">affine</a>.min #<a class="code hl_namespace" href="namespacemlir_1_1affine.html">affine</a>.min #map(%iv)[%step, %<a class="code hl_namespace" href="namespacemlir_1_1ub.html">ub</a>]</div>
</div><!-- fragment --><p> and rewrites them into (in the case the peeled loop): </p><div class="fragment"><div class="line">%r = %step</div>
</div><!-- fragment --><p> min/max operations inside the partial iteration are rewritten in a similar way.</p>
<p>This function builds up a set of constraints, capable of proving that:</p><ul>
<li>Inside the peeled loop: min(step, ub - iv) == step</li>
<li>Inside the partial iteration: min(step, ub - iv) == ub - iv</li>
</ul>
<p>Returns <span class="tt">success</span> if the given operation was replaced by a new operation; <span class="tt">failure</span> otherwise.</p>
<p>Note: <span class="tt">ub</span> is the previous upper bound of the loop (before peeling). <span class="tt">insideLoop</span> must be true for min/max ops inside the loop and false for affine.min ops inside the partial iteration. For an explanation of the other parameters, see comment of <span class="tt">canonicalizeMinMaxOpInLoop</span>. </p>

<p class="definition">Definition at line <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00197">197</a> of file <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html">AffineCanonicalizationUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::affine::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00371">mlir::presburger::IntegerRelation::addInequality()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01181">mlir::FlatLinearValueConstraints::appendDimVar()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01186">mlir::FlatLinearValueConstraints::appendSymbolVar()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00065">canonicalizeMinMaxOp()</a>, and <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopSpecialization_8cpp_source.html#l00173">rewriteAffineOpAfterPeeling()</a>.</p>

</div>
</div>
<a id="aac87521511b3088f00423de46226c32c" name="aac87521511b3088f00423de46226c32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac87521511b3088f00423de46226c32c">&#9670;&#160;</a></span>tileParallelLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; ParallelOp, ParallelOp &gt; mlir::scf::tileParallelLoop </td>
          <td>(</td>
          <td class="paramtype">ParallelOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>noMinMaxBounds</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a parallel loop of the form scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4, arg5) </p>
<p>into scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4*tileSize[0], arg5*tileSize[1]) scf.parallel (j0, j1) = (0, 0) to (min(tileSize[0], arg2-j0) min(tileSize[1], arg3-j1)) step (arg4, arg5) The old loop is replaced with the new one.</p>
<p>The function returns the resulting ParallelOps, i.e. {outer_loop_op, inner_loop_op}. </p>

</div>
</div>
<a id="a65670cb065175149d16cdca3f5d1733b" name="a65670cb065175149d16cdca3f5d1733b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65670cb065175149d16cdca3f5d1733b">&#9670;&#160;</a></span>upliftWhileToForLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; ForOp &gt; mlir::scf::upliftWhileToForLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WhileOp</td>          <td class="paramname"><span class="paramname"><em>loop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to uplift <span class="tt">scf.while</span> op to <span class="tt">scf.for</span>. </p>
<p>Uplifitng expects a specific ops pattern:</p><ul>
<li><span class="tt">before</span> block consisting of single arith.cmp op</li>
<li><span class="tt">after</span> block containing arith.addi </li>
</ul>

</div>
</div>
<a id="a1e9472eddc62665f04a9662521df3042" name="a1e9472eddc62665f04a9662521df3042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9472eddc62665f04a9662521df3042">&#9670;&#160;</a></span>wrapWhileLoopInZeroTripCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; WhileOp &gt; mlir::scf::wrapWhileLoopInZeroTripCheck </td>
          <td>(</td>
          <td class="paramtype">WhileOp</td>          <td class="paramname"><span class="paramname"><em>whileOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>forceCreateCheck</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create zero-trip-check around a <span class="tt">while</span> op and return the new loop op in the check. </p>
<p>The while loop is rotated to avoid evaluating the condition twice</p>
<p>By default the check won't be created for do-while loop as it is not required. <span class="tt">forceCreateCheck</span> can force the creation.</p>
<p>It turns:</p>
<p>scf.while (arg0 = init) : (i32) -&gt; i64 { val = .., arg0 : i64 cond = arith.cmpi .., arg0 : i32 scf.condition(cond) val : i64 } do { ^bb0(arg1: i64): next = .., arg1 : i32 scf.yield next : i32 }</p>
<p>into:</p>
<p>pre_val = .., init : i64 pre_cond = arith.cmpi .., init : i32 scf.if pre_cond -&gt; i64 { res = scf.while (arg1 = va0) : (i64) -&gt; i64 { next = .., arg1 : i32 val = .., next : i64 cond = arith.cmpi .., next : i32 scf.condition(cond) val : i64 } do { ^bb0(arg2: i64): scf.yield arg2 : i32 } scf.yield res : i64 } else { scf.yield pre_val : i64 }</p>
<p>Failure mechanism is not implemented for this function, so it currently always returns a <span class="tt">WhileOp</span> operation: a new one if the transformation took place or the input <span class="tt">whileOp</span> if the loop was already in a <span class="tt">do-while</span> form and <span class="tt">forceCreateCheck</span> is <span class="tt">false</span>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
