<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::Type Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="classmlir_1_1Type.html">Type</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmlir_1_1Type-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mlir::Type Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Instances of the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> class are uniqued, have an immutable identifier and an optional mutable component.  
 <a href="#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="IR_2Types_8h_source.html">mlir/IR/Types.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Inheritance diagram for mlir::Type:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="classmlir_1_1Type__inherit__graph.svg" width="586" height="352"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aac1a3ac45ddbfbe1d789113f7f335434" id="r_aac1a3ac45ddbfbe1d789113f7f335434"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteType, typename BaseType, typename StorageType, template&lt; typename T &gt; class... Traits&gt; </td></tr>
<tr class="memitem:aac1a3ac45ddbfbe1d789113f7f335434 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac1a3ac45ddbfbe1d789113f7f335434">TypeBase</a></td></tr>
<tr class="memdesc:aac1a3ac45ddbfbe1d789113f7f335434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for implementing types.  <br /></td></tr>
<tr class="memitem:a89de246b01ef652963e1ddde953d62e7" id="r_a89de246b01ef652963e1ddde953d62e7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89de246b01ef652963e1ddde953d62e7">ImplType</a> = <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="memitem:a0da492d52032c9c9d4fe2a1768437e13" id="r_a0da492d52032c9c9d4fe2a1768437e13"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0da492d52032c9c9d4fe2a1768437e13">AbstractTy</a> = <a class="el" href="classmlir_1_1AbstractType.html">AbstractType</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a622149b48f6d7eaf0e42f8abea6ca65e" id="r_a622149b48f6d7eaf0e42f8abea6ca65e"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a622149b48f6d7eaf0e42f8abea6ca65e">Type</a> ()=default</td></tr>
<tr class="memitem:aaa8871458ee7b2abdca3e94788ae3048" id="r_aaa8871458ee7b2abdca3e94788ae3048"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa8871458ee7b2abdca3e94788ae3048">Type</a> (const <a class="el" href="#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *<a class="el" href="#a54af6c081e012a32bba9b650480c6c06">impl</a>)</td></tr>
<tr class="memitem:a237023ae4dcab369d064457a10bcf518" id="r_a237023ae4dcab369d064457a10bcf518"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a237023ae4dcab369d064457a10bcf518">Type</a> (const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;other)=default</td></tr>
<tr class="memitem:ab1ccc7b9d96b2d9b223884824a8dc516" id="r_ab1ccc7b9d96b2d9b223884824a8dc516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1ccc7b9d96b2d9b223884824a8dc516">operator=</a> (const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;other)=default</td></tr>
<tr class="memitem:ac53df1249058e8c2ec0fa70f172f0b59" id="r_ac53df1249058e8c2ec0fa70f172f0b59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac53df1249058e8c2ec0fa70f172f0b59">operator==</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> other) const</td></tr>
<tr class="memitem:ad1be45203a0010965388d41e712dc268" id="r_ad1be45203a0010965388d41e712dc268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1be45203a0010965388d41e712dc268">operator!=</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> other) const</td></tr>
<tr class="memitem:afeb8b20e59002a0fedfcb93e314b416f" id="r_afeb8b20e59002a0fedfcb93e314b416f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afeb8b20e59002a0fedfcb93e314b416f">operator bool</a> () const</td></tr>
<tr class="memitem:ac516f7c8eb957068555b5781d78f23af" id="r_ac516f7c8eb957068555b5781d78f23af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac516f7c8eb957068555b5781d78f23af">operator!</a> () const</td></tr>
<tr class="memitem:accf7dade447f73f5b04c46fcf616b68c" id="r_accf7dade447f73f5b04c46fcf616b68c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accf7dade447f73f5b04c46fcf616b68c">getTypeID</a> ()</td></tr>
<tr class="memdesc:accf7dade447f73f5b04c46fcf616b68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unique identifier for the concrete type.  <br /></td></tr>
<tr class="memitem:a3951cad794a5bc5ad086158c20f8e50e" id="r_a3951cad794a5bc5ad086158c20f8e50e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3951cad794a5bc5ad086158c20f8e50e">getContext</a> () const</td></tr>
<tr class="memdesc:a3951cad794a5bc5ad086158c20f8e50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> in which this type was uniqued.  <br /></td></tr>
<tr class="memitem:a21810b671ec68509499ee2d4f10a8a6b" id="r_a21810b671ec68509499ee2d4f10a8a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21810b671ec68509499ee2d4f10a8a6b">getDialect</a> () const</td></tr>
<tr class="memdesc:a21810b671ec68509499ee2d4f10a8a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dialect this type is registered to.  <br /></td></tr>
<tr class="memitem:a5d5d5335ce4fc906636a2690155a7d72" id="r_a5d5d5335ce4fc906636a2690155a7d72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d5d5335ce4fc906636a2690155a7d72">isIndex</a> () const</td></tr>
<tr class="memitem:af077a551403812fae63d3ee3f9233d35" id="r_af077a551403812fae63d3ee3f9233d35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af077a551403812fae63d3ee3f9233d35">isBF16</a> () const</td></tr>
<tr class="memitem:ad5a009c7555ce7c74ab581e0ac66a593" id="r_ad5a009c7555ce7c74ab581e0ac66a593"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5a009c7555ce7c74ab581e0ac66a593">isF16</a> () const</td></tr>
<tr class="memitem:a137df877894c6158a0958329be5bb70f" id="r_a137df877894c6158a0958329be5bb70f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a137df877894c6158a0958329be5bb70f">isTF32</a> () const</td></tr>
<tr class="memitem:a6cde84bc1dbdaecf64df30e7c99e2106" id="r_a6cde84bc1dbdaecf64df30e7c99e2106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cde84bc1dbdaecf64df30e7c99e2106">isF32</a> () const</td></tr>
<tr class="memitem:a075a66eef3b8dc3f5fd51eba8399ceb8" id="r_a075a66eef3b8dc3f5fd51eba8399ceb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a075a66eef3b8dc3f5fd51eba8399ceb8">isF64</a> () const</td></tr>
<tr class="memitem:ad943633969f919ce6169fb52a5cea1cd" id="r_ad943633969f919ce6169fb52a5cea1cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad943633969f919ce6169fb52a5cea1cd">isF80</a> () const</td></tr>
<tr class="memitem:ac6105a40d762d129e4b9766d43ff647f" id="r_ac6105a40d762d129e4b9766d43ff647f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6105a40d762d129e4b9766d43ff647f">isF128</a> () const</td></tr>
<tr class="memitem:a139eaaa4ef0b399f9acec4f332a8370d" id="r_a139eaaa4ef0b399f9acec4f332a8370d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a139eaaa4ef0b399f9acec4f332a8370d">isFloat</a> () const</td></tr>
<tr class="memdesc:a139eaaa4ef0b399f9acec4f332a8370d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an float type (with the specified width).  <br /></td></tr>
<tr class="memitem:a62a3f2a48324764dc282fe7c61517bce" id="r_a62a3f2a48324764dc282fe7c61517bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62a3f2a48324764dc282fe7c61517bce">isFloat</a> (<a class="el" href="classunsigned.html">unsigned</a> width) const</td></tr>
<tr class="memdesc:a62a3f2a48324764dc282fe7c61517bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a float type with the specified width.  <br /></td></tr>
<tr class="memitem:aa26b99685376bbe95a18fdea7dd8e5cf" id="r_aa26b99685376bbe95a18fdea7dd8e5cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa26b99685376bbe95a18fdea7dd8e5cf">isInteger</a> () const</td></tr>
<tr class="memdesc:aa26b99685376bbe95a18fdea7dd8e5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer type (with the specified width).  <br /></td></tr>
<tr class="memitem:a1d16f5d47b21c67f4d49c02979c33724" id="r_a1d16f5d47b21c67f4d49c02979c33724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d16f5d47b21c67f4d49c02979c33724">isInteger</a> (<a class="el" href="classunsigned.html">unsigned</a> width) const</td></tr>
<tr class="memitem:a53765d45f36d2bbff81bb81b286a9525" id="r_a53765d45f36d2bbff81bb81b286a9525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53765d45f36d2bbff81bb81b286a9525">isSignlessInteger</a> () const</td></tr>
<tr class="memdesc:a53765d45f36d2bbff81bb81b286a9525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a signless integer type (with the specified width).  <br /></td></tr>
<tr class="memitem:a213fdac03ae27d597f277ac05ea30fca" id="r_a213fdac03ae27d597f277ac05ea30fca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a213fdac03ae27d597f277ac05ea30fca">isSignlessInteger</a> (<a class="el" href="classunsigned.html">unsigned</a> width) const</td></tr>
<tr class="memitem:a50385bcb919f49adab0f8f2521dc479f" id="r_a50385bcb919f49adab0f8f2521dc479f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50385bcb919f49adab0f8f2521dc479f">isSignedInteger</a> () const</td></tr>
<tr class="memdesc:a50385bcb919f49adab0f8f2521dc479f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a signed integer type (with the specified width).  <br /></td></tr>
<tr class="memitem:a920ada7270762d4e2f96d96f5b29a140" id="r_a920ada7270762d4e2f96d96f5b29a140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a920ada7270762d4e2f96d96f5b29a140">isSignedInteger</a> (<a class="el" href="classunsigned.html">unsigned</a> width) const</td></tr>
<tr class="memitem:a78c30270dcbb289e5931b2ed1c4c6919" id="r_a78c30270dcbb289e5931b2ed1c4c6919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78c30270dcbb289e5931b2ed1c4c6919">isUnsignedInteger</a> () const</td></tr>
<tr class="memdesc:a78c30270dcbb289e5931b2ed1c4c6919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an unsigned integer type (with the specified width).  <br /></td></tr>
<tr class="memitem:a8dbb14dffe2d155b3f3f478ca216aca7" id="r_a8dbb14dffe2d155b3f3f478ca216aca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dbb14dffe2d155b3f3f478ca216aca7">isUnsignedInteger</a> (<a class="el" href="classunsigned.html">unsigned</a> width) const</td></tr>
<tr class="memitem:aeb142623709910125e07ecf1f9f2cdd5" id="r_aeb142623709910125e07ecf1f9f2cdd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb142623709910125e07ecf1f9f2cdd5">getIntOrFloatBitWidth</a> () const</td></tr>
<tr class="memdesc:aeb142623709910125e07ecf1f9f2cdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bit width of an integer or a float type, assert failure on other types.  <br /></td></tr>
<tr class="memitem:a26f738cb5a46aeb47df2e6243a11c41c" id="r_a26f738cb5a46aeb47df2e6243a11c41c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26f738cb5a46aeb47df2e6243a11c41c">isSignlessIntOrIndex</a> () const</td></tr>
<tr class="memdesc:a26f738cb5a46aeb47df2e6243a11c41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a signless integer or index type.  <br /></td></tr>
<tr class="memitem:afeff6b78a50b5d435c10e6c8927bbb7d" id="r_afeff6b78a50b5d435c10e6c8927bbb7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afeff6b78a50b5d435c10e6c8927bbb7d">isSignlessIntOrIndexOrFloat</a> () const</td></tr>
<tr class="memdesc:afeff6b78a50b5d435c10e6c8927bbb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a signless integer, index, or float type.  <br /></td></tr>
<tr class="memitem:ae8d6282ddfa213055b965f2db7eb9752" id="r_ae8d6282ddfa213055b965f2db7eb9752"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8d6282ddfa213055b965f2db7eb9752">isSignlessIntOrFloat</a> () const</td></tr>
<tr class="memdesc:ae8d6282ddfa213055b965f2db7eb9752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true of this is a signless integer or a float type.  <br /></td></tr>
<tr class="memitem:a7f33529654fee149935f1e14cdf74305" id="r_a7f33529654fee149935f1e14cdf74305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f33529654fee149935f1e14cdf74305">isIntOrIndex</a> () const</td></tr>
<tr class="memdesc:a7f33529654fee149935f1e14cdf74305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer (of any signedness) or an index type.  <br /></td></tr>
<tr class="memitem:aa4295aaec59a8a864338a2b7dab0c935" id="r_aa4295aaec59a8a864338a2b7dab0c935"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4295aaec59a8a864338a2b7dab0c935">isIntOrFloat</a> () const</td></tr>
<tr class="memdesc:aa4295aaec59a8a864338a2b7dab0c935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer (of any signedness) or a float type.  <br /></td></tr>
<tr class="memitem:a69310264441dfb377a3789c8eedcdce7" id="r_a69310264441dfb377a3789c8eedcdce7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69310264441dfb377a3789c8eedcdce7">isIntOrIndexOrFloat</a> () const</td></tr>
<tr class="memdesc:a69310264441dfb377a3789c8eedcdce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer (of any signedness), index, or float type.  <br /></td></tr>
<tr class="memitem:a034614f0e682699a53a6e967654caf12" id="r_a034614f0e682699a53a6e967654caf12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a034614f0e682699a53a6e967654caf12">print</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os) const</td></tr>
<tr class="memdesc:a034614f0e682699a53a6e967654caf12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the current type.  <br /></td></tr>
<tr class="memitem:aef996e7de5468067879322021956d167" id="r_aef996e7de5468067879322021956d167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef996e7de5468067879322021956d167">print</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1AsmState.html">AsmState</a> &amp;state) const</td></tr>
<tr class="memitem:ace59879c4e15990d08093e040fabb957" id="r_ace59879c4e15990d08093e040fabb957"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace59879c4e15990d08093e040fabb957">dump</a> () const</td></tr>
<tr class="memitem:ac85bcf9b47f37272f84750c12c2e2bbb" id="r_ac85bcf9b47f37272f84750c12c2e2bbb"><td class="memItemLeft" align="right" valign="top">friend::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac85bcf9b47f37272f84750c12c2e2bbb">hash_value</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> arg)</td></tr>
<tr class="memitem:a5dea917c5116ff7758ebc69f7781bf6d" id="r_a5dea917c5116ff7758ebc69f7781bf6d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvoid.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dea917c5116ff7758ebc69f7781bf6d">getAsOpaquePointer</a> () const</td></tr>
<tr class="memdesc:a5dea917c5116ff7758ebc69f7781bf6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for supporting PointerLikeTypeTraits.  <br /></td></tr>
<tr class="memitem:a77b88842a7fe6aae3a99543fecea1dab" id="r_a77b88842a7fe6aae3a99543fecea1dab"><td class="memTemplParams" colspan="2">template&lt;typename InterfaceT&gt; </td></tr>
<tr class="memitem:a77b88842a7fe6aae3a99543fecea1dab template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77b88842a7fe6aae3a99543fecea1dab">hasPromiseOrImplementsInterface</a> ()</td></tr>
<tr class="memdesc:a77b88842a7fe6aae3a99543fecea1dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <span class="tt">InterfaceT</span> has been promised by the dialect or implemented.  <br /></td></tr>
<tr class="memitem:a5e876063454fa81bf686800a35ea5aa8" id="r_a5e876063454fa81bf686800a35ea5aa8"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T &gt; class Trait&gt; </td></tr>
<tr class="memitem:a5e876063454fa81bf686800a35ea5aa8 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e876063454fa81bf686800a35ea5aa8">hasTrait</a> ()</td></tr>
<tr class="memdesc:a5e876063454fa81bf686800a35ea5aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the type was registered with a particular trait.  <br /></td></tr>
<tr class="memitem:a2981d0474cf1d6b3233bc4a444d997af" id="r_a2981d0474cf1d6b3233bc4a444d997af"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a0da492d52032c9c9d4fe2a1768437e13">AbstractTy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2981d0474cf1d6b3233bc4a444d997af">getAbstractType</a> () const</td></tr>
<tr class="memdesc:a2981d0474cf1d6b3233bc4a444d997af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the abstract type descriptor for this type.  <br /></td></tr>
<tr class="memitem:a970b46b34f52f022364fc22ea222c580" id="r_a970b46b34f52f022364fc22ea222c580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a970b46b34f52f022364fc22ea222c580">getImpl</a> () const</td></tr>
<tr class="memdesc:a970b46b34f52f022364fc22ea222c580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> implementation.  <br /></td></tr>
<tr class="memitem:a6f215adc2d7aef45aaee1884bd93bcdb" id="r_a6f215adc2d7aef45aaee1884bd93bcdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f215adc2d7aef45aaee1884bd93bcdb">walkImmediateSubElements</a> (<a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt; walkAttrsFn, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Type.html">Type</a>)&gt; walkTypesFn) const</td></tr>
<tr class="memdesc:a6f215adc2d7aef45aaee1884bd93bcdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the immediately nested sub-attributes and sub-types.  <br /></td></tr>
<tr class="memitem:a22321e0d04aac43a6054e27d41846b5f" id="r_a22321e0d04aac43a6054e27d41846b5f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22321e0d04aac43a6054e27d41846b5f">replaceImmediateSubElements</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; replAttrs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; replTypes) const</td></tr>
<tr class="memdesc:a22321e0d04aac43a6054e27d41846b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the immediately nested sub-attributes and sub-types with those provided.  <br /></td></tr>
<tr class="memitem:ae56116bb5e60101fe97b5af0bf3213de" id="r_ae56116bb5e60101fe97b5af0bf3213de"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> Order = WalkOrder::PostOrder, typename... WalkFns&gt; </td></tr>
<tr class="memitem:ae56116bb5e60101fe97b5af0bf3213de template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae56116bb5e60101fe97b5af0bf3213de">walk</a> (WalkFns &amp;&amp;...walkFns)</td></tr>
<tr class="memdesc:ae56116bb5e60101fe97b5af0bf3213de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk this type and all attibutes/types nested within using the provided walk functions.  <br /></td></tr>
<tr class="memitem:add89f8ee12e06fac685dc07a272b02b9" id="r_add89f8ee12e06fac685dc07a272b02b9"><td class="memTemplParams" colspan="2">template&lt;typename... ReplacementFns&gt; </td></tr>
<tr class="memitem:add89f8ee12e06fac685dc07a272b02b9 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add89f8ee12e06fac685dc07a272b02b9">replace</a> (ReplacementFns &amp;&amp;...replacementFns)</td></tr>
<tr class="memdesc:add89f8ee12e06fac685dc07a272b02b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively replace all of the nested sub-attributes and sub-types using the provided map functions.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a58b903c935dfc504b4f4e3f77939b113" id="r_a58b903c935dfc504b4f4e3f77939b113"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58b903c935dfc504b4f4e3f77939b113">getFromOpaquePointer</a> (const <a class="el" href="classvoid.html">void</a> *pointer)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-attribs" class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a54af6c081e012a32bba9b650480c6c06" id="r_a54af6c081e012a32bba9b650480c6c06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54af6c081e012a32bba9b650480c6c06">impl</a> {<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>}</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Instances of the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> class are uniqued, have an immutable identifier and an optional mutable component. </p>
<p>They wrap a pointer to the storage object owned by <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a>. Therefore, instances of <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> are passed around by value.</p>
<p>Some types are "primitives" meaning they do not have any parameters, for example the Index type. Parametric types have additional information that differentiates the types of the same class, for example the Integer type has bitwidth, making i8 and i16 belong to the same kind by be different instances of the IntegerType. <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> parameters are part of the unique immutable key. The mutable component of the type can be modified after the type is created, but cannot affect the identity of the type.</p>
<p>Types are constructed and uniqued via the '<a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html" title="A utility class to get, or create, unique instances of types within an MLIRContext.">detail::TypeUniquer</a>' class.</p>
<p>Derived type classes are expected to implement several required implementation hooks:</p><ul>
<li>Optional:<ul>
<li>static LogicalResult verifyInvariants(
                               function_ref&lt;InFlightDiagnostic()&gt; emitError,
                               Args... args)<ul>
<li>This method is invoked when calling the '<a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a164daa29fe3c44c9a53f7659e594ff49">TypeBase::get</a>/getChecked' methods to ensure that the arguments passed in are valid to construct a type instance with.</li>
<li>This method is expected to return failure if a type cannot be constructed with 'args', success otherwise.</li>
<li>'args' must correspond with the arguments passed into the '<a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a164daa29fe3c44c9a53f7659e594ff49">TypeBase::get</a>' call.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> storage objects inherit from <a class="el" href="classmlir_1_1TypeStorage.html" title="Base storage class appearing in a Type.">TypeStorage</a> and contain the following:</p><ul>
<li>The dialect that defined the type.</li>
<li>Any parameters of the type.</li>
<li>An optional mutable component. For non-parametric types, a convenience <a class="el" href="namespacemlir.html#a4f291a678314f33c164a2bb33d32f8f5" title="Default storage type for types that require no additional initialization or storage.">DefaultTypeStorage</a> is provided. Parametric storage types must derive <a class="el" href="classmlir_1_1TypeStorage.html" title="Base storage class appearing in a Type.">TypeStorage</a> and respect the following:</li>
<li>Define a type alias, KeyTy, to a type that uniquely identifies the instance of the type.<ul>
<li>The key type must be constructible from the values passed into the <a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html#a06c28682a1cf2b71c324cdd4cf0fb2a0" title="Get an uniqued instance of a type T.">detail::TypeUniquer::get</a> call.</li>
<li>If the KeyTy does not have an <a class="el" href="structllvm_1_1DenseMapInfo.html">llvm::DenseMapInfo</a> specialization, the storage class must define a hashing method: 'static unsigned hashKey(const KeyTy &amp;)'</li>
</ul>
</li>
<li>Provide a method, 'bool operator==(const KeyTy &amp;) const', to compare the storage instance against an instance of the key type.</li>
<li>Provide a static construction method: 'DerivedStorage *construct(<a class="el" href="namespacemlir.html#a07820b1b64d9c34cc7055479eb3951aa" title="This is a utility allocator used to allocate memory for instances of derived Types.">TypeStorageAllocator</a> &amp;, const KeyTy &amp;key)' that builds a unique instance of the derived storage. The arguments to this function are an allocator to store any uniqued data within the context and the key type for this storage.</li>
<li>If they have a mutable component, this component must not be a part of the key. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00074">74</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a0da492d52032c9c9d4fe2a1768437e13" name="a0da492d52032c9c9d4fe2a1768437e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da492d52032c9c9d4fe2a1768437e13">&#9670;&#160;</a></span>AbstractTy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0da492d52032c9c9d4fe2a1768437e13">mlir::Type::AbstractTy</a> = <a class="el" href="classmlir_1_1AbstractType.html">AbstractType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00084">84</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a89de246b01ef652963e1ddde953d62e7" name="a89de246b01ef652963e1ddde953d62e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89de246b01ef652963e1ddde953d62e7">&#9670;&#160;</a></span>ImplType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a89de246b01ef652963e1ddde953d62e7">mlir::Type::ImplType</a> = <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00082">82</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="aac1a3ac45ddbfbe1d789113f7f335434" name="aac1a3ac45ddbfbe1d789113f7f335434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1a3ac45ddbfbe1d789113f7f335434">&#9670;&#160;</a></span>TypeBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType, typename BaseType, typename StorageType, template&lt; typename T &gt; class... Traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aac1a3ac45ddbfbe1d789113f7f335434">mlir::Type::TypeBase</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_class" href="classmlir_1_1detail_1_1StorageUserBase.html">detail::StorageUserBase</a>&lt;ConcreteType, BaseType, StorageType,</div>
<div class="line">                                           <a class="code hl_struct" href="structmlir_1_1detail_1_1TypeUniquer.html">detail::TypeUniquer</a>, Traits...&gt;</div>
<div class="ttc" id="aclassmlir_1_1detail_1_1StorageUserBase_html"><div class="ttname"><a href="classmlir_1_1detail_1_1StorageUserBase.html">mlir::detail::StorageUserBase</a></div><div class="ttdoc">Utility class for implementing users of storage classes uniqued by a StorageUniquer.</div><div class="ttdef"><b>Definition</b> <a href="StorageUniquerSupport_8h_source.html#l00095">StorageUniquerSupport.h:95</a></div></div>
<div class="ttc" id="astructmlir_1_1detail_1_1TypeUniquer_html"><div class="ttname"><a href="structmlir_1_1detail_1_1TypeUniquer.html">mlir::detail::TypeUniquer</a></div><div class="ttdoc">A utility class to get, or create, unique instances of types within an MLIRContext.</div><div class="ttdef"><b>Definition</b> <a href="TypeSupport_8h_source.html#l00210">TypeSupport.h:210</a></div></div>
</div><!-- fragment -->
<p>Utility class for implementing types. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00079">79</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a622149b48f6d7eaf0e42f8abea6ca65e" name="a622149b48f6d7eaf0e42f8abea6ca65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622149b48f6d7eaf0e42f8abea6ca65e">&#9670;&#160;</a></span>Type() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Type::Type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="IR_2Types_8h_source.html#l00167">getFromOpaquePointer()</a>, <a class="el" href="#ac85bcf9b47f37272f84750c12c2e2bbb">hash_value()</a>, <a class="el" href="IR_2Types_8h_source.html#l00094">operator!=()</a>, <a class="el" href="#ab1ccc7b9d96b2d9b223884824a8dc516">operator=()</a>, <a class="el" href="IR_2Types_8h_source.html#l00093">operator==()</a>, <a class="el" href="#a237023ae4dcab369d064457a10bcf518">Type()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00194">walkImmediateSubElements()</a>.</p>

</div>
</div>
<a id="aaa8871458ee7b2abdca3e94788ae3048" name="aaa8871458ee7b2abdca3e94788ae3048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8871458ee7b2abdca3e94788ae3048">&#9670;&#160;</a></span>Type() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Type::Type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *</td>          <td class="paramname"><span class="paramname"><em>impl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00087">87</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a237023ae4dcab369d064457a10bcf518" name="a237023ae4dcab369d064457a10bcf518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237023ae4dcab369d064457a10bcf518">&#9670;&#160;</a></span>Type() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Type::Type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="#a622149b48f6d7eaf0e42f8abea6ca65e">Type()</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ace59879c4e15990d08093e040fabb957" name="ace59879c4e15990d08093e040fabb957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace59879c4e15990d08093e040fabb957">&#9670;&#160;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> Type::dump </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l03998">3998</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVAttributes_8cpp_source.html#l00624">print()</a>.</p>

</div>
</div>
<a id="a2981d0474cf1d6b3233bc4a444d997af" name="a2981d0474cf1d6b3233bc4a444d997af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2981d0474cf1d6b3233bc4a444d997af">&#9670;&#160;</a></span>getAbstractType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a0da492d52032c9c9d4fe2a1768437e13">AbstractTy</a> &amp; mlir::Type::getAbstractType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the abstract type descriptor for this type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00187">187</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Types_8h_source.html#l00269">mlir::TypeInterface&lt; ConcreteType, Traits &gt;::getInterfaceFor()</a>, <a class="el" href="IR_2Types_8h_source.html#l00182">hasTrait()</a>, <a class="el" href="IR_2Types_8h_source.html#l00205">replaceImmediateSubElements()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00082">mlir::irdl::BaseTypeConstraint::verify()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00194">walkImmediateSubElements()</a>.</p>

</div>
</div>
<a id="a5dea917c5116ff7758ebc69f7781bf6d" name="a5dea917c5116ff7758ebc69f7781bf6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dea917c5116ff7758ebc69f7781bf6d">&#9670;&#160;</a></span>getAsOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvoid.html">void</a> * mlir::Type::getAsOpaquePointer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for supporting PointerLikeTypeTraits. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00164">164</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Types_8h_source.html#l00342">llvm::PointerLikeTypeTraits&lt; mlir::Type &gt;::getAsVoidPointer()</a>.</p>

</div>
</div>
<a id="a3951cad794a5bc5ad086158c20f8e50e" name="a3951cad794a5bc5ad086158c20f8e50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3951cad794a5bc5ad086158c20f8e50e">&#9670;&#160;</a></span>getContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> * Type::getContext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR operations.">MLIRContext</a> in which this type was uniqued. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00035">35</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Dialect_8h_source.html#l00052">mlir::Dialect::getContext()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00107">getDialect()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DLTI_8cpp_source.html#l00294">combineOneSpec()</a>, <a class="el" href="FakeQuantSupport_8cpp_source.html#l00108">mlir::quant::fakeQuantAttrsToType()</a>, <a class="el" href="FakeQuantSupport_8cpp_source.html#l00139">mlir::quant::fakeQuantAttrsToType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00187">mlir::gpu::MMAMatrixType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00242">mlir::quant::AnyQuantizedType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00527">mlir::quant::CalibratedQuantizedType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00335">mlir::quant::UniformQuantizedPerAxisType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00410">mlir::quant::UniformQuantizedSubChannelType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00280">mlir::quant::UniformQuantizedType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00158">mlir::spirv::ArrayType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00164">mlir::spirv::ArrayType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00269">mlir::spirv::CooperativeMatrixType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01173">mlir::spirv::MatrixType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00451">mlir::spirv::PointerType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00509">mlir::spirv::RuntimeArrayType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00513">mlir::spirv::RuntimeArrayType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00756">mlir::spirv::SampledImageType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01265">mlir::spirv::TensorArmType::get()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00149">getBoolAttribute()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00193">mlir::gpu::MMAMatrixType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00251">mlir::quant::AnyQuantizedType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00532">mlir::quant::CalibratedQuantizedType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00345">mlir::quant::UniformQuantizedPerAxisType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00420">mlir::quant::UniformQuantizedSubChannelType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00289">mlir::quant::UniformQuantizedType::getChecked()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01177">mlir::spirv::MatrixType::getChecked()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00761">mlir::spirv::SampledImageType::getChecked()</a>, <a class="el" href="Value_8h_source.html#l00108">mlir::Value::getContext()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00140">mlir::detail::getDefaultABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00194">mlir::detail::getDefaultPreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00052">mlir::detail::getDefaultTypeSizeInBits()</a>, <a class="el" href="PDLInterp_8cpp_source.html#l00238">getGetValueTypeOpValueType()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00170">getI1SameShape()</a>, <a class="el" href="ArmSVEDialect_8cpp_source.html#l00027">getI1SameShape()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00082">getI1SameShape()</a>, <a class="el" href="MathOps_8cpp_source.html#l00024">getI1SameShape()</a>, <a class="el" href="OpenACCSupport_8cpp_source.html#l00025">mlir::acc::OpenACCSupport::getRecipeName()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00148">getRegisterIndexToTileOffsetMap()</a>, <a class="el" href="BasicPtxBuilderInterface_8cpp_source.html#l00041">getRegisterType()</a>, <a class="el" href="TypeConversions_8cpp_source.html#l00052">mlir::emitc::getSignedTypeFor()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00060">mlir::memref::getTensorTypeFromMemRefType()</a>, <a class="el" href="SPIRVOpDefinition_8cpp_source.html#l00053">mlir::spirv::getUnaryOpResultType()</a>, <a class="el" href="TypeConversions_8cpp_source.html#l00039">mlir::emitc::getUnsignedTypeFor()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l03533">getValAndBoolStructType()</a>, <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00059">inferIntrinsicResultType()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00813">mlir::LLVM::isCompatibleType()</a>, <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00168">mlir::spirv::MemorySpaceToStorageClassConverter::MemorySpaceToStorageClassConverter()</a>, <a class="el" href="Arith_2Transforms_2EmulateNarrowType_8cpp_source.html#l00027">mlir::arith::NarrowTypeEmulationConverter::NarrowTypeEmulationConverter()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l03029">mlir::populateAMDGPUTypeAndAttributeConversions()</a>, <a class="el" href="TosaTypeConverters_8cpp_source.html#l00020">mlir::tosa::populateTosaTypeConversion()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00469">mlir::UnrankedMemRefDescriptor::sizeBasePtr()</a>, and <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l01228">mlir::arith::WideIntEmulationConverter::WideIntEmulationConverter()</a>.</p>

</div>
</div>
<a id="a21810b671ec68509499ee2d4f10a8a6b" name="a21810b671ec68509499ee2d4f10a8a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21810b671ec68509499ee2d4f10a8a6b">&#9670;&#160;</a></span>getDialect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a> Type::getDialect </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dialect this type is registered to. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00107">107</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="PDLTypes_8cpp_source.html#l00058">mlir::pdl::PDLType::classof()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00040">mlir::quant::QuantizedType::classof()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00677">mlir::spirv::SPIRVType::classof()</a>, <a class="el" href="DLTI_8cpp_source.html#l00294">combineOneSpec()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00035">getContext()</a>, <a class="el" href="IR_2Types_8h_source.html#l00269">mlir::TypeInterface&lt; ConcreteType, Traits &gt;::getInterfaceFor()</a>, <a class="el" href="IR_2Types_8h_source.html#l00174">hasPromiseOrImplementsInterface()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00345">mlir::TensorType::isValidElementType()</a>, <a class="el" href="LLVMMemorySlot_8cpp_source.html#l01030">memsetCanRewire()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00163">parseAndVerifyType()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l02913">mlir::AsmPrinter::Impl::printDialectType()</a>.</p>

</div>
</div>
<a id="a58b903c935dfc504b4f4e3f77939b113" name="a58b903c935dfc504b4f4e3f77939b113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b903c935dfc504b4f4e3f77939b113">&#9670;&#160;</a></span>getFromOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::Type::getFromOpaquePointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoid.html">void</a> *</td>          <td class="paramname"><span class="paramname"><em>pointer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00167">167</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="#a622149b48f6d7eaf0e42f8abea6ca65e">Type()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00052">mlir::DiagnosticArgument::getAsType()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00345">llvm::PointerLikeTypeTraits&lt; mlir::Type &gt;::getFromVoidPointer()</a>.</p>

</div>
</div>
<a id="a970b46b34f52f022364fc22ea222c580" name="a970b46b34f52f022364fc22ea222c580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970b46b34f52f022364fc22ea222c580">&#9670;&#160;</a></span>getImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a89de246b01ef652963e1ddde953d62e7">ImplType</a> * mlir::Type::getImpl </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> implementation. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00190">190</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Types_8h_source.html#l00377">llvm::CastInfo&lt; To, From, std::enable_if_t&lt; std::is_same_v&lt; mlir::Type, std::remove_const_t&lt; From &gt; &gt;||std::is_base_of_v&lt; mlir::Type, From &gt; &gt; &gt;::doCast()</a>.</p>

</div>
</div>
<a id="aeb142623709910125e07ecf1f9f2cdd5" name="aeb142623709910125e07ecf1f9f2cdd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb142623709910125e07ecf1f9f2cdd5">&#9670;&#160;</a></span>getIntOrFloatBitWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> Type::getIntOrFloatBitWidth </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bit width of an integer or a float type, assert failure on other types. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00122">122</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00116">isIntOrFloat()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01634">alignedConversionPrecondition()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00145">areSameBitwidthScalarType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00360">buildAttributeAPInt()</a>, <a class="el" href="ArithToAMDGPU_8cpp_source.html#l00107">castF32To()</a>, <a class="el" href="ArithToAMDGPU_8cpp_source.html#l00201">castToF32()</a>, <a class="el" href="ArithToAPFloat_8cpp_source.html#l00144">checkPreconditions()</a>, <a class="el" href="Math_2Transforms_2ExpandOps_8cpp_source.html#l00515">convertRoundEvenOp()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00186">convertScalarToComplexDtype()</a>, <a class="el" href="MathToFuncs_8cpp_source.html#l00653">createCtlzFunc()</a>, <a class="el" href="MathToFuncs_8cpp_source.html#l00183">createElementIPowIFunc()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l01054">createInitialValueForReduceOp()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00082">createLinalgBodyCalculationForElementwiseOp()</a>, <a class="el" href="SCFToOpenMP_8cpp_source.html#l00244">declareReduction()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00084">deduceCanonicalResource()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00364">emulatedVectorLoad()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00378">getBitWidth()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00064">getBitWidth()</a>, <a class="el" href="SPIRVOpUtils_8h_source.html#l00014">mlir::spirv::getBitWidth()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00609">mlir::tosa::getBitWidth()</a>, <a class="el" href="IntelGpuXe2_8h_source.html#l00091">mlir::xegpu::uArch::Subgroup2DBlockLoadInstruction::getBlockWidthHeightCount()</a>, <a class="el" href="IntelGpuXe2_8h_source.html#l00143">mlir::xegpu::uArch::Subgroup2DBlockPrefetchInstruction::getBlockWidthHeightCount()</a>, <a class="el" href="IntelGpuXe2_8h_source.html#l00059">mlir::xegpu::uArch::Subgroup2DBlockStoreInstruction::getBlockWidthHeightCount()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00052">mlir::detail::getDefaultTypeSizeInBits()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00034">mlir::detail::getDenseElementBitWidth()</a>, <a class="el" href="XeGPUPropagateLayout_8cpp_source.html#l00307">mlir::xegpu::impl::XeGPUPropagateLayoutBase&lt; DerivedT &gt;::getDependentDialects()</a>, <a class="el" href="Builders_8cpp_source.html#l00228">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="VectorToSPIRV_8cpp_source.html#l00047">getNumBits()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00148">getRegisterIndexToTileOffsetMap()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00129">getScalarOrElementWidth()</a>, <a class="el" href="TypeConversions_8cpp_source.html#l00052">mlir::emitc::getSignedTypeFor()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00705">mlir::spirv::SPIRVType::getSizeInBytes()</a>, <a class="el" href="Dialect_2ArmSME_2IR_2Utils_8cpp_source.html#l00032">mlir::arm_sme::getSMETileSliceMinNumElts()</a>, <a class="el" href="IntelGpuXe2_8h_source.html#l00407">mlir::xegpu::uArch::SubgroupMatrixMultiplyAcc::getSupportedK()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00037">getTileShape()</a>, <a class="el" href="TypeConversions_8cpp_source.html#l00039">mlir::emitc::getUnsignedTypeFor()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00391">mlir::GPUPrintfOpToHIPLowering::matchAndRewrite()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00910">mlir::detail::Parser::parseDenseArrayAttr()</a>, <a class="el" href="SPIRVOpDefinition_8cpp_source.html#l00087">mlir::spirv::parseSwitchOpCases()</a>, <a class="el" href="ControlFlow_2IR_2ControlFlowOps_8cpp_source.html#l00546">parseSwitchOpCases()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00549">parseSwitchOpCases()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00635">mlir::memref::populateMemRefNarrowTypeEmulationConversions()</a>, <a class="el" href="TosaTypeConverters_8cpp_source.html#l00020">mlir::tosa::populateTosaTypeConversion()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l02681">mlir::AsmPrinter::Impl::printDenseArrayAttr()</a>, <a class="el" href="CreateAsyncGroups_8cpp_source.html#l00126">resultsInSupportedAsyncCopy()</a>, <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00101">shiftValue()</a>, <a class="el" href="NVGPUToNVVM_8cpp_source.html#l00049">truncToI32()</a>, <a class="el" href="AMDGPUDialect_8cpp_source.html#l00772">verifyBase()</a>, <a class="el" href="NVGPUDialect_8cpp_source.html#l00137">verifyMmaSyncOp()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00574">verifyRescaleValueAndZpTypes()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00691">wmmaPushInputOperand()</a>, and <a class="el" href="XeGPUPropagateLayout_8cpp_source.html#l00318">mlir::xegpu::impl::XeGPUPropagateLayoutBase&lt; DerivedT &gt;::XeGPUPropagateLayoutBase()</a>.</p>

</div>
</div>
<a id="accf7dade447f73f5b04c46fcf616b68c" name="accf7dade447f73f5b04c46fcf616b68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf7dade447f73f5b04c46fcf616b68c">&#9670;&#160;</a></span>getTypeID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a> mlir::Type::getTypeID </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a unique identifier for the concrete type. </p>
<p>This is used to support dynamic type casting. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00101">101</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Types_8h_source.html#l00269">mlir::TypeInterface&lt; ConcreteType, Traits &gt;::getInterfaceFor()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00581">mlir::DataLayout::getTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00593">mlir::DataLayout::getTypePreferredAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00557">mlir::DataLayout::getTypeSize()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00569">mlir::DataLayout::getTypeSizeInBits()</a>, <a class="el" href="IR_2Types_8h_source.html#l00174">hasPromiseOrImplementsInterface()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00339">mlir::DynamicType::isa()</a>, <a class="el" href="IRDLVerifiers_8cpp_source.html#l00082">mlir::irdl::BaseTypeConstraint::verify()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01307">mlir::OpTrait::impl::verifyElementwise()</a>, and <a class="el" href="MemOpInterfaces_8cpp_source.html#l00017">mlir::detail::verifyMemorySpaceCastOpInterface()</a>.</p>

</div>
</div>
<a id="ac85bcf9b47f37272f84750c12c2e2bbb" name="ac85bcf9b47f37272f84750c12c2e2bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85bcf9b47f37272f84750c12c2e2bbb">&#9670;&#160;</a></span>hash_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend::llvm::hash_code mlir::Type::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="#a622149b48f6d7eaf0e42f8abea6ca65e">Type()</a>.</p>

</div>
</div>
<a id="a77b88842a7fe6aae3a99543fecea1dab" name="a77b88842a7fe6aae3a99543fecea1dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b88842a7fe6aae3a99543fecea1dab">&#9670;&#160;</a></span>hasPromiseOrImplementsInterface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InterfaceT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::Type::hasPromiseOrImplementsInterface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <span class="tt">InterfaceT</span> has been promised by the dialect or implemented. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00174">174</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00107">getDialect()</a>, <a class="el" href="IR_2Types_8h_source.html#l00101">getTypeID()</a>, and <a class="el" href="IR_2Dialect_8cpp_source.html#l00163">mlir::dialect_extension_detail::hasPromisedInterface()</a>.</p>

</div>
</div>
<a id="a5e876063454fa81bf686800a35ea5aa8" name="a5e876063454fa81bf686800a35ea5aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e876063454fa81bf686800a35ea5aa8">&#9670;&#160;</a></span>hasTrait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename T &gt; class Trait&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::Type::hasTrait </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the type was registered with a particular trait. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00182">182</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00187">getAbstractType()</a>, and <a class="el" href="TypeSupport_8h_source.html#l00090">mlir::AbstractType::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExtensibleDialect_8cpp_source.html#l00150">mlir::DynamicType::classof()</a>.</p>

</div>
</div>
<a id="af077a551403812fae63d3ee3f9233d35" name="af077a551403812fae63d3ee3f9233d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af077a551403812fae63d3ee3f9233d35">&#9670;&#160;</a></span>isBF16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isBF16 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00037">37</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntelGpuXe2_8h_source.html#l00345">mlir::xegpu::uArch::SubgroupMatrixMultiplyAcc::checkSupportedTypes()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00610">getCuSparseDataTypeFrom()</a>, <a class="el" href="BasicPtxBuilderInterface_8cpp_source.html#l00041">getRegisterType()</a>, <a class="el" href="NVGPUDialect_8cpp_source.html#l00555">isAllowedSizeN()</a>, <a class="el" href="NVGPUDialect_8cpp_source.html#l00521">isAllowedWGMMADataType()</a>, <a class="el" href="Dialect_2ArmSME_2IR_2Utils_8cpp_source.html#l00037">mlir::arm_sme::isValidSMETileElementType()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00784">mfmaOpToIntrinsic()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00102">mlir::sparse_tensor::primaryTypeEncoding()</a>, <a class="el" href="NVGPUDialect_8cpp_source.html#l00137">verifyMmaSyncOp()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l01049">wmmaOpToIntrinsicGfx1250()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00993">wmmaOpToIntrinsicRDNA()</a>, and <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00749">wmmaPushOutputOperand()</a>.</p>

</div>
</div>
<a id="ac6105a40d762d129e4b9766d43ff647f" name="ac6105a40d762d129e4b9766d43ff647f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6105a40d762d129e4b9766d43ff647f">&#9670;&#160;</a></span>isF128()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isF128 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00043">43</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2ArmSME_2IR_2Utils_8cpp_source.html#l00037">mlir::arm_sme::isValidSMETileElementType()</a>.</p>

</div>
</div>
<a id="ad5a009c7555ce7c74ab581e0ac66a593" name="ad5a009c7555ce7c74ab581e0ac66a593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a009c7555ce7c74ab581e0ac66a593">&#9670;&#160;</a></span>isF16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isF16 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00038">38</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntelGpuXe2_8h_source.html#l00345">mlir::xegpu::uArch::SubgroupMatrixMultiplyAcc::checkSupportedTypes()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00178">floatCst()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00610">getCuSparseDataTypeFrom()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00600">getCuSparseLtDataTypeFrom()</a>, <a class="el" href="BasicPtxBuilderInterface_8cpp_source.html#l00041">getRegisterType()</a>, <a class="el" href="NVGPUDialect_8cpp_source.html#l00555">isAllowedSizeN()</a>, <a class="el" href="NVGPUDialect_8cpp_source.html#l00521">isAllowedWGMMADataType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00210">mlir::gpu::MMAMatrixType::isValidElementType()</a>, <a class="el" href="Dialect_2ArmSME_2IR_2Utils_8cpp_source.html#l00037">mlir::arm_sme::isValidSMETileElementType()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01018">mlir::math::ErfPolynomialApproximation::matchAndRewrite()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00784">mfmaOpToIntrinsic()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00102">mlir::sparse_tensor::primaryTypeEncoding()</a>, <a class="el" href="NVGPUDialect_8cpp_source.html#l00137">verifyMmaSyncOp()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l01049">wmmaOpToIntrinsicGfx1250()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00993">wmmaOpToIntrinsicRDNA()</a>, and <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00749">wmmaPushOutputOperand()</a>.</p>

</div>
</div>
<a id="a6cde84bc1dbdaecf64df30e7c99e2106" name="a6cde84bc1dbdaecf64df30e7c99e2106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cde84bc1dbdaecf64df30e7c99e2106">&#9670;&#160;</a></span>isF32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isF32 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00040">40</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithToAMDGPU_8cpp_source.html#l00107">castF32To()</a>, <a class="el" href="ArithToAMDGPU_8cpp_source.html#l00201">castToF32()</a>, <a class="el" href="IntelGpuXe2_8h_source.html#l00345">mlir::xegpu::uArch::SubgroupMatrixMultiplyAcc::checkSupportedTypes()</a>, <a class="el" href="Math_2Transforms_2ExpandOps_8cpp_source.html#l00412">convertRoundOp()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00178">floatCst()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00610">getCuSparseDataTypeFrom()</a>, <a class="el" href="BasicPtxBuilderInterface_8cpp_source.html#l00041">getRegisterType()</a>, <a class="el" href="NVGPUDialect_8cpp_source.html#l00555">isAllowedSizeN()</a>, <a class="el" href="NVGPUDialect_8cpp_source.html#l00521">isAllowedWGMMADataType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00210">mlir::gpu::MMAMatrixType::isValidElementType()</a>, <a class="el" href="Dialect_2ArmSME_2IR_2Utils_8cpp_source.html#l00037">mlir::arm_sme::isValidSMETileElementType()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01139">mlir::math::ErfcPolynomialApproximation::matchAndRewrite()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l01018">mlir::math::ErfPolynomialApproximation::matchAndRewrite()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00784">mfmaOpToIntrinsic()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00102">mlir::sparse_tensor::primaryTypeEncoding()</a>, <a class="el" href="NVGPUDialect_8cpp_source.html#l00137">verifyMmaSyncOp()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l01049">wmmaOpToIntrinsicGfx1250()</a>, and <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00993">wmmaOpToIntrinsicRDNA()</a>.</p>

</div>
</div>
<a id="a075a66eef3b8dc3f5fd51eba8399ceb8" name="a075a66eef3b8dc3f5fd51eba8399ceb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075a66eef3b8dc3f5fd51eba8399ceb8">&#9670;&#160;</a></span>isF64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isF64 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00041">41</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00610">getCuSparseDataTypeFrom()</a>, <a class="el" href="BasicPtxBuilderInterface_8cpp_source.html#l00041">getRegisterType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00210">mlir::gpu::MMAMatrixType::isValidElementType()</a>, <a class="el" href="Dialect_2ArmSME_2IR_2Utils_8cpp_source.html#l00037">mlir::arm_sme::isValidSMETileElementType()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00784">mfmaOpToIntrinsic()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00102">mlir::sparse_tensor::primaryTypeEncoding()</a>, and <a class="el" href="NVGPUDialect_8cpp_source.html#l00137">verifyMmaSyncOp()</a>.</p>

</div>
</div>
<a id="ad943633969f919ce6169fb52a5cea1cd" name="ad943633969f919ce6169fb52a5cea1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad943633969f919ce6169fb52a5cea1cd">&#9670;&#160;</a></span>isF80()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isF80 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00042">42</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="a139eaaa4ef0b399f9acec4f332a8370d" name="a139eaaa4ef0b399f9acec4f332a8370d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139eaaa4ef0b399f9acec4f332a8370d">&#9670;&#160;</a></span>isFloat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isFloat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an float type (with the specified width). </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00045">45</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BasicPtxBuilderInterface_8cpp_source.html#l00041">getRegisterType()</a>, and <a class="el" href="MathToXeVM_8cpp_source.html#l00075">ConvertNativeFuncPattern&lt; Op &gt;::isSPIRVCompatibleFloatOrVec()</a>.</p>

</div>
</div>
<a id="a62a3f2a48324764dc282fe7c61517bce" name="a62a3f2a48324764dc282fe7c61517bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a3f2a48324764dc282fe7c61517bce">&#9670;&#160;</a></span>isFloat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>width</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a float type with the specified width. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00048">48</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="a5d5d5335ce4fc906636a2690155a7d72" name="a5d5d5335ce4fc906636a2690155a7d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5d5335ce4fc906636a2690155a7d72">&#9670;&#160;</a></span>isIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00054">54</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithOps_8cpp_source.html#l01819">areIndexCastCompatible()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00167">assertValidValueDim()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00360">buildAttributeAPInt()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00463">mlir::ValueBoundsConstraintSet::computeBound()</a>, <a class="el" href="XeGPUTransformOps_8cpp_source.html#l00027">convertMixedValuesToInt()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00140">convertScalarToIntDtype()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00854">delinearizeInductionVariable()</a>, <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00169">mlir::affine::fullyComposeAndComputeConstantDelta()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00034">mlir::detail::getDenseElementBitWidth()</a>, <a class="el" href="Builders_8cpp_source.html#l00228">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00818">getProductOfIntsOrIndexes()</a>, <a class="el" href="InferIntRangeInterface_8cpp_source.html#l00031">mlir::ConstantIntRanges::getStorageBitwidth()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00119">mlir::getValueOrCreateCastToIndexLike()</a>, <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00132">getZero()</a>, <a class="el" href="Index_2IR_2InferIntRangeInterfaceImpls_8cpp_source.html#l00193">inferIndexCast()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00112">isIntOrIndex()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00120">isIntOrIndexOrFloat()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01244">isMatchingWidth()</a>, <a class="el" href="Dialect_2EmitC_2IR_2EmitC_8cpp_source.html#l00061">mlir::emitc::isSupportedEmitCType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00290">mlir::affine::isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00314">mlir::affine::isValidDim()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01117">isValidIntOrFloat()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00412">mlir::affine::isValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00457">mlir::affine::isValidSymbol()</a>, <a class="el" href="lib_2Conversion_2SPIRVCommon_2Pattern_8h_source.html#l00027">mlir::spirv::ElementwiseOpPattern&lt; Op, SPIRVOp &gt;::matchAndRewrite()</a>, <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00034">mlir::affine::materializeComputedBound()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00043">mlir::sparse_tensor::overheadTypeEncoding()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l01400">printLaunchDimType()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00172">reifyMixedParamAndHandleResults()</a>, <a class="el" href="Arith_2Transforms_2ReifyValueBounds_8cpp_source.html#l00066">mlir::arith::reifyValueBound()</a>, <a class="el" href="SparseTensorDescriptor_8cpp_source.html#l00093">mlir::sparse_tensor::SparseTensorSpecifier::setSpecifierField()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l00086">unpackSingleIndexResultPayloadOperations()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00088">mlir::ValueBoundsConstraintSet::Variable::Variable()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01166">vectorizeTensorExtract()</a>, <a class="el" href="Dialect_2EmitC_2IR_2EmitC_8cpp_source.html#l00144">verifyInitializationAttribute()</a>, and <a class="el" href="ShapedOpInterfaces_8cpp_source.html#l00017">mlir::detail::verifyShapedDimOpInterface()</a>.</p>

</div>
</div>
<a id="aa26b99685376bbe95a18fdea7dd8e5cf" name="aa26b99685376bbe95a18fdea7dd8e5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26b99685376bbe95a18fdea7dd8e5cf">&#9670;&#160;</a></span>isInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isInteger </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer type (with the specified width). </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00056">56</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00088">castBoolToIntN()</a>, <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00165">castIntNToBool()</a>, <a class="el" href="IntelGpuXe2_8h_source.html#l00345">mlir::xegpu::uArch::SubgroupMatrixMultiplyAcc::checkSupportedTypes()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l01054">createInitialValueForReduceOp()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00082">createLinalgBodyCalculationForElementwiseOp()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l01106">createLinalgBodyCalculationForReduceOp()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>, <a class="el" href="AMDGPUDialect_8cpp_source.html#l00248">getConstantUint32()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00610">getCuSparseDataTypeFrom()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00592">getCuSparseIndexTypeFrom()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l00600">getCuSparseLtDataTypeFrom()</a>, <a class="el" href="OpToFuncCallLowering_8h_source.html#l00177">mlir::OpToFuncCallLowering&lt; SourceOp &gt;::getFunctionName()</a>, <a class="el" href="NVVMToLLVMIRTranslation_8cpp_source.html#l00105">getMatchSyncIntrinsicId()</a>, <a class="el" href="BasicPtxBuilderInterface_8cpp_source.html#l00041">getRegisterType()</a>, <a class="el" href="MathToSPIRV_8cpp_source.html#l00033">getScalarOrVectorI32Constant()</a>, <a class="el" href="TypeConversions_8cpp_source.html#l00052">mlir::emitc::getSignedTypeFor()</a>, <a class="el" href="TypeConversions_8cpp_source.html#l00039">mlir::emitc::getUnsignedTypeFor()</a>, <a class="el" href="NVGPUDialect_8cpp_source.html#l00555">isAllowedSizeN()</a>, <a class="el" href="NVGPUDialect_8cpp_source.html#l00521">isAllowedWGMMADataType()</a>, <a class="el" href="ArithToSPIRV_8cpp_source.html#l00114">isBoolScalarOrVector()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01244">isMatchingWidth()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00680">mlir::DenseElementsAttr::isValidBool()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00210">mlir::gpu::MMAMatrixType::isValidElementType()</a>, <a class="el" href="Dialect_2ArmSME_2IR_2Utils_8cpp_source.html#l00037">mlir::arm_sme::isValidSMETileElementType()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00784">mfmaOpToIntrinsic()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00910">mlir::detail::Parser::parseDenseArrayAttr()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00635">mlir::memref::populateMemRefNarrowTypeEmulationConversions()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00102">mlir::sparse_tensor::primaryTypeEncoding()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l02681">mlir::AsmPrinter::Impl::printDenseArrayAttr()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l02544">printDenseIntElement()</a>, <a class="el" href="NVGPUDialect_8cpp_source.html#l00137">verifyMmaSyncOp()</a>, <a class="el" href="TosaOps_8h_source.html#l00069">mlir::OpTrait::tosa::MulOperandsAndResultElementType&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="TosaOps_8cpp_source.html#l02629">verifyZeroPoint()</a>, <a class="el" href="TosaOps_8cpp_source.html#l02644">verifyZeroPoint()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l01049">wmmaOpToIntrinsicGfx1250()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00993">wmmaOpToIntrinsicRDNA()</a>, and <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00749">wmmaPushOutputOperand()</a>.</p>

</div>
</div>
<a id="a1d16f5d47b21c67f4d49c02979c33724" name="a1d16f5d47b21c67f4d49c02979c33724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d16f5d47b21c67f4d49c02979c33724">&#9670;&#160;</a></span>isInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>width</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00058">58</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="aa4295aaec59a8a864338a2b7dab0c935" name="aa4295aaec59a8a864338a2b7dab0c935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4295aaec59a8a864338a2b7dab0c935">&#9670;&#160;</a></span>isIntOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isIntOrFloat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer (of any signedness) or a float type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00116">116</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l01634">alignedConversionPrecondition()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00145">areSameBitwidthScalarType()</a>, <a class="el" href="ArithToAPFloat_8cpp_source.html#l00144">checkPreconditions()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00082">createLinalgBodyCalculationForElementwiseOp()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00378">getBitWidth()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00064">getBitWidth()</a>, <a class="el" href="SPIRVOpUtils_8h_source.html#l00014">mlir::spirv::getBitWidth()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00052">mlir::detail::getDefaultTypeSizeInBits()</a>, <a class="el" href="XeGPUPropagateLayout_8cpp_source.html#l00307">mlir::xegpu::impl::XeGPUPropagateLayoutBase&lt; DerivedT &gt;::getDependentDialects()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00122">getIntOrFloatBitWidth()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00129">getScalarOrElementWidth()</a>, <a class="el" href="IntelGpuXe2_8h_source.html#l00407">mlir::xegpu::uArch::SubgroupMatrixMultiplyAcc::getSupportedK()</a>, <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00124">isAllocationSupported()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00120">isIntOrIndexOrFloat()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00690">mlir::spirv::SPIRVType::isScalarOrVector()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00344">ConvertAccessChain::matchAndRewrite()</a>, <a class="el" href="UnifyAliasedResourcePass_8cpp_source.html#l00535">ConvertStore::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00540">mlir::GPUPrintfOpToVPrintfLowering::matchAndRewrite()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00635">mlir::memref::populateMemRefNarrowTypeEmulationConversions()</a>, and <a class="el" href="Deserializer_8cpp_source.html#l02036">mlir::spirv::Deserializer::processConstantNull()</a>.</p>

</div>
</div>
<a id="a7f33529654fee149935f1e14cdf74305" name="a7f33529654fee149935f1e14cdf74305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f33529654fee149935f1e14cdf74305">&#9670;&#160;</a></span>isIntOrIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isIntOrIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer (of any signedness) or an index type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00112">112</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00054">isIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00265">ceilDivPositive()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00283">ceilDivPositive()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00201">mlir::sparse_tensor::genIsNonzero()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00132">isSupportedCombiningKind()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00910">mlir::detail::Parser::parseDenseArrayAttr()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l02681">mlir::AsmPrinter::Impl::printDenseArrayAttr()</a>.</p>

</div>
</div>
<a id="a69310264441dfb377a3789c8eedcdce7" name="a69310264441dfb377a3789c8eedcdce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69310264441dfb377a3789c8eedcdce7">&#9670;&#160;</a></span>isIntOrIndexOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isIntOrIndexOrFloat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer (of any signedness), index, or float type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00120">120</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00054">isIndex()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00116">isIntOrFloat()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00910">mlir::DenseElementsAttr::get()</a>, <a class="el" href="ShardingInterface_8cpp_source.html#l00384">getSharding()</a>, <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00132">getZero()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00132">isSupportedCombiningKind()</a>, <a class="el" href="MathToSPIRV_8cpp_source.html#l00052">isSupportedSourceType()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01097">isUniformDefinition()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00413">mlir::BaseMemRefType::isValidElementType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00910">mlir::detail::Parser::parseDenseArrayAttr()</a>, and <a class="el" href="SPIRVDialect_8cpp_source.html#l01036">verifyRegionAttribute()</a>.</p>

</div>
</div>
<a id="a50385bcb919f49adab0f8f2521dc479f" name="a50385bcb919f49adab0f8f2521dc479f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50385bcb919f49adab0f8f2521dc479f">&#9670;&#160;</a></span>isSignedInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isSignedInteger </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a signed integer type (with the specified width). </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00076">76</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeParser_8cpp_source.html#l00360">buildAttributeAPInt()</a>, <a class="el" href="Builders_8cpp_source.html#l00228">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00089">mlir::quant::QuantizedType::hasStorageTypeBounds()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00035">isSignedIntegerOrVector()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00210">mlir::gpu::MMAMatrixType::isValidElementType()</a>, and <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00691">wmmaPushInputOperand()</a>.</p>

</div>
</div>
<a id="a920ada7270762d4e2f96d96f5b29a140" name="a920ada7270762d4e2f96d96f5b29a140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920ada7270762d4e2f96d96f5b29a140">&#9670;&#160;</a></span>isSignedInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isSignedInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>width</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00082">82</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="a53765d45f36d2bbff81bb81b286a9525" name="a53765d45f36d2bbff81bb81b286a9525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53765d45f36d2bbff81bb81b286a9525">&#9670;&#160;</a></span>isSignlessInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isSignlessInteger </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a signless integer type (with the specified width). </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00064">64</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArithOps_8cpp_source.html#l01819">areIndexCastCompatible()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00108">isSignlessIntOrFloat()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00100">isSignlessIntOrIndex()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00104">isSignlessIntOrIndexOrFloat()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l02389">mlir::AsmPrinter::Impl::printAttributeImpl()</a>.</p>

</div>
</div>
<a id="a213fdac03ae27d597f277ac05ea30fca" name="a213fdac03ae27d597f277ac05ea30fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213fdac03ae27d597f277ac05ea30fca">&#9670;&#160;</a></span>isSignlessInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isSignlessInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>width</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00070">70</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="ae8d6282ddfa213055b965f2db7eb9752" name="ae8d6282ddfa213055b965f2db7eb9752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d6282ddfa213055b965f2db7eb9752">&#9670;&#160;</a></span>isSignlessIntOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isSignlessIntOrFloat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true of this is a signless integer or a float type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00108">108</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00064">isSignlessInteger()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00093">mlir::linalg::RegionMatcher::matchAsScalarBinaryOp()</a>.</p>

</div>
</div>
<a id="a26f738cb5a46aeb47df2e6243a11c41c" name="a26f738cb5a46aeb47df2e6243a11c41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f738cb5a46aeb47df2e6243a11c41c">&#9670;&#160;</a></span>isSignlessIntOrIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isSignlessIntOrIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a signless integer or index type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00100">100</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00064">isSignlessInteger()</a>.</p>

</div>
</div>
<a id="afeff6b78a50b5d435c10e6c8927bbb7d" name="afeff6b78a50b5d435c10e6c8927bbb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeff6b78a50b5d435c10e6c8927bbb7d">&#9670;&#160;</a></span>isSignlessIntOrIndexOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isSignlessIntOrIndexOrFloat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a signless integer, index, or float type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00104">104</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00064">isSignlessInteger()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l02482">appendMangledType()</a>.</p>

</div>
</div>
<a id="a137df877894c6158a0958329be5bb70f" name="a137df877894c6158a0958329be5bb70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137df877894c6158a0958329be5bb70f">&#9670;&#160;</a></span>isTF32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isTF32 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00039">39</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IntelGpuXe2_8h_source.html#l00345">mlir::xegpu::uArch::SubgroupMatrixMultiplyAcc::checkSupportedTypes()</a>, <a class="el" href="NVGPUDialect_8cpp_source.html#l00555">isAllowedSizeN()</a>, and <a class="el" href="NVGPUDialect_8cpp_source.html#l00521">isAllowedWGMMADataType()</a>.</p>

</div>
</div>
<a id="a78c30270dcbb289e5931b2ed1c4c6919" name="a78c30270dcbb289e5931b2ed1c4c6919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c30270dcbb289e5931b2ed1c4c6919">&#9670;&#160;</a></span>isUnsignedInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isUnsignedInteger </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an unsigned integer type (with the specified width). </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00088">88</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TosaToLinalg_8cpp_source.html#l00082">createLinalgBodyCalculationForElementwiseOp()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00044">isUnsignedIntegerOrVector()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00210">mlir::gpu::MMAMatrixType::isValidElementType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00406">mlir::detail::Parser::parseDecOrHexAttr()</a>, <a class="el" href="TosaTypeConverters_8cpp_source.html#l00020">mlir::tosa::populateTosaTypeConversion()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l02389">mlir::AsmPrinter::Impl::printAttributeImpl()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l02544">printDenseIntElement()</a>, and <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00691">wmmaPushInputOperand()</a>.</p>

</div>
</div>
<a id="a8dbb14dffe2d155b3f3f478ca216aca7" name="a8dbb14dffe2d155b3f3f478ca216aca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbb14dffe2d155b3f3f478ca216aca7">&#9670;&#160;</a></span>isUnsignedInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Type::isUnsignedInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>width</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8cpp_source.html#l00094">94</a> of file <a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="afeb8b20e59002a0fedfcb93e314b416f" name="afeb8b20e59002a0fedfcb93e314b416f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb8b20e59002a0fedfcb93e314b416f">&#9670;&#160;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Type::operator <a class="el" href="classbool.html">bool</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00095">95</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="ac516f7c8eb957068555b5781d78f23af" name="ac516f7c8eb957068555b5781d78f23af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac516f7c8eb957068555b5781d78f23af">&#9670;&#160;</a></span>operator!()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::Type::operator! </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00097">97</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="ad1be45203a0010965388d41e712dc268" name="ad1be45203a0010965388d41e712dc268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1be45203a0010965388d41e712dc268">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="#ac516f7c8eb957068555b5781d78f23af">mlir::Type::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00094">94</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="#a622149b48f6d7eaf0e42f8abea6ca65e">Type()</a>.</p>

</div>
</div>
<a id="ab1ccc7b9d96b2d9b223884824a8dc516" name="ab1ccc7b9d96b2d9b223884824a8dc516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ccc7b9d96b2d9b223884824a8dc516">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> &amp; mlir::Type::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="#a622149b48f6d7eaf0e42f8abea6ca65e">Type()</a>.</p>

</div>
</div>
<a id="ac53df1249058e8c2ec0fa70f172f0b59" name="ac53df1249058e8c2ec0fa70f172f0b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53df1249058e8c2ec0fa70f172f0b59">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::Type::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00093">93</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00234">impl</a>, and <a class="el" href="#a622149b48f6d7eaf0e42f8abea6ca65e">Type()</a>.</p>

</div>
</div>
<a id="a034614f0e682699a53a6e967654caf12" name="a034614f0e682699a53a6e967654caf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034614f0e682699a53a6e967654caf12">&#9670;&#160;</a></span>print() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> Type::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the current type. </p>

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l03985">3985</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp.html#a420db562c84b0a026e92385cb33aaf6f">getContext()</a>, and <a class="el" href="SPIRVAttributes_8cpp_source.html#l00624">print()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpenACCUtils_8cpp_source.html#l00116">mlir::acc::getRecipeName()</a>, <a class="el" href="IR_2Types_8h_source.html#l00237">mlir::operator&lt;&lt;()</a>, and <a class="el" href="LLVMTypeSyntax_8cpp_source.html#l00097">mlir::LLVM::detail::printType()</a>.</p>

</div>
</div>
<a id="aef996e7de5468067879322021956d167" name="aef996e7de5468067879322021956d167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef996e7de5468067879322021956d167">&#9670;&#160;</a></span>print() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> Type::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmState.html">AsmState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l03994">3994</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmState_8h_source.html#l00568">mlir::AsmState::getImpl()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l02706">mlir::AsmPrinter::Impl::printType()</a>.</p>

</div>
</div>
<a id="add89f8ee12e06fac685dc07a272b02b9" name="add89f8ee12e06fac685dc07a272b02b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add89f8ee12e06fac685dc07a272b02b9">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... ReplacementFns&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::Type::replace </td>
          <td>(</td>
          <td class="paramtype">ReplacementFns &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>replacementFns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively replace all of the nested sub-attributes and sub-types using the provided map functions. </p>
<p>Returns nullptr in the case of failure. See <span class="tt"><a class="el" href="classmlir_1_1AttrTypeReplacer.html" title="This is an attribute/type replacer that is naively cached.">AttrTypeReplacer</a></span> for information on the support replacement function types. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00226">226</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="AttrTypeSubElements_8cpp_source.html#l00074">mlir::detail::AttrTypeReplacerBase&lt; Concrete &gt;::addReplacement()</a>, and <a class="el" href="AttrTypeSubElements_8cpp_source.html#l00251">mlir::AttrTypeReplacer::replace()</a>.</p>

</div>
</div>
<a id="a22321e0d04aac43a6054e27d41846b5f" name="a22321e0d04aac43a6054e27d41846b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22321e0d04aac43a6054e27d41846b5f">&#9670;&#160;</a></span>replaceImmediateSubElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::Type::replaceImmediateSubElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>replAttrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>replTypes</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the immediately nested sub-attributes and sub-types with those provided. </p>
<p>The order of the provided elements is derived from the order of the elements returned by the callbacks of <span class="tt">walkImmediateSubElements</span>. The element at index 0 would replace the very first attribute given by <span class="tt">walkImmediateSubElements</span>. On success, the new instance with the values replaced is returned. If replacement fails, nullptr is returned. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00205">205</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00187">getAbstractType()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00025">mlir::AbstractType::replaceImmediateSubElements()</a>.</p>

</div>
</div>
<a id="ae56116bb5e60101fe97b5af0bf3213de" name="ae56116bb5e60101fe97b5af0bf3213de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56116bb5e60101fe97b5af0bf3213de">&#9670;&#160;</a></span>walk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adc">WalkOrder</a> Order = WalkOrder::PostOrder, typename... WalkFns&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::Type::walk </td>
          <td>(</td>
          <td class="paramtype">WalkFns &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>walkFns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walk this type and all attibutes/types nested within using the provided walk functions. </p>
<p>See <span class="tt"><a class="el" href="classmlir_1_1AttrTypeWalker.html" title="AttrTypeWalker.">AttrTypeWalker</a></span> for information on the supported walk function types. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00215">215</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="AttrTypeSubElements_8h_source.html#l00069">mlir::AttrTypeWalker::addWalk()</a>, and <a class="el" href="AttrTypeSubElements_8h_source.html#l00042">mlir::AttrTypeWalker::walk()</a>.</p>

</div>
</div>
<a id="a6f215adc2d7aef45aaee1884bd93bcdb" name="a6f215adc2d7aef45aaee1884bd93bcdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f215adc2d7aef45aaee1884bd93bcdb">&#9670;&#160;</a></span>walkImmediateSubElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::Type::walkImmediateSubElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>walkAttrsFn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Type.html">Type</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>walkTypesFn</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walk all of the immediately nested sub-attributes and sub-types. </p>
<p>This method does not recurse into sub elements. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00194">194</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00187">getAbstractType()</a>, <a class="el" href="#a622149b48f6d7eaf0e42f8abea6ca65e">Type()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00019">mlir::AbstractType::walkImmediateSubElements()</a>.</p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a54af6c081e012a32bba9b650480c6c06" name="a54af6c081e012a32bba9b650480c6c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54af6c081e012a32bba9b650480c6c06">&#9670;&#160;</a></span>impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a89de246b01ef652963e1ddde953d62e7">ImplType</a>* mlir::Type::impl {<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Types_8h_source.html#l00234">234</a> of file <a class="el" href="IR_2Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Types_8h_source.html#l00302">mlir::hash_value()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00093">operator==()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/IR/<a class="el" href="IR_2Types_8h_source.html">Types.h</a></li>
<li>lib/IR/<a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a></li>
<li>lib/IR/<a class="el" href="IR_2Types_8cpp_source.html">Types.cpp</a></li>
<li>lib/TableGen/<a class="el" href="Type_8cpp_source.html">Type.cpp</a></li>
<li>lib/Tools/PDLL/AST/<a class="el" href="NodePrinter_8cpp_source.html">NodePrinter.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
