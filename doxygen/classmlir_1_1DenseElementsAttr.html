<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::DenseElementsAttr Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classmlir_1_1DenseElementsAttr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::DenseElementsAttr Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An attribute that represents a reference to a dense vector or tensor object.  
 <a href="classmlir_1_1DenseElementsAttr.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">mlir/IR/BuiltinAttributes.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mlir::DenseElementsAttr:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classmlir_1_1DenseElementsAttr__inherit__graph.svg" width="194" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1AttributeElementIterator.html">AttributeElementIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility iterator that allows walking over the internal <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> values of a <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a>.  <a href="classmlir_1_1DenseElementsAttr_1_1AttributeElementIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1BoolElementIterator.html">BoolElementIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility iterator that allows walking over the internal bool values.  <a href="classmlir_1_1DenseElementsAttr_1_1BoolElementIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1ComplexFloatElementIterator.html">ComplexFloatElementIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for walking over complex APFloat values.  <a href="classmlir_1_1DenseElementsAttr_1_1ComplexFloatElementIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1ComplexIntElementIterator.html">ComplexIntElementIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility iterator that allows walking over the internal raw complex APInt values.  <a href="classmlir_1_1DenseElementsAttr_1_1ComplexIntElementIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DenseElementsAttr_1_1DerivedAttributeElementIterator.html">DerivedAttributeElementIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1ElementIterator.html">ElementIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for walking raw element values of the specified type 'T', which may be any c++ data type matching the stored representation: int32_t, float, etc.  <a href="classmlir_1_1DenseElementsAttr_1_1ElementIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1FloatElementIterator.html">FloatElementIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for walking over APFloat values.  <a href="classmlir_1_1DenseElementsAttr_1_1FloatElementIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility iterator that allows walking over the internal raw APInt values.  <a href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DenseElementsAttr_1_1is__valid__cpp__fp__type.html">is_valid_cpp_fp_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> trait used to check if the given type T is a potentially valid C++ floating point type that can be used to access the underlying element types of a <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a>.  <a href="structmlir_1_1DenseElementsAttr_1_1is__valid__cpp__fp__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a439feabbf1e2b2810b106246841e4904"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT &gt; </td></tr>
<tr class="memitem:a439feabbf1e2b2810b106246841e4904"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a> = <a class="el" href="classmlir_1_1detail_1_1ElementsAttrRange.html">detail::ElementsAttrRange</a>&lt; IteratorT &gt;</td></tr>
<tr class="memdesc:a439feabbf1e2b2810b106246841e4904"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator range over the given iterator type T.  <a href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">More...</a><br /></td></tr>
<tr class="separator:a439feabbf1e2b2810b106246841e4904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769d16dc3360561b0c1853ff70548afe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename AttrT  = DenseElementsAttr&gt; </td></tr>
<tr class="memitem:a769d16dc3360561b0c1853ff70548afe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a769d16dc3360561b0c1853ff70548afe">iterator</a> = decltype(std::declval&lt; AttrT &gt;().template <a class="el" href="classmlir_1_1DenseElementsAttr.html#a143f2e8369898f5efe51aa6f3aa3c61d">value_begin</a>&lt; T &gt;())</td></tr>
<tr class="memdesc:a769d16dc3360561b0c1853ff70548afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator for the given element type T.  <a href="classmlir_1_1DenseElementsAttr.html#a769d16dc3360561b0c1853ff70548afe">More...</a><br /></td></tr>
<tr class="separator:a769d16dc3360561b0c1853ff70548afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b213091649867bcadbbbf8627a4652f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename AttrT  = DenseElementsAttr&gt; </td></tr>
<tr class="memitem:a7b213091649867bcadbbbf8627a4652f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a7b213091649867bcadbbbf8627a4652f">iterator_range</a> = decltype(std::declval&lt; AttrT &gt;().template <a class="el" href="classmlir_1_1DenseElementsAttr.html#a416662fc7e96dfef98c8e48682afd8fc">getValues</a>&lt; T &gt;())</td></tr>
<tr class="memdesc:a7b213091649867bcadbbbf8627a4652f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator range over the given element T.  <a href="classmlir_1_1DenseElementsAttr.html#a7b213091649867bcadbbbf8627a4652f">More...</a><br /></td></tr>
<tr class="separator:a7b213091649867bcadbbbf8627a4652f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a19b125635be753a67f5a323a5eba0d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a19b125635be753a67f5a323a5eba0d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a6a19b125635be753a67f5a323a5eba0d">IntFloatValueTemplateCheckT</a> = std::enable_if_t&lt;(!std::is_same&lt; T, bool &gt;::value &amp;&amp;std::numeric_limits&lt; T &gt;::is_integer)||<a class="el" href="structmlir_1_1DenseElementsAttr_1_1is__valid__cpp__fp__type.html">is_valid_cpp_fp_type</a>&lt; T &gt;::value &gt;</td></tr>
<tr class="memdesc:a6a19b125635be753a67f5a323a5eba0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the held element values as a range of integer or floating-point values.  <a href="classmlir_1_1DenseElementsAttr.html#a6a19b125635be753a67f5a323a5eba0d">More...</a><br /></td></tr>
<tr class="separator:a6a19b125635be753a67f5a323a5eba0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7221ce978d6cd452b2d890dd14ffb060"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ElementT &gt; </td></tr>
<tr class="memitem:a7221ce978d6cd452b2d890dd14ffb060"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a7221ce978d6cd452b2d890dd14ffb060">ComplexValueTemplateCheckT</a> = std::enable_if_t&lt; <a class="el" href="structmlir_1_1detail_1_1is__complex__t.html">detail::is_complex_t</a>&lt; T &gt;::value &amp;&amp;(std::numeric_limits&lt; ElementT &gt;::is_integer||<a class="el" href="structmlir_1_1DenseElementsAttr_1_1is__valid__cpp__fp__type.html">is_valid_cpp_fp_type</a>&lt; ElementT &gt;::value)&gt;</td></tr>
<tr class="memdesc:a7221ce978d6cd452b2d890dd14ffb060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the held element values as a range of std::complex.  <a href="classmlir_1_1DenseElementsAttr.html#a7221ce978d6cd452b2d890dd14ffb060">More...</a><br /></td></tr>
<tr class="separator:a7221ce978d6cd452b2d890dd14ffb060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb6160557ef2245de767e84b265244b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3bb6160557ef2245de767e84b265244b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a3bb6160557ef2245de767e84b265244b">StringRefValueTemplateCheckT</a> = std::enable_if_t&lt; std::is_same&lt; T, StringRef &gt;::value &gt;</td></tr>
<tr class="memdesc:a3bb6160557ef2245de767e84b265244b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the held element values as a range of StringRef.  <a href="classmlir_1_1DenseElementsAttr.html#a3bb6160557ef2245de767e84b265244b">More...</a><br /></td></tr>
<tr class="separator:a3bb6160557ef2245de767e84b265244b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e30c4d5f532c36520e9016b8d4ff938"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e30c4d5f532c36520e9016b8d4ff938"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a3e30c4d5f532c36520e9016b8d4ff938">AttributeValueTemplateCheckT</a> = std::enable_if_t&lt; std::is_same&lt; T, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;::value &gt;</td></tr>
<tr class="memdesc:a3e30c4d5f532c36520e9016b8d4ff938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the held element values as a range of Attributes.  <a href="classmlir_1_1DenseElementsAttr.html#a3e30c4d5f532c36520e9016b8d4ff938">More...</a><br /></td></tr>
<tr class="separator:a3e30c4d5f532c36520e9016b8d4ff938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddfdd4c9620200091e52aab76f83ac9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adddfdd4c9620200091e52aab76f83ac9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#adddfdd4c9620200091e52aab76f83ac9">DerivedAttrValueTemplateCheckT</a> = std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T &gt;::value &gt;</td></tr>
<tr class="memdesc:adddfdd4c9620200091e52aab76f83ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the held element values a range of T, where T is a derived attribute type.  <a href="classmlir_1_1DenseElementsAttr.html#adddfdd4c9620200091e52aab76f83ac9">More...</a><br /></td></tr>
<tr class="separator:adddfdd4c9620200091e52aab76f83ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09276fddb726b8b77c0b33eb37c086a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab09276fddb726b8b77c0b33eb37c086a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#ab09276fddb726b8b77c0b33eb37c086a">BoolValueTemplateCheckT</a> = std::enable_if_t&lt; std::is_same&lt; T, bool &gt;::value &gt;</td></tr>
<tr class="memdesc:ab09276fddb726b8b77c0b33eb37c086a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the held element values as a range of bool.  <a href="classmlir_1_1DenseElementsAttr.html#ab09276fddb726b8b77c0b33eb37c086a">More...</a><br /></td></tr>
<tr class="separator:ab09276fddb726b8b77c0b33eb37c086a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fb08ec708ddf44a36c6295fa9d298f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0fb08ec708ddf44a36c6295fa9d298f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#ac0fb08ec708ddf44a36c6295fa9d298f">APIntValueTemplateCheckT</a> = std::enable_if_t&lt; std::is_same&lt; T, APInt &gt;::value &gt;</td></tr>
<tr class="memdesc:ac0fb08ec708ddf44a36c6295fa9d298f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the held element values as a range of APInts.  <a href="classmlir_1_1DenseElementsAttr.html#ac0fb08ec708ddf44a36c6295fa9d298f">More...</a><br /></td></tr>
<tr class="separator:ac0fb08ec708ddf44a36c6295fa9d298f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac429e22c9ebcc952b5e8cfa20ff9c99a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac429e22c9ebcc952b5e8cfa20ff9c99a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#ac429e22c9ebcc952b5e8cfa20ff9c99a">ComplexAPIntValueTemplateCheckT</a> = std::enable_if_t&lt; std::is_same&lt; T, std::complex&lt; APInt &gt; &gt;::value &gt;</td></tr>
<tr class="memdesc:ac429e22c9ebcc952b5e8cfa20ff9c99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the held element values as a range of complex APInts.  <a href="classmlir_1_1DenseElementsAttr.html#ac429e22c9ebcc952b5e8cfa20ff9c99a">More...</a><br /></td></tr>
<tr class="separator:ac429e22c9ebcc952b5e8cfa20ff9c99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392afbd8f80c58837623b089bd0ce60b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a392afbd8f80c58837623b089bd0ce60b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a392afbd8f80c58837623b089bd0ce60b">APFloatValueTemplateCheckT</a> = std::enable_if_t&lt; std::is_same&lt; T, APFloat &gt;::value &gt;</td></tr>
<tr class="memdesc:a392afbd8f80c58837623b089bd0ce60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the held element values as a range of APFloat.  <a href="classmlir_1_1DenseElementsAttr.html#a392afbd8f80c58837623b089bd0ce60b">More...</a><br /></td></tr>
<tr class="separator:a392afbd8f80c58837623b089bd0ce60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363e8739b46ab37b154d64d2bee84377"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a363e8739b46ab37b154d64d2bee84377"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a363e8739b46ab37b154d64d2bee84377">ComplexAPFloatValueTemplateCheckT</a> = std::enable_if_t&lt; std::is_same&lt; T, std::complex&lt; APFloat &gt; &gt;::value &gt;</td></tr>
<tr class="memdesc:a363e8739b46ab37b154d64d2bee84377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the held element values as a range of complex APFloat.  <a href="classmlir_1_1DenseElementsAttr.html#a363e8739b46ab37b154d64d2bee84377">More...</a><br /></td></tr>
<tr class="separator:a363e8739b46ab37b154d64d2bee84377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classmlir_1_1Attribute"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmlir_1_1Attribute')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmlir_1_1Attribute.html">mlir::Attribute</a></td></tr>
<tr class="memitem:a3e507cbff1850e3d3c7bd0e92d6f490a inherit pub_types_classmlir_1_1Attribute"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteType , typename BaseType , typename StorageType , template&lt; typename T &gt; class... Traits&gt; </td></tr>
<tr class="memitem:a3e507cbff1850e3d3c7bd0e92d6f490a inherit pub_types_classmlir_1_1Attribute"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a3e507cbff1850e3d3c7bd0e92d6f490a">AttrBase</a> = <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">detail::StorageUserBase</a>&lt; ConcreteType, <a class="el" href="classBaseType.html">BaseType</a>, StorageType, <a class="el" href="classmlir_1_1detail_1_1AttributeUniquer.html">detail::AttributeUniquer</a>, Traits... &gt;</td></tr>
<tr class="memdesc:a3e507cbff1850e3d3c7bd0e92d6f490a inherit pub_types_classmlir_1_1Attribute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for implementing attributes.  <a href="classmlir_1_1Attribute.html#a3e507cbff1850e3d3c7bd0e92d6f490a">More...</a><br /></td></tr>
<tr class="separator:a3e507cbff1850e3d3c7bd0e92d6f490a inherit pub_types_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa42f4a50b44cf2daab81c9b94cbc7cb inherit pub_types_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#aaa42f4a50b44cf2daab81c9b94cbc7cb">ImplType</a> = <a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td></tr>
<tr class="separator:aaa42f4a50b44cf2daab81c9b94cbc7cb inherit pub_types_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623c975d64311bcc8f7b2a2b71d6a4fa inherit pub_types_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a623c975d64311bcc8f7b2a2b71d6a4fa">ValueType</a> = void</td></tr>
<tr class="separator:a623c975d64311bcc8f7b2a2b71d6a4fa inherit pub_types_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303062c8179f2b504b8f7215713bfbce inherit pub_types_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a303062c8179f2b504b8f7215713bfbce">AbstractTy</a> = <a class="el" href="classmlir_1_1AbstractAttribute.html">AbstractAttribute</a></td></tr>
<tr class="separator:a303062c8179f2b504b8f7215713bfbce inherit pub_types_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ada699912638115ac33ef75819290d427"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#ada699912638115ac33ef75819290d427">operator ElementsAttr</a> () const</td></tr>
<tr class="memdesc:ada699912638115ac33ef75819290d427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow implicit conversion to ElementsAttr.  <a href="classmlir_1_1DenseElementsAttr.html#ada699912638115ac33ef75819290d427">More...</a><br /></td></tr>
<tr class="separator:ada699912638115ac33ef75819290d427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0f00f7c901434c22e8e64e1a5b2eda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a3b0f00f7c901434c22e8e64e1a5b2eda">operator TypedAttr</a> () const</td></tr>
<tr class="memdesc:a3b0f00f7c901434c22e8e64e1a5b2eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow implicit conversion to TypedAttr.  <a href="classmlir_1_1DenseElementsAttr.html#a3b0f00f7c901434c22e8e64e1a5b2eda">More...</a><br /></td></tr>
<tr class="separator:a3b0f00f7c901434c22e8e64e1a5b2eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a415aaf672c2a9a8559335b29c31284"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a5a415aaf672c2a9a8559335b29c31284">isSplat</a> () const</td></tr>
<tr class="memdesc:a5a415aaf672c2a9a8559335b29c31284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this attribute corresponds to a splat, i.e.  <a href="classmlir_1_1DenseElementsAttr.html#a5a415aaf672c2a9a8559335b29c31284">More...</a><br /></td></tr>
<tr class="separator:a5a415aaf672c2a9a8559335b29c31284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0177943562d955068f1f4615bcf05e50"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0177943562d955068f1f4615bcf05e50"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_base_of&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T &gt;::value||std::is_same&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a0177943562d955068f1f4615bcf05e50">getSplatValue</a> () const</td></tr>
<tr class="memdesc:a0177943562d955068f1f4615bcf05e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the splat value for this attribute.  <a href="classmlir_1_1DenseElementsAttr.html#a0177943562d955068f1f4615bcf05e50">More...</a><br /></td></tr>
<tr class="separator:a0177943562d955068f1f4615bcf05e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de73daf965a6027d7ee91144f417fe6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4de73daf965a6027d7ee91144f417fe6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a4de73daf965a6027d7ee91144f417fe6">getSplatValue</a> () const</td></tr>
<tr class="memdesc:a4de73daf965a6027d7ee91144f417fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the splat value for derived attribute element types.  <a href="classmlir_1_1DenseElementsAttr.html#a4de73daf965a6027d7ee91144f417fe6">More...</a><br /></td></tr>
<tr class="separator:a4de73daf965a6027d7ee91144f417fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28da9d46faffde8946bd8fe310c78f20"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28da9d46faffde8946bd8fe310c78f20"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a28da9d46faffde8946bd8fe310c78f20">try_value_begin</a> () const</td></tr>
<tr class="memdesc:a28da9d46faffde8946bd8fe310c78f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get an iterator of the given type to the start of the held element values.  <a href="classmlir_1_1DenseElementsAttr.html#a28da9d46faffde8946bd8fe310c78f20">More...</a><br /></td></tr>
<tr class="separator:a28da9d46faffde8946bd8fe310c78f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e14aee1b18d33af1ec76716254f4f2c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e14aee1b18d33af1ec76716254f4f2c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a5e14aee1b18d33af1ec76716254f4f2c">try_value_end</a> () const</td></tr>
<tr class="memdesc:a5e14aee1b18d33af1ec76716254f4f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get an iterator of the given type to the end of the held element values.  <a href="classmlir_1_1DenseElementsAttr.html#a5e14aee1b18d33af1ec76716254f4f2c">More...</a><br /></td></tr>
<tr class="separator:a5e14aee1b18d33af1ec76716254f4f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416662fc7e96dfef98c8e48682afd8fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a416662fc7e96dfef98c8e48682afd8fc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a416662fc7e96dfef98c8e48682afd8fc">getValues</a> () const</td></tr>
<tr class="memdesc:a416662fc7e96dfef98c8e48682afd8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the held element values as a range of the given type.  <a href="classmlir_1_1DenseElementsAttr.html#a416662fc7e96dfef98c8e48682afd8fc">More...</a><br /></td></tr>
<tr class="separator:a416662fc7e96dfef98c8e48682afd8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143f2e8369898f5efe51aa6f3aa3c61d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a143f2e8369898f5efe51aa6f3aa3c61d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a143f2e8369898f5efe51aa6f3aa3c61d">value_begin</a> () const</td></tr>
<tr class="memdesc:a143f2e8369898f5efe51aa6f3aa3c61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator of the given type to the start of the held element values.  <a href="classmlir_1_1DenseElementsAttr.html#a143f2e8369898f5efe51aa6f3aa3c61d">More...</a><br /></td></tr>
<tr class="separator:a143f2e8369898f5efe51aa6f3aa3c61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89e55019ccd184eb8ad2fa764feb0cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad89e55019ccd184eb8ad2fa764feb0cc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#ad89e55019ccd184eb8ad2fa764feb0cc">value_end</a> () const</td></tr>
<tr class="memdesc:ad89e55019ccd184eb8ad2fa764feb0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator of the given type to the end of the held element values.  <a href="classmlir_1_1DenseElementsAttr.html#ad89e55019ccd184eb8ad2fa764feb0cc">More...</a><br /></td></tr>
<tr class="separator:ad89e55019ccd184eb8ad2fa764feb0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda44a8c5503c3f58137c1526f6e68e4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = IntFloatValueTemplateCheckT&lt;T&gt;&gt; </td></tr>
<tr class="memitem:adda44a8c5503c3f58137c1526f6e68e4"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1ElementIterator.html">ElementIterator</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#adda44a8c5503c3f58137c1526f6e68e4">tryGetValues</a> () const</td></tr>
<tr class="separator:adda44a8c5503c3f58137c1526f6e68e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1a0ac18af8b159406efda8285bf755"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ElementT  = typename T::value_type, typename  = ComplexValueTemplateCheckT&lt;T, ElementT&gt;&gt; </td></tr>
<tr class="memitem:a6a1a0ac18af8b159406efda8285bf755"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1ElementIterator.html">ElementIterator</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a6a1a0ac18af8b159406efda8285bf755">tryGetValues</a> () const</td></tr>
<tr class="separator:a6a1a0ac18af8b159406efda8285bf755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07d7e5e52e2a121e2f96ac9421aa220"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = StringRefValueTemplateCheckT&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ad07d7e5e52e2a121e2f96ac9421aa220"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1ElementIterator.html">ElementIterator</a>&lt; StringRef &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#ad07d7e5e52e2a121e2f96ac9421aa220">tryGetValues</a> () const</td></tr>
<tr class="separator:ad07d7e5e52e2a121e2f96ac9421aa220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ec191520cd7d3a255f560ce41974e6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = AttributeValueTemplateCheckT&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aa6ec191520cd7d3a255f560ce41974e6"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1AttributeElementIterator.html">AttributeElementIterator</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#aa6ec191520cd7d3a255f560ce41974e6">tryGetValues</a> () const</td></tr>
<tr class="separator:aa6ec191520cd7d3a255f560ce41974e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687b8e34e3383003918550b11ff523c3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = DerivedAttrValueTemplateCheckT&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a687b8e34e3383003918550b11ff523c3"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt; <a class="el" href="structmlir_1_1DenseElementsAttr_1_1DerivedAttributeElementIterator.html">DerivedAttributeElementIterator</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a687b8e34e3383003918550b11ff523c3">tryGetValues</a> () const</td></tr>
<tr class="separator:a687b8e34e3383003918550b11ff523c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c551043cccc1197412fa3a962f4bd45"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = BoolValueTemplateCheckT&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a3c551043cccc1197412fa3a962f4bd45"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1BoolElementIterator.html">BoolElementIterator</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a3c551043cccc1197412fa3a962f4bd45">tryGetValues</a> () const</td></tr>
<tr class="separator:a3c551043cccc1197412fa3a962f4bd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93b8f26471aaa9a3e00880da6c04f4d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = APIntValueTemplateCheckT&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aa93b8f26471aaa9a3e00880da6c04f4d"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#aa93b8f26471aaa9a3e00880da6c04f4d">tryGetValues</a> () const</td></tr>
<tr class="separator:aa93b8f26471aaa9a3e00880da6c04f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539cb7678d5c0578157ed90e7ab80198"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = ComplexAPIntValueTemplateCheckT&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a539cb7678d5c0578157ed90e7ab80198"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1ComplexIntElementIterator.html">ComplexIntElementIterator</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a539cb7678d5c0578157ed90e7ab80198">tryGetValues</a> () const</td></tr>
<tr class="separator:a539cb7678d5c0578157ed90e7ab80198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705318307107f7ef2534d51257234804"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = APFloatValueTemplateCheckT&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a705318307107f7ef2534d51257234804"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1FloatElementIterator.html">FloatElementIterator</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a705318307107f7ef2534d51257234804">tryGetValues</a> () const</td></tr>
<tr class="separator:a705318307107f7ef2534d51257234804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411f01a35df7e65a6da7ced4d8829dee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = ComplexAPFloatValueTemplateCheckT&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a411f01a35df7e65a6da7ced4d8829dee"><td class="memTemplItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1ComplexFloatElementIterator.html">ComplexFloatElementIterator</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a411f01a35df7e65a6da7ced4d8829dee">tryGetValues</a> () const</td></tr>
<tr class="separator:a411f01a35df7e65a6da7ced4d8829dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6814d418f6b952cd05a1fec9ca35ca0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a6814d418f6b952cd05a1fec9ca35ca0b">getRawData</a> () const</td></tr>
<tr class="memdesc:a6814d418f6b952cd05a1fec9ca35ca0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw storage data held by this attribute.  <a href="classmlir_1_1DenseElementsAttr.html#a6814d418f6b952cd05a1fec9ca35ca0b">More...</a><br /></td></tr>
<tr class="separator:a6814d418f6b952cd05a1fec9ca35ca0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3209ac8755fa5a6e73b5e9d4964790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a0d3209ac8755fa5a6e73b5e9d4964790">getRawStringData</a> () const</td></tr>
<tr class="memdesc:a0d3209ac8755fa5a6e73b5e9d4964790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw StringRef data held by this attribute.  <a href="classmlir_1_1DenseElementsAttr.html#a0d3209ac8755fa5a6e73b5e9d4964790">More...</a><br /></td></tr>
<tr class="separator:a0d3209ac8755fa5a6e73b5e9d4964790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94078d9d2001e2d92c2f27dac66970ab"><td class="memItemLeft" align="right" valign="top">ShapedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a94078d9d2001e2d92c2f27dac66970ab">getType</a> () const</td></tr>
<tr class="memdesc:a94078d9d2001e2d92c2f27dac66970ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type of this ElementsAttr, guaranteed to be a vector or tensor with static shape.  <a href="classmlir_1_1DenseElementsAttr.html#a94078d9d2001e2d92c2f27dac66970ab">More...</a><br /></td></tr>
<tr class="separator:a94078d9d2001e2d92c2f27dac66970ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6023ce5062e321b001911e4b946642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a7d6023ce5062e321b001911e4b946642">getElementType</a> () const</td></tr>
<tr class="memdesc:a7d6023ce5062e321b001911e4b946642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element type of this <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a>.  <a href="classmlir_1_1DenseElementsAttr.html#a7d6023ce5062e321b001911e4b946642">More...</a><br /></td></tr>
<tr class="separator:a7d6023ce5062e321b001911e4b946642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45eabfa2aa1c4da62c050b8c6f923553"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a45eabfa2aa1c4da62c050b8c6f923553">getNumElements</a> () const</td></tr>
<tr class="memdesc:a45eabfa2aa1c4da62c050b8c6f923553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements held by this attribute.  <a href="classmlir_1_1DenseElementsAttr.html#a45eabfa2aa1c4da62c050b8c6f923553">More...</a><br /></td></tr>
<tr class="separator:a45eabfa2aa1c4da62c050b8c6f923553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e42b360accbd284581b15d695e2508f"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a4e42b360accbd284581b15d695e2508f">size</a> () const</td></tr>
<tr class="memdesc:a4e42b360accbd284581b15d695e2508f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements held by this attribute.  <a href="classmlir_1_1DenseElementsAttr.html#a4e42b360accbd284581b15d695e2508f">More...</a><br /></td></tr>
<tr class="separator:a4e42b360accbd284581b15d695e2508f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b87a8f66feb5c5b1207fc1ca2076e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#aa7b87a8f66feb5c5b1207fc1ca2076e2">empty</a> () const</td></tr>
<tr class="memdesc:aa7b87a8f66feb5c5b1207fc1ca2076e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the number of elements held by this attribute is 0.  <a href="classmlir_1_1DenseElementsAttr.html#aa7b87a8f66feb5c5b1207fc1ca2076e2">More...</a><br /></td></tr>
<tr class="separator:aa7b87a8f66feb5c5b1207fc1ca2076e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09e89266a795b6620886950bf0c6494"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#ac09e89266a795b6620886950bf0c6494">reshape</a> (ShapedType newType)</td></tr>
<tr class="memdesc:ac09e89266a795b6620886950bf0c6494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> that has the same data as the current attribute, but has been reshaped to 'newType'.  <a href="classmlir_1_1DenseElementsAttr.html#ac09e89266a795b6620886950bf0c6494">More...</a><br /></td></tr>
<tr class="separator:ac09e89266a795b6620886950bf0c6494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bd90f89d7c1fc4adb4b28c699ae2b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a41bd90f89d7c1fc4adb4b28c699ae2b3">resizeSplat</a> (ShapedType newType)</td></tr>
<tr class="memdesc:a41bd90f89d7c1fc4adb4b28c699ae2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> that has the same data as the current attribute, but with a different shape for a splat type.  <a href="classmlir_1_1DenseElementsAttr.html#a41bd90f89d7c1fc4adb4b28c699ae2b3">More...</a><br /></td></tr>
<tr class="separator:a41bd90f89d7c1fc4adb4b28c699ae2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc6a39b8cbe129f081bcfb0b9315695"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#aabc6a39b8cbe129f081bcfb0b9315695">bitcast</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> newElType)</td></tr>
<tr class="memdesc:aabc6a39b8cbe129f081bcfb0b9315695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> that has the same data as the current attribute, but has bitcast elements to 'newElType'.  <a href="classmlir_1_1DenseElementsAttr.html#aabc6a39b8cbe129f081bcfb0b9315695">More...</a><br /></td></tr>
<tr class="separator:aabc6a39b8cbe129f081bcfb0b9315695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ba5d17627aea7a53baa138bb63d1c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a71ba5d17627aea7a53baa138bb63d1c9">mapValues</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> newElementType, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; APInt(const APInt &amp;)&gt; mapping) const</td></tr>
<tr class="memdesc:a71ba5d17627aea7a53baa138bb63d1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a new <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> by mapping each int value to a new underlying APInt.  <a href="classmlir_1_1DenseElementsAttr.html#a71ba5d17627aea7a53baa138bb63d1c9">More...</a><br /></td></tr>
<tr class="separator:a71ba5d17627aea7a53baa138bb63d1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f171c2c466569cb71f70004846ec478"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a1f171c2c466569cb71f70004846ec478">mapValues</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> newElementType, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; APInt(const APFloat &amp;)&gt; mapping) const</td></tr>
<tr class="memdesc:a1f171c2c466569cb71f70004846ec478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a new <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> by mapping each float value to a new underlying APInt.  <a href="classmlir_1_1DenseElementsAttr.html#a1f171c2c466569cb71f70004846ec478">More...</a><br /></td></tr>
<tr class="separator:a1f171c2c466569cb71f70004846ec478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2655f89d5ff31b0a7282459c68a0c8"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a6a2655f89d5ff31b0a7282459c68a0c8">Attribute</a> ()=default</td></tr>
<tr class="separator:a6a2655f89d5ff31b0a7282459c68a0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5d0d275732c4cfb26de25d071192a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a5a5d0d275732c4cfb26de25d071192a9">Attribute</a> (const <a class="el" href="classmlir_1_1Attribute.html#aaa42f4a50b44cf2daab81c9b94cbc7cb">ImplType</a> *<a class="el" href="classmlir_1_1Attribute.html#a5131bd44c4b60c95b7aaf8266d42ca81">impl</a>)</td></tr>
<tr class="separator:a5a5d0d275732c4cfb26de25d071192a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd48b18df35704549a7e75704fbd3895"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#acd48b18df35704549a7e75704fbd3895">Attribute</a> (const <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;other)=default</td></tr>
<tr class="separator:acd48b18df35704549a7e75704fbd3895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1Attribute"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1Attribute')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1Attribute.html">mlir::Attribute</a></td></tr>
<tr class="memitem:a6a2655f89d5ff31b0a7282459c68a0c8 inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a6a2655f89d5ff31b0a7282459c68a0c8">Attribute</a> ()=default</td></tr>
<tr class="separator:a6a2655f89d5ff31b0a7282459c68a0c8 inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5d0d275732c4cfb26de25d071192a9 inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a5a5d0d275732c4cfb26de25d071192a9">Attribute</a> (const <a class="el" href="classmlir_1_1Attribute.html#aaa42f4a50b44cf2daab81c9b94cbc7cb">ImplType</a> *<a class="el" href="classmlir_1_1Attribute.html#a5131bd44c4b60c95b7aaf8266d42ca81">impl</a>)</td></tr>
<tr class="separator:a5a5d0d275732c4cfb26de25d071192a9 inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd48b18df35704549a7e75704fbd3895 inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#acd48b18df35704549a7e75704fbd3895">Attribute</a> (const <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;other)=default</td></tr>
<tr class="separator:acd48b18df35704549a7e75704fbd3895 inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba47836d05c23d6480c90e41696f4ff8 inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#aba47836d05c23d6480c90e41696f4ff8">operator=</a> (const <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;other)=default</td></tr>
<tr class="separator:aba47836d05c23d6480c90e41696f4ff8 inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88dab3feccf02922ed6a5ca7cc4afa18 inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a88dab3feccf02922ed6a5ca7cc4afa18">operator==</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> other) const</td></tr>
<tr class="separator:a88dab3feccf02922ed6a5ca7cc4afa18 inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9654b4e35c5f92677942fa55e93cb2d5 inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a9654b4e35c5f92677942fa55e93cb2d5">operator!=</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> other) const</td></tr>
<tr class="separator:a9654b4e35c5f92677942fa55e93cb2d5 inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed790024058bac6fe5fb6a9eef7430d inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#aeed790024058bac6fe5fb6a9eef7430d">operator bool</a> () const</td></tr>
<tr class="separator:aeed790024058bac6fe5fb6a9eef7430d inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5327169c96c8439e44aca386b77512af inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a5327169c96c8439e44aca386b77512af">operator!</a> () const</td></tr>
<tr class="separator:a5327169c96c8439e44aca386b77512af inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae041a4c6495dd6b43e1f4c988e8d24d8 inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#ae041a4c6495dd6b43e1f4c988e8d24d8">getTypeID</a> ()</td></tr>
<tr class="memdesc:ae041a4c6495dd6b43e1f4c988e8d24d8 inherit pub_methods_classmlir_1_1Attribute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unique identifier for the concrete attribute type.  <a href="classmlir_1_1Attribute.html#ae041a4c6495dd6b43e1f4c988e8d24d8">More...</a><br /></td></tr>
<tr class="separator:ae041a4c6495dd6b43e1f4c988e8d24d8 inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d224808f80c18b62b74534fc4aa332 inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#aa2d224808f80c18b62b74534fc4aa332">getContext</a> () const</td></tr>
<tr class="memdesc:aa2d224808f80c18b62b74534fc4aa332 inherit pub_methods_classmlir_1_1Attribute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the context this attribute belongs to.  <a href="classmlir_1_1Attribute.html#aa2d224808f80c18b62b74534fc4aa332">More...</a><br /></td></tr>
<tr class="separator:aa2d224808f80c18b62b74534fc4aa332 inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b10918ec869b6d8aaad3dea807042f inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a18b10918ec869b6d8aaad3dea807042f">getDialect</a> () const</td></tr>
<tr class="memdesc:a18b10918ec869b6d8aaad3dea807042f inherit pub_methods_classmlir_1_1Attribute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dialect this attribute is registered to.  <a href="classmlir_1_1Attribute.html#a18b10918ec869b6d8aaad3dea807042f">More...</a><br /></td></tr>
<tr class="separator:a18b10918ec869b6d8aaad3dea807042f inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b41e92a4a26c3ae315ccbc0f4cfd4d7 inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a8b41e92a4a26c3ae315ccbc0f4cfd4d7">print</a> (raw_ostream &amp;os, bool elideType=false) const</td></tr>
<tr class="memdesc:a8b41e92a4a26c3ae315ccbc0f4cfd4d7 inherit pub_methods_classmlir_1_1Attribute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the attribute.  <a href="classmlir_1_1Attribute.html#a8b41e92a4a26c3ae315ccbc0f4cfd4d7">More...</a><br /></td></tr>
<tr class="separator:a8b41e92a4a26c3ae315ccbc0f4cfd4d7 inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f356ea84c0d0828dc097534a54927c inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#ab7f356ea84c0d0828dc097534a54927c">print</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AsmState.html">AsmState</a> &amp;state, bool elideType=false) const</td></tr>
<tr class="separator:ab7f356ea84c0d0828dc097534a54927c inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9440fb79f712d4405de239b31c56fd1e inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a9440fb79f712d4405de239b31c56fd1e">dump</a> () const</td></tr>
<tr class="separator:a9440fb79f712d4405de239b31c56fd1e inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5ab7efc597834daf38dc4a4ac871e7 inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a7d5ab7efc597834daf38dc4a4ac871e7">printStripped</a> (raw_ostream &amp;os) const</td></tr>
<tr class="memdesc:a7d5ab7efc597834daf38dc4a4ac871e7 inherit pub_methods_classmlir_1_1Attribute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the attribute without dialect wrapping.  <a href="classmlir_1_1Attribute.html#a7d5ab7efc597834daf38dc4a4ac871e7">More...</a><br /></td></tr>
<tr class="separator:a7d5ab7efc597834daf38dc4a4ac871e7 inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10929aa9a48fbae75455ea42be359e56 inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a10929aa9a48fbae75455ea42be359e56">printStripped</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AsmState.html">AsmState</a> &amp;state) const</td></tr>
<tr class="separator:a10929aa9a48fbae75455ea42be359e56 inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4ba0fce2d545662952fc10ed2b20b6 inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#abf4ba0fce2d545662952fc10ed2b20b6">getAsOpaquePointer</a> () const</td></tr>
<tr class="memdesc:abf4ba0fce2d545662952fc10ed2b20b6 inherit pub_methods_classmlir_1_1Attribute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an opaque pointer to the attribute.  <a href="classmlir_1_1Attribute.html#abf4ba0fce2d545662952fc10ed2b20b6">More...</a><br /></td></tr>
<tr class="separator:abf4ba0fce2d545662952fc10ed2b20b6 inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad313634512fb28db137200719c6df87b inherit pub_methods_classmlir_1_1Attribute"><td class="memTemplParams" colspan="2">template&lt;typename InterfaceT &gt; </td></tr>
<tr class="memitem:ad313634512fb28db137200719c6df87b inherit pub_methods_classmlir_1_1Attribute"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#ad313634512fb28db137200719c6df87b">hasPromiseOrImplementsInterface</a> ()</td></tr>
<tr class="memdesc:ad313634512fb28db137200719c6df87b inherit pub_methods_classmlir_1_1Attribute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>InterfaceT</code> has been promised by the dialect or implemented.  <a href="classmlir_1_1Attribute.html#ad313634512fb28db137200719c6df87b">More...</a><br /></td></tr>
<tr class="separator:ad313634512fb28db137200719c6df87b inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbff43d98bc872ba3b54230bbf8791ad inherit pub_methods_classmlir_1_1Attribute"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T &gt; class Trait&gt; </td></tr>
<tr class="memitem:abbff43d98bc872ba3b54230bbf8791ad inherit pub_methods_classmlir_1_1Attribute"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#abbff43d98bc872ba3b54230bbf8791ad">hasTrait</a> ()</td></tr>
<tr class="memdesc:abbff43d98bc872ba3b54230bbf8791ad inherit pub_methods_classmlir_1_1Attribute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the type was registered with a particular trait.  <a href="classmlir_1_1Attribute.html#abbff43d98bc872ba3b54230bbf8791ad">More...</a><br /></td></tr>
<tr class="separator:abbff43d98bc872ba3b54230bbf8791ad inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8122c728c7adfdcc7f066cca17f5fd86 inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1Attribute.html#a303062c8179f2b504b8f7215713bfbce">AbstractTy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a8122c728c7adfdcc7f066cca17f5fd86">getAbstractAttribute</a> () const</td></tr>
<tr class="memdesc:a8122c728c7adfdcc7f066cca17f5fd86 inherit pub_methods_classmlir_1_1Attribute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the abstract descriptor for this attribute.  <a href="classmlir_1_1Attribute.html#a8122c728c7adfdcc7f066cca17f5fd86">More...</a><br /></td></tr>
<tr class="separator:a8122c728c7adfdcc7f066cca17f5fd86 inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f08b9286cbbaa0bfc9a60ebb0ba7dc5 inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a8f08b9286cbbaa0bfc9a60ebb0ba7dc5">walkImmediateSubElements</a> (<a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt; walkAttrsFn, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Type.html">Type</a>)&gt; walkTypesFn) const</td></tr>
<tr class="memdesc:a8f08b9286cbbaa0bfc9a60ebb0ba7dc5 inherit pub_methods_classmlir_1_1Attribute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the immediately nested sub-attributes and sub-types.  <a href="classmlir_1_1Attribute.html#a8f08b9286cbbaa0bfc9a60ebb0ba7dc5">More...</a><br /></td></tr>
<tr class="separator:a8f08b9286cbbaa0bfc9a60ebb0ba7dc5 inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa929170a649c94a3b450b8b5d9babb4b inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#aa929170a649c94a3b450b8b5d9babb4b">replaceImmediateSubElements</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; replAttrs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; replTypes) const</td></tr>
<tr class="memdesc:aa929170a649c94a3b450b8b5d9babb4b inherit pub_methods_classmlir_1_1Attribute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the immediately nested sub-attributes and sub-types with those provided.  <a href="classmlir_1_1Attribute.html#aa929170a649c94a3b450b8b5d9babb4b">More...</a><br /></td></tr>
<tr class="separator:aa929170a649c94a3b450b8b5d9babb4b inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45925360c62234b9b99badd73ee10d8b inherit pub_methods_classmlir_1_1Attribute"><td class="memTemplParams" colspan="2">template&lt;WalkOrder Order = WalkOrder::PostOrder, typename... WalkFns&gt; </td></tr>
<tr class="memitem:a45925360c62234b9b99badd73ee10d8b inherit pub_methods_classmlir_1_1Attribute"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a45925360c62234b9b99badd73ee10d8b">walk</a> (WalkFns &amp;&amp;...walkFns)</td></tr>
<tr class="memdesc:a45925360c62234b9b99badd73ee10d8b inherit pub_methods_classmlir_1_1Attribute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk this attribute and all attibutes/types nested within using the provided walk functions.  <a href="classmlir_1_1Attribute.html#a45925360c62234b9b99badd73ee10d8b">More...</a><br /></td></tr>
<tr class="separator:a45925360c62234b9b99badd73ee10d8b inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5d3cbf2404e2d8ca86b58c2876d238 inherit pub_methods_classmlir_1_1Attribute"><td class="memTemplParams" colspan="2">template&lt;typename... ReplacementFns&gt; </td></tr>
<tr class="memitem:a8b5d3cbf2404e2d8ca86b58c2876d238 inherit pub_methods_classmlir_1_1Attribute"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a8b5d3cbf2404e2d8ca86b58c2876d238">replace</a> (ReplacementFns &amp;&amp;...replacementFns)</td></tr>
<tr class="memdesc:a8b5d3cbf2404e2d8ca86b58c2876d238 inherit pub_methods_classmlir_1_1Attribute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively replace all of the nested sub-attributes and sub-types using the provided map functions.  <a href="classmlir_1_1Attribute.html#a8b5d3cbf2404e2d8ca86b58c2876d238">More...</a><br /></td></tr>
<tr class="separator:a8b5d3cbf2404e2d8ca86b58c2876d238 inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc33b660e2ded3d0ddcb6277557c9a55 inherit pub_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html#aaa42f4a50b44cf2daab81c9b94cbc7cb">ImplType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#adc33b660e2ded3d0ddcb6277557c9a55">getImpl</a> () const</td></tr>
<tr class="memdesc:adc33b660e2ded3d0ddcb6277557c9a55 inherit pub_methods_classmlir_1_1Attribute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the internal <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> implementation.  <a href="classmlir_1_1Attribute.html#adc33b660e2ded3d0ddcb6277557c9a55">More...</a><br /></td></tr>
<tr class="separator:adc33b660e2ded3d0ddcb6277557c9a55 inherit pub_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2ece52068798c350f9b9f2faa29f2406"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a2ece52068798c350f9b9f2faa29f2406">classof</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a2ece52068798c350f9b9f2faa29f2406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for support type inquiry through isa, cast and dyn_cast.  <a href="classmlir_1_1DenseElementsAttr.html#a2ece52068798c350f9b9f2faa29f2406">More...</a><br /></td></tr>
<tr class="separator:a2ece52068798c350f9b9f2faa29f2406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e51b516164da8fa942cb0ec3c0a7f3e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a8e51b516164da8fa942cb0ec3c0a7f3e">get</a> (ShapedType type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; values)</td></tr>
<tr class="memdesc:a8e51b516164da8fa942cb0ec3c0a7f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a dense elements attribute from an array of element values.  <a href="classmlir_1_1DenseElementsAttr.html#a8e51b516164da8fa942cb0ec3c0a7f3e">More...</a><br /></td></tr>
<tr class="separator:a8e51b516164da8fa942cb0ec3c0a7f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd07741e5976d7768d65a5613e0cb36"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;std::numeric_limits&lt;T&gt;::is_integer ||                                        is_valid_cpp_fp_type&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a6fd07741e5976d7768d65a5613e0cb36"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a6fd07741e5976d7768d65a5613e0cb36">get</a> (const ShapedType &amp;type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; T &gt; values)</td></tr>
<tr class="memdesc:a6fd07741e5976d7768d65a5613e0cb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a dense integer elements attribute from an array of integer or floating-point values.  <a href="classmlir_1_1DenseElementsAttr.html#a6fd07741e5976d7768d65a5613e0cb36">More...</a><br /></td></tr>
<tr class="separator:a6fd07741e5976d7768d65a5613e0cb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8976a7140578a7553fec2afc678c13"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;std::numeric_limits&lt;T&gt;::is_integer ||                                        is_valid_cpp_fp_type&lt;T&gt;::value ||                                        detail::is_complex_t&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:aae8976a7140578a7553fec2afc678c13"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#aae8976a7140578a7553fec2afc678c13">get</a> (const ShapedType &amp;type, T value)</td></tr>
<tr class="memdesc:aae8976a7140578a7553fec2afc678c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a dense integer elements attribute from a single element.  <a href="classmlir_1_1DenseElementsAttr.html#aae8976a7140578a7553fec2afc678c13">More...</a><br /></td></tr>
<tr class="separator:aae8976a7140578a7553fec2afc678c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdb415c8b6d22cc3e12a7a515bda899"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ElementT  = typename T::value_type, typename  = std::enable_if_t&lt;detail::is_complex_t&lt;T&gt;::value &amp;&amp;                                  (std::numeric_limits&lt;ElementT&gt;::is_integer ||                                   is_valid_cpp_fp_type&lt;ElementT&gt;::value)&gt;&gt; </td></tr>
<tr class="memitem:adcdb415c8b6d22cc3e12a7a515bda899"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#adcdb415c8b6d22cc3e12a7a515bda899">get</a> (const ShapedType &amp;type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; T &gt; values)</td></tr>
<tr class="memdesc:adcdb415c8b6d22cc3e12a7a515bda899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a dense complex elements attribute from an array of complex values.  <a href="classmlir_1_1DenseElementsAttr.html#adcdb415c8b6d22cc3e12a7a515bda899">More...</a><br /></td></tr>
<tr class="separator:adcdb415c8b6d22cc3e12a7a515bda899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7ef288cc0b46b2bd383eea70e18da8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a5c7ef288cc0b46b2bd383eea70e18da8">get</a> (ShapedType type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt; values)</td></tr>
<tr class="memdesc:a5c7ef288cc0b46b2bd383eea70e18da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the above 'get' method that is specialized for boolean values.  <a href="classmlir_1_1DenseElementsAttr.html#a5c7ef288cc0b46b2bd383eea70e18da8">More...</a><br /></td></tr>
<tr class="separator:a5c7ef288cc0b46b2bd383eea70e18da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2c03de3c042aaa480b61e865c81050"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a4e2c03de3c042aaa480b61e865c81050">get</a> (ShapedType type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; values)</td></tr>
<tr class="memdesc:a4e2c03de3c042aaa480b61e865c81050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the above 'get' method that is specialized for StringRef values.  <a href="classmlir_1_1DenseElementsAttr.html#a4e2c03de3c042aaa480b61e865c81050">More...</a><br /></td></tr>
<tr class="separator:a4e2c03de3c042aaa480b61e865c81050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea3b823f2902e8c7a070b69f1c9c2c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a5ea3b823f2902e8c7a070b69f1c9c2c7">get</a> (ShapedType type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; APInt &gt; values)</td></tr>
<tr class="memdesc:a5ea3b823f2902e8c7a070b69f1c9c2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a dense integer elements attribute from an array of APInt values.  <a href="classmlir_1_1DenseElementsAttr.html#a5ea3b823f2902e8c7a070b69f1c9c2c7">More...</a><br /></td></tr>
<tr class="separator:a5ea3b823f2902e8c7a070b69f1c9c2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad635b22acf3747392a29c8d5f5fc5393"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#ad635b22acf3747392a29c8d5f5fc5393">get</a> (ShapedType type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::complex&lt; APInt &gt;&gt; values)</td></tr>
<tr class="memdesc:ad635b22acf3747392a29c8d5f5fc5393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a dense complex elements attribute from an array of APInt values.  <a href="classmlir_1_1DenseElementsAttr.html#ad635b22acf3747392a29c8d5f5fc5393">More...</a><br /></td></tr>
<tr class="separator:ad635b22acf3747392a29c8d5f5fc5393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88cee592a4002325ca21c1e3b5dd2e6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#af88cee592a4002325ca21c1e3b5dd2e6">get</a> (ShapedType type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; APFloat &gt; values)</td></tr>
<tr class="memdesc:af88cee592a4002325ca21c1e3b5dd2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a dense float elements attribute from an array of APFloat values.  <a href="classmlir_1_1DenseElementsAttr.html#af88cee592a4002325ca21c1e3b5dd2e6">More...</a><br /></td></tr>
<tr class="separator:af88cee592a4002325ca21c1e3b5dd2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b76f7287511fd56062bd9b0fc4d14f8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a3b76f7287511fd56062bd9b0fc4d14f8">get</a> (ShapedType type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::complex&lt; APFloat &gt;&gt; values)</td></tr>
<tr class="memdesc:a3b76f7287511fd56062bd9b0fc4d14f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a dense complex elements attribute from an array of APFloat values.  <a href="classmlir_1_1DenseElementsAttr.html#a3b76f7287511fd56062bd9b0fc4d14f8">More...</a><br /></td></tr>
<tr class="separator:a3b76f7287511fd56062bd9b0fc4d14f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d306b90bf720ebe6f36c0714ee9bb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74d306b90bf720ebe6f36c0714ee9bb5"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a74d306b90bf720ebe6f36c0714ee9bb5">get</a> (const ShapedType &amp;type, const std::initializer_list&lt; T &gt; &amp;list)</td></tr>
<tr class="memdesc:a74d306b90bf720ebe6f36c0714ee9bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a dense elements attribute for an initializer_list of values.  <a href="classmlir_1_1DenseElementsAttr.html#a74d306b90bf720ebe6f36c0714ee9bb5">More...</a><br /></td></tr>
<tr class="separator:a74d306b90bf720ebe6f36c0714ee9bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4e168288b6baad41d35db7a9fc6d40"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a4d4e168288b6baad41d35db7a9fc6d40">getFromRawBuffer</a> (ShapedType type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; char &gt; rawBuffer)</td></tr>
<tr class="memdesc:a4d4e168288b6baad41d35db7a9fc6d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a dense elements attribute from a raw buffer representing the data for this attribute.  <a href="classmlir_1_1DenseElementsAttr.html#a4d4e168288b6baad41d35db7a9fc6d40">More...</a><br /></td></tr>
<tr class="separator:a4d4e168288b6baad41d35db7a9fc6d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa637afa1e234e39038afa1a3668fcae6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#aa637afa1e234e39038afa1a3668fcae6">isValidRawBuffer</a> (ShapedType type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; char &gt; rawBuffer, bool &amp;detectedSplat)</td></tr>
<tr class="memdesc:aa637afa1e234e39038afa1a3668fcae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given buffer is a valid raw buffer for the given type.  <a href="classmlir_1_1DenseElementsAttr.html#aa637afa1e234e39038afa1a3668fcae6">More...</a><br /></td></tr>
<tr class="separator:aa637afa1e234e39038afa1a3668fcae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1Attribute"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1Attribute')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1Attribute.html">mlir::Attribute</a></td></tr>
<tr class="memitem:afe671f51c0b75d99179b8708688e8963 inherit pub_static_methods_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#afe671f51c0b75d99179b8708688e8963">getFromOpaquePointer</a> (const void *ptr)</td></tr>
<tr class="memdesc:afe671f51c0b75d99179b8708688e8963 inherit pub_static_methods_classmlir_1_1Attribute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an attribute from the opaque pointer representation.  <a href="classmlir_1_1Attribute.html#afe671f51c0b75d99179b8708688e8963">More...</a><br /></td></tr>
<tr class="separator:afe671f51c0b75d99179b8708688e8963 inherit pub_static_methods_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a11fbc2ca37e1bbfa30550c0becd8edd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a11fbc2ca37e1bbfa30550c0becd8edd1">raw_int_begin</a> () const</td></tr>
<tr class="memdesc:a11fbc2ca37e1bbfa30550c0becd8edd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterators to various elements that require out-of-line definition.  <a href="classmlir_1_1DenseElementsAttr.html#a11fbc2ca37e1bbfa30550c0becd8edd1">More...</a><br /></td></tr>
<tr class="separator:a11fbc2ca37e1bbfa30550c0becd8edd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8777e4250a1fefb04eb82cfcfa5c9161"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a8777e4250a1fefb04eb82cfcfa5c9161">raw_int_end</a> () const</td></tr>
<tr class="separator:a8777e4250a1fefb04eb82cfcfa5c9161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fba92271e9477c694d6e0a00077a7b"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1ComplexIntElementIterator.html">ComplexIntElementIterator</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#ad1fba92271e9477c694d6e0a00077a7b">tryGetComplexIntValues</a> () const</td></tr>
<tr class="separator:ad1fba92271e9477c694d6e0a00077a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5101ee1804164d500cdfb0d21c0bda0"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1FloatElementIterator.html">FloatElementIterator</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#aa5101ee1804164d500cdfb0d21c0bda0">tryGetFloatValues</a> () const</td></tr>
<tr class="separator:aa5101ee1804164d500cdfb0d21c0bda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815dbf5c7ef6dc673832500f988ca4ec"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1ComplexFloatElementIterator.html">ComplexFloatElementIterator</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a815dbf5c7ef6dc673832500f988ca4ec">tryGetComplexFloatValues</a> () const</td></tr>
<tr class="separator:a815dbf5c7ef6dc673832500f988ca4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57001c1ee84a0410ce8fcedcad6166a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a57001c1ee84a0410ce8fcedcad6166a0">isValidBool</a> () const</td></tr>
<tr class="memdesc:a57001c1ee84a0410ce8fcedcad6166a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the information for a C++ data type, check if this type is valid for the current attribute.  <a href="classmlir_1_1DenseElementsAttr.html#a57001c1ee84a0410ce8fcedcad6166a0">More...</a><br /></td></tr>
<tr class="separator:a57001c1ee84a0410ce8fcedcad6166a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab588f0109b838320b64235cec7b9dba2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#ab588f0109b838320b64235cec7b9dba2">isValidIntOrFloat</a> (int64_t dataEltSize, bool isInt, bool isSigned) const</td></tr>
<tr class="separator:ab588f0109b838320b64235cec7b9dba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea9a53f71dee996090b2b32b1ad1dea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a3ea9a53f71dee996090b2b32b1ad1dea">isValidComplex</a> (int64_t dataEltSize, bool isInt, bool isSigned) const</td></tr>
<tr class="separator:a3ea9a53f71dee996090b2b32b1ad1dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a1c069546715390387f03b541c530ea30"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a1c069546715390387f03b541c530ea30">getRawComplex</a> (ShapedType type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; char &gt; data, int64_t dataEltSize, bool isInt, bool isSigned)</td></tr>
<tr class="memdesc:a1c069546715390387f03b541c530ea30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the raw 'get' method that asserts that the given type is of complex type.  <a href="classmlir_1_1DenseElementsAttr.html#a1c069546715390387f03b541c530ea30">More...</a><br /></td></tr>
<tr class="separator:a1c069546715390387f03b541c530ea30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130086f989bb028f0fdbeed2cbf3723b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a130086f989bb028f0fdbeed2cbf3723b">getRawIntOrFloat</a> (ShapedType type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; char &gt; data, int64_t dataEltSize, bool isInt, bool isSigned)</td></tr>
<tr class="memdesc:a130086f989bb028f0fdbeed2cbf3723b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the raw 'get' method that asserts that the given type is of integer or floating-point type.  <a href="classmlir_1_1DenseElementsAttr.html#a130086f989bb028f0fdbeed2cbf3723b">More...</a><br /></td></tr>
<tr class="separator:a130086f989bb028f0fdbeed2cbf3723b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classmlir_1_1Attribute"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmlir_1_1Attribute')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmlir_1_1Attribute.html">mlir::Attribute</a></td></tr>
<tr class="memitem:a5131bd44c4b60c95b7aaf8266d42ca81 inherit pro_attribs_classmlir_1_1Attribute"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html#aaa42f4a50b44cf2daab81c9b94cbc7cb">ImplType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html#a5131bd44c4b60c95b7aaf8266d42ca81">impl</a> {nullptr}</td></tr>
<tr class="separator:a5131bd44c4b60c95b7aaf8266d42ca81 inherit pro_attribs_classmlir_1_1Attribute"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An attribute that represents a reference to a dense vector or tensor object. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00082">82</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a392afbd8f80c58837623b089bd0ce60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392afbd8f80c58837623b089bd0ce60b">&#9670;&nbsp;</a></span>APFloatValueTemplateCheckT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1DenseElementsAttr.html#a392afbd8f80c58837623b089bd0ce60b">mlir::DenseElementsAttr::APFloatValueTemplateCheckT</a> =  std::enable_if_t&lt;std::is_same&lt;T, APFloat&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to get the held element values as a range of APFloat. </p>
<p>The element type of this attribute must be of float type. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00571">571</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ac0fb08ec708ddf44a36c6295fa9d298f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0fb08ec708ddf44a36c6295fa9d298f">&#9670;&nbsp;</a></span>APIntValueTemplateCheckT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1DenseElementsAttr.html#ac0fb08ec708ddf44a36c6295fa9d298f">mlir::DenseElementsAttr::APIntValueTemplateCheckT</a> =  std::enable_if_t&lt;std::is_same&lt;T, APInt&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to get the held element values as a range of APInts. </p>
<p>The element type of this attribute must be of integer type. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00547">547</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a3e30c4d5f532c36520e9016b8d4ff938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e30c4d5f532c36520e9016b8d4ff938">&#9670;&nbsp;</a></span>AttributeValueTemplateCheckT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1DenseElementsAttr.html#a3e30c4d5f532c36520e9016b8d4ff938">mlir::DenseElementsAttr::AttributeValueTemplateCheckT</a> =  std::enable_if_t&lt;std::is_same&lt;T, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to get the held element values as a range of Attributes. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00494">494</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ab09276fddb726b8b77c0b33eb37c086a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09276fddb726b8b77c0b33eb37c086a">&#9670;&nbsp;</a></span>BoolValueTemplateCheckT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1DenseElementsAttr.html#ab09276fddb726b8b77c0b33eb37c086a">mlir::DenseElementsAttr::BoolValueTemplateCheckT</a> =  std::enable_if_t&lt;std::is_same&lt;T, bool&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to get the held element values as a range of bool. </p>
<p>The element type of this attribute must be of integer type of bitwidth 1. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00533">533</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a363e8739b46ab37b154d64d2bee84377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363e8739b46ab37b154d64d2bee84377">&#9670;&nbsp;</a></span>ComplexAPFloatValueTemplateCheckT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1DenseElementsAttr.html#a363e8739b46ab37b154d64d2bee84377">mlir::DenseElementsAttr::ComplexAPFloatValueTemplateCheckT</a> =  std::enable_if_t&lt;std::is_same&lt;T, std::complex&lt;APFloat&gt; &gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to get the held element values as a range of complex APFloat. </p>
<p>The element type of this attribute must be a complex of float type. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00581">581</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ac429e22c9ebcc952b5e8cfa20ff9c99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac429e22c9ebcc952b5e8cfa20ff9c99a">&#9670;&nbsp;</a></span>ComplexAPIntValueTemplateCheckT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1DenseElementsAttr.html#ac429e22c9ebcc952b5e8cfa20ff9c99a">mlir::DenseElementsAttr::ComplexAPIntValueTemplateCheckT</a> =  std::enable_if_t&lt;std::is_same&lt;T, std::complex&lt;APInt&gt; &gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to get the held element values as a range of complex APInts. </p>
<p>The element type of this attribute must be a complex of integer type. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00560">560</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a7221ce978d6cd452b2d890dd14ffb060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7221ce978d6cd452b2d890dd14ffb060">&#9670;&nbsp;</a></span>ComplexValueTemplateCheckT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ElementT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1DenseElementsAttr.html#a7221ce978d6cd452b2d890dd14ffb060">mlir::DenseElementsAttr::ComplexValueTemplateCheckT</a> =  std::enable_if_t&lt;<a class="el" href="structmlir_1_1detail_1_1is__complex__t.html">detail::is_complex_t</a>&lt;T&gt;::value &amp;&amp; (std::numeric_limits&lt;ElementT&gt;::is_integer || <a class="el" href="structmlir_1_1DenseElementsAttr_1_1is__valid__cpp__fp__type.html">is_valid_cpp_fp_type</a>&lt;ElementT&gt;::value)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to get the held element values as a range of std::complex. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00460">460</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="adddfdd4c9620200091e52aab76f83ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adddfdd4c9620200091e52aab76f83ac9">&#9670;&nbsp;</a></span>DerivedAttrValueTemplateCheckT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1DenseElementsAttr.html#adddfdd4c9620200091e52aab76f83ac9">mlir::DenseElementsAttr::DerivedAttrValueTemplateCheckT</a> =  std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T&gt;::value &amp;&amp; !std::is_same&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to get the held element values a range of T, where T is a derived attribute type. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00507">507</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a6a19b125635be753a67f5a323a5eba0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a19b125635be753a67f5a323a5eba0d">&#9670;&nbsp;</a></span>IntFloatValueTemplateCheckT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1DenseElementsAttr.html#a6a19b125635be753a67f5a323a5eba0d">mlir::DenseElementsAttr::IntFloatValueTemplateCheckT</a> =  std::enable_if_t&lt;(!std::is_same&lt;T, bool&gt;::value &amp;&amp; std::numeric_limits&lt;T&gt;::is_integer) || <a class="el" href="structmlir_1_1DenseElementsAttr_1_1is__valid__cpp__fp__type.html">is_valid_cpp_fp_type</a>&lt;T&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to get the held element values as a range of integer or floating-point values. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00442">442</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a769d16dc3360561b0c1853ff70548afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769d16dc3360561b0c1853ff70548afe">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename AttrT  = DenseElementsAttr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1DenseElementsAttr.html#a769d16dc3360561b0c1853ff70548afe">mlir::DenseElementsAttr::iterator</a> =  decltype(std::declval&lt;AttrT&gt;().template <a class="el" href="classmlir_1_1DenseElementsAttr.html#a143f2e8369898f5efe51aa6f3aa3c61d">value_begin</a>&lt;T&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The iterator for the given element type T. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00232">232</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a7b213091649867bcadbbbf8627a4652f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b213091649867bcadbbbf8627a4652f">&#9670;&nbsp;</a></span>iterator_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename AttrT  = DenseElementsAttr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1DenseElementsAttr.html#a7b213091649867bcadbbbf8627a4652f">mlir::DenseElementsAttr::iterator_range</a> =  decltype(std::declval&lt;AttrT&gt;().template <a class="el" href="classmlir_1_1DenseElementsAttr.html#a416662fc7e96dfef98c8e48682afd8fc">getValues</a>&lt;T&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The iterator range over the given element T. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00235">235</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a439feabbf1e2b2810b106246841e4904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439feabbf1e2b2810b106246841e4904">&#9670;&nbsp;</a></span>iterator_range_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">mlir::DenseElementsAttr::iterator_range_impl</a> =  <a class="el" href="classmlir_1_1detail_1_1ElementsAttrRange.html">detail::ElementsAttrRange</a>&lt;IteratorT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The iterator range over the given iterator type T. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00228">228</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a3bb6160557ef2245de767e84b265244b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb6160557ef2245de767e84b265244b">&#9670;&nbsp;</a></span>StringRefValueTemplateCheckT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1DenseElementsAttr.html#a3bb6160557ef2245de767e84b265244b">mlir::DenseElementsAttr::StringRefValueTemplateCheckT</a> =  std::enable_if_t&lt;std::is_same&lt;T, StringRef&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to get the held element values as a range of StringRef. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00479">479</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6a2655f89d5ff31b0a7282459c68a0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2655f89d5ff31b0a7282459c68a0c8">&#9670;&nbsp;</a></span>Attribute() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mlir::Attribute::Attribute</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acd48b18df35704549a7e75704fbd3895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd48b18df35704549a7e75704fbd3895">&#9670;&nbsp;</a></span>Attribute() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Attribute::Attribute</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a5d0d275732c4cfb26de25d071192a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5d0d275732c4cfb26de25d071192a9">&#9670;&nbsp;</a></span>Attribute() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Attribute::Attribute</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributes_8h_source.html#l00038">38</a> of file <a class="el" href="Attributes_8h_source.html">Attributes.h</a>.</p>

</div>
</div>
<a id="aabc6a39b8cbe129f081bcfb0b9315695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc6a39b8cbe129f081bcfb0b9315695">&#9670;&nbsp;</a></span>bitcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::bitcast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>newElType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> that has the same data as the current attribute, but has bitcast elements to 'newElType'. </p>
<p>Return a new <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> that has the same data as the current attribute, but has bitcast elements such that it is now 'newType'.</p>
<p>The new type must have the same bitwidth as the current element type.</p>
<p>The new type must have the same shape and element types of the same bitwidth as the current type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01272">1272</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="AttributeDetail_8h_source.html#l00034">mlir::detail::getDenseElementBitWidth()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01233">getRawData()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01298">getType()</a>.</p>

</div>
</div>
<a id="a2ece52068798c350f9b9f2faa29f2406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ece52068798c350f9b9f2faa29f2406">&#9670;&nbsp;</a></span>classof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DenseElementsAttr::classof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method for support type inquiry through isa, cast and dyn_cast. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00905">905</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

</div>
</div>
<a id="aa7b87a8f66feb5c5b1207fc1ca2076e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b87a8f66feb5c5b1207fc1ca2076e2">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::DenseElementsAttr::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the number of elements held by this attribute is 0. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00611">611</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00608">size()</a>.</p>

</div>
</div>
<a id="a6fd07741e5976d7768d65a5613e0cb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd07741e5976d7768d65a5613e0cb36">&#9670;&nbsp;</a></span>get() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;std::numeric_limits&lt;T&gt;::is_integer ||                                        is_valid_cpp_fp_type&lt;T&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> mlir::DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype">const ShapedType &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a dense integer elements attribute from an array of integer or floating-point values. </p>
<p>Each value is expected to be the same bitwidth of the element type of 'type'. 'type' must be a vector or tensor with static shape. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00121">121</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01167">getRawIntOrFloat()</a>.</p>

</div>
</div>
<a id="adcdb415c8b6d22cc3e12a7a515bda899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcdb415c8b6d22cc3e12a7a515bda899">&#9670;&nbsp;</a></span>get() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ElementT  = typename T::value_type, typename  = std::enable_if_t&lt;detail::is_complex_t&lt;T&gt;::value &amp;&amp;                                  (std::numeric_limits&lt;ElementT&gt;::is_integer ||                                   is_valid_cpp_fp_type&lt;ElementT&gt;::value)&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> mlir::DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype">const ShapedType &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a dense complex elements attribute from an array of complex values. </p>
<p>Each value is expected to be the same bitwidth of the element type of 'type'. 'type' must be a vector or tensor with static shape. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00145">145</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01160">getRawComplex()</a>.</p>

</div>
</div>
<a id="a74d306b90bf720ebe6f36c0714ee9bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d306b90bf720ebe6f36c0714ee9bb5">&#9670;&nbsp;</a></span>get() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> mlir::DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype">const ShapedType &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a dense elements attribute for an initializer_list of values. </p>
<p>Each value is expected to be the same bitwidth of the element type of 'type'. 'type' must be a vector or tensor with static shape. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00189">189</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00909">get()</a>.</p>

</div>
</div>
<a id="aae8976a7140578a7553fec2afc678c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8976a7140578a7553fec2afc678c13">&#9670;&nbsp;</a></span>get() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;std::numeric_limits&lt;T&gt;::is_integer ||                                        is_valid_cpp_fp_type&lt;T&gt;::value ||                                        detail::is_complex_t&lt;T&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> mlir::DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype">const ShapedType &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a dense integer elements attribute from a single element. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00133">133</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00909">get()</a>.</p>

</div>
</div>
<a id="af88cee592a4002325ca21c1e3b5dd2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88cee592a4002325ca21c1e3b5dd2e6">&#9670;&nbsp;</a></span>get() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; APFloat &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a dense float elements attribute from an array of APFloat values. </p>
<p>Each APFloat value is expected to have the same bitwidth as the element type of 'type'. 'type' must be a vector or tensor with static shape. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01048">1048</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00460">getDenseElementStorageWidth()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00599">hasSameNumElementsOrSplat()</a>.</p>

</div>
</div>
<a id="a5ea3b823f2902e8c7a070b69f1c9c2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea3b823f2902e8c7a070b69f1c9c2c7">&#9670;&nbsp;</a></span>get() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; APInt &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a dense integer elements attribute from an array of APInt values. </p>
<p>Each APInt value is expected to have the same bitwidth as the element type of 'type'. 'type' must be a vector or tensor with static shape.</p>
<p>Each APInt value is expected to have the same bitwidth as the element type of 'type'. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01027">1027</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00460">getDenseElementStorageWidth()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00599">hasSameNumElementsOrSplat()</a>.</p>

</div>
</div>
<a id="a8e51b516164da8fa942cb0ec3c0a7f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e51b516164da8fa942cb0ec3c0a7f3e">&#9670;&nbsp;</a></span>get() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a dense elements attribute from an array of element values. </p>
<p>Each element attribute value is expected to be an element of 'type'. 'type' must be a vector or tensor with static shape. If the element of <code>type</code> is non-integer/index/float it is assumed to be a string type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00909">909</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00468">mlir::detail::divideCeil()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00034">mlir::detail::getDenseElementBitWidth()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00460">getDenseElementStorageWidth()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00599">hasSameNumElementsOrSplat()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00056">mlir::Type::isInteger()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00120">mlir::Type::isIntOrIndexOrFloat()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00545">writeBits()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00913">binaryFolder()</a>, <a class="el" href="CommonFolders_8h_source.html#l00038">mlir::constFoldBinaryOpConditional()</a>, <a class="el" href="CommonFolders_8h_source.html#l00268">mlir::constFoldCastOp()</a>, <a class="el" href="CommonFolders_8h_source.html#l00197">mlir::constFoldUnaryOpConditional()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00635">convertConstantOpMmaSync()</a>, <a class="el" href="Arith_2Transforms_2ExpandOps_8cpp_source.html#l00027">createConst()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00094">createConstantAllBitsSet()</a>, <a class="el" href="Arith_2Transforms_2ExpandOps_8cpp_source.html#l00038">createFloatConst()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00107">createFPConstant()</a>, <a class="el" href="ExpandPatterns_8cpp_source.html#l00047">createIntConst()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00314">mlir::tosa::createPadConstTensor()</a>, <a class="el" href="PrintCallHelper_8cpp_source.html#l00048">mlir::LLVM::createPrintStrCall()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00270">mlir::createScalarOrSplatConstant()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00237">mlir::xegpu::createVectorWithShapeFromValues()</a>, <a class="el" href="TosaOps_8cpp_source.html#l03992">mlir::tosa::createZeroPointTensor()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00922">mlir::DenseFPElementsAttr::get()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00963">mlir::DenseIntElementsAttr::get()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00133">get()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00149">getBoolAttribute()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00076">getCompressedMaskOp()</a>, <a class="el" href="QuantUtils_8h_source.html#l00036">mlir::tosa::getConstTensorInt()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00596">getDenseAttribute()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00186">mlir::sparse_tensor::getOneAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00337">mlir::Builder::getOneAttr()</a>, <a class="el" href="ArithToSPIRV_8cpp_source.html#l00126">getScalarOrVectorConstInt()</a>, <a class="el" href="Builders_8cpp_source.html#l00319">mlir::Builder::getZeroAttr()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00586">mlirDenseElementsAttrBoolGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00540">mlirDenseElementsAttrBoolSplatGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00580">mlirDenseElementsAttrDoubleSplatGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00575">mlirDenseElementsAttrFloatSplatGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00513">mlirDenseElementsAttrGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00560">mlirDenseElementsAttrInt32SplatGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00570">mlirDenseElementsAttrInt64SplatGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00550">mlirDenseElementsAttrInt8SplatGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00535">mlirDenseElementsAttrSplatGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00668">mlirDenseElementsAttrStringGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00555">mlirDenseElementsAttrUInt32SplatGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00565">mlirDenseElementsAttrUInt64SplatGet()</a>, <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00545">mlirDenseElementsAttrUInt8SplatGet()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00848">mlir::detail::DenseArrayAttrImpl&lt; T &gt;::parse()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l01038">mlir::detail::Parser::parseSparseElementsAttr()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00324">parseUniformType()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00832">mlir::detail::DenseArrayAttrImpl&lt; T &gt;::parseWithoutBraces()</a>.</p>

</div>
</div>
<a id="a5c7ef288cc0b46b2bd383eea70e18da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7ef288cc0b46b2bd383eea70e18da8">&#9670;&nbsp;</a></span>get() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the above 'get' method that is specialized for boolean values. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00993">993</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00468">mlir::detail::divideCeil()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00599">hasSameNumElementsOrSplat()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01189">isSplat()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00468">setBit()</a>.</p>

</div>
</div>
<a id="a3b76f7287511fd56062bd9b0fc4d14f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b76f7287511fd56062bd9b0fc4d14f8">&#9670;&nbsp;</a></span>get() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::complex&lt; APFloat &gt;&gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a dense complex elements attribute from an array of APFloat values. </p>
<p>Each APFloat value is expected to have the same bitwidth as the element type of 'type'. 'type' must be a vector or tensor with static shape. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01056">1056</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00460">getDenseElementStorageWidth()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00599">hasSameNumElementsOrSplat()</a>.</p>

</div>
</div>
<a id="ad635b22acf3747392a29c8d5f5fc5393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad635b22acf3747392a29c8d5f5fc5393">&#9670;&nbsp;</a></span>get() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::complex&lt; APInt &gt;&gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a dense complex elements attribute from an array of APInt values. </p>
<p>Each APInt value is expected to have the same bitwidth as the element type of 'type'. 'type' must be a vector or tensor with static shape. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01034">1034</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00460">getDenseElementStorageWidth()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00599">hasSameNumElementsOrSplat()</a>.</p>

</div>
</div>
<a id="a4e2c03de3c042aaa480b61e865c81050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2c03de3c042aaa480b61e865c81050">&#9670;&nbsp;</a></span>get() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the above 'get' method that is specialized for StringRef values. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01018">1018</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

</div>
</div>
<a id="a7d6023ce5062e321b001911e4b946642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6023ce5062e321b001911e4b946642">&#9670;&nbsp;</a></span>getElementType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> DenseElementsAttr::getElementType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element type of this <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01302">1302</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01298">getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00913">binaryFolder()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01194">isComplexOfIntType()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00680">isValidBool()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01180">isValidComplex()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01176">isValidIntOrFloat()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01218">tryGetComplexFloatValues()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01198">tryGetComplexIntValues()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01207">tryGetFloatValues()</a>, and <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00550">tryGetValues()</a>.</p>

</div>
</div>
<a id="a4d4e168288b6baad41d35db7a9fc6d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4e168288b6baad41d35db7a9fc6d40">&#9670;&nbsp;</a></span>getFromRawBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::getFromRawBuffer </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>rawBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a dense elements attribute from a raw buffer representing the data for this attribute. </p>
<p>Users are encouraged to use one of the constructors above, which provide more safeties. However, this constructor is useful for tools which may want to interop and can follow the precise definition.</p>
<p>The format of the raw buffer is a densely packed array of values that can be bitcast to the storage format of the element type specified. Types that are not byte aligned will be:</p><ul>
<li>For bitwidth &gt; 1: Rounded up to the next byte.</li>
<li>For bitwidth = 1: Packed into 8bit bytes with bits corresponding to the linear order of the shape type from MSB to LSB, padded to on the right.</li>
</ul>
<p>Users should generally not use this methods as the expected buffer format may not be a form the user expects. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01071">1071</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00522">mlirDenseElementsAttrRawBufferGet()</a>.</p>

</div>
</div>
<a id="a45eabfa2aa1c4da62c050b8c6f923553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45eabfa2aa1c4da62c050b8c6f923553">&#9670;&nbsp;</a></span>getNumElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t DenseElementsAttr::getNumElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements held by this attribute. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01306">1306</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01298">getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleTranslation_8cpp_source.html#l00375">convertDenseElementsAttr()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00652">raw_int_end()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00608">size()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01218">tryGetComplexFloatValues()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01198">tryGetComplexIntValues()</a>, and <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00447">tryGetValues()</a>.</p>

</div>
</div>
<a id="a1c069546715390387f03b541c530ea30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c069546715390387f03b541c530ea30">&#9670;&nbsp;</a></span>getRawComplex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::getRawComplex </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dataEltSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSigned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the raw 'get' method that asserts that the given type is of complex type. </p>
<p>Defaults down the subclass implementation.</p>
<p>This method is used to verify type invariants that the templatized 'get' method cannot. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01160">1160</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00145">get()</a>.</p>

</div>
</div>
<a id="a6814d418f6b952cd05a1fec9ca35ca0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6814d418f6b952cd05a1fec9ca35ca0b">&#9670;&nbsp;</a></span>getRawData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; char &gt; DenseElementsAttr::getRawData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the raw storage data held by this attribute. </p>
<p>Users should generally not use this directly, as the internal storage format is not always in the form the user might expect. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01233">1233</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00147">mlir::Attribute::impl</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01272">bitcast()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00375">convertDenseElementsAttr()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00862">mlir::detail::DenseArrayAttrImpl&lt; T &gt;::operator ArrayRef&lt; T &gt;()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01244">reshape()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01256">resizeSplat()</a>, and <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00447">tryGetValues()</a>.</p>

</div>
</div>
<a id="a130086f989bb028f0fdbeed2cbf3723b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130086f989bb028f0fdbeed2cbf3723b">&#9670;&nbsp;</a></span>getRawIntOrFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::getRawIntOrFloat </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dataEltSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSigned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the raw 'get' method that asserts that the given type is of integer or floating-point type. </p>
<p>This method is used to verify type invariants that the templatized 'get' method cannot. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01167">1167</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00121">get()</a>.</p>

</div>
</div>
<a id="a0d3209ac8755fa5a6e73b5e9d4964790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3209ac8755fa5a6e73b5e9d4964790">&#9670;&nbsp;</a></span>getRawStringData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; DenseElementsAttr::getRawStringData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the raw StringRef data held by this attribute. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01237">1237</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00147">mlir::Attribute::impl</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00483">tryGetValues()</a>.</p>

</div>
</div>
<a id="a0177943562d955068f1f4615bcf05e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0177943562d955068f1f4615bcf05e50">&#9670;&nbsp;</a></span>getSplatValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_base_of&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T&gt;::value || std::is_same&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T&gt;::value, T&gt; mlir::DenseElementsAttr::getSplatValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the splat value for this attribute. </p>
<p>This asserts that the attribute corresponds to a splat. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00388">388</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01189">isSplat()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00913">binaryFolder()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00375">convertDenseElementsAttr()</a>, <a class="el" href="ConversionUtils_8cpp_source.html#l00201">mlir::tosa::convertFromIntAttr()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00947">isSplatOne()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00206">isSplatWriteConsistentWithMaskedRead()</a>, and <a class="el" href="ArithToArmSME_8cpp_source.html#l00031">isSplatZero()</a>.</p>

</div>
</div>
<a id="a4de73daf965a6027d7ee91144f417fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de73daf965a6027d7ee91144f417fe6">&#9670;&nbsp;</a></span>getSplatValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T&gt;::value &amp;&amp; !std::is_same&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T&gt;::value, T&gt; mlir::DenseElementsAttr::getSplatValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the splat value for derived attribute element types. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00397">397</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a94078d9d2001e2d92c2f27dac66970ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94078d9d2001e2d92c2f27dac66970ab">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ShapedType DenseElementsAttr::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the type of this ElementsAttr, guaranteed to be a vector or tensor with static shape. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01298">1298</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00147">mlir::Attribute::impl</a>.</p>

<p class="reference">Referenced by <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00913">binaryFolder()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01272">bitcast()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00375">convertDenseElementsAttr()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01302">getElementType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01306">getNumElements()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01504">mlir::DenseFPElementsAttr::mapValues()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01524">mlir::DenseIntElementsAttr::mapValues()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00619">printUniformQuantizedSubChannelType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01244">reshape()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01256">resizeSplat()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01218">tryGetComplexFloatValues()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01198">tryGetComplexIntValues()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01207">tryGetFloatValues()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00447">tryGetValues()</a>, and <a class="el" href="QuantTypes_8cpp_source.html#l00432">mlir::quant::UniformQuantizedSubChannelType::verifyInvariants()</a>.</p>

</div>
</div>
<a id="a416662fc7e96dfef98c8e48682afd8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416662fc7e96dfef98c8e48682afd8fc">&#9670;&nbsp;</a></span>getValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::DenseElementsAttr::getValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the held element values as a range of the given type. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00421">421</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TosaToLinalg_8cpp_source.html#l00082">createLinalgBodyCalculationForElementwiseOp()</a>, <a class="el" href="ConversionUtils_8cpp_source.html#l00181">mlir::tosa::getConstShapeValues()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeDetail_8h_source.html#l00303">mlir::quant::detail::UniformQuantizedSubChannelTypeStorage::KeyTy::getHashValue()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00656">ConcatSliceOptimization::matchAndRewrite()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00724">PadSliceOptimization::matchAndRewrite()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00619">printUniformQuantizedSubChannelType()</a>, and <a class="el" href="TosaOps_8cpp_source.html#l00250">mlir::tosa::printVariableOpTypeOrInitialValue()</a>.</p>

</div>
</div>
<a id="a5a415aaf672c2a9a8559335b29c31284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a415aaf672c2a9a8559335b29c31284">&#9670;&nbsp;</a></span>isSplat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DenseElementsAttr::isSplat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this attribute corresponds to a splat, i.e. </p>
<p>if all element values are the same. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01189">1189</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00147">mlir::Attribute::impl</a>.</p>

<p class="reference">Referenced by <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00913">binaryFolder()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00375">convertDenseElementsAttr()</a>, <a class="el" href="ConversionUtils_8cpp_source.html#l00201">mlir::tosa::convertFromIntAttr()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00993">get()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00388">getSplatValue()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00947">isSplatOne()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00206">isSplatWriteConsistentWithMaskedRead()</a>, <a class="el" href="ArithToArmSME_8cpp_source.html#l00031">isSplatZero()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01256">resizeSplat()</a>, and <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00447">tryGetValues()</a>.</p>

</div>
</div>
<a id="a57001c1ee84a0410ce8fcedcad6166a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57001c1ee84a0410ce8fcedcad6166a0">&#9670;&nbsp;</a></span>isValidBool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::DenseElementsAttr::isValidBool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the information for a C++ data type, check if this type is valid for the current attribute. </p>
<p>This method is used to verify specific type invariants that the templatized 'getValues' method cannot. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00680">680</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01302">getElementType()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00056">mlir::Type::isInteger()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00536">tryGetValues()</a>.</p>

</div>
</div>
<a id="a3ea9a53f71dee996090b2b32b1ad1dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea9a53f71dee996090b2b32b1ad1dea">&#9670;&nbsp;</a></span>isValidComplex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DenseElementsAttr::isValidComplex </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dataEltSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSigned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01180">1180</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01302">getElementType()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01116">isValidIntOrFloat()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00466">tryGetValues()</a>.</p>

</div>
</div>
<a id="ab588f0109b838320b64235cec7b9dba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab588f0109b838320b64235cec7b9dba2">&#9670;&nbsp;</a></span>isValidIntOrFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DenseElementsAttr::isValidIntOrFloat </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dataEltSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSigned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01176">1176</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01302">getElementType()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01116">isValidIntOrFloat()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00447">tryGetValues()</a>.</p>

</div>
</div>
<a id="aa637afa1e234e39038afa1a3668fcae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa637afa1e234e39038afa1a3668fcae6">&#9670;&nbsp;</a></span>isValidRawBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DenseElementsAttr::isValidRawBuffer </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>rawBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>detectedSplat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given buffer is a valid raw buffer for the given type. </p>
<p><code>detectedSplat</code> is set if the buffer is valid and represents a splat buffer. The definition may be expanded over time, but currently, a splat buffer is detected if:</p><ul>
<li>For &gt;1bit: The buffer consists of a single element.</li>
<li>For 1bit: The buffer consists of a single byte with value 0 or 255.</li>
</ul>
<p>User code should be prepared for additional, conformant patterns to be identified as splats in the future. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01076">1076</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00460">getDenseElementStorageWidth()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CAPI_2IR_2BuiltinAttributes_8cpp_source.html#l00522">mlirDenseElementsAttrRawBufferGet()</a>.</p>

</div>
</div>
<a id="a1f171c2c466569cb71f70004846ec478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f171c2c466569cb71f70004846ec478">&#9670;&nbsp;</a></span>mapValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::mapValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>newElementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; APInt(const APFloat &amp;)&gt;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a new <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> by mapping each float value to a new underlying APInt. </p>
<p>the new values can represent either an integer or float. This underlying type must be an <a class="el" href="classmlir_1_1DenseFPElementsAttr.html" title="An attribute that represents a reference to a dense float vector or tensor object.">DenseFPElementsAttr</a>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01292">1292</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01286">mapValues()</a>.</p>

</div>
</div>
<a id="a71ba5d17627aea7a53baa138bb63d1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ba5d17627aea7a53baa138bb63d1c9">&#9670;&nbsp;</a></span>mapValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::mapValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>newElementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; APInt(const APInt &amp;)&gt;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a new <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> by mapping each int value to a new underlying APInt. </p>
<p>The new values can represent either an integer or float. This underlying type must be an <a class="el" href="classmlir_1_1DenseIntElementsAttr.html" title="An attribute that represents a reference to a dense integer vector or tensor object.">DenseIntElementsAttr</a>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01286">1286</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01286">mapValues()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01286">mapValues()</a>.</p>

</div>
</div>
<a id="ada699912638115ac33ef75819290d427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada699912638115ac33ef75819290d427">&#9670;&nbsp;</a></span>operator ElementsAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::DenseElementsAttr::operator ElementsAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow implicit conversion to ElementsAttr. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00087">87</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a3b0f00f7c901434c22e8e64e1a5b2eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0f00f7c901434c22e8e64e1a5b2eda">&#9670;&nbsp;</a></span>operator TypedAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::DenseElementsAttr::operator TypedAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow implicit conversion to TypedAttr. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00089">89</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a11fbc2ca37e1bbfa30550c0becd8edd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fbc2ca37e1bbfa30550c0becd8edd1">&#9670;&nbsp;</a></span>raw_int_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a> mlir::DenseElementsAttr::raw_int_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterators to various elements that require out-of-line definition. </p>
<p>These are hidden from the user to encourage consistent use of the getValues/value_begin/value_end API. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00649">649</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01207">tryGetFloatValues()</a>, and <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00550">tryGetValues()</a>.</p>

</div>
</div>
<a id="a8777e4250a1fefb04eb82cfcfa5c9161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8777e4250a1fefb04eb82cfcfa5c9161">&#9670;&nbsp;</a></span>raw_int_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a> mlir::DenseElementsAttr::raw_int_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00652">652</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01306">getNumElements()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01207">tryGetFloatValues()</a>, and <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00550">tryGetValues()</a>.</p>

</div>
</div>
<a id="ac09e89266a795b6620886950bf0c6494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09e89266a795b6620886950bf0c6494">&#9670;&nbsp;</a></span>reshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::reshape </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>newType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> that has the same data as the current attribute, but has been reshaped to 'newType'. </p>
<p>The new type must have the same total number of elements as well as element type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01244">1244</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01233">getRawData()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01298">getType()</a>.</p>

</div>
</div>
<a id="a41bd90f89d7c1fc4adb4b28c699ae2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bd90f89d7c1fc4adb4b28c699ae2b3">&#9670;&nbsp;</a></span>resizeSplat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::resizeSplat </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>newType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new <a class="el" href="classmlir_1_1DenseElementsAttr.html" title="An attribute that represents a reference to a dense vector or tensor object.">DenseElementsAttr</a> that has the same data as the current attribute, but with a different shape for a splat type. </p>
<p>The new type must have the same element type. </p>

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01256">1256</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01233">getRawData()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01298">getType()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01189">isSplat()</a>.</p>

</div>
</div>
<a id="a4e42b360accbd284581b15d695e2508f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e42b360accbd284581b15d695e2508f">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::DenseElementsAttr::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements held by this attribute. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00608">608</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01306">getNumElements()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00041">checkMatchingPadConstAndZp()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00611">empty()</a>, <a class="el" href="ConversionUtils_8cpp_source.html#l00181">mlir::tosa::getConstShapeValues()</a>, and <a class="el" href="QuantTypes_8cpp_source.html#l00432">mlir::quant::UniformQuantizedSubChannelType::verifyInvariants()</a>.</p>

</div>
</div>
<a id="a28da9d46faffde8946bd8fe310c78f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28da9d46faffde8946bd8fe310c78f20">&#9670;&nbsp;</a></span>try_value_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::DenseElementsAttr::try_value_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to get an iterator of the given type to the start of the held element values. </p>
<p>Return failure if the type cannot be iterated. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00404">404</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a5e14aee1b18d33af1ec76716254f4f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e14aee1b18d33af1ec76716254f4f2c">&#9670;&nbsp;</a></span>try_value_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::DenseElementsAttr::try_value_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to get an iterator of the given type to the end of the held element values. </p>
<p>Return failure if the type cannot be iterated. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00413">413</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="a815dbf5c7ef6dc673832500f988ca4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815dbf5c7ef6dc673832500f988ca4ec">&#9670;&nbsp;</a></span>tryGetComplexFloatValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DenseElementsAttr::tryGetComplexFloatValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01218">1218</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01302">getElementType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01306">getNumElements()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01298">getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00585">tryGetValues()</a>.</p>

</div>
</div>
<a id="ad1fba92271e9477c694d6e0a00077a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1fba92271e9477c694d6e0a00077a7b">&#9670;&nbsp;</a></span>tryGetComplexIntValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DenseElementsAttr::tryGetComplexIntValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01198">1198</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01302">getElementType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01306">getNumElements()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01298">getType()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01194">isComplexOfIntType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00564">tryGetValues()</a>.</p>

</div>
</div>
<a id="aa5101ee1804164d500cdfb0d21c0bda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5101ee1804164d500cdfb0d21c0bda0">&#9670;&nbsp;</a></span>tryGetFloatValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DenseElementsAttr::tryGetFloatValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01207">1207</a> of file <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01302">getElementType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01298">getType()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00649">raw_int_begin()</a>, and <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00652">raw_int_end()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00574">tryGetValues()</a>.</p>

</div>
</div>
<a id="adda44a8c5503c3f58137c1526f6e68e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda44a8c5503c3f58137c1526f6e68e4">&#9670;&nbsp;</a></span>tryGetValues() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = IntFloatValueTemplateCheckT&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;<a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt;<a class="el" href="classmlir_1_1DenseElementsAttr_1_1ElementIterator.html">ElementIterator</a>&lt;T&gt; &gt; &gt; mlir::DenseElementsAttr::tryGetValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00447">447</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01306">getNumElements()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01233">getRawData()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01298">getType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01189">isSplat()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01176">isValidIntOrFloat()</a>.</p>

</div>
</div>
<a id="a6a1a0ac18af8b159406efda8285bf755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1a0ac18af8b159406efda8285bf755">&#9670;&nbsp;</a></span>tryGetValues() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ElementT  = typename T::value_type, typename  = ComplexValueTemplateCheckT&lt;T, ElementT&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;<a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt;<a class="el" href="classmlir_1_1DenseElementsAttr_1_1ElementIterator.html">ElementIterator</a>&lt;T&gt; &gt; &gt; mlir::DenseElementsAttr::tryGetValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00466">466</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01306">getNumElements()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01233">getRawData()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01298">getType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01189">isSplat()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01180">isValidComplex()</a>.</p>

</div>
</div>
<a id="ad07d7e5e52e2a121e2f96ac9421aa220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07d7e5e52e2a121e2f96ac9421aa220">&#9670;&nbsp;</a></span>tryGetValues() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = StringRefValueTemplateCheckT&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;<a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt;<a class="el" href="classmlir_1_1DenseElementsAttr_1_1ElementIterator.html">ElementIterator</a>&lt;StringRef&gt; &gt; &gt; mlir::DenseElementsAttr::tryGetValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00483">483</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01306">getNumElements()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01237">getRawStringData()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01298">getType()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01189">isSplat()</a>.</p>

</div>
</div>
<a id="aa6ec191520cd7d3a255f560ce41974e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ec191520cd7d3a255f560ce41974e6">&#9670;&nbsp;</a></span>tryGetValues() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = AttributeValueTemplateCheckT&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;<a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt;<a class="el" href="classmlir_1_1DenseElementsAttr_1_1AttributeElementIterator.html">AttributeElementIterator</a>&gt; &gt; mlir::DenseElementsAttr::tryGetValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00498">498</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01306">getNumElements()</a>, and <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01298">getType()</a>.</p>

</div>
</div>
<a id="a687b8e34e3383003918550b11ff523c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687b8e34e3383003918550b11ff523c3">&#9670;&nbsp;</a></span>tryGetValues() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = DerivedAttrValueTemplateCheckT&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;<a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt;<a class="el" href="structmlir_1_1DenseElementsAttr_1_1DerivedAttributeElementIterator.html">DerivedAttributeElementIterator</a>&lt;T&gt; &gt; &gt; mlir::DenseElementsAttr::tryGetValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00523">523</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01298">getType()</a>.</p>

</div>
</div>
<a id="a3c551043cccc1197412fa3a962f4bd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c551043cccc1197412fa3a962f4bd45">&#9670;&nbsp;</a></span>tryGetValues() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = BoolValueTemplateCheckT&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;<a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt;<a class="el" href="classmlir_1_1DenseElementsAttr_1_1BoolElementIterator.html">BoolElementIterator</a>&gt; &gt; mlir::DenseElementsAttr::tryGetValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00536">536</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01306">getNumElements()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01298">getType()</a>, and <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00680">isValidBool()</a>.</p>

</div>
</div>
<a id="aa93b8f26471aaa9a3e00880da6c04f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93b8f26471aaa9a3e00880da6c04f4d">&#9670;&nbsp;</a></span>tryGetValues() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = APIntValueTemplateCheckT&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;<a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt;<a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a>&gt; &gt; mlir::DenseElementsAttr::tryGetValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00550">550</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01302">getElementType()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01298">getType()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00649">raw_int_begin()</a>, and <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00652">raw_int_end()</a>.</p>

</div>
</div>
<a id="a539cb7678d5c0578157ed90e7ab80198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539cb7678d5c0578157ed90e7ab80198">&#9670;&nbsp;</a></span>tryGetValues() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = ComplexAPIntValueTemplateCheckT&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;<a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt;<a class="el" href="classmlir_1_1DenseElementsAttr_1_1ComplexIntElementIterator.html">ComplexIntElementIterator</a>&gt; &gt; mlir::DenseElementsAttr::tryGetValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00564">564</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01198">tryGetComplexIntValues()</a>.</p>

</div>
</div>
<a id="a705318307107f7ef2534d51257234804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705318307107f7ef2534d51257234804">&#9670;&nbsp;</a></span>tryGetValues() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = APFloatValueTemplateCheckT&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;<a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt;<a class="el" href="classmlir_1_1DenseElementsAttr_1_1FloatElementIterator.html">FloatElementIterator</a>&gt; &gt; mlir::DenseElementsAttr::tryGetValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00574">574</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01207">tryGetFloatValues()</a>.</p>

</div>
</div>
<a id="a411f01a35df7e65a6da7ced4d8829dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411f01a35df7e65a6da7ced4d8829dee">&#9670;&nbsp;</a></span>tryGetValues() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = ComplexAPFloatValueTemplateCheckT&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt;<a class="el" href="classmlir_1_1DenseElementsAttr.html#a439feabbf1e2b2810b106246841e4904">iterator_range_impl</a>&lt;<a class="el" href="classmlir_1_1DenseElementsAttr_1_1ComplexFloatElementIterator.html">ComplexFloatElementIterator</a>&gt; &gt; mlir::DenseElementsAttr::tryGetValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00585">585</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01218">tryGetComplexFloatValues()</a>.</p>

</div>
</div>
<a id="a143f2e8369898f5efe51aa6f3aa3c61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143f2e8369898f5efe51aa6f3aa3c61d">&#9670;&nbsp;</a></span>value_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::DenseElementsAttr::value_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator of the given type to the start of the held element values. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00429">429</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<a id="ad89e55019ccd184eb8ad2fa764feb0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89e55019ccd184eb8ad2fa764feb0cc">&#9670;&nbsp;</a></span>value_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::DenseElementsAttr::value_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator of the given type to the end of the held element values. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00435">435</a> of file <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/IR/<a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html">BuiltinAttributes.h</a></li>
<li>lib/IR/<a class="el" href="IR_2BuiltinAttributes_8cpp_source.html">BuiltinAttributes.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:29 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
