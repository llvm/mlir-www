<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::affine::AffineDmaStartOp Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1affine.html">affine</a></li><li class="navelem"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html">AffineDmaStartOp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmlir_1_1affine_1_1AffineDmaStartOp-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::affine::AffineDmaStartOp Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html" title="AffineDmaStartOp starts a non-blocking DMA operation that transfers data from a source memref to a de...">AffineDmaStartOp</a> starts a non-blocking DMA operation that transfers data from a source memref to a destination memref.  
 <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mlir::affine::AffineDmaStartOp:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classmlir_1_1affine_1_1AffineDmaStartOp__inherit__graph.svg" width="2487" height="263"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6cde3d6b340c303a5e08b8b11e709c7e"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a6cde3d6b340c303a5e08b8b11e709c7e">getSrcMemRefOperandIndex</a> ()</td></tr>
<tr class="memdesc:a6cde3d6b340c303a5e08b8b11e709c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the operand index of the source memref.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a6cde3d6b340c303a5e08b8b11e709c7e">More...</a><br /></td></tr>
<tr class="separator:a6cde3d6b340c303a5e08b8b11e709c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae538ff0513111a50865f0d16f67abdbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#ae538ff0513111a50865f0d16f67abdbe">getSrcMemRef</a> ()</td></tr>
<tr class="memdesc:ae538ff0513111a50865f0d16f67abdbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the source MemRefType for this DMA operation.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#ae538ff0513111a50865f0d16f67abdbe">More...</a><br /></td></tr>
<tr class="separator:ae538ff0513111a50865f0d16f67abdbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9fc1f32c984857deb613e4ee6fb407"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#abc9fc1f32c984857deb613e4ee6fb407">getSrcMemRefMutable</a> ()</td></tr>
<tr class="separator:abc9fc1f32c984857deb613e4ee6fb407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85270f869e3053952dc85eae6d36281"><td class="memItemLeft" align="right" valign="top">MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#aa85270f869e3053952dc85eae6d36281">getSrcMemRefType</a> ()</td></tr>
<tr class="separator:aa85270f869e3053952dc85eae6d36281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30727f03a0ffac2321ce847d6ac596f7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a30727f03a0ffac2321ce847d6ac596f7">getSrcMemRefRank</a> ()</td></tr>
<tr class="memdesc:a30727f03a0ffac2321ce847d6ac596f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank (number of indices) of the source MemRefType.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a30727f03a0ffac2321ce847d6ac596f7">More...</a><br /></td></tr>
<tr class="separator:a30727f03a0ffac2321ce847d6ac596f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99daa6c36f6be1fa8681dee1798f230"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#ab99daa6c36f6be1fa8681dee1798f230">getSrcMap</a> ()</td></tr>
<tr class="memdesc:ab99daa6c36f6be1fa8681dee1798f230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the affine map used to access the source memref.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#ab99daa6c36f6be1fa8681dee1798f230">More...</a><br /></td></tr>
<tr class="separator:ab99daa6c36f6be1fa8681dee1798f230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be21265ff48e92ba3ff8163756812d3"><td class="memItemLeft" align="right" valign="top">AffineMapAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a3be21265ff48e92ba3ff8163756812d3">getSrcMapAttr</a> ()</td></tr>
<tr class="separator:a3be21265ff48e92ba3ff8163756812d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314d893f11826746c945abd69aefc031"><td class="memItemLeft" align="right" valign="top">operand_range&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a314d893f11826746c945abd69aefc031">getSrcIndices</a> ()</td></tr>
<tr class="memdesc:a314d893f11826746c945abd69aefc031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the source memref affine map indices for this DMA operation.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a314d893f11826746c945abd69aefc031">More...</a><br /></td></tr>
<tr class="separator:a314d893f11826746c945abd69aefc031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d6fdcfb7f415fcc5d78199a78fed7c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a29d6fdcfb7f415fcc5d78199a78fed7c">getSrcMemorySpace</a> ()</td></tr>
<tr class="memdesc:a29d6fdcfb7f415fcc5d78199a78fed7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory space of the source memref.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a29d6fdcfb7f415fcc5d78199a78fed7c">More...</a><br /></td></tr>
<tr class="separator:a29d6fdcfb7f415fcc5d78199a78fed7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad518330477f5cbedc4bb02cf50f9fe21"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#ad518330477f5cbedc4bb02cf50f9fe21">getDstMemRefOperandIndex</a> ()</td></tr>
<tr class="memdesc:ad518330477f5cbedc4bb02cf50f9fe21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the operand index of the destination memref.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#ad518330477f5cbedc4bb02cf50f9fe21">More...</a><br /></td></tr>
<tr class="separator:ad518330477f5cbedc4bb02cf50f9fe21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c27685ba72f2c73c09cd1fc213ad83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a55c27685ba72f2c73c09cd1fc213ad83">getDstMemRef</a> ()</td></tr>
<tr class="memdesc:a55c27685ba72f2c73c09cd1fc213ad83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the destination MemRefType for this DMA operation.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a55c27685ba72f2c73c09cd1fc213ad83">More...</a><br /></td></tr>
<tr class="separator:a55c27685ba72f2c73c09cd1fc213ad83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbec6c0f609cb86d8beff0a5e848428a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#afbec6c0f609cb86d8beff0a5e848428a">getDstMemRefMutable</a> ()</td></tr>
<tr class="separator:afbec6c0f609cb86d8beff0a5e848428a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0321f3f90d5949d77da0a30af3e51e"><td class="memItemLeft" align="right" valign="top">MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#aef0321f3f90d5949d77da0a30af3e51e">getDstMemRefType</a> ()</td></tr>
<tr class="separator:aef0321f3f90d5949d77da0a30af3e51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0e03a46741fd1b491e94a27e94a683"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a9d0e03a46741fd1b491e94a27e94a683">getDstMemRefRank</a> ()</td></tr>
<tr class="memdesc:a9d0e03a46741fd1b491e94a27e94a683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank (number of indices) of the destination MemRefType.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a9d0e03a46741fd1b491e94a27e94a683">More...</a><br /></td></tr>
<tr class="separator:a9d0e03a46741fd1b491e94a27e94a683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b4444174eb9d79dc200e2976b9c1b0"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a66b4444174eb9d79dc200e2976b9c1b0">getDstMemorySpace</a> ()</td></tr>
<tr class="memdesc:a66b4444174eb9d79dc200e2976b9c1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory space of the source memref.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a66b4444174eb9d79dc200e2976b9c1b0">More...</a><br /></td></tr>
<tr class="separator:a66b4444174eb9d79dc200e2976b9c1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3576dd59ab05b1547841d2524a8c1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a4a3576dd59ab05b1547841d2524a8c1e">getDstMap</a> ()</td></tr>
<tr class="memdesc:a4a3576dd59ab05b1547841d2524a8c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the affine map used to access the destination memref.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a4a3576dd59ab05b1547841d2524a8c1e">More...</a><br /></td></tr>
<tr class="separator:a4a3576dd59ab05b1547841d2524a8c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ef4d3b337fbd143d174093b2aa96f0"><td class="memItemLeft" align="right" valign="top">AffineMapAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a62ef4d3b337fbd143d174093b2aa96f0">getDstMapAttr</a> ()</td></tr>
<tr class="separator:a62ef4d3b337fbd143d174093b2aa96f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1dedffa0cef4bc3b88d8171d42f30a"><td class="memItemLeft" align="right" valign="top">operand_range&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a1f1dedffa0cef4bc3b88d8171d42f30a">getDstIndices</a> ()</td></tr>
<tr class="memdesc:a1f1dedffa0cef4bc3b88d8171d42f30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the destination memref indices for this DMA operation.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a1f1dedffa0cef4bc3b88d8171d42f30a">More...</a><br /></td></tr>
<tr class="separator:a1f1dedffa0cef4bc3b88d8171d42f30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739272ea8d27f17c08aca9595cb0c9a4"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a739272ea8d27f17c08aca9595cb0c9a4">getTagMemRefOperandIndex</a> ()</td></tr>
<tr class="memdesc:a739272ea8d27f17c08aca9595cb0c9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the operand index of the tag memref.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a739272ea8d27f17c08aca9595cb0c9a4">More...</a><br /></td></tr>
<tr class="separator:a739272ea8d27f17c08aca9595cb0c9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b9ff2451de31dbe10bbc380bcb88d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a01b9ff2451de31dbe10bbc380bcb88d7">getTagMemRef</a> ()</td></tr>
<tr class="memdesc:a01b9ff2451de31dbe10bbc380bcb88d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Tag MemRef for this DMA operation.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a01b9ff2451de31dbe10bbc380bcb88d7">More...</a><br /></td></tr>
<tr class="separator:a01b9ff2451de31dbe10bbc380bcb88d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb30131d4c6a45d7dd5bbebe91e51b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#abbb30131d4c6a45d7dd5bbebe91e51b2">getTagMemRefMutable</a> ()</td></tr>
<tr class="separator:abbb30131d4c6a45d7dd5bbebe91e51b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6155a4d70419c964029508747fb2e1"><td class="memItemLeft" align="right" valign="top">MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#aad6155a4d70419c964029508747fb2e1">getTagMemRefType</a> ()</td></tr>
<tr class="separator:aad6155a4d70419c964029508747fb2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b0d327dd9591680e2d9ae4484221a6"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a16b0d327dd9591680e2d9ae4484221a6">getTagMemRefRank</a> ()</td></tr>
<tr class="memdesc:a16b0d327dd9591680e2d9ae4484221a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank (number of indices) of the tag MemRefType.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a16b0d327dd9591680e2d9ae4484221a6">More...</a><br /></td></tr>
<tr class="separator:a16b0d327dd9591680e2d9ae4484221a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb26efcda7503fd685d4821dce36afe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#acb26efcda7503fd685d4821dce36afe4">getTagMap</a> ()</td></tr>
<tr class="memdesc:acb26efcda7503fd685d4821dce36afe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the affine map used to access the tag memref.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#acb26efcda7503fd685d4821dce36afe4">More...</a><br /></td></tr>
<tr class="separator:acb26efcda7503fd685d4821dce36afe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d302e9a31e509038dcc559f5a96e5f2"><td class="memItemLeft" align="right" valign="top">AffineMapAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a2d302e9a31e509038dcc559f5a96e5f2">getTagMapAttr</a> ()</td></tr>
<tr class="separator:a2d302e9a31e509038dcc559f5a96e5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6891b2d37503d0191e6322bab3ac33"><td class="memItemLeft" align="right" valign="top">operand_range&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#aec6891b2d37503d0191e6322bab3ac33">getTagIndices</a> ()</td></tr>
<tr class="memdesc:aec6891b2d37503d0191e6322bab3ac33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tag memref indices for this DMA operation.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#aec6891b2d37503d0191e6322bab3ac33">More...</a><br /></td></tr>
<tr class="separator:aec6891b2d37503d0191e6322bab3ac33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1208ebca4d8fac46260f469ab867ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#abb1208ebca4d8fac46260f469ab867ef">getNumElements</a> ()</td></tr>
<tr class="memdesc:abb1208ebca4d8fac46260f469ab867ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements being transferred by this DMA operation.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#abb1208ebca4d8fac46260f469ab867ef">More...</a><br /></td></tr>
<tr class="separator:abb1208ebca4d8fac46260f469ab867ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2237a77be8ae948ecbf9fb48b752321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#ae2237a77be8ae948ecbf9fb48b752321">getAffineMapAttrForMemRef</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> memref)</td></tr>
<tr class="memdesc:ae2237a77be8ae948ecbf9fb48b752321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impelements the AffineMapAccessInterface.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#ae2237a77be8ae948ecbf9fb48b752321">More...</a><br /></td></tr>
<tr class="separator:ae2237a77be8ae948ecbf9fb48b752321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1da5351dac17136aec768e3825e422"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a0a1da5351dac17136aec768e3825e422">isDestMemorySpaceFaster</a> ()</td></tr>
<tr class="memdesc:a0a1da5351dac17136aec768e3825e422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is a DMA from a faster memory space to a slower one.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a0a1da5351dac17136aec768e3825e422">More...</a><br /></td></tr>
<tr class="separator:a0a1da5351dac17136aec768e3825e422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cb5491e6651433a3e1af5dca532a41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a07cb5491e6651433a3e1af5dca532a41">isSrcMemorySpaceFaster</a> ()</td></tr>
<tr class="memdesc:a07cb5491e6651433a3e1af5dca532a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is a DMA from a slower memory space to a faster one.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a07cb5491e6651433a3e1af5dca532a41">More...</a><br /></td></tr>
<tr class="separator:a07cb5491e6651433a3e1af5dca532a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153d5d57f4b3172a2f590378bea956e5"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a153d5d57f4b3172a2f590378bea956e5">getFasterMemPos</a> ()</td></tr>
<tr class="memdesc:a153d5d57f4b3172a2f590378bea956e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a DMA start operation, returns the operand position of either the source or destination memref depending on the one that is at the higher level of the memory hierarchy.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a153d5d57f4b3172a2f590378bea956e5">More...</a><br /></td></tr>
<tr class="separator:a153d5d57f4b3172a2f590378bea956e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d836160aa1d4eb3c26edee4fe75040"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a09d836160aa1d4eb3c26edee4fe75040">getEffects</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1SideEffects_1_1EffectInstance.html">SideEffects::EffectInstance</a>&lt; <a class="el" href="structmlir_1_1MemoryEffects_1_1Effect.html">MemoryEffects::Effect</a> &gt;&gt; &amp;effects)</td></tr>
<tr class="separator:a09d836160aa1d4eb3c26edee4fe75040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a378a1f108aa52ebda32f5df80c4e3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a4a378a1f108aa52ebda32f5df80c4e3e">print</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p)</td></tr>
<tr class="separator:a4a378a1f108aa52ebda32f5df80c4e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782e830a8d8657b8df21c5a42491e247"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a782e830a8d8657b8df21c5a42491e247">verifyInvariantsImpl</a> ()</td></tr>
<tr class="separator:a782e830a8d8657b8df21c5a42491e247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0547127e5437bd1bbf68943f447be4c"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#aa0547127e5437bd1bbf68943f447be4c">verifyInvariants</a> ()</td></tr>
<tr class="separator:aa0547127e5437bd1bbf68943f447be4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0550bb3a330b3f291f20deade5b58d1"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#af0550bb3a330b3f291f20deade5b58d1">fold</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; cstOperands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;results)</td></tr>
<tr class="separator:af0550bb3a330b3f291f20deade5b58d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9d1b60dd4ffe76c6aae25fe9524700"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a3d9d1b60dd4ffe76c6aae25fe9524700">isStrided</a> ()</td></tr>
<tr class="memdesc:a3d9d1b60dd4ffe76c6aae25fe9524700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this DMA operation is strided, returns false otherwise.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a3d9d1b60dd4ffe76c6aae25fe9524700">More...</a><br /></td></tr>
<tr class="separator:a3d9d1b60dd4ffe76c6aae25fe9524700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb451f83a12780d323f7610baaa52c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#acfb451f83a12780d323f7610baaa52c2">getStride</a> ()</td></tr>
<tr class="memdesc:acfb451f83a12780d323f7610baaa52c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stride value for this DMA operation.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#acfb451f83a12780d323f7610baaa52c2">More...</a><br /></td></tr>
<tr class="separator:acfb451f83a12780d323f7610baaa52c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a5a5d36d59921b38eeced52fd03636"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a22a5a5d36d59921b38eeced52fd03636">getNumElementsPerStride</a> ()</td></tr>
<tr class="memdesc:a22a5a5d36d59921b38eeced52fd03636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements to transfer per stride for this DMA op.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a22a5a5d36d59921b38eeced52fd03636">More...</a><br /></td></tr>
<tr class="separator:a22a5a5d36d59921b38eeced52fd03636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9f320696122f31b6b22509d137d33d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#abe9f320696122f31b6b22509d137d33d">Op</a> ()</td></tr>
<tr class="memdesc:abe9f320696122f31b6b22509d137d33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a public constructor. Any op can be initialized to null.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#abe9f320696122f31b6b22509d137d33d">More...</a><br /></td></tr>
<tr class="separator:abe9f320696122f31b6b22509d137d33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b3a86209028ced4a8405877fb51b5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a25b3a86209028ced4a8405877fb51b5b">Op</a> (std::nullptr_t)</td></tr>
<tr class="separator:a25b3a86209028ced4a8405877fb51b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5905d939c92414ac6cce2c7d54f8f05e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a5905d939c92414ac6cce2c7d54f8f05e">Op</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *state)</td></tr>
<tr class="memdesc:a5905d939c92414ac6cce2c7d54f8f05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a public constructor to enable access via the llvm::cast family of methods.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a5905d939c92414ac6cce2c7d54f8f05e">More...</a><br /></td></tr>
<tr class="separator:a5905d939c92414ac6cce2c7d54f8f05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1Op"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1Op')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1Op.html">mlir::Op&lt; AffineDmaStartOp, OpTrait::MemRefsNormalizable, OpTrait::VariadicOperands, OpTrait::ZeroResults, OpTrait::OpInvariants, AffineMapAccessInterface::Trait, MemoryEffectOpInterface::Trait &gt;</a></td></tr>
<tr class="memitem:a78d7e2ead4d30cbc9c32d8ecfa1d1fbb inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">AffineDmaStartOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a78d7e2ead4d30cbc9c32d8ecfa1d1fbb">clone</a> ()</td></tr>
<tr class="memdesc:a78d7e2ead4d30cbc9c32d8ecfa1d1fbb inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a deep copy of this operation.  <a href="classmlir_1_1Op.html#a78d7e2ead4d30cbc9c32d8ecfa1d1fbb">More...</a><br /></td></tr>
<tr class="separator:a78d7e2ead4d30cbc9c32d8ecfa1d1fbb inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcbe19488b3c38705a819fb09e0be5d inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">AffineDmaStartOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#aebcbe19488b3c38705a819fb09e0be5d">cloneWithoutRegions</a> ()</td></tr>
<tr class="memdesc:aebcbe19488b3c38705a819fb09e0be5d inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a partial copy of this operation without traversing into attached regions.  <a href="classmlir_1_1Op.html#aebcbe19488b3c38705a819fb09e0be5d">More...</a><br /></td></tr>
<tr class="separator:aebcbe19488b3c38705a819fb09e0be5d inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9f320696122f31b6b22509d137d33d inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#abe9f320696122f31b6b22509d137d33d">Op</a> ()</td></tr>
<tr class="memdesc:abe9f320696122f31b6b22509d137d33d inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a public constructor. Any op can be initialized to null.  <a href="classmlir_1_1Op.html#abe9f320696122f31b6b22509d137d33d">More...</a><br /></td></tr>
<tr class="separator:abe9f320696122f31b6b22509d137d33d inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b3a86209028ced4a8405877fb51b5b inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a25b3a86209028ced4a8405877fb51b5b">Op</a> (std::nullptr_t)</td></tr>
<tr class="separator:a25b3a86209028ced4a8405877fb51b5b inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5905d939c92414ac6cce2c7d54f8f05e inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a5905d939c92414ac6cce2c7d54f8f05e">Op</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *state)</td></tr>
<tr class="memdesc:a5905d939c92414ac6cce2c7d54f8f05e inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a public constructor to enable access via the llvm::cast family of methods.  <a href="classmlir_1_1Op.html#a5905d939c92414ac6cce2c7d54f8f05e">More...</a><br /></td></tr>
<tr class="separator:a5905d939c92414ac6cce2c7d54f8f05e inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab748974126586683a89d2355aeccc2f9 inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#ab748974126586683a89d2355aeccc2f9">getAsOpaquePointer</a> () const</td></tr>
<tr class="memdesc:ab748974126586683a89d2355aeccc2f9 inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for supporting PointerLikeTypeTraits.  <a href="classmlir_1_1Op.html#ab748974126586683a89d2355aeccc2f9">More...</a><br /></td></tr>
<tr class="separator:ab748974126586683a89d2355aeccc2f9 inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc93f31894a0fa90004999ceea8dbe36 inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Op.html#aeb22cbbff9dc8dab72c638ea384ecd2a">InferredProperties</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#abc93f31894a0fa90004999ceea8dbe36">getProperties</a> ()</td></tr>
<tr class="separator:abc93f31894a0fa90004999ceea8dbe36 inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0de86e7f83e0d3c90eb5ac7b36d5b3b inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#ab0de86e7f83e0d3c90eb5ac7b36d5b3b">getOperation</a> ()</td></tr>
<tr class="memdesc:ab0de86e7f83e0d3c90eb5ac7b36d5b3b inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherit getOperation from <code>OpState</code>.  <a href="classmlir_1_1Op.html#ab0de86e7f83e0d3c90eb5ac7b36d5b3b">More...</a><br /></td></tr>
<tr class="separator:ab0de86e7f83e0d3c90eb5ac7b36d5b3b inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353c0e5088dbb6624b01221f62262f78 inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a353c0e5088dbb6624b01221f62262f78">verify</a> ()</td></tr>
<tr class="memdesc:a353c0e5088dbb6624b01221f62262f78 inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the concrete type didn't implement a custom verifier hook, just fall back to this one which accepts everything.  <a href="classmlir_1_1Op.html#a353c0e5088dbb6624b01221f62262f78">More...</a><br /></td></tr>
<tr class="separator:a353c0e5088dbb6624b01221f62262f78 inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707e0acf20eca83644d64ca1718a6c4a inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a707e0acf20eca83644d64ca1718a6c4a">verifyRegions</a> ()</td></tr>
<tr class="separator:a707e0acf20eca83644d64ca1718a6c4a inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:a4a630754c7bac8e1c33ced0f4f25e3ba inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a4a630754c7bac8e1c33ced0f4f25e3ba">operator bool</a> ()</td></tr>
<tr class="memdesc:a4a630754c7bac8e1c33ced0f4f25e3ba inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ops are pointer-like, so we allow conversion to bool.  <a href="classmlir_1_1OpState.html#a4a630754c7bac8e1c33ced0f4f25e3ba">More...</a><br /></td></tr>
<tr class="separator:a4a630754c7bac8e1c33ced0f4f25e3ba inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53baa7db4eecd983c7387027ebf0f44 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ac53baa7db4eecd983c7387027ebf0f44">operator Operation *</a> () const</td></tr>
<tr class="memdesc:ac53baa7db4eecd983c7387027ebf0f44 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implicitly converts to Operation*.  <a href="classmlir_1_1OpState.html#ac53baa7db4eecd983c7387027ebf0f44">More...</a><br /></td></tr>
<tr class="separator:ac53baa7db4eecd983c7387027ebf0f44 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4123d8ee9f66429dadb11acbfefc0b inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#afd4123d8ee9f66429dadb11acbfefc0b">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:afd4123d8ee9f66429dadb11acbfefc0b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut of <code>-&gt;</code> to access a member of <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="classmlir_1_1OpState.html#afd4123d8ee9f66429dadb11acbfefc0b">More...</a><br /></td></tr>
<tr class="separator:afd4123d8ee9f66429dadb11acbfefc0b inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0de86e7f83e0d3c90eb5ac7b36d5b3b inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ab0de86e7f83e0d3c90eb5ac7b36d5b3b">getOperation</a> ()</td></tr>
<tr class="memdesc:ab0de86e7f83e0d3c90eb5ac7b36d5b3b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the operation that this refers to.  <a href="classmlir_1_1OpState.html#ab0de86e7f83e0d3c90eb5ac7b36d5b3b">More...</a><br /></td></tr>
<tr class="separator:ab0de86e7f83e0d3c90eb5ac7b36d5b3b inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15857fa62a3a6e8423b3d1511acfc040 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a15857fa62a3a6e8423b3d1511acfc040">getContext</a> ()</td></tr>
<tr class="memdesc:a15857fa62a3a6e8423b3d1511acfc040 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the context this operation belongs to.  <a href="classmlir_1_1OpState.html#a15857fa62a3a6e8423b3d1511acfc040">More...</a><br /></td></tr>
<tr class="separator:a15857fa62a3a6e8423b3d1511acfc040 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a472af9de9610021657c2874e6b1191 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a5a472af9de9610021657c2874e6b1191">print</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags={})</td></tr>
<tr class="memdesc:a5a472af9de9610021657c2874e6b1191 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the operation to the given stream.  <a href="classmlir_1_1OpState.html#a5a472af9de9610021657c2874e6b1191">More...</a><br /></td></tr>
<tr class="separator:a5a472af9de9610021657c2874e6b1191 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae2204ca73ef2a338a1f980d3662f80 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a5ae2204ca73ef2a338a1f980d3662f80">print</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AsmState.html">AsmState</a> &amp;asmState)</td></tr>
<tr class="separator:a5ae2204ca73ef2a338a1f980d3662f80 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023cde86e8d01c23ae2f7c07d084d21a inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a023cde86e8d01c23ae2f7c07d084d21a">dump</a> ()</td></tr>
<tr class="memdesc:a023cde86e8d01c23ae2f7c07d084d21a inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump this operation.  <a href="classmlir_1_1OpState.html#a023cde86e8d01c23ae2f7c07d084d21a">More...</a><br /></td></tr>
<tr class="separator:a023cde86e8d01c23ae2f7c07d084d21a inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad824acf76e230e3cd64a02d66a82a0cb inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ad824acf76e230e3cd64a02d66a82a0cb">getLoc</a> ()</td></tr>
<tr class="memdesc:ad824acf76e230e3cd64a02d66a82a0cb inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">The source location the operation was defined or derived from.  <a href="classmlir_1_1OpState.html#ad824acf76e230e3cd64a02d66a82a0cb">More...</a><br /></td></tr>
<tr class="separator:ad824acf76e230e3cd64a02d66a82a0cb inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3159f7aa51ff5db54cbab48867d00365 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a3159f7aa51ff5db54cbab48867d00365">use_empty</a> ()</td></tr>
<tr class="memdesc:a3159f7aa51ff5db54cbab48867d00365 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are no users of any results of this operation.  <a href="classmlir_1_1OpState.html#a3159f7aa51ff5db54cbab48867d00365">More...</a><br /></td></tr>
<tr class="separator:a3159f7aa51ff5db54cbab48867d00365 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202c02a251ca0fce2c2a9df84b9ea32f inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a202c02a251ca0fce2c2a9df84b9ea32f">erase</a> ()</td></tr>
<tr class="memdesc:a202c02a251ca0fce2c2a9df84b9ea32f inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove this operation from its parent block and delete it.  <a href="classmlir_1_1OpState.html#a202c02a251ca0fce2c2a9df84b9ea32f">More...</a><br /></td></tr>
<tr class="separator:a202c02a251ca0fce2c2a9df84b9ea32f inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a602baeafc892ba94fd30bfeb0624b inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a96a602baeafc892ba94fd30bfeb0624b">emitOpError</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:a96a602baeafc892ba94fd30bfeb0624b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an error with the op name prefixed, like "'dim' op " which is convenient for verifiers.  <a href="classmlir_1_1OpState.html#a96a602baeafc892ba94fd30bfeb0624b">More...</a><br /></td></tr>
<tr class="separator:a96a602baeafc892ba94fd30bfeb0624b inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ab2e156408bc77bb5d5629068bda60 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a78ab2e156408bc77bb5d5629068bda60">emitError</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:a78ab2e156408bc77bb5d5629068bda60 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an error about fatal conditions with this operation, reporting up to any diagnostic handlers that may be listening.  <a href="classmlir_1_1OpState.html#a78ab2e156408bc77bb5d5629068bda60">More...</a><br /></td></tr>
<tr class="separator:a78ab2e156408bc77bb5d5629068bda60 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94173f14645d198ba9e07f763acfe4b inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#aa94173f14645d198ba9e07f763acfe4b">emitWarning</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:aa94173f14645d198ba9e07f763acfe4b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a warning about this operation, reporting up to any diagnostic handlers that may be listening.  <a href="classmlir_1_1OpState.html#aa94173f14645d198ba9e07f763acfe4b">More...</a><br /></td></tr>
<tr class="separator:aa94173f14645d198ba9e07f763acfe4b inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac456e15c3588fd348490eb8e423617ea inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ac456e15c3588fd348490eb8e423617ea">emitRemark</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:ac456e15c3588fd348490eb8e423617ea inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a remark about this operation, reporting up to any diagnostic handlers that may be listening.  <a href="classmlir_1_1OpState.html#ac456e15c3588fd348490eb8e423617ea">More...</a><br /></td></tr>
<tr class="separator:ac456e15c3588fd348490eb8e423617ea inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3992b78b5c039f6f48ab9ab53b999480 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplParams" colspan="2">template&lt;WalkOrder Order = WalkOrder::PostOrder, typename Iterator  = ForwardIterator, typename FnT , typename RetT  = detail::walkResultType&lt;FnT&gt;&gt; </td></tr>
<tr class="memitem:a3992b78b5c039f6f48ab9ab53b999480 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::function_traits&lt; std::decay_t&lt; FnT &gt; &gt;::num_args==1, RetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a3992b78b5c039f6f48ab9ab53b999480">walk</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a3992b78b5c039f6f48ab9ab53b999480 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk the operation by calling the callback for each nested operation (including this one), block or region, depending on the callback provided.  <a href="classmlir_1_1OpState.html#a3992b78b5c039f6f48ab9ab53b999480">More...</a><br /></td></tr>
<tr class="separator:a3992b78b5c039f6f48ab9ab53b999480 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d45fa93789d2ba8003734baef9f9454 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename RetT  = detail::walkResultType&lt;FnT&gt;&gt; </td></tr>
<tr class="memitem:a0d45fa93789d2ba8003734baef9f9454 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; llvm::function_traits&lt; std::decay_t&lt; FnT &gt; &gt;::num_args==2, RetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a0d45fa93789d2ba8003734baef9f9454">walk</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a0d45fa93789d2ba8003734baef9f9454 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic walker with a stage aware callback.  <a href="classmlir_1_1OpState.html#a0d45fa93789d2ba8003734baef9f9454">More...</a><br /></td></tr>
<tr class="separator:a0d45fa93789d2ba8003734baef9f9454 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac5dc9214ed7df1eca30ff607a9b564bf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#ac5dc9214ed7df1eca30ff607a9b564bf">getAttributeNames</a> ()</td></tr>
<tr class="separator:ac5dc9214ed7df1eca30ff607a9b564bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19883c4882629356846071044435680b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a19883c4882629356846071044435680b">build</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result, <a class="el" href="classmlir_1_1Value.html">Value</a> srcMemRef, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> srcMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> srcIndices, <a class="el" href="classmlir_1_1Value.html">Value</a> destMemRef, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> dstMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> destIndices, <a class="el" href="classmlir_1_1Value.html">Value</a> tagMemRef, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> tagMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> tagIndices, <a class="el" href="classmlir_1_1Value.html">Value</a> numElements, <a class="el" href="classmlir_1_1Value.html">Value</a> stride=nullptr, <a class="el" href="classmlir_1_1Value.html">Value</a> elementsPerStride=nullptr)</td></tr>
<tr class="separator:a19883c4882629356846071044435680b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe995d2bc68af154a3521a8c96a425c6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html">AffineDmaStartOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#abe995d2bc68af154a3521a8c96a425c6">create</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> location, <a class="el" href="classmlir_1_1Value.html">Value</a> srcMemRef, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> srcMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> srcIndices, <a class="el" href="classmlir_1_1Value.html">Value</a> destMemRef, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> dstMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> destIndices, <a class="el" href="classmlir_1_1Value.html">Value</a> tagMemRef, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> tagMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> tagIndices, <a class="el" href="classmlir_1_1Value.html">Value</a> numElements, <a class="el" href="classmlir_1_1Value.html">Value</a> stride=nullptr, <a class="el" href="classmlir_1_1Value.html">Value</a> elementsPerStride=nullptr)</td></tr>
<tr class="separator:abe995d2bc68af154a3521a8c96a425c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ee1e992153b62c59e75f49e81cb39b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html">AffineDmaStartOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a57ee1e992153b62c59e75f49e81cb39b">create</a> (<a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Value.html">Value</a> srcMemRef, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> srcMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> srcIndices, <a class="el" href="classmlir_1_1Value.html">Value</a> destMemRef, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> dstMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> destIndices, <a class="el" href="classmlir_1_1Value.html">Value</a> tagMemRef, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> tagMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> tagIndices, <a class="el" href="classmlir_1_1Value.html">Value</a> numElements, <a class="el" href="classmlir_1_1Value.html">Value</a> stride=nullptr, <a class="el" href="classmlir_1_1Value.html">Value</a> elementsPerStride=nullptr)</td></tr>
<tr class="separator:a57ee1e992153b62c59e75f49e81cb39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3ffce399728b8007b7f2becfdfe365"><td class="memItemLeft" align="right" valign="top">static StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a5e3ffce399728b8007b7f2becfdfe365">getSrcMapAttrStrName</a> ()</td></tr>
<tr class="separator:a5e3ffce399728b8007b7f2becfdfe365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab143ca69b8d506d211a38057adf67a"><td class="memItemLeft" align="right" valign="top">static StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#adab143ca69b8d506d211a38057adf67a">getDstMapAttrStrName</a> ()</td></tr>
<tr class="separator:adab143ca69b8d506d211a38057adf67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fe3d905737d38b5af8eedf542bacfa"><td class="memItemLeft" align="right" valign="top">static StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#a74fe3d905737d38b5af8eedf542bacfa">getTagMapAttrStrName</a> ()</td></tr>
<tr class="separator:a74fe3d905737d38b5af8eedf542bacfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0493d01946d5d000e80a429c6561d3d"><td class="memItemLeft" align="right" valign="top">static StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#ae0493d01946d5d000e80a429c6561d3d">getOperationName</a> ()</td></tr>
<tr class="separator:ae0493d01946d5d000e80a429c6561d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb973563b8e0821187ad21c800bf595"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html#acbb973563b8e0821187ad21c800bf595">parse</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result)</td></tr>
<tr class="separator:acbb973563b8e0821187ad21c800bf595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1Op"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1Op')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1Op.html">mlir::Op&lt; AffineDmaStartOp, OpTrait::MemRefsNormalizable, OpTrait::VariadicOperands, OpTrait::ZeroResults, OpTrait::OpInvariants, AffineMapAccessInterface::Trait, MemoryEffectOpInterface::Trait &gt;</a></td></tr>
<tr class="memitem:ab0f28a9a8ea472061179fd53883ea589 inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#ab0f28a9a8ea472061179fd53883ea589">hasTrait</a> ()</td></tr>
<tr class="memdesc:ab0f28a9a8ea472061179fd53883ea589 inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if this operation contains the provided trait.  <a href="classmlir_1_1Op.html#ab0f28a9a8ea472061179fd53883ea589">More...</a><br /></td></tr>
<tr class="separator:ab0f28a9a8ea472061179fd53883ea589 inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1240be31ea922d33b1b2392e723a3b4e inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a1240be31ea922d33b1b2392e723a3b4e">classof</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a1240be31ea922d33b1b2392e723a3b4e inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this "op class" can match against the specified operation.  <a href="classmlir_1_1Op.html#a1240be31ea922d33b1b2392e723a3b4e">More...</a><br /></td></tr>
<tr class="separator:a1240be31ea922d33b1b2392e723a3b4e inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c101993f4bb1de5e348350e13578094 inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1OpState.html">OpState</a>, T &gt;::value, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a9c101993f4bb1de5e348350e13578094">classof</a> (const T *op)</td></tr>
<tr class="memdesc:a9c101993f4bb1de5e348350e13578094 inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <code>classof</code> support for other OpBase derived classes, such as Interfaces.  <a href="classmlir_1_1Op.html#a9c101993f4bb1de5e348350e13578094">More...</a><br /></td></tr>
<tr class="separator:a9c101993f4bb1de5e348350e13578094 inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2c41a61d1531398c6bfc2f2ed1e4e8 inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Op.html#a63c65a9810b37ce3fa35ca27acdce394">ConcreteOpType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a2c2c41a61d1531398c6bfc2f2ed1e4e8">getFromOpaquePointer</a> (const void *pointer)</td></tr>
<tr class="separator:a2c2c41a61d1531398c6bfc2f2ed1e4e8 inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad859b0a042439ebb5182e4493ff7b853 inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#ad859b0a042439ebb5182e4493ff7b853">attachInterface</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;context)</td></tr>
<tr class="memdesc:ad859b0a042439ebb5182e4493ff7b853 inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach the given models as implementations of the corresponding interfaces for the concrete operation.  <a href="classmlir_1_1Op.html#ad859b0a042439ebb5182e4493ff7b853">More...</a><br /></td></tr>
<tr class="separator:ad859b0a042439ebb5182e4493ff7b853 inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbadb7faf098d7d2e7a276b594a966d inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a1bbadb7faf098d7d2e7a276b594a966d">setPropertiesFromAttr</a> (PropertiesTy &amp;prop, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>()&gt; <a class="el" href="classmlir_1_1OpState.html#a78ab2e156408bc77bb5d5629068bda60">emitError</a>)</td></tr>
<tr class="memdesc:a1bbadb7faf098d7d2e7a276b594a966d inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided attribute to a property and assigned it to the provided properties.  <a href="classmlir_1_1Op.html#a1bbadb7faf098d7d2e7a276b594a966d">More...</a><br /></td></tr>
<tr class="separator:a1bbadb7faf098d7d2e7a276b594a966d inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65160d5d9f4234c81d7db4be013aad40 inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a65160d5d9f4234c81d7db4be013aad40">getPropertiesAsAttr</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, const PropertiesTy &amp;prop)</td></tr>
<tr class="memdesc:a65160d5d9f4234c81d7db4be013aad40 inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the provided properties to an attribute.  <a href="classmlir_1_1Op.html#a65160d5d9f4234c81d7db4be013aad40">More...</a><br /></td></tr>
<tr class="separator:a65160d5d9f4234c81d7db4be013aad40 inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e2d0393e4914199370400b54baa4a8 inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#ab4e2d0393e4914199370400b54baa4a8">computePropertiesHash</a> (const PropertiesTy &amp;prop)</td></tr>
<tr class="memdesc:ab4e2d0393e4914199370400b54baa4a8 inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash the provided properties.  <a href="classmlir_1_1Op.html#ab4e2d0393e4914199370400b54baa4a8">More...</a><br /></td></tr>
<tr class="separator:ab4e2d0393e4914199370400b54baa4a8 inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab836044f7d5dc6bd251ec324e6a59d20 inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#ab836044f7d5dc6bd251ec324e6a59d20">hasProperties</a> ()</td></tr>
<tr class="memdesc:ab836044f7d5dc6bd251ec324e6a59d20 inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this operation defines a <code>Properties</code> inner type.  <a href="classmlir_1_1Op.html#ab836044f7d5dc6bd251ec324e6a59d20">More...</a><br /></td></tr>
<tr class="separator:ab836044f7d5dc6bd251ec324e6a59d20 inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb1f4a3688ae37231e943a74f5a9079 inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#afbb1f4a3688ae37231e943a74f5a9079">populateDefaultProperties</a> (<a class="el" href="classmlir_1_1OperationName.html">OperationName</a> opName, <a class="el" href="classmlir_1_1Op.html#aeb22cbbff9dc8dab72c638ea384ecd2a">InferredProperties</a>&lt; T &gt; &amp;properties)</td></tr>
<tr class="memdesc:afbb1f4a3688ae37231e943a74f5a9079 inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook populates any unset default attrs when mapped to properties.  <a href="classmlir_1_1Op.html#afbb1f4a3688ae37231e943a74f5a9079">More...</a><br /></td></tr>
<tr class="separator:afbb1f4a3688ae37231e943a74f5a9079 inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78566efdfb9083f28e2a290758be204e inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a78566efdfb9083f28e2a290758be204e">printProperties</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, const T &amp;properties, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; elidedProps={})</td></tr>
<tr class="memdesc:a78566efdfb9083f28e2a290758be204e inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the operation properties with names not included within 'elidedProps'.  <a href="classmlir_1_1Op.html#a78566efdfb9083f28e2a290758be204e">More...</a><br /></td></tr>
<tr class="separator:a78566efdfb9083f28e2a290758be204e inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaebd0595f35c45f8ddb7c3bb0d7911b inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#acaebd0595f35c45f8ddb7c3bb0d7911b">parseProperties</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result)</td></tr>
<tr class="memdesc:acaebd0595f35c45f8ddb7c3bb0d7911b inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses 'prop-dict' for the operation.  <a href="classmlir_1_1Op.html#acaebd0595f35c45f8ddb7c3bb0d7911b">More...</a><br /></td></tr>
<tr class="separator:acaebd0595f35c45f8ddb7c3bb0d7911b inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:ab697ae7a73f65229a4c63fc72dc5655d inherit pub_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ab697ae7a73f65229a4c63fc72dc5655d">getCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;results, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ab697ae7a73f65229a4c63fc72dc5655d inherit pub_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook returns any canonicalization pattern rewrites that the operation supports, for use by the canonicalization pass.  <a href="classmlir_1_1OpState.html#ab697ae7a73f65229a4c63fc72dc5655d">More...</a><br /></td></tr>
<tr class="separator:ab697ae7a73f65229a4c63fc72dc5655d inherit pub_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86c745166da5745b6043c84025780f0 inherit pub_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ad86c745166da5745b6043c84025780f0">populateDefaultAttrs</a> (const <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> &amp;, <a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;)</td></tr>
<tr class="memdesc:ad86c745166da5745b6043c84025780f0 inherit pub_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook populates any unset default attrs.  <a href="classmlir_1_1OpState.html#ad86c745166da5745b6043c84025780f0">More...</a><br /></td></tr>
<tr class="separator:ad86c745166da5745b6043c84025780f0 inherit pub_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classmlir_1_1Op"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmlir_1_1Op')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmlir_1_1Op.html">mlir::Op&lt; AffineDmaStartOp, OpTrait::MemRefsNormalizable, OpTrait::VariadicOperands, OpTrait::ZeroResults, OpTrait::OpInvariants, AffineMapAccessInterface::Trait, MemoryEffectOpInterface::Trait &gt;</a></td></tr>
<tr class="memitem:a63c65a9810b37ce3fa35ca27acdce394 inherit pub_types_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a63c65a9810b37ce3fa35ca27acdce394">ConcreteOpType</a> = AffineDmaStartOp</td></tr>
<tr class="memdesc:a63c65a9810b37ce3fa35ca27acdce394 inherit pub_types_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expose the type we are instantiated on to template machinery that may want to introspect traits on this operation.  <a href="classmlir_1_1Op.html#a63c65a9810b37ce3fa35ca27acdce394">More...</a><br /></td></tr>
<tr class="separator:a63c65a9810b37ce3fa35ca27acdce394 inherit pub_types_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb22cbbff9dc8dab72c638ea384ecd2a inherit pub_types_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#aeb22cbbff9dc8dab72c638ea384ecd2a">InferredProperties</a> = typename <a class="el" href="structmlir_1_1PropertiesSelector.html">PropertiesSelector</a>&lt; T &gt;::type</td></tr>
<tr class="separator:aeb22cbbff9dc8dab72c638ea384ecd2a inherit pub_types_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:a353c0e5088dbb6624b01221f62262f78 inherit pro_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a353c0e5088dbb6624b01221f62262f78">verify</a> ()</td></tr>
<tr class="memdesc:a353c0e5088dbb6624b01221f62262f78 inherit pro_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the concrete type didn't implement a custom verifier hook, just fall back to this one which accepts everything.  <a href="classmlir_1_1OpState.html#a353c0e5088dbb6624b01221f62262f78">More...</a><br /></td></tr>
<tr class="separator:a353c0e5088dbb6624b01221f62262f78 inherit pro_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707e0acf20eca83644d64ca1718a6c4a inherit pro_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a707e0acf20eca83644d64ca1718a6c4a">verifyRegions</a> ()</td></tr>
<tr class="separator:a707e0acf20eca83644d64ca1718a6c4a inherit pro_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cb0c062a04c9797e443d2ee1a4d9e7 inherit pro_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ad2cb0c062a04c9797e443d2ee1a4d9e7">OpState</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *state)</td></tr>
<tr class="memdesc:ad2cb0c062a04c9797e443d2ee1a4d9e7 inherit pro_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutability management is handled by the OpWrapper/OpConstWrapper classes, so we can cast it away here.  <a href="classmlir_1_1OpState.html#ad2cb0c062a04c9797e443d2ee1a4d9e7">More...</a><br /></td></tr>
<tr class="separator:ad2cb0c062a04c9797e443d2ee1a4d9e7 inherit pro_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1OpTrait_1_1TraitBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1OpTrait_1_1TraitBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html">mlir::OpTrait::TraitBase&lt; ConcreteType, TraitType &gt;</a></td></tr>
<tr class="memitem:aba6545e9c958929a57b6f37947fab14d inherit pro_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html#aba6545e9c958929a57b6f37947fab14d">getOperation</a> ()</td></tr>
<tr class="memdesc:aba6545e9c958929a57b6f37947fab14d inherit pro_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ultimate <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> being worked on.  <a href="classmlir_1_1OpTrait_1_1TraitBase.html#aba6545e9c958929a57b6f37947fab14d">More...</a><br /></td></tr>
<tr class="separator:aba6545e9c958929a57b6f37947fab14d inherit pro_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:abcfdfbc4f6158e19c5993549247132fb inherit pro_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#abcfdfbc4f6158e19c5993549247132fb">parse</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result)</td></tr>
<tr class="memdesc:abcfdfbc4f6158e19c5993549247132fb inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the custom form of an operation.  <a href="classmlir_1_1OpState.html#abcfdfbc4f6158e19c5993549247132fb">More...</a><br /></td></tr>
<tr class="separator:abcfdfbc4f6158e19c5993549247132fb inherit pro_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d2761129af0c55404133f9b47f21b6 inherit pro_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#aa1d2761129af0c55404133f9b47f21b6">print</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, StringRef defaultDialect)</td></tr>
<tr class="memdesc:aa1d2761129af0c55404133f9b47f21b6 inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the operation.  <a href="classmlir_1_1OpState.html#aa1d2761129af0c55404133f9b47f21b6">More...</a><br /></td></tr>
<tr class="separator:aa1d2761129af0c55404133f9b47f21b6 inherit pro_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e0ae9c848fe4e633e46a3ce0863bab inherit pro_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ab8e0ae9c848fe4e633e46a3ce0863bab">genericParseProperties</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;result)</td></tr>
<tr class="memdesc:ab8e0ae9c848fe4e633e46a3ce0863bab inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse properties as a <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>.  <a href="classmlir_1_1OpState.html#ab8e0ae9c848fe4e633e46a3ce0863bab">More...</a><br /></td></tr>
<tr class="separator:ab8e0ae9c848fe4e633e46a3ce0863bab inherit pro_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07588469ccab75d875094f095c4f2d1b inherit pro_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a07588469ccab75d875094f095c4f2d1b">genericPrintProperties</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> properties, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; elidedProps={})</td></tr>
<tr class="memdesc:a07588469ccab75d875094f095c4f2d1b inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the properties as a <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> with names not included within 'elidedProps'.  <a href="classmlir_1_1OpState.html#a07588469ccab75d875094f095c4f2d1b">More...</a><br /></td></tr>
<tr class="separator:a07588469ccab75d875094f095c4f2d1b inherit pro_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624f18cf4e9a772ab1187fd997ccf2b8 inherit pro_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a624f18cf4e9a772ab1187fd997ccf2b8">printOpName</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, StringRef defaultDialect)</td></tr>
<tr class="memdesc:a624f18cf4e9a772ab1187fd997ccf2b8 inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an operation name, eliding the dialect prefix if necessary.  <a href="classmlir_1_1OpState.html#a624f18cf4e9a772ab1187fd997ccf2b8">More...</a><br /></td></tr>
<tr class="separator:a624f18cf4e9a772ab1187fd997ccf2b8 inherit pro_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9229a9829135abc357f1da5086695d inherit pro_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1EmptyProperties.html">EmptyProperties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a5e9229a9829135abc357f1da5086695d">getEmptyProperties</a> ()</td></tr>
<tr class="memdesc:a5e9229a9829135abc357f1da5086695d inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">For all op which don't have properties, we keep a single instance of <code><a class="el" href="structmlir_1_1EmptyProperties.html" title="Structure used by default as a &quot;marker&quot; when no &quot;Properties&quot; are set on an Operation.">EmptyProperties</a></code> to be used where a reference to a properties is needed: this allow to bind a pointer to the reference without triggering UB.  <a href="classmlir_1_1OpState.html#a5e9229a9829135abc357f1da5086695d">More...</a><br /></td></tr>
<tr class="separator:a5e9229a9829135abc357f1da5086695d inherit pro_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html" title="AffineDmaStartOp starts a non-blocking DMA operation that transfers data from a source memref to a de...">AffineDmaStartOp</a> starts a non-blocking DMA operation that transfers data from a source memref to a destination memref. </p>
<p>The source and destination memref need not be of the same dimensionality, but need to have the same elemental type. The operands include the source and destination memref's each followed by its indices, size of the data transfer in terms of the number of elements (of the elemental type of the memref), a tag memref with its indices, and optionally at the end, a stride and a number_of_elements_per_stride arguments. The tag location is used by an <a class="el" href="classmlir_1_1affine_1_1AffineDmaWaitOp.html" title="AffineDmaWaitOp blocks until the completion of a DMA operation associated with the tag element &#39;tag[i...">AffineDmaWaitOp</a> to check for completion. The indices of the source memref, destination memref, and the tag memref have the same restrictions as any affine.load/store. In particular, index for each memref dimension must be an affine expression of loop induction variables and symbols. The optional stride arguments should be of 'index' type, and specify a stride for the slower memory space (memory space with a lower memory space id), transferring chunks of number_of_elements_per_stride every stride until num_elements are transferred. Either both or no stride arguments should be specified. The value of 'num_elements' must be a multiple of 'number_of_elements_per_stride'. If the source and destination locations overlap the behavior of this operation is not defined. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00102">102</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a19883c4882629356846071044435680b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19883c4882629356846071044435680b">&#9670;&nbsp;</a></span>build()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AffineDmaStartOp::build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>srcMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>srcMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>srcIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>destMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>dstMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>destIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>tagMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>tagMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>tagIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>stride</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>elementsPerStride</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01724">1724</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l01075">mlir::OperationState::addAttribute()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00206">mlir::OperationState::addOperands()</a>, and <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>.</p>

</div>
</div>
<a id="a57ee1e992153b62c59e75f49e81cb39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ee1e992153b62c59e75f49e81cb39b">&#9670;&nbsp;</a></span>create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html">AffineDmaStartOp</a> AffineDmaStartOp::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>srcMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>srcMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>srcIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>destMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>dstMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>destIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>tagMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>tagMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>tagIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>stride</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>elementsPerStride</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01761">1761</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00654">mlir::ImplicitLocOpBuilder::getLoc()</a>.</p>

</div>
</div>
<a id="abe995d2bc68af154a3521a8c96a425c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe995d2bc68af154a3521a8c96a425c6">&#9670;&nbsp;</a></span>create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html">AffineDmaStartOp</a> AffineDmaStartOp::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>srcMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>srcMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>srcIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>destMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>dstMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>destIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>tagMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>tagMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>tagIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>stride</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>elementsPerStride</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01746">1746</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01935">generateCopy()</a>.</p>

</div>
</div>
<a id="af0550bb3a330b3f291f20deade5b58d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0550bb3a330b3f291f20deade5b58d1">&#9670;&nbsp;</a></span>fold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult AffineDmaStartOp::fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>cstOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dma_start(memrefcast) -&gt; dma_start</p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01911">1911</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefOps_8cpp_source.html#l00045">mlir::memref::foldMemRefCast()</a>.</p>

</div>
</div>
<a id="ae2237a77be8ae948ecbf9fb48b752321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2237a77be8ae948ecbf9fb48b752321">&#9670;&nbsp;</a></span>getAffineMapAttrForMemRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> mlir::affine::AffineDmaStartOp::getAffineMapAttrForMemRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impelements the AffineMapAccessInterface. </p>
<p>Returns the AffineMapAttr associated with 'memref'. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00245">245</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="OpDefinition_8h_source.html#l00115">mlir::OpState::getContext()</a>, <a class="el" href="AffineOps_8h_source.html#l00192">getDstMapAttr()</a>, <a class="el" href="AffineOps_8h_source.html#l00282">getDstMapAttrStrName()</a>, <a class="el" href="AffineOps_8h_source.html#l00172">getDstMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00149">getSrcMapAttr()</a>, <a class="el" href="AffineOps_8h_source.html#l00281">getSrcMapAttrStrName()</a>, <a class="el" href="AffineOps_8h_source.html#l00136">getSrcMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00225">getTagMapAttr()</a>, <a class="el" href="AffineOps_8h_source.html#l00283">getTagMapAttrStrName()</a>, and <a class="el" href="AffineOps_8h_source.html#l00210">getTagMemRef()</a>.</p>

</div>
</div>
<a id="ac5dc9214ed7df1eca30ff607a9b564bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5dc9214ed7df1eca30ff607a9b564bf">&#9670;&nbsp;</a></span>getAttributeNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;StringRef&gt; mlir::affine::AffineDmaStartOp::getAttributeNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00109">109</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

</div>
</div>
<a id="a1f1dedffa0cef4bc3b88d8171d42f30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1dedffa0cef4bc3b88d8171d42f30a">&#9670;&nbsp;</a></span>getDstIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operand_range mlir::affine::AffineDmaStartOp::getDstIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the destination memref indices for this DMA operation. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00198">198</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00191">getDstMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00167">getDstMemRefOperandIndex()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>.</p>

</div>
</div>
<a id="a4a3576dd59ab05b1547841d2524a8c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3576dd59ab05b1547841d2524a8c1e">&#9670;&nbsp;</a></span>getDstMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::affine::AffineDmaStartOp::getDstMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the affine map used to access the destination memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00191">191</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00192">getDstMapAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00198">getDstIndices()</a>, and <a class="el" href="AffineOps_8h_source.html#l00205">getTagMemRefOperandIndex()</a>.</p>

</div>
</div>
<a id="a62ef4d3b337fbd143d174093b2aa96f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ef4d3b337fbd143d174093b2aa96f0">&#9670;&nbsp;</a></span>getDstMapAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AffineMapAttr mlir::affine::AffineDmaStartOp::getDstMapAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00192">192</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00282">getDstMapAttrStrName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00245">getAffineMapAttrForMemRef()</a>, and <a class="el" href="AffineOps_8h_source.html#l00191">getDstMap()</a>.</p>

</div>
</div>
<a id="adab143ca69b8d506d211a38057adf67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab143ca69b8d506d211a38057adf67a">&#9670;&nbsp;</a></span>getDstMapAttrStrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StringRef mlir::affine::AffineDmaStartOp::getDstMapAttrStrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00282">282</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00245">getAffineMapAttrForMemRef()</a>, and <a class="el" href="AffineOps_8h_source.html#l00192">getDstMapAttr()</a>.</p>

</div>
</div>
<a id="a66b4444174eb9d79dc200e2976b9c1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b4444174eb9d79dc200e2976b9c1b0">&#9670;&nbsp;</a></span>getDstMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::affine::AffineDmaStartOp::getDstMemorySpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the memory space of the source memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00186">186</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00172">getDstMemRef()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00259">isDestMemorySpaceFaster()</a>, and <a class="el" href="AffineOps_8h_source.html#l00264">isSrcMemorySpaceFaster()</a>.</p>

</div>
</div>
<a id="a55c27685ba72f2c73c09cd1fc213ad83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c27685ba72f2c73c09cd1fc213ad83">&#9670;&nbsp;</a></span>getDstMemRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::affine::AffineDmaStartOp::getDstMemRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the destination MemRefType for this DMA operation. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00172">172</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00167">getDstMemRefOperandIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00245">getAffineMapAttrForMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00186">getDstMemorySpace()</a>, <a class="el" href="AffineOps_8h_source.html#l00181">getDstMemRefRank()</a>, and <a class="el" href="AffineOps_8h_source.html#l00176">getDstMemRefType()</a>.</p>

</div>
</div>
<a id="afbec6c0f609cb86d8beff0a5e848428a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbec6c0f609cb86d8beff0a5e848428a">&#9670;&nbsp;</a></span>getDstMemRefMutable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a>&amp; mlir::affine::AffineDmaStartOp::getDstMemRefMutable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00173">173</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00167">getDstMemRefOperandIndex()</a>, <a class="el" href="OpDefinition_8h_source.html#l00112">mlir::Op&lt; AffineDmaStartOp, OpTrait::MemRefsNormalizable, OpTrait::VariadicOperands, OpTrait::ZeroResults, OpTrait::OpInvariants, AffineMapAccessInterface::Trait, MemoryEffectOpInterface::Trait &gt;::getOperation()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00388">mlir::Operation::getOpOperand()</a>.</p>

</div>
</div>
<a id="ad518330477f5cbedc4bb02cf50f9fe21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad518330477f5cbedc4bb02cf50f9fe21">&#9670;&nbsp;</a></span>getDstMemRefOperandIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::affine::AffineDmaStartOp::getDstMemRefOperandIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the operand index of the destination memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00167">167</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="AffineOps_8h_source.html#l00148">getSrcMap()</a>, and <a class="el" href="AffineOps_8h_source.html#l00133">getSrcMemRefOperandIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00198">getDstIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00172">getDstMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00173">getDstMemRefMutable()</a>, <a class="el" href="AffineOps_8h_source.html#l00272">getFasterMemPos()</a>, and <a class="el" href="AffineOps_8h_source.html#l00205">getTagMemRefOperandIndex()</a>.</p>

</div>
</div>
<a id="a9d0e03a46741fd1b491e94a27e94a683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0e03a46741fd1b491e94a27e94a683">&#9670;&nbsp;</a></span>getDstMemRefRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::affine::AffineDmaStartOp::getDstMemRefRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank (number of indices) of the destination MemRefType. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00181">181</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00172">getDstMemRef()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>.</p>

</div>
</div>
<a id="aef0321f3f90d5949d77da0a30af3e51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0321f3f90d5949d77da0a30af3e51e">&#9670;&nbsp;</a></span>getDstMemRefType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MemRefType mlir::affine::AffineDmaStartOp::getDstMemRefType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00176">176</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00172">getDstMemRef()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>.</p>

</div>
</div>
<a id="a09d836160aa1d4eb3c26edee4fe75040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d836160aa1d4eb3c26edee4fe75040">&#9670;&nbsp;</a></span>getEffects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineDmaStartOp::getEffects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1SideEffects_1_1EffectInstance.html">SideEffects::EffectInstance</a>&lt; <a class="el" href="structmlir_1_1MemoryEffects_1_1Effect.html">MemoryEffects::Effect</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>effects</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01917">1917</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="SideEffectInterfaces_8h_source.html#l00043">mlir::SideEffects::Effect::Base&lt; DerivedEffect, BaseEffect &gt;::get()</a>, and <a class="el" href="SideEffectInterfaces_8h_source.html#l00090">mlir::SideEffects::Resource::Base&lt; DefaultResource &gt;::get()</a>.</p>

</div>
</div>
<a id="a153d5d57f4b3172a2f590378bea956e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153d5d57f4b3172a2f590378bea956e5">&#9670;&nbsp;</a></span>getFasterMemPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::affine::AffineDmaStartOp::getFasterMemPos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a DMA start operation, returns the operand position of either the source or destination memref depending on the one that is at the higher level of the memory hierarchy. </p>
<p>Asserts failure if neither is true. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00272">272</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00167">getDstMemRefOperandIndex()</a>, <a class="el" href="AffineOps_8h_source.html#l00259">isDestMemorySpaceFaster()</a>, and <a class="el" href="AffineOps_8h_source.html#l00264">isSrcMemorySpaceFaster()</a>.</p>

</div>
</div>
<a id="abb1208ebca4d8fac46260f469ab867ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1208ebca4d8fac46260f469ab867ef">&#9670;&nbsp;</a></span>getNumElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::affine::AffineDmaStartOp::getNumElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements being transferred by this DMA operation. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00238">238</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00224">getTagMap()</a>, and <a class="el" href="AffineOps_8h_source.html#l00205">getTagMemRefOperandIndex()</a>.</p>

</div>
</div>
<a id="a22a5a5d36d59921b38eeced52fd03636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a5a5d36d59921b38eeced52fd03636">&#9670;&nbsp;</a></span>getNumElementsPerStride()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::affine::AffineDmaStartOp::getNumElementsPerStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements to transfer per stride for this DMA op. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00307">307</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00294">isStrided()</a>.</p>

</div>
</div>
<a id="ae0493d01946d5d000e80a429c6561d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0493d01946d5d000e80a429c6561d3d">&#9670;&nbsp;</a></span>getOperationName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StringRef mlir::affine::AffineDmaStartOp::getOperationName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00285">285</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

</div>
</div>
<a id="a314d893f11826746c945abd69aefc031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314d893f11826746c945abd69aefc031">&#9670;&nbsp;</a></span>getSrcIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operand_range mlir::affine::AffineDmaStartOp::getSrcIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the source memref affine map indices for this DMA operation. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00155">155</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="AffineOps_8h_source.html#l00148">getSrcMap()</a>, and <a class="el" href="AffineOps_8h_source.html#l00133">getSrcMemRefOperandIndex()</a>.</p>

</div>
</div>
<a id="ab99daa6c36f6be1fa8681dee1798f230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99daa6c36f6be1fa8681dee1798f230">&#9670;&nbsp;</a></span>getSrcMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::affine::AffineDmaStartOp::getSrcMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the affine map used to access the source memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00148">148</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00149">getSrcMapAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00167">getDstMemRefOperandIndex()</a>, and <a class="el" href="AffineOps_8h_source.html#l00155">getSrcIndices()</a>.</p>

</div>
</div>
<a id="a3be21265ff48e92ba3ff8163756812d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be21265ff48e92ba3ff8163756812d3">&#9670;&nbsp;</a></span>getSrcMapAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AffineMapAttr mlir::affine::AffineDmaStartOp::getSrcMapAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00149">149</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00281">getSrcMapAttrStrName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00245">getAffineMapAttrForMemRef()</a>, and <a class="el" href="AffineOps_8h_source.html#l00148">getSrcMap()</a>.</p>

</div>
</div>
<a id="a5e3ffce399728b8007b7f2becfdfe365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3ffce399728b8007b7f2becfdfe365">&#9670;&nbsp;</a></span>getSrcMapAttrStrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StringRef mlir::affine::AffineDmaStartOp::getSrcMapAttrStrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00281">281</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00245">getAffineMapAttrForMemRef()</a>, and <a class="el" href="AffineOps_8h_source.html#l00149">getSrcMapAttr()</a>.</p>

</div>
</div>
<a id="a29d6fdcfb7f415fcc5d78199a78fed7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d6fdcfb7f415fcc5d78199a78fed7c">&#9670;&nbsp;</a></span>getSrcMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::affine::AffineDmaStartOp::getSrcMemorySpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the memory space of the source memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00162">162</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00136">getSrcMemRef()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00259">isDestMemorySpaceFaster()</a>, and <a class="el" href="AffineOps_8h_source.html#l00264">isSrcMemorySpaceFaster()</a>.</p>

</div>
</div>
<a id="ae538ff0513111a50865f0d16f67abdbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae538ff0513111a50865f0d16f67abdbe">&#9670;&nbsp;</a></span>getSrcMemRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::affine::AffineDmaStartOp::getSrcMemRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the source MemRefType for this DMA operation. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00136">136</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00133">getSrcMemRefOperandIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00245">getAffineMapAttrForMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00162">getSrcMemorySpace()</a>, and <a class="el" href="AffineOps_8h_source.html#l00140">getSrcMemRefType()</a>.</p>

</div>
</div>
<a id="abc9fc1f32c984857deb613e4ee6fb407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9fc1f32c984857deb613e4ee6fb407">&#9670;&nbsp;</a></span>getSrcMemRefMutable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a>&amp; mlir::affine::AffineDmaStartOp::getSrcMemRefMutable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00137">137</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00112">mlir::Op&lt; AffineDmaStartOp, OpTrait::MemRefsNormalizable, OpTrait::VariadicOperands, OpTrait::ZeroResults, OpTrait::OpInvariants, AffineMapAccessInterface::Trait, MemoryEffectOpInterface::Trait &gt;::getOperation()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00388">mlir::Operation::getOpOperand()</a>, and <a class="el" href="AffineOps_8h_source.html#l00133">getSrcMemRefOperandIndex()</a>.</p>

</div>
</div>
<a id="a6cde3d6b340c303a5e08b8b11e709c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cde3d6b340c303a5e08b8b11e709c7e">&#9670;&nbsp;</a></span>getSrcMemRefOperandIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::affine::AffineDmaStartOp::getSrcMemRefOperandIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the operand index of the source memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00133">133</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00167">getDstMemRefOperandIndex()</a>, <a class="el" href="AffineOps_8h_source.html#l00155">getSrcIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00136">getSrcMemRef()</a>, and <a class="el" href="AffineOps_8h_source.html#l00137">getSrcMemRefMutable()</a>.</p>

</div>
</div>
<a id="a30727f03a0ffac2321ce847d6ac596f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30727f03a0ffac2321ce847d6ac596f7">&#9670;&nbsp;</a></span>getSrcMemRefRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::affine::AffineDmaStartOp::getSrcMemRefRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank (number of indices) of the source MemRefType. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00145">145</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00140">getSrcMemRefType()</a>.</p>

</div>
</div>
<a id="aa85270f869e3053952dc85eae6d36281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85270f869e3053952dc85eae6d36281">&#9670;&nbsp;</a></span>getSrcMemRefType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MemRefType mlir::affine::AffineDmaStartOp::getSrcMemRefType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00140">140</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00136">getSrcMemRef()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00145">getSrcMemRefRank()</a>.</p>

</div>
</div>
<a id="acfb451f83a12780d323f7610baaa52c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb451f83a12780d323f7610baaa52c2">&#9670;&nbsp;</a></span>getStride()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::affine::AffineDmaStartOp::getStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the stride value for this DMA operation. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00300">300</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00294">isStrided()</a>.</p>

</div>
</div>
<a id="aec6891b2d37503d0191e6322bab3ac33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6891b2d37503d0191e6322bab3ac33">&#9670;&nbsp;</a></span>getTagIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operand_range mlir::affine::AffineDmaStartOp::getTagIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tag memref indices for this DMA operation. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00231">231</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="AffineOps_8h_source.html#l00224">getTagMap()</a>, and <a class="el" href="AffineOps_8h_source.html#l00205">getTagMemRefOperandIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00152">checkTagMatch()</a>.</p>

</div>
</div>
<a id="acb26efcda7503fd685d4821dce36afe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb26efcda7503fd685d4821dce36afe4">&#9670;&nbsp;</a></span>getTagMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::affine::AffineDmaStartOp::getTagMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the affine map used to access the tag memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00224">224</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00225">getTagMapAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00238">getNumElements()</a>, <a class="el" href="AffineOps_8h_source.html#l00231">getTagIndices()</a>, and <a class="el" href="AffineOps_8h_source.html#l00294">isStrided()</a>.</p>

</div>
</div>
<a id="a2d302e9a31e509038dcc559f5a96e5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d302e9a31e509038dcc559f5a96e5f2">&#9670;&nbsp;</a></span>getTagMapAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AffineMapAttr mlir::affine::AffineDmaStartOp::getTagMapAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00225">225</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00283">getTagMapAttrStrName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00245">getAffineMapAttrForMemRef()</a>, and <a class="el" href="AffineOps_8h_source.html#l00224">getTagMap()</a>.</p>

</div>
</div>
<a id="a74fe3d905737d38b5af8eedf542bacfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fe3d905737d38b5af8eedf542bacfa">&#9670;&nbsp;</a></span>getTagMapAttrStrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StringRef mlir::affine::AffineDmaStartOp::getTagMapAttrStrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00283">283</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00245">getAffineMapAttrForMemRef()</a>, and <a class="el" href="AffineOps_8h_source.html#l00225">getTagMapAttr()</a>.</p>

</div>
</div>
<a id="a01b9ff2451de31dbe10bbc380bcb88d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b9ff2451de31dbe10bbc380bcb88d7">&#9670;&nbsp;</a></span>getTagMemRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::affine::AffineDmaStartOp::getTagMemRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Tag MemRef for this DMA operation. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00210">210</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00205">getTagMemRefOperandIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00152">checkTagMatch()</a>, <a class="el" href="AffineOps_8h_source.html#l00245">getAffineMapAttrForMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00219">getTagMemRefRank()</a>, and <a class="el" href="AffineOps_8h_source.html#l00214">getTagMemRefType()</a>.</p>

</div>
</div>
<a id="abbb30131d4c6a45d7dd5bbebe91e51b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb30131d4c6a45d7dd5bbebe91e51b2">&#9670;&nbsp;</a></span>getTagMemRefMutable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a>&amp; mlir::affine::AffineDmaStartOp::getTagMemRefMutable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00211">211</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00112">mlir::Op&lt; AffineDmaStartOp, OpTrait::MemRefsNormalizable, OpTrait::VariadicOperands, OpTrait::ZeroResults, OpTrait::OpInvariants, AffineMapAccessInterface::Trait, MemoryEffectOpInterface::Trait &gt;::getOperation()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00388">mlir::Operation::getOpOperand()</a>, and <a class="el" href="AffineOps_8h_source.html#l00205">getTagMemRefOperandIndex()</a>.</p>

</div>
</div>
<a id="a739272ea8d27f17c08aca9595cb0c9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739272ea8d27f17c08aca9595cb0c9a4">&#9670;&nbsp;</a></span>getTagMemRefOperandIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::affine::AffineDmaStartOp::getTagMemRefOperandIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the operand index of the tag memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00205">205</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00191">getDstMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00167">getDstMemRefOperandIndex()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00238">getNumElements()</a>, <a class="el" href="AffineOps_8h_source.html#l00231">getTagIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00210">getTagMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00211">getTagMemRefMutable()</a>, and <a class="el" href="AffineOps_8h_source.html#l00294">isStrided()</a>.</p>

</div>
</div>
<a id="a16b0d327dd9591680e2d9ae4484221a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b0d327dd9591680e2d9ae4484221a6">&#9670;&nbsp;</a></span>getTagMemRefRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::affine::AffineDmaStartOp::getTagMemRefRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank (number of indices) of the tag MemRefType. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00219">219</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00210">getTagMemRef()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>.</p>

</div>
</div>
<a id="aad6155a4d70419c964029508747fb2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6155a4d70419c964029508747fb2e1">&#9670;&nbsp;</a></span>getTagMemRefType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MemRefType mlir::affine::AffineDmaStartOp::getTagMemRefType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00214">214</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00210">getTagMemRef()</a>, and <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>.</p>

</div>
</div>
<a id="a0a1da5351dac17136aec768e3825e422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1da5351dac17136aec768e3825e422">&#9670;&nbsp;</a></span>isDestMemorySpaceFaster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::AffineDmaStartOp::isDestMemorySpaceFaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this is a DMA from a faster memory space to a slower one. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00259">259</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00186">getDstMemorySpace()</a>, and <a class="el" href="AffineOps_8h_source.html#l00162">getSrcMemorySpace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00272">getFasterMemPos()</a>.</p>

</div>
</div>
<a id="a07cb5491e6651433a3e1af5dca532a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cb5491e6651433a3e1af5dca532a41">&#9670;&nbsp;</a></span>isSrcMemorySpaceFaster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::AffineDmaStartOp::isSrcMemorySpaceFaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this is a DMA from a slower memory space to a faster one. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00264">264</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00186">getDstMemorySpace()</a>, and <a class="el" href="AffineOps_8h_source.html#l00162">getSrcMemorySpace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00272">getFasterMemPos()</a>.</p>

</div>
</div>
<a id="a3d9d1b60dd4ffe76c6aae25fe9524700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9d1b60dd4ffe76c6aae25fe9524700">&#9670;&nbsp;</a></span>isStrided()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::AffineDmaStartOp::isStrided </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this DMA operation is strided, returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00294">294</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="AffineOps_8h_source.html#l00224">getTagMap()</a>, and <a class="el" href="AffineOps_8h_source.html#l00205">getTagMemRefOperandIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00307">getNumElementsPerStride()</a>, and <a class="el" href="AffineOps_8h_source.html#l00300">getStride()</a>.</p>

</div>
</div>
<a id="abe9f320696122f31b6b22509d137d33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9f320696122f31b6b22509d137d33d">&#9670;&nbsp;</a></span>Op() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::<a class="el" href="classmlir_1_1Op.html">Op</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a public constructor. Any op can be initialized to null. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01721">1721</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a5905d939c92414ac6cce2c7d54f8f05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5905d939c92414ac6cce2c7d54f8f05e">&#9670;&nbsp;</a></span>Op() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::<a class="el" href="classmlir_1_1Op.html">Op</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a public constructor to enable access via the llvm::cast family of methods. </p>
<p>This should not be used directly. </p>

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01726">1726</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="a25b3a86209028ced4a8405877fb51b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b3a86209028ced4a8405877fb51b5b">&#9670;&nbsp;</a></span>Op() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Op.html">mlir::Op</a>&lt; ConcreteType, Traits &gt;::<a class="el" href="classmlir_1_1Op.html">Op</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l01722">1722</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

</div>
</div>
<a id="acbb973563b8e0821187ad21c800bf595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb973563b8e0821187ad21c800bf595">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult AffineDmaStartOp::parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01794">1794</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00954">mlir::OperationState::attributes</a>, <a class="el" href="classmlir_1_1AsmParser.html#a33803273c4fc1a660d73cb91aceac30b">mlir::AsmParser::emitError()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00050">mlir::Builder::getIndexType()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a8d00f93debeb1567ae8f7bbb76cdea37">mlir::AsmParser::getNameLoc()</a>, <a class="el" href="OperationSupport_8h_source.html#l00951">mlir::OperationState::operands</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a55ebc9079a03a42c71c883b21e733dfa">mlir::OpAsmParser::parseAffineMapOfSSAIds()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a1313f3689e72471402e478d479ff269b">mlir::AsmParser::parseColonTypeList()</a>, <a class="el" href="classmlir_1_1AsmParser.html#ac6ae46c606240d5588dbd91262f3a9a4">mlir::AsmParser::parseComma()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#ac30f229849bfc580b251da20cc8923ee">mlir::OpAsmParser::parseOperand()</a>, <a class="el" href="OpImplementation_8h_source.html#l01618">mlir::OpAsmParser::parseTrailingOperandList()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a8c583b0d425ac93c7f8a867f5546db6a">mlir::OpAsmParser::resolveOperand()</a>, and <a class="el" href="OpImplementation_8h_source.html#l01634">mlir::OpAsmParser::resolveOperands()</a>.</p>

</div>
</div>
<a id="a4a378a1f108aa52ebda32f5df80c4e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a378a1f108aa52ebda32f5df80c4e3e">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineDmaStartOp::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01772">1772</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LLVMDialect_8cpp_source.html#l03178">getNumElements()</a>, <a class="el" href="AMXDialect_8cpp_source.html#l00085">getStride()</a>, and <a class="el" href="classmlir_1_1OpAsmPrinter.html#aa04de9fec0531cddf28646b119a770af">mlir::OpAsmPrinter::printAffineMapOfSSAIds()</a>.</p>

</div>
</div>
<a id="aa0547127e5437bd1bbf68943f447be4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0547127e5437bd1bbf68943f447be4c">&#9670;&nbsp;</a></span>verifyInvariants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::AffineDmaStartOp::verifyInvariants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00289">289</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01870">verifyInvariantsImpl()</a>.</p>

</div>
</div>
<a id="a782e830a8d8657b8df21c5a42491e247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782e830a8d8657b8df21c5a42491e247">&#9670;&nbsp;</a></span>verifyInvariantsImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult AffineDmaStartOp::verifyInvariantsImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01870">1870</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00265">mlir::affine::getAffineScope()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00490">isValidAffineIndexOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00289">verifyInvariants()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Dialect/Affine/IR/<a class="el" href="AffineOps_8h_source.html">AffineOps.h</a></li>
<li>lib/Dialect/Affine/IR/<a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:30 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
