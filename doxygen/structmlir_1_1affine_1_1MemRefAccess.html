<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::affine::MemRefAccess Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1affine.html">affine</a></li><li class="navelem"><a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structmlir_1_1affine_1_1MemRefAccess-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::affine::MemRefAccess Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulates a memref load or store access information.  
 <a href="structmlir_1_1affine_1_1MemRefAccess.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="AffineAnalysis_8h_source.html">mlir/Dialect/Affine/Analysis/AffineAnalysis.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aac4047ddb486d05784d6902562a8306d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html#aac4047ddb486d05784d6902562a8306d">MemRefAccess</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *memOp)</td></tr>
<tr class="memdesc:aac4047ddb486d05784d6902562a8306d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html" title="Encapsulates a memref load or store access information.">MemRefAccess</a> from an affine read/write operation.  <a href="structmlir_1_1affine_1_1MemRefAccess.html#aac4047ddb486d05784d6902562a8306d">More...</a><br /></td></tr>
<tr class="separator:aac4047ddb486d05784d6902562a8306d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf51296504b5089513d8734b71ecd19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html#afcf51296504b5089513d8734b71ecd19">MemRefAccess</a> ()=default</td></tr>
<tr class="separator:afcf51296504b5089513d8734b71ecd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526c91a17c33ec0ecd61e02f8a9dc727"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html#a526c91a17c33ec0ecd61e02f8a9dc727">getRank</a> () const</td></tr>
<tr class="separator:a526c91a17c33ec0ecd61e02f8a9dc727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43e1a81b38be947541f999798c21698"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html#ad43e1a81b38be947541f999798c21698">isStore</a> () const</td></tr>
<tr class="separator:ad43e1a81b38be947541f999798c21698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61324ba40f7e6e38f5edad6c9fb0a0ac"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html#a61324ba40f7e6e38f5edad6c9fb0a0ac">getAccessRelation</a> (<a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">presburger::IntegerRelation</a> &amp;accessRel) const</td></tr>
<tr class="memdesc:a61324ba40f7e6e38f5edad6c9fb0a0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an access relation for the access.  <a href="structmlir_1_1affine_1_1MemRefAccess.html#a61324ba40f7e6e38f5edad6c9fb0a0ac">More...</a><br /></td></tr>
<tr class="separator:a61324ba40f7e6e38f5edad6c9fb0a0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da32e1a020733c74c768fd5e8283efc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html#a8da32e1a020733c74c768fd5e8283efc">getAccessMap</a> (<a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html">AffineValueMap</a> *accessMap) const</td></tr>
<tr class="memdesc:a8da32e1a020733c74c768fd5e8283efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'accessMap' with composition of AffineApplyOps reachable from 'indices'.  <a href="structmlir_1_1affine_1_1MemRefAccess.html#a8da32e1a020733c74c768fd5e8283efc">More...</a><br /></td></tr>
<tr class="separator:a8da32e1a020733c74c768fd5e8283efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85886d92df14c563fc1857b0d85911c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html#ac85886d92df14c563fc1857b0d85911c">operator==</a> (const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ac85886d92df14c563fc1857b0d85911c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal if both affine accesses can be proved to be equivalent at compile time (considering the memrefs, their respective affine access maps and operands).  <a href="structmlir_1_1affine_1_1MemRefAccess.html#ac85886d92df14c563fc1857b0d85911c">More...</a><br /></td></tr>
<tr class="separator:ac85886d92df14c563fc1857b0d85911c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83473ee0122e6f6502c32193c23dee3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html#a83473ee0122e6f6502c32193c23dee3d">operator!=</a> (const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;rhs) const</td></tr>
<tr class="separator:a83473ee0122e6f6502c32193c23dee3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c6a416642dd63219952c5560b412fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html#a71c6a416642dd63219952c5560b412fe">operator bool</a> () const</td></tr>
<tr class="separator:a71c6a416642dd63219952c5560b412fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aff7b7db75286dfd542235e3d6429c02c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html#aff7b7db75286dfd542235e3d6429c02c">memref</a></td></tr>
<tr class="separator:aff7b7db75286dfd542235e3d6429c02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae057bb8649717fe420a2b448aa468920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html#ae057bb8649717fe420a2b448aa468920">opInst</a> = nullptr</td></tr>
<tr class="separator:ae057bb8649717fe420a2b448aa468920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e1ca4370ce7299f4adf320ccba4c21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html#a56e1ca4370ce7299f4adf320ccba4c21">indices</a></td></tr>
<tr class="separator:a56e1ca4370ce7299f4adf320ccba4c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates a memref load or store access information. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00082">82</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aac4047ddb486d05784d6902562a8306d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4047ddb486d05784d6902562a8306d">&#9670;&nbsp;</a></span>MemRefAccess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MemRefAccess::MemRefAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>memOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html" title="Encapsulates a memref load or store access information.">MemRefAccess</a> from an affine read/write operation. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02038">2038</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="afcf51296504b5089513d8734b71ecd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf51296504b5089513d8734b71ecd19">&#9670;&nbsp;</a></span>MemRefAccess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::affine::MemRefAccess::MemRefAccess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8da32e1a020733c74c768fd5e8283efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da32e1a020733c74c768fd5e8283efc">&#9670;&nbsp;</a></span>getAccessMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemRefAccess::getAccessMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html">AffineValueMap</a> *&#160;</td>
          <td class="paramname"><em>accessMap</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates 'accessMap' with composition of AffineApplyOps reachable from 'indices'. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00507">507</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01619">mlir::affine::canonicalizeMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01260">mlir::affine::fullyComposeAffineMapAndOperands()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00020">mlir::affine::AffineValueMap::reset()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00766">mlir::simplifyAffineMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02081">operator==()</a>.</p>

</div>
</div>
<a id="a61324ba40f7e6e38f5edad6c9fb0a0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61324ba40f7e6e38f5edad6c9fb0a0ac">&#9670;&nbsp;</a></span>getAccessRelation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult MemRefAccess::getAccessRelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">presburger::IntegerRelation</a> &amp;&#160;</td>
          <td class="paramname"><em>accessRel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an access relation for the access. </p>
<p>An access relation maps elements of an iteration domain to the element(s) of an array domain accessed by that iteration of the associated statement through some array reference. For example, given the MLIR code:</p>
<p>affine.for i0 = 0 to 10 { affine.for i1 = 0 to 10 { a = affine.load arr[i0 + i1, i0 + 2 * i1] : memref&lt;100x100xf32&gt; } }</p>
<p>The access relation, assuming that the memory locations for arr are represented as m0, m1 would be:</p>
<p>(i0, i1) -&gt; (m0, m1) m0 = i0 + i1 m1 = i0 + 2 * i1 0 &lt;= i0 &lt; 10 0 &lt;= i1 &lt; 10</p>
<p>Returns failure for yet unimplemented/unsupported cases (see docs of mlir::getIndexSet and mlir::getRelationFromMap for these cases). </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00457">457</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00079">mlir::presburger::IntegerRelation::append()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00357">mlir::presburger::IntegerRelation::appendVar()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01451">mlir::presburger::IntegerRelation::convertVarKind()</a>, <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00073">mlir::presburger::IntegerRelation::getIds()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00075">mlir::affine::AffineValueMap::getNumDims()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00217">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00077">mlir::affine::AffineValueMap::getNumResults()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00282">getOpIndexSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00499">mlir::affine::getRelationFromMap()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00121">mlir::presburger::IntegerRelation::getSpace()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00354">mlir::FlatLinearValueConstraints::getValue()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00348">mlir::presburger::IntegerRelation::insertVar()</a>, <a class="el" href="PresburgerSpace_8h_source.html#l00284">mlir::presburger::PresburgerSpace::isUsingIds()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01303">mlir::presburger::IntegerRelation::mergeAndAlignSymbols()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01345">mlir::presburger::IntegerRelation::mergeLocalVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00139">mlir::presburger::IntegerRelation::resetIds()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00065">mlir::presburger::IntegerRelation::setId()</a>, and <a class="el" href="IntegerRelation_8cpp_source.html#l00456">mlir::presburger::IntegerRelation::swapVar()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00608">mlir::affine::checkMemrefAccessDependence()</a>.</p>

</div>
</div>
<a id="a526c91a17c33ec0ecd61e02f8a9dc727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526c91a17c33ec0ecd61e02f8a9dc727">&#9670;&nbsp;</a></span>getRank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MemRefAccess::getRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02053">2053</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>.</p>

</div>
</div>
<a id="ad43e1a81b38be947541f999798c21698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43e1a81b38be947541f999798c21698">&#9670;&nbsp;</a></span>isStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MemRefAccess::isStore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02057">2057</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>.</p>

</div>
</div>
<a id="a71c6a416642dd63219952c5560b412fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c6a416642dd63219952c5560b412fe">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::affine::MemRefAccess::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00134">134</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8h_source.html#l00083">memref</a>.</p>

</div>
</div>
<a id="a83473ee0122e6f6502c32193c23dee3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83473ee0122e6f6502c32193c23dee3d">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::MemRefAccess::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00132">132</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>

</div>
</div>
<a id="ac85886d92df14c563fc1857b0d85911c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85886d92df14c563fc1857b0d85911c">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MemRefAccess::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equal if both affine accesses can be proved to be equivalent at compile time (considering the memrefs, their respective affine access maps and operands). </p>
<p>Equal if both affine accesses are provably equivalent (at compile time) when considering the memref, the affine maps and their respective operands.</p>
<p>The equality of access functions + operands is checked by subtracting fully composed value maps, and then simplifying the difference using the expression flattener. This does not account for aliasing of memrefs.</p>
<p>The equality of access functions + operands is checked by subtracting fully composed value maps, and then simplifying the difference using the expression flattener. TODO: this does not account for aliasing of memrefs. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02081">2081</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00507">getAccessMap()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00083">memref</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a56e1ca4370ce7299f4adf320ccba4c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e1ca4370ce7299f4adf320ccba4c21">&#9670;&nbsp;</a></span>indices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, 4&gt; mlir::affine::MemRefAccess::indices</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00085">85</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>

</div>
</div>
<a id="aff7b7db75286dfd542235e3d6429c02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7b7db75286dfd542235e3d6429c02c">&#9670;&nbsp;</a></span>memref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::affine::MemRefAccess::memref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00083">83</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00608">mlir::affine::checkMemrefAccessDependence()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">mlir::affine::computeSliceUnion()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00264">mayDependence()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00654">mayHaveEffect()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00134">operator bool()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02081">operator==()</a>.</p>

</div>
</div>
<a id="ae057bb8649717fe420a2b448aa468920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae057bb8649717fe420a2b448aa468920">&#9670;&nbsp;</a></span>opInst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a>* mlir::affine::MemRefAccess::opInst = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00084">84</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00608">mlir::affine::checkMemrefAccessDependence()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">mlir::affine::computeSliceUnion()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00520">mlir::affine::isTilingValid()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00636">mustReachAtInnermost()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00355">srcAppearsBeforeDstInAncestralBlock()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/mlir/Dialect/Affine/Analysis/<a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a></li>
<li>lib/Dialect/Affine/Analysis/<a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a></li>
<li>lib/Dialect/Affine/Analysis/<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 27 2025 16:33:10 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
