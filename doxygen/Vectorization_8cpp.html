<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Linalg/Transforms/Vectorization.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a href="dir_8edb792440615361a0811a7329611599.html">Linalg</a></li><li class="navelem"><a href="dir_7e2f808e77498894ca0efbd745da2201.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Vectorization.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Dialect_2Affine_2Utils_8h_source.html">mlir/Dialect/Affine/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SliceAnalysis_8h_source.html">mlir/Analysis/SliceAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Arith_2IR_2Arith_8h_source.html">mlir/Dialect/Arith/IR/Arith.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="FuncOps_8h_source.html">mlir/Dialect/Func/IR/FuncOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Linalg_2IR_2Linalg_8h_source.html">mlir/Dialect/Linalg/IR/Linalg.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">mlir/Dialect/Linalg/Transforms/Transforms.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">mlir/Dialect/Linalg/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Tensor_2IR_2Tensor_8h_source.html">mlir/Dialect/Tensor/IR/Tensor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IndexingUtils_8h_source.html">mlir/Dialect/Utils/IndexingUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StructuredOpsUtils_8h_source.html">mlir/Dialect/Utils/StructuredOpsUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VectorOps_8h_source.html">mlir/Dialect/Vector/IR/VectorOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MaskableOpInterface_8h_source.html">mlir/Dialect/Vector/Interfaces/MaskableOpInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VectorUtils_8h_source.html">mlir/Dialect/Vector/Utils/VectorUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">mlir/IR/AffineExpr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineMap_8h_source.html">mlir/IR/AffineMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Builders_8h_source.html">mlir/IR/Builders.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="BuiltinTypeInterfaces_8h_source.html">mlir/IR/BuiltinTypeInterfaces.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html">mlir/IR/BuiltinTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OpDefinition_8h_source.html">mlir/IR/OpDefinition.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Value_8h_source.html">mlir/IR/Value.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Support_2LLVM_8h_source.html">mlir/Support/LLVM.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="RegionUtils_8h_source.html">mlir/Transforms/RegionUtils.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/Sequence.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/TypeSwitch.h&quot;</code><br />
<code>#include &quot;llvm/Support/DebugLog.h&quot;</code><br />
<code>#include &quot;llvm/Support/InterleavedRange.h&quot;</code><br />
<code>#include &quot;llvm/Support/MathExtras.h&quot;</code><br />
<code>#include &quot;llvm/Support/raw_ostream.h&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
</div>
<p><a href="Vectorization_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:VectorizationState" id="r_VectorizationState"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVectorizationState.html">VectorizationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the vectorization state and related methods used across the vectorization process of a given operation.  <a href="structVectorizationState.html#details">More...</a><br /></td></tr>
<tr class="memitem:VectorizationHookResult" id="r_VectorizationHookResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVectorizationHookResult.html">VectorizationHookResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structVectorizationHookResult.html" title="VectorizationHookResult contains the vectorized op returned from a CustomVectorizationHook.">VectorizationHookResult</a> contains the vectorized op returned from a <a class="el" href="#ac9d5de1ac70bcbcc2f773e554a39bd1e">CustomVectorizationHook</a>.  <a href="structVectorizationHookResult.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d" id="r_ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;linalg-vectorization&quot;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a765387385c36b8245aca7e886c0e98fb" id="r_a765387385c36b8245aca7e886c0e98fb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a765387385c36b8245aca7e886c0e98fb">CustomVectorizationPrecondition</a></td></tr>
<tr class="memitem:ac9d5de1ac70bcbcc2f773e554a39bd1e" id="r_ac9d5de1ac70bcbcc2f773e554a39bd1e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9d5de1ac70bcbcc2f773e554a39bd1e">CustomVectorizationHook</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a88081210ed22e2f80c50dd07348f3fec" id="r_a88081210ed22e2f80c50dd07348f3fec"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88081210ed22e2f80c50dd07348f3fec">Conv1DOpOrder</a> { <a class="el" href="#a88081210ed22e2f80c50dd07348f3feca61e9c06ea9a85a5088a499df6458d276">W</a>
, <a class="el" href="#a88081210ed22e2f80c50dd07348f3feca93d1093d4ebc345b0e2d3520c41ca741">Ncw</a>
, <a class="el" href="#a88081210ed22e2f80c50dd07348f3fecacca9538f495516027540f166e6ca3ba3">Nwc</a>
 }</td></tr>
<tr class="memdesc:a88081210ed22e2f80c50dd07348f3fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper enum to represent conv1d input traversal order.  <a href="#a88081210ed22e2f80c50dd07348f3fec">More...</a><br /></td></tr>
<tr class="memitem:a894a3a33f4cfc348a3aced8a058b550a" id="r_a894a3a33f4cfc348a3aced8a058b550a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a894a3a33f4cfc348a3aced8a058b550a">VectorizationHookStatus</a> { <a class="el" href="#a894a3a33f4cfc348a3aced8a058b550aa6fb01c5d76aa5b0825fd3c52dc5f3661">Failure</a> = 0
, <a class="el" href="#a894a3a33f4cfc348a3aced8a058b550aaf97b2f48071b6944652bfffb71351c8f">NoReplace</a>
, <a class="el" href="#a894a3a33f4cfc348a3aced8a058b550aaaaf8d13847a58092eb64f52b2bed99c6">NewOp</a>
 }</td></tr>
<tr class="memdesc:a894a3a33f4cfc348a3aced8a058b550a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper data structure to represent the result of vectorization for a single operation.  <a href="#a894a3a33f4cfc348a3aced8a058b550a">More...</a><br /></td></tr>
<tr class="memitem:a224b215237fb8401f7031f2991266dcc" id="r_a224b215237fb8401f7031f2991266dcc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a224b215237fb8401f7031f2991266dcc">VectorMemoryAccessKind</a> { <a class="el" href="#a224b215237fb8401f7031f2991266dccae08c87afc59477607178b88f356268ca">ScalarBroadcast</a>
, <a class="el" href="#a224b215237fb8401f7031f2991266dcca1910b77e1772ac1536cb49936f8c32ea">Contiguous</a>
, <a class="el" href="#a224b215237fb8401f7031f2991266dccaceba1db2e3b2f5aa1258aae0105e2a4d">Gather</a>
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a320b06f6c6f3905541d59f2c33ce5aea" id="r_a320b06f6c6f3905541d59f2c33ce5aea"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a320b06f6c6f3905541d59f2c33ce5aea">vectorizeConvolution</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp convOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; inputVecSizes={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; inputVecScalableFlags={}, <a class="el" href="classbool.html">bool</a> flatten1DDepthwiseConv=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a320b06f6c6f3905541d59f2c33ce5aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to vectorize <span class="tt">convOp</span> as a convolution.  <br /></td></tr>
<tr class="memitem:a298ab89fe37b4d0e351c2d1619476926" id="r_a298ab89fe37b4d0e351c2d1619476926"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a298ab89fe37b4d0e351c2d1619476926">vectorizeAsInsertSliceOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::InsertSliceOp sliceOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; inputVectorSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;newResults)</td></tr>
<tr class="memdesc:a298ab89fe37b4d0e351c2d1619476926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorize tensor::InsertSliceOp with:  <br /></td></tr>
<tr class="memitem:a51c7625311de4f665ab3c2cde71709ec" id="r_a51c7625311de4f665ab3c2cde71709ec"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51c7625311de4f665ab3c2cde71709ec">getStaticPadVal</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a51c7625311de4f665ab3c2cde71709ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the effective Pad value for the input op, provided it's a scalar.  <br /></td></tr>
<tr class="memitem:ab37ae3178304b744d6b0249a60a6e7a3" id="r_ab37ae3178304b744d6b0249a60a6e7a3"><td class="memTemplParams" colspan="2">template&lt;typename OpType&gt; </td></tr>
<tr class="memitem:ab37ae3178304b744d6b0249a60a6e7a3 template"><td class="memItemLeft" align="right" valign="top">static OpType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab37ae3178304b744d6b0249a60a6e7a3">getSingleOpOfType</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> &amp;block)</td></tr>
<tr class="memdesc:ab37ae3178304b744d6b0249a60a6e7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unique instance of OpType in <span class="tt">block</span> if it is indeed unique.  <br /></td></tr>
<tr class="memitem:a200fa245f199890432efcd7596b5e672" id="r_a200fa245f199890432efcd7596b5e672"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a200fa245f199890432efcd7596b5e672">extractConvInputSlices</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> input, <a class="el" href="classint64__t.html">int64_t</a> nSize, <a class="el" href="classint64__t.html">int64_t</a> wSize, <a class="el" href="classint64__t.html">int64_t</a> cSize, <a class="el" href="classint64__t.html">int64_t</a> kwSize, int strideW, int dilationW, <a class="el" href="classint64__t.html">int64_t</a> wSizeStep, <a class="el" href="classbool.html">bool</a> isSingleChanneled)</td></tr>
<tr class="memdesc:a200fa245f199890432efcd7596b5e672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to extract the input slices after filter is unrolled along kw.  <br /></td></tr>
<tr class="memitem:a5fd4201faa9fbc0aad08b5af06556cc8" id="r_a5fd4201faa9fbc0aad08b5af06556cc8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fd4201faa9fbc0aad08b5af06556cc8">extractConvFilterSlices</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> filter, <a class="el" href="classint64__t.html">int64_t</a> kwSize)</td></tr>
<tr class="memdesc:a5fd4201faa9fbc0aad08b5af06556cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to extract the filter slices after filter is unrolled along kw.  <br /></td></tr>
<tr class="memitem:af0d6a3da24bf08205af9661c55447701" id="r_af0d6a3da24bf08205af9661c55447701"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0d6a3da24bf08205af9661c55447701">extractConvResultSlices</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> res, <a class="el" href="classint64__t.html">int64_t</a> nSize, <a class="el" href="classint64__t.html">int64_t</a> wSize, <a class="el" href="classint64__t.html">int64_t</a> fSize, <a class="el" href="classint64__t.html">int64_t</a> wSizeStep, <a class="el" href="classbool.html">bool</a> isSingleChanneled)</td></tr>
<tr class="memdesc:af0d6a3da24bf08205af9661c55447701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to extract the result slices after filter is unrolled along kw.  <br /></td></tr>
<tr class="memitem:a110d1ed6891097419f0358bd63e974c8" id="r_a110d1ed6891097419f0358bd63e974c8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a110d1ed6891097419f0358bd63e974c8">insertConvResultSlices</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> res, <a class="el" href="classint64__t.html">int64_t</a> wSize, <a class="el" href="classint64__t.html">int64_t</a> wSizeStep, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;resVals, <a class="el" href="classbool.html">bool</a> isSingleChanneled)</td></tr>
<tr class="memdesc:a110d1ed6891097419f0358bd63e974c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to insert the computed result slices.  <br /></td></tr>
<tr class="memitem:ace2ca9537983c711e37b040688830950" id="r_ace2ca9537983c711e37b040688830950"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace2ca9537983c711e37b040688830950">reindexIndexingMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:ace2ca9537983c711e37b040688830950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an indexing <span class="tt">map</span> coming from a LinalgOp indexing, restricted to a projectedPermutation, compress the unused dimensions to serve as a permutation_map for a vector transfer operation.  <br /></td></tr>
<tr class="memitem:a4c99d55a1274aa91b750b22a4a3c76e2" id="r_a4c99d55a1274aa91b750b22a4a3c76e2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c99d55a1274aa91b750b22a4a3c76e2">matchLinalgReduction</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *outputOperand)</td></tr>
<tr class="memdesc:a4c99d55a1274aa91b750b22a4a3c76e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether <span class="tt">outputOperand</span> is a reduction with a single combiner operation.  <br /></td></tr>
<tr class="memitem:ae3a45e985a37cbb4db1c7c23ce0d9e9f" id="r_ae3a45e985a37cbb4db1c7c23ce0d9e9f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3a45e985a37cbb4db1c7c23ce0d9e9f">broadcastIfNeeded</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Type.html">Type</a> dstType)</td></tr>
<tr class="memdesc:ae3a45e985a37cbb4db1c7c23ce0d9e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast <span class="tt">value</span> to a vector of <span class="tt">shape</span> if possible.  <br /></td></tr>
<tr class="memitem:af936802591fc5ba398ba106887feac8f" id="r_af936802591fc5ba398ba106887feac8f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af936802591fc5ba398ba106887feac8f">buildMultiDimReduce</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *reduceOp, <a class="el" href="classmlir_1_1Value.html">Value</a> valueToReduce, <a class="el" href="classmlir_1_1Value.html">Value</a> acc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; dimsToMask)</td></tr>
<tr class="memdesc:af936802591fc5ba398ba106887feac8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create MultiDimReductionOp to compute the reduction for <span class="tt">reductionOp</span>.  <br /></td></tr>
<tr class="memitem:a129f4ae5f0a8071a3f98c8f73ee729f9" id="r_a129f4ae5f0a8071a3f98c8f73ee729f9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a129f4ae5f0a8071a3f98c8f73ee729f9">getDimsToReduce</a> (LinalgOp linalgOp)</td></tr>
<tr class="memitem:a66021212cd375df8f87b79b0f01b7e19" id="r_a66021212cd375df8f87b79b0f01b7e19"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66021212cd375df8f87b79b0f01b7e19">hasReductionIterator</a> (LinalgOp &amp;op)</td></tr>
<tr class="memdesc:a66021212cd375df8f87b79b0f01b7e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <span class="tt">op</span> is a linalg.reduce or a linalg.generic that has at least one reduction iterator.  <br /></td></tr>
<tr class="memitem:a4ffeefd6b3cba67afe11ecdc2b48fcef" id="r_a4ffeefd6b3cba67afe11ecdc2b48fcef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ffeefd6b3cba67afe11ecdc2b48fcef">buildVectorWrite</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *outputOperand, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state)</td></tr>
<tr class="memdesc:a4ffeefd6b3cba67afe11ecdc2b48fcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a vector.transfer_write of <span class="tt">value</span> into <span class="tt">outputOperand</span> at indices set to all <span class="tt">0</span>; where <span class="tt">outputOperand</span> is an output operand of the LinalgOp currently being vectorized.  <br /></td></tr>
<tr class="memitem:af85a26f7c1860388d0e83d22745a27aa" id="r_af85a26f7c1860388d0e83d22745a27aa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structVectorizationHookResult.html">VectorizationHookResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af85a26f7c1860388d0e83d22745a27aa">vectorizeLinalgYield</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;bvm, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state, LinalgOp linalgOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;newResults)</td></tr>
<tr class="memdesc:af85a26f7c1860388d0e83d22745a27aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to vectorize the terminator of a <span class="tt">linalgOp</span>.  <br /></td></tr>
<tr class="memitem:a280bd1ab81d418cd32713eeb0a2dfffd" id="r_a280bd1ab81d418cd32713eeb0a2dfffd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structVectorizationHookResult.html">VectorizationHookResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a280bd1ab81d418cd32713eeb0a2dfffd">vectorizeLinalgIndex</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a280bd1ab81d418cd32713eeb0a2dfffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to vectorize the index operations of a <span class="tt">linalgOp</span>.  <br /></td></tr>
<tr class="memitem:ad09df73d48432e3de8291c7076164ba7" id="r_ad09df73d48432e3de8291c7076164ba7"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad09df73d48432e3de8291c7076164ba7">tensorExtractVectorizationPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classbool.html">bool</a> vectorizeNDExtract)</td></tr>
<tr class="memdesc:ad09df73d48432e3de8291c7076164ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to check if the tensor.extract can be vectorized by the custom hook vectorizeTensorExtract.  <br /></td></tr>
<tr class="memitem:ae4411a5d89520c86474035493a7da7c1" id="r_ae4411a5d89520c86474035493a7da7c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4411a5d89520c86474035493a7da7c1">calculateGatherOffset</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state, tensor::ExtractOp extractOp, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;bvm)</td></tr>
<tr class="memdesc:ae4411a5d89520c86474035493a7da7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the offsets (<span class="tt">$index_vec</span>) for <span class="tt">vector.gather</span> operations generated from <span class="tt">tensor.extract</span>.  <br /></td></tr>
<tr class="memitem:a7e9ce28bca426dd4de93ad09392b4ec1" id="r_a7e9ce28bca426dd4de93ad09392b4ec1"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e9ce28bca426dd4de93ad09392b4ec1">getTrailingNonUnitLoopDimIdx</a> (LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a7e9ce28bca426dd4de93ad09392b4ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of the trailing non-unit dim in linalgOp.  <br /></td></tr>
<tr class="memitem:a0bcdc4b64d42010b23b271435831cb39" id="r_a0bcdc4b64d42010b23b271435831cb39"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bcdc4b64d42010b23b271435831cb39">isLoopInvariantIdx</a> (LinalgOp &amp;linalgOp, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;val, VectorType resType)</td></tr>
<tr class="memdesc:a0bcdc4b64d42010b23b271435831cb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <span class="tt">val</span> can be used for calculating a loop invariant index.  <br /></td></tr>
<tr class="memitem:af2f7690c564bae0d01129c661bfcb1f3" id="r_af2f7690c564bae0d01129c661bfcb1f3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2f7690c564bae0d01129c661bfcb1f3">isContiguousLoadIdx</a> (LinalgOp &amp;linalgOp, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;val, <a class="el" href="classbool.html">bool</a> &amp;foundIndexOp, VectorType resType)</td></tr>
<tr class="memdesc:af2f7690c564bae0d01129c661bfcb1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether <span class="tt">val</span> could be used for calculating the trailing index for a contiguous load operation.  <br /></td></tr>
<tr class="memitem:a172594be3a7384cb03a833aed99dc03c" id="r_a172594be3a7384cb03a833aed99dc03c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a224b215237fb8401f7031f2991266dcc">VectorMemoryAccessKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a172594be3a7384cb03a833aed99dc03c">getTensorExtractMemoryAccessPattern</a> (tensor::ExtractOp extractOp, LinalgOp &amp;linalgOp, VectorType resType)</td></tr>
<tr class="memdesc:a172594be3a7384cb03a833aed99dc03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the memory access pattern for the input ExtractOp.  <br /></td></tr>
<tr class="memitem:a26cb5e24425fdce30baaba6f7c0f5c84" id="r_a26cb5e24425fdce30baaba6f7c0f5c84"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structVectorizationHookResult.html">VectorizationHookResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26cb5e24425fdce30baaba6f7c0f5c84">vectorizeTensorExtract</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, LinalgOp linalgOp, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;bvm)</td></tr>
<tr class="memdesc:a26cb5e24425fdce30baaba6f7c0f5c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to vectorize the tensor.extract operations.  <br /></td></tr>
<tr class="memitem:aae426acd0929292f99ebde650870d27b" id="r_aae426acd0929292f99ebde650870d27b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae426acd0929292f99ebde650870d27b">reduceIfNeeded</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, LinalgOp linalgOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> reduceValue, <a class="el" href="classmlir_1_1Value.html">Value</a> initialValue, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;bvm)</td></tr>
<tr class="memdesc:aae426acd0929292f99ebde650870d27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit reduction operations if the shapes of the value to reduce is different that the result shape.  <br /></td></tr>
<tr class="memitem:a455f83de6534e53da06be057973f7e38" id="r_a455f83de6534e53da06be057973f7e38"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structVectorizationHookResult.html">VectorizationHookResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a455f83de6534e53da06be057973f7e38">vectorizeOneOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state, LinalgOp linalgOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;bvm, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#ac9d5de1ac70bcbcc2f773e554a39bd1e">CustomVectorizationHook</a> &gt; customVectorizationHooks)</td></tr>
<tr class="memdesc:a455f83de6534e53da06be057973f7e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic vectorization for a single operation <span class="tt">op</span>, given already vectorized operands carried by <span class="tt">bvm</span>.  <br /></td></tr>
<tr class="memitem:a35e1ec347850959af0bc7cbdf61b9da3" id="r_a35e1ec347850959af0bc7cbdf61b9da3"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35e1ec347850959af0bc7cbdf61b9da3">vectorizeAsLinalgGeneric</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;state, LinalgOp linalgOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;newResults)</td></tr>
<tr class="memdesc:a35e1ec347850959af0bc7cbdf61b9da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic vectorization function that rewrites the body of a <span class="tt">linalgOp</span> into vector form.  <br /></td></tr>
<tr class="memitem:a1bedce144a30ca3ef5eac6628b35d4a9" id="r_a1bedce144a30ca3ef5eac6628b35d4a9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bedce144a30ca3ef5eac6628b35d4a9">isMaskTriviallyFoldable</a> (<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;maskSizes, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;writeIdxs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; destShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; maskShape)</td></tr>
<tr class="memdesc:a1bedce144a30ca3ef5eac6628b35d4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a mask for xfer_write is trivially "all true".  <br /></td></tr>
<tr class="memitem:a2d04989901c1df355793bb8a71328797" id="r_a2d04989901c1df355793bb8a71328797"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d04989901c1df355793bb8a71328797">createWriteOrMaskedWrite</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> vecToStore, <a class="el" href="classmlir_1_1Value.html">Value</a> dest, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; writeIndices={}, <a class="el" href="classbool.html">bool</a> useInBoundsInsteadOfMasking=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a2d04989901c1df355793bb8a71328797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optionally masked TransferWriteOp.  <br /></td></tr>
<tr class="memitem:a8019302085ef04a05864f2bb3f198f5c" id="r_a8019302085ef04a05864f2bb3f198f5c"><td class="memItemLeft" align="right" valign="top">static VectorType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8019302085ef04a05864f2bb3f198f5c">getCollapsedVecType</a> (VectorType type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; reassociation)</td></tr>
<tr class="memdesc:a8019302085ef04a05864f2bb3f198f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the re-associations, "collapses" the input <a class="el" href="structVector.html">Vector</a> type.  <br /></td></tr>
</table>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&#160;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;linalg-vectorization&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00050">50</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ac9d5de1ac70bcbcc2f773e554a39bd1e" name="ac9d5de1ac70bcbcc2f773e554a39bd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d5de1ac70bcbcc2f773e554a39bd1e">&#9670;&#160;</a></span>CustomVectorizationHook</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac9d5de1ac70bcbcc2f773e554a39bd1e">CustomVectorizationHook</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;<a class="code hl_struct" href="structVectorizationHookResult.html">VectorizationHookResult</a>(<a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *, <span class="keyword">const</span> <a class="code hl_class" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;)&gt;</div>
<div class="ttc" id="aclassmlir_1_1IRMapping_html"><div class="ttname"><a href="classmlir_1_1IRMapping.html">mlir::IRMapping</a></div><div class="ttdoc">This is a utility class for mapping one set of IR entities to another.</div><div class="ttdef"><b>Definition</b> <a href="IRMapping_8h_source.html#l00026">IRMapping.h:26</a></div></div>
<div class="ttc" id="aclassmlir_1_1Operation_html"><div class="ttname"><a href="classmlir_1_1Operation.html">mlir::Operation</a></div><div class="ttdoc">Operation is the basic unit of execution within MLIR.</div><div class="ttdef"><b>Definition</b> <a href="IR_2Operation_8h_source.html#l00084">Operation.h:88</a></div></div>
<div class="ttc" id="astructVectorizationHookResult_html"><div class="ttname"><a href="structVectorizationHookResult.html">VectorizationHookResult</a></div><div class="ttdoc">VectorizationHookResult contains the vectorized op returned from a CustomVectorizationHook.</div><div class="ttdef"><b>Definition</b> <a href="Vectorization_8cpp_source.html#l00629">Vectorization.cpp:629</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00793">793</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="a765387385c36b8245aca7e886c0e98fb" name="a765387385c36b8245aca7e886c0e98fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765387385c36b8245aca7e886c0e98fb">&#9670;&#160;</a></span>CustomVectorizationPrecondition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a765387385c36b8245aca7e886c0e98fb">CustomVectorizationPrecondition</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;LogicalResult(<a class="code hl_class" href="classmlir_1_1Operation.html">Operation</a> *, <span class="keywordtype">bool</span>)&gt;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00787">787</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a88081210ed22e2f80c50dd07348f3fec" name="a88081210ed22e2f80c50dd07348f3fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88081210ed22e2f80c50dd07348f3fec">&#9670;&#160;</a></span>Conv1DOpOrder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a88081210ed22e2f80c50dd07348f3fec">Conv1DOpOrder</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper enum to represent conv1d input traversal order. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a88081210ed22e2f80c50dd07348f3feca61e9c06ea9a85a5088a499df6458d276" name="a88081210ed22e2f80c50dd07348f3feca61e9c06ea9a85a5088a499df6458d276"></a>W&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a88081210ed22e2f80c50dd07348f3feca93d1093d4ebc345b0e2d3520c41ca741" name="a88081210ed22e2f80c50dd07348f3feca93d1093d4ebc345b0e2d3520c41ca741"></a>Ncw&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a88081210ed22e2f80c50dd07348f3fecacca9538f495516027540f166e6ca3ba3" name="a88081210ed22e2f80c50dd07348f3fecacca9538f495516027540f166e6ca3ba3"></a>Nwc&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00606">606</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="a894a3a33f4cfc348a3aced8a058b550a" name="a894a3a33f4cfc348a3aced8a058b550a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894a3a33f4cfc348a3aced8a058b550a">&#9670;&#160;</a></span>VectorizationHookStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a894a3a33f4cfc348a3aced8a058b550a">VectorizationHookStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper data structure to represent the result of vectorization for a single operation. </p>
<p>In certain specific cases, like terminators, we do not want to propagate. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a894a3a33f4cfc348a3aced8a058b550aa6fb01c5d76aa5b0825fd3c52dc5f3661" name="a894a3a33f4cfc348a3aced8a058b550aa6fb01c5d76aa5b0825fd3c52dc5f3661"></a>Failure&#160;</td><td class="fielddoc"><p><a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a> failed to vectorize. </p>
</td></tr>
<tr><td class="fieldname"><a id="a894a3a33f4cfc348a3aced8a058b550aaf97b2f48071b6944652bfffb71351c8f" name="a894a3a33f4cfc348a3aced8a058b550aaf97b2f48071b6944652bfffb71351c8f"></a>NoReplace&#160;</td><td class="fielddoc"><p><a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a> vectorized and custom function took care of replacement logic. </p>
</td></tr>
<tr><td class="fieldname"><a id="a894a3a33f4cfc348a3aced8a058b550aaaaf8d13847a58092eb64f52b2bed99c6" name="a894a3a33f4cfc348a3aced8a058b550aaaaf8d13847a58092eb64f52b2bed99c6"></a>NewOp&#160;</td><td class="fielddoc"><p><a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a> vectorized into a new <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a> whose results will replace original <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a>'s results. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00615">615</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="a224b215237fb8401f7031f2991266dcc" name="a224b215237fb8401f7031f2991266dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224b215237fb8401f7031f2991266dcc">&#9670;&#160;</a></span>VectorMemoryAccessKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a224b215237fb8401f7031f2991266dcc">VectorMemoryAccessKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a224b215237fb8401f7031f2991266dccae08c87afc59477607178b88f356268ca" name="a224b215237fb8401f7031f2991266dccae08c87afc59477607178b88f356268ca"></a>ScalarBroadcast&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a224b215237fb8401f7031f2991266dcca1910b77e1772ac1536cb49936f8c32ea" name="a224b215237fb8401f7031f2991266dcca1910b77e1772ac1536cb49936f8c32ea"></a>Contiguous&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a224b215237fb8401f7031f2991266dccaceba1db2e3b2f5aa1258aae0105e2a4d" name="a224b215237fb8401f7031f2991266dccaceba1db2e3b2f5aa1258aae0105e2a4d"></a>Gather&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00936">936</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ae3a45e985a37cbb4db1c7c23ce0d9e9f" name="ae3a45e985a37cbb4db1c7c23ce0d9e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a45e985a37cbb4db1c7c23ce0d9e9f">&#9670;&#160;</a></span>broadcastIfNeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> broadcastIfNeeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>dstType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast <span class="tt">value</span> to a vector of <span class="tt">shape</span> if possible. </p>
<p>Return value otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00685">685</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02924">mlir::vector::isBroadcastableTo()</a>, and <a class="el" href="VectorOps_8h_source.html#l00073">mlir::vector::Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00730">buildVectorWrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00905">calculateGatherOffset()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01337">vectorizeOneOp()</a>.</p>

</div>
</div>
<a id="af936802591fc5ba398ba106887feac8f" name="af936802591fc5ba398ba106887feac8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af936802591fc5ba398ba106887feac8f">&#9670;&#160;</a></span>buildMultiDimReduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * buildMultiDimReduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>reduceOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>valueToReduce</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>acc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classbool.html">bool</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dimsToMask</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create MultiDimReductionOp to compute the reduction for <span class="tt">reductionOp</span>. </p>
<p>This assumes that <span class="tt">reductionOp</span> has two operands and one of them is the reduction initial value.buildMultiDimReduce </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00702">702</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Vectorization_8cpp_source.html#l00638">mlir::linalg::getCombinerOpKind()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01301">reduceIfNeeded()</a>.</p>

</div>
</div>
<a id="a4ffeefd6b3cba67afe11ecdc2b48fcef" name="a4ffeefd6b3cba67afe11ecdc2b48fcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffeefd6b3cba67afe11ecdc2b48fcef">&#9670;&#160;</a></span>buildVectorWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> buildVectorWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *</td>          <td class="paramname"><span class="paramname"><em>outputOperand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a vector.transfer_write of <span class="tt">value</span> into <span class="tt">outputOperand</span> at indices set to all <span class="tt">0</span>; where <span class="tt">outputOperand</span> is an output operand of the LinalgOp currently being vectorized. </p>
<p>If <span class="tt">dest</span> has null rank, build an memref.store. Return the produced value or null if no value is produced. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00730">730</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorization_8cpp_source.html#l00685">broadcastIfNeeded()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00270">mlir::Builder::getBoolArrayAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00023">mlir::getElementTypeOrSelf()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00138">mlir::AffineMap::getFilteredIdentityMap()</a>, <a class="el" href="Value_8cpp_source.html#l00024">mlir::Value::getLoc()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00595">reindexIndexingMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00804">vectorizeLinalgYield()</a>.</p>

</div>
</div>
<a id="ae4411a5d89520c86474035493a7da7c1" name="ae4411a5d89520c86474035493a7da7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4411a5d89520c86474035493a7da7c1">&#9670;&#160;</a></span>calculateGatherOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> calculateGatherOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ExtractOp</td>          <td class="paramname"><span class="paramname"><em>extractOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bvm</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the offsets (<span class="tt">$index_vec</span>) for <span class="tt">vector.gather</span> operations generated from <span class="tt">tensor.extract</span>. </p>
<p>The offset is calculated as follows (example using scalar values):</p>
<p>offset = extractOp.indices[0] for (i = 1; i &lt; numIndices; i++) offset = extractOp.dimSize[i] * offset + extractOp.indices[i];</p>
<p>For <a class="el" href="namespacemlir_1_1tensor.html">tensor&lt;45 x 80 x 15 x f32&gt;</a> and index [1, 2, 3], this leads to: offset = ( ( 1 ) * 80 + 2 ) * 15 + 3 </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00905">905</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorization_8cpp_source.html#l00685">broadcastIfNeeded()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="Builders_8cpp_source.html#l00051">mlir::Builder::getIndexType()</a>, and <a class="el" href="IRMapping_8h_source.html#l00072">mlir::IRMapping::lookup()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01166">vectorizeTensorExtract()</a>.</p>

</div>
</div>
<a id="a2d04989901c1df355793bb8a71328797" name="a2d04989901c1df355793bb8a71328797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d04989901c1df355793bb8a71328797">&#9670;&#160;</a></span>createWriteOrMaskedWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * createWriteOrMaskedWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>vecToStore</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>writeIndices</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useInBoundsInsteadOfMasking</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an optionally masked TransferWriteOp. </p>
<p>Generates the following operation: res = vector.transfer_write vecToStore into dest</p>
<p>If <a class="el" href="namespacemlir_1_1shape.html">shape(vecToStore)</a> != <a class="el" href="namespacemlir_1_1shape.html">shape(dest)</a>, masking is used to ensure correctness:</p>
<p>mask = vector.create_mask(destShape) : vecToStoreShape res = vector.mask mask { vector.transfer_write vecToStore into dest }</p>
<p>The mask shape is identical to <span class="tt">vecToStore</span> (with the element type == i1), and the mask values are based on the shape of the <span class="tt">dest</span> tensor.</p>
<p>If <span class="tt">useInBoundsInsteadOfMasking</span> is set to <span class="tt">true</span>, the <span class="tt">in_bounds</span> attribute is used instead of masking:</p>
<p>write = vector.transfer_write vecToStore into dest in_bounds_flags = (...) res = vector.transfer_write input into dest {in_bounds = in_bounds_flags}</p>
<p>Finally, <span class="tt">writeIndices</span> specifies the offsets to use. If empty, all indices are set to 0. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01690">1690</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="a5fd4201faa9fbc0aad08b5af06556cc8" name="a5fd4201faa9fbc0aad08b5af06556cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd4201faa9fbc0aad08b5af06556cc8">&#9670;&#160;</a></span>extractConvFilterSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extractConvFilterSlices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>filter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>kwSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to extract the filter slices after filter is unrolled along kw. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00145">145</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="a200fa245f199890432efcd7596b5e672" name="a200fa245f199890432efcd7596b5e672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200fa245f199890432efcd7596b5e672">&#9670;&#160;</a></span>extractConvInputSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extractConvInputSlices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>nSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>wSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>cSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>kwSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>strideW</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dilationW</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>wSizeStep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isSingleChanneled</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to extract the input slices after filter is unrolled along kw. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00109">109</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="af0d6a3da24bf08205af9661c55447701" name="af0d6a3da24bf08205af9661c55447701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d6a3da24bf08205af9661c55447701">&#9670;&#160;</a></span>extractConvResultSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extractConvResultSlices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>nSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>wSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>fSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>wSizeStep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isSingleChanneled</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to extract the result slices after filter is unrolled along kw. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00161">161</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="a8019302085ef04a05864f2bb3f198f5c" name="a8019302085ef04a05864f2bb3f198f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8019302085ef04a05864f2bb3f198f5c">&#9670;&#160;</a></span>getCollapsedVecType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorType getCollapsedVecType </td>
          <td>(</td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reassociation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the re-associations, "collapses" the input <a class="el" href="structVector.html">Vector</a> type. </p>
<p>This is similar to CollapseShapeOp::inferCollapsedType with two notable differences:</p><ul>
<li>We can safely assume that there are no dynamic sizes.</li>
<li>Scalable flags are updated alongside regular dims.</li>
</ul>
<p>When collapsing scalable flags, conservatively avoids cases with two scalable dims. We could re-visit this in the future.</p>
<p>EXAMPLE: type = <a class="el" href="namespacemlir_1_1vector.html">vector&lt;4x16x[8]x16xf32&gt;</a> reassociation = [(d0, d1, d2, d3) -&gt; (d0, d1), (d0, d1, d2, d3) -&gt; (d2, d3)] Result: <a class="el" href="namespacemlir_1_1vector.html">vector&lt;64x[128]xf32&gt;</a> </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01773">1773</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00460">mlir::isReassociationValid()</a>.</p>

</div>
</div>
<a id="a129f4ae5f0a8071a3f98c8f73ee729f9" name="a129f4ae5f0a8071a3f98c8f73ee729f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129f4ae5f0a8071a3f98c8f73ee729f9">&#9670;&#160;</a></span>getDimsToReduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; getDimsToReduce </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00711">711</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00234">mlir::linalg::isReductionIterator()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01301">reduceIfNeeded()</a>.</p>

</div>
</div>
<a id="ab37ae3178304b744d6b0249a60a6e7a3" name="ab37ae3178304b744d6b0249a60a6e7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37ae3178304b744d6b0249a60a6e7a3">&#9670;&#160;</a></span>getSingleOpOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpType getSingleOpOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the unique instance of OpType in <span class="tt">block</span> if it is indeed unique. </p>
<p>Return null if none or more than 1 instances exist. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00093">93</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, and <a class="el" href="Block_8h_source.html#l00308">mlir::Block::walk()</a>.</p>

</div>
</div>
<a id="a51c7625311de4f665ab3c2cde71709ec" name="a51c7625311de4f665ab3c2cde71709ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c7625311de4f665ab3c2cde71709ec">&#9670;&#160;</a></span>getStaticPadVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> getStaticPadVal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the effective Pad value for the input op, provided it's a scalar. </p>
<p>Many Ops exhibit pad-like behaviour, but this isn't always explicit. If this <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a> performs padding, retrieve the padding value provided that it's a scalar and static/fixed for all the padded values. Returns an empty value otherwise. </p>

</div>
</div>
<a id="a172594be3a7384cb03a833aed99dc03c" name="a172594be3a7384cb03a833aed99dc03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172594be3a7384cb03a833aed99dc03c">&#9670;&#160;</a></span>getTensorExtractMemoryAccessPattern()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a224b215237fb8401f7031f2991266dcc">VectorMemoryAccessKind</a> getTensorExtractMemoryAccessPattern </td>
          <td>(</td>
          <td class="paramtype">tensor::ExtractOp</td>          <td class="paramname"><span class="paramname"><em>extractOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp &amp;</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>resType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Infer the memory access pattern for the input ExtractOp. </p>
<p>Based on the ExtratOp result shape and the access indices, decides whether this <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a> corresponds to a contiguous load (including a broadcast of a scalar) or a gather load. When analysing the ExtractOp indices (to identify contiguous laods), this method looks for "loop" invariant indices (e.g. block arguments) and indices that change linearly (e.g. via <span class="tt">linalg.index</span> <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a>).</p>
<p>Note that it is always safe to use gather load operations for contiguous loads (albeit slow), but not vice-versa. When in doubt, bail out and assume that <span class="tt">extractOp</span> is a gather load. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01085">1085</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorization_8cpp_source.html#l00936">Contiguous</a>, <a class="el" href="Vectorization_8cpp_source.html#l00936">Gather</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, <a class="el" href="Vectorization_8cpp_source.html#l01030">isContiguousLoadIdx()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00971">isLoopInvariantIdx()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00936">ScalarBroadcast</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01166">vectorizeTensorExtract()</a>.</p>

</div>
</div>
<a id="a7e9ce28bca426dd4de93ad09392b4ec1" name="a7e9ce28bca426dd4de93ad09392b4ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9ce28bca426dd4de93ad09392b4ec1">&#9670;&#160;</a></span>getTrailingNonUnitLoopDimIdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t getTrailingNonUnitLoopDimIdx </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the index of the trailing non-unit dim in linalgOp. </p>
<p>This hook is used when checking whether <span class="tt">tensor.extract</span> <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a> (within a <span class="tt">linalg.generic</span> <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a>) represents a contiguous load operation.</p>
<p>Note that when calling this hook, it is assumed that the output vector is effectively 1D. Other cases (i.e. reading n-D vectors) should've been labelled as a gather load before entering this method.</p>
<p>Following on from the above, it is assumed that:</p><ul>
<li>for statically shaped loops, when no masks are used, only one dim is != 1 (that's what the shape of the output vector is based on).</li>
<li>for dynamically shaped loops, there might be more non-unit dims as the output vector type is user-specified.</li>
</ul>
<p>TODO: Statically shaped loops + vector masking </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00953">953</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01030">isContiguousLoadIdx()</a>.</p>

</div>
</div>
<a id="a66021212cd375df8f87b79b0f01b7e19" name="a66021212cd375df8f87b79b0f01b7e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66021212cd375df8f87b79b0f01b7e19">&#9670;&#160;</a></span>hasReductionIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> hasReductionIterator </td>
          <td>(</td>
          <td class="paramtype">LinalgOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <span class="tt">op</span> is a linalg.reduce or a linalg.generic that has at least one reduction iterator. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00718">718</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00234">mlir::linalg::isReductionIterator()</a>.</p>

</div>
</div>
<a id="a110d1ed6891097419f0358bd63e974c8" name="a110d1ed6891097419f0358bd63e974c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110d1ed6891097419f0358bd63e974c8">&#9670;&#160;</a></span>insertConvResultSlices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> insertConvResultSlices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>wSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>wSizeStep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>resVals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isSingleChanneled</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to insert the computed result slices. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00189">189</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="af2f7690c564bae0d01129c661bfcb1f3" name="af2f7690c564bae0d01129c661bfcb1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f7690c564bae0d01129c661bfcb1f3">&#9670;&#160;</a></span>isContiguousLoadIdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isContiguousLoadIdx </td>
          <td>(</td>
          <td class="paramtype">LinalgOp &amp;</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundIndexOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>resType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether <span class="tt">val</span> could be used for calculating the trailing index for a contiguous load operation. </p>
<p>There are currently 3 types of values that are allowed here:</p><ol type="1">
<li>loop-invariant values,</li>
<li>values that increment by 1 with every loop iteration,</li>
<li>results of basic arithmetic operations (linear and continuous) involving 1., 2. and 3. This method returns True if indeed only such values are used in calculating <span class="tt">val.</span></li>
</ol>
<p>Additionally, the trailing index for a contiguous load operation should increment by 1 with every loop iteration, i.e. be based on:</p><ul>
<li><span class="tt">linalg.index &lt;dim&gt;</span> , where &lt;dim&gt; is the trailing non-unit dim of the iteration space (this way, <span class="tt">linalg.index &lt;dim&gt;</span> increments by 1 with every loop iteration). <span class="tt">foundIndexOp</span> is updated to <span class="tt">true</span> when such <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a> is found. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01030">1030</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00953">getTrailingNonUnitLoopDimIdx()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01030">isContiguousLoadIdx()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01085">getTensorExtractMemoryAccessPattern()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01030">isContiguousLoadIdx()</a>.</p>

</div>
</div>
<a id="a0bcdc4b64d42010b23b271435831cb39" name="a0bcdc4b64d42010b23b271435831cb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcdc4b64d42010b23b271435831cb39">&#9670;&#160;</a></span>isLoopInvariantIdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isLoopInvariantIdx </td>
          <td>(</td>
          <td class="paramtype">LinalgOp &amp;</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>resType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <span class="tt">val</span> can be used for calculating a loop invariant index. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00971">971</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00971">isLoopInvariantIdx()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01085">getTensorExtractMemoryAccessPattern()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00971">isLoopInvariantIdx()</a>.</p>

</div>
</div>
<a id="a1bedce144a30ca3ef5eac6628b35d4a9" name="a1bedce144a30ca3ef5eac6628b35d4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bedce144a30ca3ef5eac6628b35d4a9">&#9670;&#160;</a></span>isMaskTriviallyFoldable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isMaskTriviallyFoldable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>maskSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>writeIdxs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>destShape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>maskShape</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a mask for xfer_write is trivially "all true". </p>
<p>Given all the inputs required to generate a mask (mask sizes and shapes), and an xfer_write operation (write indices and the destination tensor shape), determines whether the corresponding mask would be trivially foldable (i.e., trivially "all true").</p>
<p>Use this method to avoid generating spurious masks and relaying on vectorization post-processing to remove them.</p>
<p>Pre-conditions for a mask to be trivially foldable:</p><ul>
<li>All involved shapes (mask + destination tensor) are static.</li>
<li>All write indices are constant.</li>
<li>All mask sizes are constant (including <span class="tt">arith.constant</span>).</li>
</ul>
<p>If the pre-conditions are met, the method checks for each destination dimension <span class="tt">d</span>: (1) destDimSize[rankDiff + d] &lt;= maskShape[d] (2) destDimSize[rankDiff + d] &lt;= writeIndex[d] + maskSize[d]</p>
<p>rankDiff = rank(dest) - rank(mask).</p>
<p>This method takes a conservative view: it may return false even if the mask is technically foldable.</p>
<p>EXAMPLE 1 (trivially foldable, all shapes match, mask sizes match the shape of the dest tensor): c0 = arith.constant 0 : index mask = vector.create_mask 5, 1 vector.mask mask { vector.transfer_write vecToStore_1, dest{[c0, c0] {in_bounds = [true, true]} : <a class="el" href="namespacemlir_1_1vector.html">vector&lt;5x1xi32&gt;</a>, <a class="el" href="namespacemlir_1_1tensor.html">tensor&lt;5x1xi32&gt;</a> }</p>
<p>EXAMPLE 2 (not trivially foldable - vector shape exceeds the tensor shape, mask is required to avoid out-of-bounds write): c0 = arith.constant 0 : index mask = vector.create_mask 5, 1 vector.mask mask { vector.transfer_write vecToStore_2, dest[c0, c0] {in_bounds = [true, true]} : <a class="el" href="namespacemlir_1_1vector.html">vector&lt;8x1xi32&gt;</a>, <a class="el" href="namespacemlir_1_1tensor.html">tensor&lt;5x1xi32&gt;</a> }</p>
<p>TODO: Re-use in createReadOrMaskedRead </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01613">1613</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="Matchers_8h_source.html#l00527">mlir::m_ConstantInt()</a>, and <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>.</p>

</div>
</div>
<a id="a4c99d55a1274aa91b750b22a4a3c76e2" name="a4c99d55a1274aa91b750b22a4a3c76e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c99d55a1274aa91b750b22a4a3c76e2">&#9670;&#160;</a></span>matchLinalgReduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * matchLinalgReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *</td>          <td class="paramname"><span class="paramname"><em>outputOperand</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether <span class="tt">outputOperand</span> is a reduction with a single combiner operation. </p>
<p>Return the combiner operation of the reduction. Return nullptr otherwise. Multiple reduction operations would impose an ordering between reduction dimensions and is currently unsupported in Linalg. This limitation is motivated by the fact that e.g. min(max(X)) != max(min(X)) </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00669">669</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00226">mlir::OpOperand::getOperandNumber()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, and <a class="el" href="SliceAnalysis_8cpp_source.html#l00290">mlir::matchReduction()</a>.</p>

</div>
</div>
<a id="aae426acd0929292f99ebde650870d27b" name="aae426acd0929292f99ebde650870d27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae426acd0929292f99ebde650870d27b">&#9670;&#160;</a></span>reduceIfNeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * reduceIfNeeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>reduceValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>initialValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bvm</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit reduction operations if the shapes of the value to reduce is different that the result shape. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01301">1301</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Vectorization_8cpp_source.html#l00702">buildMultiDimReduce()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00711">getDimsToReduce()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="IRMapping_8h_source.html#l00072">mlir::IRMapping::lookup()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01337">vectorizeOneOp()</a>.</p>

</div>
</div>
<a id="ace2ca9537983c711e37b040688830950" name="ace2ca9537983c711e37b040688830950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2ca9537983c711e37b040688830950">&#9670;&#160;</a></span>reindexIndexingMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> reindexIndexingMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an indexing <span class="tt">map</span> coming from a LinalgOp indexing, restricted to a projectedPermutation, compress the unused dimensions to serve as a permutation_map for a vector transfer operation. </p>
<p>For example, given a linalg op such as:</p>
<div class="fragment"><div class="line">%0 = <a class="code hl_namespace" href="namespacemlir_1_1linalg.html">linalg</a>.generic {</div>
<div class="line">     indexing_maps = affine_map&lt;(d0, d1, d2, d3, d4) -&gt; (d4, d0, d2)&gt;,</div>
<div class="line">     indexing_maps = affine_map&lt;(d0, d1, d2, d3, d4) -&gt; (d1, d3)&gt;</div>
<div class="line">   }</div>
<div class="line">  ins(%0 : tensor&lt;2x3x4xf32&gt;)</div>
<div class="line"> outs(%1 : tensor&lt;5x6xf32&gt;)</div>
<div class="ttc" id="anamespacemlir_1_1linalg_html"><div class="ttname"><a href="namespacemlir_1_1linalg.html">mlir::linalg</a></div><div class="ttdef"><b>Definition</b> <a href="LinalgToStandard_8h_source.html#l00024">LinalgToStandard.h:24</a></div></div>
</div><!-- fragment --><p>the iteration domain size of the linalg op is 3x5x4x6x2. The first affine map is reindexed to <span class="tt">affine_map&lt;(d0, d1, d2) -&gt; (d2, d0, d1)&gt;</span>, the second affine map is reindexed to <span class="tt">affine_map&lt;(d0, d1) -&gt; (d0, d1)&gt;</span>. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00595">595</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00715">mlir::compressUnusedDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">mlir::AffineMap::isProjectedPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00730">buildVectorWrite()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01452">vectorizeAsLinalgGeneric()</a>.</p>

</div>
</div>
<a id="ad09df73d48432e3de8291c7076164ba7" name="ad09df73d48432e3de8291c7076164ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09df73d48432e3de8291c7076164ba7">&#9670;&#160;</a></span>tensorExtractVectorizationPrecondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult tensorExtractVectorizationPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>vectorizeNDExtract</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to check if the tensor.extract can be vectorized by the custom hook vectorizeTensorExtract. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00872">872</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a298ab89fe37b4d0e351c2d1619476926" name="a298ab89fe37b4d0e351c2d1619476926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298ab89fe37b4d0e351c2d1619476926">&#9670;&#160;</a></span>vectorizeAsInsertSliceOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult vectorizeAsInsertSliceOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::InsertSliceOp</td>          <td class="paramname"><span class="paramname"><em>sliceOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inputVectorSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>newResults</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vectorize tensor::InsertSliceOp with: </p>
<ul>
<li>vector::TransferReadOp + vector::TransferWriteOp The vector sizes are either:</li>
<li>user-provided in <span class="tt">inputVectorSizes</span>, or</li>
<li>inferred from the static dims in the input and output tensors. Bails out if:</li>
<li>vector sizes are not user-provided, and</li>
<li>at least one dim is dynamic (in both the input and output tensors).</li>
</ul>
<p>Before: !t_in_type = <a class="el" href="namespacemlir_1_1tensor.html">tensor&lt;1x2x3xf32&gt;</a> !t_out_type = <a class="el" href="namespacemlir_1_1tensor.html">tensor&lt;9x8x7x1x2x3xf32&gt;</a> !v_type = <a class="el" href="namespacemlir_1_1vector.html">vector&lt;1x2x3xf32&gt;</a> inserted_slice = tensor.insert_slice src into dest ... : !t_in_type into !t_out_type After: read = vector.transfer_read src[...], pad ... : !t_in_type, !v_type write = vector.transfer_write read, dest ... : !v_type, !t_out_type </p>

</div>
</div>
<a id="a35e1ec347850959af0bc7cbdf61b9da3" name="a35e1ec347850959af0bc7cbdf61b9da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e1ec347850959af0bc7cbdf61b9da3">&#9670;&#160;</a></span>vectorizeAsLinalgGeneric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult vectorizeAsLinalgGeneric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>newResults</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic vectorization function that rewrites the body of a <span class="tt">linalgOp</span> into vector form. </p>
<p>Generic vectorization proceeds as follows:</p><ol type="1">
<li>Verify the <span class="tt">linalgOp</span> has one non-empty region.</li>
<li>Values defined above the region are mapped to themselves and will be broadcasted on a per-need basis by their consumers.</li>
<li>Each region argument is vectorized into a vector.transfer_read (or 0-d load). TODO: Reuse opportunities for RAR dependencies. 4a. Register <a class="el" href="#ac9d5de1ac70bcbcc2f773e554a39bd1e">CustomVectorizationHook</a> for YieldOp to capture the results. 4rewriter. Register <a class="el" href="#ac9d5de1ac70bcbcc2f773e554a39bd1e">CustomVectorizationHook</a> for IndexOp to access the iteration indices.</li>
<li>Iteratively call vectorizeOneOp on the region operations.</li>
</ol>
<p>When <span class="tt">broadcastToMaximalCommonShape</span> is set to true, eager broadcasting is performed to the maximal common vector size implied by the <span class="tt">linalgOp</span> iteration space. This eager broadcasting is introduced in the permutation_map of the vector.transfer_read operations. The eager broadcasting makes it trivial to determine where broadcast, transposes and reductions should occur, without any bookkeeping. The tradeoff is that, in the absence of good canonicalizations, the amount of work increases. This is not deemed a problem as we expect canonicalizations and foldings to aggressively clean up the useless work. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01452">1452</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">mlir::AffineMap::compose()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00617">Failure</a>, <a class="el" href="Value_8h_source.html#l00321">mlir::BlockArgument::getArgNumber()</a>, <a class="el" href="Builders_8cpp_source.html#l00270">mlir::Builder::getBoolArrayAttr()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00023">mlir::getElementTypeOrSelf()</a>, <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00415">mlir::Operation::getResults()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00070">mlir::getUsedValuesDefinedAbove()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00808">mlir::inverseAndBroadcastProjectedPermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00622">NewOp</a>, <a class="el" href="Vectorization_8cpp_source.html#l00595">reindexIndexingMap()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00828">vectorizeLinalgIndex()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00804">vectorizeLinalgYield()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01337">vectorizeOneOp()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01166">vectorizeTensorExtract()</a>.</p>

</div>
</div>
<a id="a320b06f6c6f3905541d59f2c33ce5aea" name="a320b06f6c6f3905541d59f2c33ce5aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320b06f6c6f3905541d59f2c33ce5aea">&#9670;&#160;</a></span>vectorizeConvolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; vectorizeConvolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>convOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inputVecSizes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classbool.html">bool</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inputVecScalableFlags</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>flatten1DDepthwiseConv</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to vectorize <span class="tt">convOp</span> as a convolution. </p>

</div>
</div>
<a id="a280bd1ab81d418cd32713eeb0a2dfffd" name="a280bd1ab81d418cd32713eeb0a2dfffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280bd1ab81d418cd32713eeb0a2dfffd">&#9670;&#160;</a></span>vectorizeLinalgIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVectorizationHookResult.html">VectorizationHookResult</a> vectorizeLinalgIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to vectorize the index operations of a <span class="tt">linalgOp</span>. </p>
<p>Return VectorizationHookStatus::NewOp to signal the vectorization algorithm that it should map the produced operations. This function is meant to be used as a <a class="el" href="#ac9d5de1ac70bcbcc2f773e554a39bd1e">CustomVectorizationHook</a>. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00828">828</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorization_8cpp_source.html#l00617">Failure</a>, <a class="el" href="Builders_8cpp_source.html#l00051">mlir::Builder::getIndexType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00260">mlir::AffineMap::getPermutationMap()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00622">NewOp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01452">vectorizeAsLinalgGeneric()</a>.</p>

</div>
</div>
<a id="af85a26f7c1860388d0e83d22745a27aa" name="af85a26f7c1860388d0e83d22745a27aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85a26f7c1860388d0e83d22745a27aa">&#9670;&#160;</a></span>vectorizeLinalgYield()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVectorizationHookResult.html">VectorizationHookResult</a> vectorizeLinalgYield </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bvm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>newResults</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to vectorize the terminator of a <span class="tt">linalgOp</span>. </p>
<p>New result vector values are appended to <span class="tt">newResults</span>. Return VectorizationHookStatus::NoReplace to signal the vectorization algorithm that it should not try to map produced operations and instead return the results using the <span class="tt">newResults</span> vector making them available to the vectorization algorithm for RAUW. This function is meant to be used as a <a class="el" href="#ac9d5de1ac70bcbcc2f773e554a39bd1e">CustomVectorizationHook</a>. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00804">804</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorization_8cpp_source.html#l00730">buildVectorWrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00617">Failure</a>, <a class="el" href="IRMapping_8h_source.html#l00072">mlir::IRMapping::lookup()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00619">NoReplace</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01452">vectorizeAsLinalgGeneric()</a>.</p>

</div>
</div>
<a id="a455f83de6534e53da06be057973f7e38" name="a455f83de6534e53da06be057973f7e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455f83de6534e53da06be057973f7e38">&#9670;&#160;</a></span>vectorizeOneOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVectorizationHookResult.html">VectorizationHookResult</a> vectorizeOneOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bvm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#ac9d5de1ac70bcbcc2f773e554a39bd1e">CustomVectorizationHook</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>customVectorizationHooks</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic vectorization for a single operation <span class="tt">op</span>, given already vectorized operands carried by <span class="tt">bvm</span>. </p>
<p>Vectorization occurs as follows:</p><ol type="1">
<li>Try to apply any of the <span class="tt">customVectorizationHooks</span> and return its result on success.</li>
<li>Clone any constant in the current scope without vectorization: each consumer of the constant will later determine the shape to which the constant needs to be broadcast to.</li>
<li>Fail on any remaining non <span class="tt">ElementwiseMappable</span> op. It is the purpose of the <span class="tt">customVectorizationHooks</span> to cover such cases.</li>
<li>Clone <span class="tt">op</span> in vector form to a vector of shape prescribed by the first operand of maximal rank. Other operands have smaller rank and are broadcast accordingly. It is assumed this broadcast is always legal, otherwise, it means one of the <span class="tt">customVectorizationHooks</span> is incorrect.</li>
</ol>
<p>This function assumes all operands of <span class="tt">op</span> have been vectorized and are in the <span class="tt">bvm</span> mapping. As a consequence, this function is meant to be called on a topologically-sorted list of ops. This function does not update <span class="tt">bvm</span> but returns a <a class="el" href="#a894a3a33f4cfc348a3aced8a058b550a" title="Helper data structure to represent the result of vectorization for a single operation.">VectorizationHookStatus</a> that instructs the caller what <span class="tt">bvm</span> update needs to occur. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01337">1337</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorization_8cpp_source.html#l00685">broadcastIfNeeded()</a>, <a class="el" href="Builders_8cpp_source.html#l00562">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8cpp_source.html#l00457">mlir::OpBuilder::create()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00617">Failure</a>, <a class="el" href="IR_2Operation_8h_source.html#l00512">mlir::Operation::getAttrs()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00023">mlir::getElementTypeOrSelf()</a>, <a class="el" href="OperationSupport_8h_source.html#l00476">mlir::OperationName::getIdentifier()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00428">mlir::Operation::getResultTypes()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l01390">mlir::OpTrait::hasElementwiseMappableTraits()</a>, <a class="el" href="IRMapping_8h_source.html#l00072">mlir::IRMapping::lookup()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00290">mlir::matchReduction()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00622">NewOp</a>, <a class="el" href="Vectorization_8cpp_source.html#l01301">reduceIfNeeded()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01452">vectorizeAsLinalgGeneric()</a>.</p>

</div>
</div>
<a id="a26cb5e24425fdce30baaba6f7c0f5c84" name="a26cb5e24425fdce30baaba6f7c0f5c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26cb5e24425fdce30baaba6f7c0f5c84">&#9670;&#160;</a></span>vectorizeTensorExtract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVectorizationHookResult.html">VectorizationHookResult</a> vectorizeTensorExtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorizationState.html">VectorizationState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IRMapping.html">IRMapping</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bvm</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to vectorize the tensor.extract operations. </p>
<p>Returns VectorizationHookStatus::NewOp to signal the vectorization algorithm that it should map the produced operations. This function is meant to be used as a <a class="el" href="#ac9d5de1ac70bcbcc2f773e554a39bd1e">CustomVectorizationHook</a>. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01166">1166</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorOps_8h_source.html#l00064">mlir::vector::AllTrue</a>, <a class="el" href="Vectorization_8cpp_source.html#l00905">calculateGatherOffset()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00617">Failure</a>, <a class="el" href="Vectorization_8cpp_source.html#l00936">Gather</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l00963">mlir::DenseIntElementsAttr::get()</a>, <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00053">mlir::Builder::getI1Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00051">mlir::Builder::getIndexType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00131">mlir::AffineMap::getMinorIdentityMap()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01085">getTensorExtractMemoryAccessPattern()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="Builders_8cpp_source.html#l00324">mlir::Builder::getZeroAttr()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>, <a class="el" href="IRMapping_8h_source.html#l00072">mlir::IRMapping::lookup()</a>, <a class="el" href="namespacemlir_1_1vector.html#a21bfcee9196fe1a2cfa548b7df8193a9">mlir::vector::maskOperation()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00622">NewOp</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00936">ScalarBroadcast</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l01452">vectorizeAsLinalgGeneric()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
