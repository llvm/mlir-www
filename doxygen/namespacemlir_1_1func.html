<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::func Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="namespacemlir_1_1func.html">func</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mlir::func Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:arith" id="r_arith"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1func_1_1arith.html">arith</a></td></tr>
<tr class="memitem:impl" id="r_impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1func_1_1impl.html">impl</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6ffb0a4fad2d0e6f112e87b0a0f5aba1" id="r_a6ffb0a4fad2d0e6f112e87b0a0f5aba1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ffb0a4fad2d0e6f112e87b0a0f5aba1">registerAllExtensions</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a6ffb0a4fad2d0e6f112e87b0a0f5aba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register all extensions of the func dialect.  <br /></td></tr>
<tr class="memitem:a5319838573a4ef27627ad2590f51e7d2" id="r_a5319838573a4ef27627ad2590f51e7d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5319838573a4ef27627ad2590f51e7d2">registerInlinerExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a5319838573a4ef27627ad2590f51e7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the extension used to support inlining the func dialect.  <br /></td></tr>
<tr class="memitem:aaf8314a4179c6e56c5fd18cd5d6d27ee" id="r_aaf8314a4179c6e56c5fd18cd5d6d27ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf8314a4179c6e56c5fd18cd5d6d27ee">registerShardingInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a229c4d70826d4f7927f733fd98c101d9" id="r_a229c4d70826d4f7927f733fd98c101d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a229c4d70826d4f7927f733fd98c101d9">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:ab94a0bd728c6c5cf9bc102afa1aee523" id="r_ab94a0bd728c6c5cf9bc102afa1aee523"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab94a0bd728c6c5cf9bc102afa1aee523">createDuplicateFunctionEliminationPass</a> ()</td></tr>
<tr class="memitem:a02a192d021c750fe472deb85ee8bc808" id="r_a02a192d021c750fe472deb85ee8bc808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02a192d021c750fe472deb85ee8bc808">registerDuplicateFunctionEliminationPass</a> ()</td></tr>
<tr class="memitem:a4d93813b12c8c64b46dbbbaadd34ac7c" id="r_a4d93813b12c8c64b46dbbbaadd34ac7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d93813b12c8c64b46dbbbaadd34ac7c">registerDuplicateFunctionEliminationPassPass</a> ()</td></tr>
<tr class="memitem:a7f554eddd5f3f5365c636f86adfa2e8f" id="r_a7f554eddd5f3f5365c636f86adfa2e8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f554eddd5f3f5365c636f86adfa2e8f">registerFuncPasses</a> ()</td></tr>
<tr class="memitem:ab9e1f97cb960c9321469b383a2f7ce67" id="r_ab9e1f97cb960c9321469b383a2f7ce67"><td class="memItemLeft" align="right" valign="top">mlir::FailureOr&lt; mlir::func::FuncOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9e1f97cb960c9321469b383a2f7ce67">replaceFuncWithNewMapping</a> (<a class="el" href="classmlir_1_1RewriterBase.html">mlir::RewriterBase</a> &amp;rewriter, mlir::func::FuncOp funcOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt; oldArgIdxToNewArgIdx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt; oldResIdxToNewResIdx)</td></tr>
<tr class="memdesc:ab9e1f97cb960c9321469b383a2f7ce67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new function operation with the same name as the original function operation, but with the arguments mapped according to the <span class="tt">oldArgToNewArg</span> and <span class="tt">oldResToNewRes</span>.  <br /></td></tr>
<tr class="memitem:a16c708d34d693e4129987da6a392688a" id="r_a16c708d34d693e4129987da6a392688a"><td class="memItemLeft" align="right" valign="top">mlir::func::CallOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16c708d34d693e4129987da6a392688a">replaceCallOpWithNewMapping</a> (<a class="el" href="classmlir_1_1RewriterBase.html">mlir::RewriterBase</a> &amp;rewriter, mlir::func::CallOp callOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt; oldArgIdxToNewArgIdx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt; oldResIdxToNewResIdx)</td></tr>
<tr class="memdesc:a16c708d34d693e4129987da6a392688a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new call operation with the values as the original call operation, but with the arguments mapped according to the <span class="tt">oldArgToNewArg</span> and <span class="tt">oldResToNewRes</span>.  <br /></td></tr>
<tr class="memitem:ac5b0c9614bcbacae79669cfb277ce71e" id="r_ac5b0c9614bcbacae79669cfb277ce71e"><td class="memItemLeft" align="right" valign="top">mlir::FailureOr&lt; std::pair&lt; mlir::func::FuncOp, mlir::func::CallOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5b0c9614bcbacae79669cfb277ce71e">deduplicateArgsOfFuncOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">mlir::RewriterBase</a> &amp;rewriter, mlir::func::FuncOp funcOp, mlir::ModuleOp moduleOp)</td></tr>
<tr class="memdesc:ac5b0c9614bcbacae79669cfb277ce71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility function examines all call operations within the given <span class="tt">moduleOp</span> that target the specified <span class="tt">funcOp</span>.  <br /></td></tr>
<tr class="memitem:a468357bc98750513c12a0901ef07124b" id="r_a468357bc98750513c12a0901ef07124b"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; FuncOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a468357bc98750513c12a0901ef07124b">lookupFnDecl</a> (SymbolOpInterface symTable, StringRef name, FunctionType funcT, <a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> *symbolTables=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a468357bc98750513c12a0901ef07124b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a FuncOp with signature <span class="tt">resultTypes</span>(<span class="tt">paramTypes</span>)<span class="tt"> and name
/ </span>name`.  <br /></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ab94a0bd728c6c5cf9bc102afa1aee523" name="ab94a0bd728c6c5cf9bc102afa1aee523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94a0bd728c6c5cf9bc102afa1aee523">&#9670;&#160;</a></span>createDuplicateFunctionEliminationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::func::createDuplicateFunctionEliminationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="DuplicateFunctionElimination_8cpp_source.html#l00079">79</a> of file <a class="el" href="DuplicateFunctionElimination_8cpp_source.html">DuplicateFunctionElimination.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l01325">mlir::OperationEquivalence::IgnoreLocations</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="ac5b0c9614bcbacae79669cfb277ce71e" name="ac5b0c9614bcbacae79669cfb277ce71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b0c9614bcbacae79669cfb277ce71e">&#9670;&#160;</a></span>deduplicateArgsOfFuncOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; std::pair&lt; mlir::func::FuncOp, mlir::func::CallOp &gt; &gt; mlir::func::deduplicateArgsOfFuncOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">mlir::RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::func::FuncOp</td>          <td class="paramname"><span class="paramname"><em>funcOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::ModuleOp</td>          <td class="paramname"><span class="paramname"><em>moduleOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This utility function examines all call operations within the given <span class="tt">moduleOp</span> that target the specified <span class="tt">funcOp</span>. </p>
<p>It identifies duplicate operands in the call operations, creates mappings to deduplicate them, and then applies the transformation to both the function and its call sites. For now, it only supports one call operation for the function operation. The function returns a pair containing the new funcOp and the new callOp. Note: after the transformation, the original funcOp and callOp will be erased. </p>

</div>
</div>
<a id="a468357bc98750513c12a0901ef07124b" name="a468357bc98750513c12a0901ef07124b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468357bc98750513c12a0901ef07124b">&#9670;&#160;</a></span>lookupFnDecl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; func::FuncOp &gt; mlir::func::lookupFnDecl </td>
          <td>(</td>
          <td class="paramtype">SymbolOpInterface</td>          <td class="paramname"><span class="paramname"><em>symTable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionType</td>          <td class="paramname"><span class="paramname"><em>funcT</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> *</td>          <td class="paramname"><span class="paramname"><em>symbolTables</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up a FuncOp with signature <span class="tt">resultTypes</span>(<span class="tt">paramTypes</span>)<span class="tt"> and name
/ </span>name`. </p>
<p>Return a failure if the FuncOp is found but with a different signature. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Func_2Utils_2Utils_8cpp_source.html#l00259">259</a> of file <a class="el" href="Dialect_2Func_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="SymbolTable_8cpp_source.html#l00384">mlir::SymbolTable::lookupSymbolIn()</a>, and <a class="el" href="SymbolTable_8cpp_source.html#l00959">mlir::SymbolTableCollection::lookupSymbolIn()</a>.</p>

</div>
</div>
<a id="a6ffb0a4fad2d0e6f112e87b0a0f5aba1" name="a6ffb0a4fad2d0e6f112e87b0a0f5aba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffb0a4fad2d0e6f112e87b0a0f5aba1">&#9670;&#160;</a></span>registerAllExtensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::func::registerAllExtensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register all extensions of the func dialect. </p>
<p>This should generally only be used by tools, or other use cases that really do want <em>all</em> extensions of the dialect. All other cases should prefer to instead register the specific extensions they intend to take advantage of. </p>

<p class="definition">Definition at line <a class="el" href="Func_2Extensions_2AllExtensions_8cpp_source.html#l00015">15</a> of file <a class="el" href="Func_2Extensions_2AllExtensions_8cpp_source.html">AllExtensions.cpp</a>.</p>

<p class="reference">References <a class="el" href="InlinerExtension_8cpp_source.html#l00087">registerInlinerExtension()</a>, and <a class="el" href="Func_2Extensions_2ShardingExtensions_8cpp_source.html#l00016">registerShardingInterfaceExternalModels()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a02a192d021c750fe472deb85ee8bc808" name="a02a192d021c750fe472deb85ee8bc808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a192d021c750fe472deb85ee8bc808">&#9670;&#160;</a></span>registerDuplicateFunctionEliminationPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::func::registerDuplicateFunctionEliminationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Func_2Transforms_2Passes_8h_source.html#l00094">94</a> of file <a class="el" href="Dialect_2Func_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a4d93813b12c8c64b46dbbbaadd34ac7c" name="a4d93813b12c8c64b46dbbbaadd34ac7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d93813b12c8c64b46dbbbaadd34ac7c">&#9670;&#160;</a></span>registerDuplicateFunctionEliminationPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::func::registerDuplicateFunctionEliminationPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Func_2Transforms_2Passes_8h_source.html#l00101">101</a> of file <a class="el" href="Dialect_2Func_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a7f554eddd5f3f5365c636f86adfa2e8f" name="a7f554eddd5f3f5365c636f86adfa2e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f554eddd5f3f5365c636f86adfa2e8f">&#9670;&#160;</a></span>registerFuncPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::func::registerFuncPasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Func_2Transforms_2Passes_8h_source.html#l00115">115</a> of file <a class="el" href="Dialect_2Func_2Transforms_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllPasses_8cpp_source.html#l00059">mlir::registerAllPasses()</a>.</p>

</div>
</div>
<a id="a5319838573a4ef27627ad2590f51e7d2" name="a5319838573a4ef27627ad2590f51e7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5319838573a4ef27627ad2590f51e7d2">&#9670;&#160;</a></span>registerInlinerExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::func::registerInlinerExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the extension used to support inlining the func dialect. </p>

<p class="definition">Definition at line <a class="el" href="InlinerExtension_8cpp_source.html#l00087">87</a> of file <a class="el" href="InlinerExtension_8cpp_source.html">InlinerExtension.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="MLIRContext_8h_source.html#l00100">mlir::MLIRContext::getOrLoadDialect()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Func_2Extensions_2AllExtensions_8cpp_source.html#l00015">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="aaf8314a4179c6e56c5fd18cd5d6d27ee" name="aaf8314a4179c6e56c5fd18cd5d6d27ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8314a4179c6e56c5fd18cd5d6d27ee">&#9670;&#160;</a></span>registerShardingInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::func::registerShardingInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Func_2Extensions_2ShardingExtensions_8cpp_source.html#l00016">16</a> of file <a class="el" href="Func_2Extensions_2ShardingExtensions_8cpp_source.html">ShardingExtensions.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Func_2Extensions_2AllExtensions_8cpp_source.html#l00015">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a229c4d70826d4f7927f733fd98c101d9" name="a229c4d70826d4f7927f733fd98c101d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229c4d70826d4f7927f733fd98c101d9">&#9670;&#160;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::func::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FuncTransformOps_8cpp_source.html#l00412">412</a> of file <a class="el" href="FuncTransformOps_8cpp_source.html">FuncTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00222">mlir::DialectRegistry::addExtensions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a16c708d34d693e4129987da6a392688a" name="a16c708d34d693e4129987da6a392688a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c708d34d693e4129987da6a392688a">&#9670;&#160;</a></span>replaceCallOpWithNewMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::func::CallOp mlir::func::replaceCallOpWithNewMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">mlir::RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::func::CallOp</td>          <td class="paramname"><span class="paramname"><em>callOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>oldArgIdxToNewArgIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>oldResIdxToNewResIdx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new call operation with the values as the original call operation, but with the arguments mapped according to the <span class="tt">oldArgToNewArg</span> and <span class="tt">oldResToNewRes</span>. </p>
<p>Note: the method asserts that the <span class="tt">oldArgToNewArg</span> and <span class="tt">oldResToNewRes</span> maps the whole call operation arguments and results. </p>

</div>
</div>
<a id="ab9e1f97cb960c9321469b383a2f7ce67" name="ab9e1f97cb960c9321469b383a2f7ce67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e1f97cb960c9321469b383a2f7ce67">&#9670;&#160;</a></span>replaceFuncWithNewMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt; mlir::func::FuncOp &gt; mlir::func::replaceFuncWithNewMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">mlir::RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::func::FuncOp</td>          <td class="paramname"><span class="paramname"><em>funcOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>oldArgIdxToNewArgIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>oldResIdxToNewResIdx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new function operation with the same name as the original function operation, but with the arguments mapped according to the <span class="tt">oldArgToNewArg</span> and <span class="tt">oldResToNewRes</span>. </p>
<p>The <span class="tt">funcOp</span> operation must have exactly one block. Returns the new function operation or failure if <span class="tt">funcOp</span> doesn't have exactly one block. Note: the method asserts that the <span class="tt">oldArgToNewArg</span> and <span class="tt">oldResToNewRes</span> maps the whole function arguments and results. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
