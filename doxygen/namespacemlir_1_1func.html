<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::func Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1func.html">func</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::func Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1func_1_1arith"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1func_1_1arith.html">arith</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6ffb0a4fad2d0e6f112e87b0a0f5aba1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1func.html#a6ffb0a4fad2d0e6f112e87b0a0f5aba1">registerAllExtensions</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a6ffb0a4fad2d0e6f112e87b0a0f5aba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register all extensions of the func dialect.  <a href="namespacemlir_1_1func.html#a6ffb0a4fad2d0e6f112e87b0a0f5aba1">More...</a><br /></td></tr>
<tr class="separator:a6ffb0a4fad2d0e6f112e87b0a0f5aba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5319838573a4ef27627ad2590f51e7d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1func.html#a5319838573a4ef27627ad2590f51e7d2">registerInlinerExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a5319838573a4ef27627ad2590f51e7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the extension used to support inlining the func dialect.  <a href="namespacemlir_1_1func.html#a5319838573a4ef27627ad2590f51e7d2">More...</a><br /></td></tr>
<tr class="separator:a5319838573a4ef27627ad2590f51e7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8314a4179c6e56c5fd18cd5d6d27ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1func.html#aaf8314a4179c6e56c5fd18cd5d6d27ee">registerShardingInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:aaf8314a4179c6e56c5fd18cd5d6d27ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229c4d70826d4f7927f733fd98c101d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1func.html#a229c4d70826d4f7927f733fd98c101d9">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a229c4d70826d4f7927f733fd98c101d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e006fd204279aca938339aaf38b3dc3"><td class="memItemLeft" align="right" valign="top">mlir::FailureOr&lt; mlir::func::FuncOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1func.html#a3e006fd204279aca938339aaf38b3dc3">replaceFuncWithNewMapping</a> (<a class="el" href="classmlir_1_1RewriterBase.html">mlir::RewriterBase</a> &amp;rewriter, mlir::func::FuncOp funcOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt; oldArgIdxToNewArgIdx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt; oldResIdxToNewResIdx)</td></tr>
<tr class="memdesc:a3e006fd204279aca938339aaf38b3dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new function operation with the same name as the original function operation, but with the arguments mapped according to the <code>oldArgToNewArg</code> and <code>oldResToNewRes</code>.  <a href="namespacemlir_1_1func.html#a3e006fd204279aca938339aaf38b3dc3">More...</a><br /></td></tr>
<tr class="separator:a3e006fd204279aca938339aaf38b3dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c708d34d693e4129987da6a392688a"><td class="memItemLeft" align="right" valign="top">mlir::func::CallOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1func.html#a16c708d34d693e4129987da6a392688a">replaceCallOpWithNewMapping</a> (<a class="el" href="classmlir_1_1RewriterBase.html">mlir::RewriterBase</a> &amp;rewriter, mlir::func::CallOp callOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt; oldArgIdxToNewArgIdx, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt; oldResIdxToNewResIdx)</td></tr>
<tr class="memdesc:a16c708d34d693e4129987da6a392688a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new call operation with the values as the original call operation, but with the arguments mapped according to the <code>oldArgToNewArg</code> and <code>oldResToNewRes</code>.  <a href="namespacemlir_1_1func.html#a16c708d34d693e4129987da6a392688a">More...</a><br /></td></tr>
<tr class="separator:a16c708d34d693e4129987da6a392688a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b88d83258f6f7262b4fcc76202bd692"><td class="memItemLeft" align="right" valign="top">mlir::FailureOr&lt; std::pair&lt; mlir::func::FuncOp, mlir::func::CallOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1func.html#a6b88d83258f6f7262b4fcc76202bd692">deduplicateArgsOfFuncOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">mlir::RewriterBase</a> &amp;rewriter, mlir::func::FuncOp funcOp, mlir::ModuleOp moduleOp)</td></tr>
<tr class="memdesc:a6b88d83258f6f7262b4fcc76202bd692"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility function examines all call operations within the given <code>moduleOp</code> that target the specified <code>funcOp</code>.  <a href="namespacemlir_1_1func.html#a6b88d83258f6f7262b4fcc76202bd692">More...</a><br /></td></tr>
<tr class="separator:a6b88d83258f6f7262b4fcc76202bd692"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6b88d83258f6f7262b4fcc76202bd692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b88d83258f6f7262b4fcc76202bd692">&#9670;&nbsp;</a></span>deduplicateArgsOfFuncOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt;std::pair&lt;mlir::func::FuncOp, mlir::func::CallOp&gt; &gt; mlir::func::deduplicateArgsOfFuncOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">mlir::RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::func::FuncOp&#160;</td>
          <td class="paramname"><em>funcOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This utility function examines all call operations within the given <code>moduleOp</code> that target the specified <code>funcOp</code>. </p>
<p>It identifies duplicate operands in the call operations, creates mappings to deduplicate them, and then applies the transformation to both the function and its call sites. For now, it only supports one call operation for the function operation. The function returns a pair containing the new funcOp and the new callOp. Note: after the transformation, the original funcOp and callOp will be erased. </p>

</div>
</div>
<a id="a6ffb0a4fad2d0e6f112e87b0a0f5aba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffb0a4fad2d0e6f112e87b0a0f5aba1">&#9670;&nbsp;</a></span>registerAllExtensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::func::registerAllExtensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register all extensions of the func dialect. </p>
<p>This should generally only be used by tools, or other use cases that really do want <em>all</em> extensions of the dialect. All other cases should prefer to instead register the specific extensions they intend to take advantage of. </p>

<p class="definition">Definition at line <a class="el" href="Func_2Extensions_2AllExtensions_8cpp_source.html#l00015">15</a> of file <a class="el" href="Func_2Extensions_2AllExtensions_8cpp_source.html">AllExtensions.cpp</a>.</p>

<p class="reference">References <a class="el" href="InlinerExtension_8cpp_source.html#l00087">registerInlinerExtension()</a>, and <a class="el" href="Arith_2Transforms_2ShardingInterfaceImpl_8cpp_source.html#l00098">mlir::arith::registerShardingInterfaceExternalModels()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00070">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a5319838573a4ef27627ad2590f51e7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5319838573a4ef27627ad2590f51e7d2">&#9670;&nbsp;</a></span>registerInlinerExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::func::registerInlinerExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the extension used to support inlining the func dialect. </p>

<p class="definition">Definition at line <a class="el" href="InlinerExtension_8cpp_source.html#l00087">87</a> of file <a class="el" href="InlinerExtension_8cpp_source.html">InlinerExtension.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="MLIRContext_8h_source.html#l00100">mlir::MLIRContext::getOrLoadDialect()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Func_2Extensions_2AllExtensions_8cpp_source.html#l00015">registerAllExtensions()</a>.</p>

</div>
</div>
<a id="aaf8314a4179c6e56c5fd18cd5d6d27ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8314a4179c6e56c5fd18cd5d6d27ee">&#9670;&nbsp;</a></span>registerShardingInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::func::registerShardingInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Func_2Extensions_2ShardingExtensions_8cpp_source.html#l00016">16</a> of file <a class="el" href="Func_2Extensions_2ShardingExtensions_8cpp_source.html">ShardingExtensions.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

</div>
</div>
<a id="a229c4d70826d4f7927f733fd98c101d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229c4d70826d4f7927f733fd98c101d9">&#9670;&nbsp;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::func::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FuncTransformOps_8cpp_source.html#l00412">412</a> of file <a class="el" href="FuncTransformOps_8cpp_source.html">FuncTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00222">mlir::DialectRegistry::addExtensions()</a>.</p>

</div>
</div>
<a id="a16c708d34d693e4129987da6a392688a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c708d34d693e4129987da6a392688a">&#9670;&nbsp;</a></span>replaceCallOpWithNewMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::func::CallOp mlir::func::replaceCallOpWithNewMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">mlir::RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::func::CallOp&#160;</td>
          <td class="paramname"><em>callOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>oldArgIdxToNewArgIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>oldResIdxToNewResIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new call operation with the values as the original call operation, but with the arguments mapped according to the <code>oldArgToNewArg</code> and <code>oldResToNewRes</code>. </p>
<p>Note: the method asserts that the <code>oldArgToNewArg</code> and <code>oldResToNewRes</code> maps the whole call operation arguments and results. </p>

</div>
</div>
<a id="a3e006fd204279aca938339aaf38b3dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e006fd204279aca938339aaf38b3dc3">&#9670;&nbsp;</a></span>replaceFuncWithNewMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FailureOr&lt;mlir::func::FuncOp&gt; mlir::func::replaceFuncWithNewMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">mlir::RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::func::FuncOp&#160;</td>
          <td class="paramname"><em>funcOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>oldArgIdxToNewArgIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>oldResIdxToNewResIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new function operation with the same name as the original function operation, but with the arguments mapped according to the <code>oldArgToNewArg</code> and <code>oldResToNewRes</code>. </p>
<p>The <code>funcOp</code> operation must have exactly one block. Returns the new function operation or failure if <code>funcOp</code> doesn't have exactly one block. Note: the method asserts that the <code>oldArgToNewArg</code> and <code>oldResToNewRes</code> maps the whole function arguments and results. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 27 2025 16:33:11 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
