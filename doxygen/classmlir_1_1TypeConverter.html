<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::TypeConverter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlir_1_1TypeConverter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::TypeConverter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> conversion class.  
 <a href="classmlir_1_1TypeConverter.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="DialectConversion_8h_source.html">mlir/Transforms/DialectConversion.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mlir::TypeConverter:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classmlir_1_1TypeConverter__inherit__graph.svg" width="447" height="547"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter_1_1AttributeConversionResult.html">AttributeConversionResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The general result of a type attribute conversion callback, allowing for early termination.  <a href="classmlir_1_1TypeConverter_1_1AttributeConversionResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides all of the information necessary to convert a type signature.  <a href="classmlir_1_1TypeConverter_1_1SignatureConversion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac23c45fa40bd2771f27702f46fac5232"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ac23c45fa40bd2771f27702f46fac5232">~TypeConverter</a> ()=default</td></tr>
<tr class="separator:ac23c45fa40bd2771f27702f46fac5232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7055830377e3f38b6160a9712b5beba1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a7055830377e3f38b6160a9712b5beba1">TypeConverter</a> ()=default</td></tr>
<tr class="separator:a7055830377e3f38b6160a9712b5beba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b77498262ce63baee43eafd23b3e6df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a7b77498262ce63baee43eafd23b3e6df">TypeConverter</a> (const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;other)</td></tr>
<tr class="separator:a7b77498262ce63baee43eafd23b3e6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7c8bca88d9cd366e8b727b1aca27ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a7e7c8bca88d9cd366e8b727b1aca27ae">operator=</a> (const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;other)</td></tr>
<tr class="separator:a7e7c8bca88d9cd366e8b727b1aca27ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272bc4144b1ac5a3f7f1ad25c0e39e03"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;0&gt;&gt; </td></tr>
<tr class="memitem:a272bc4144b1ac5a3f7f1ad25c0e39e03"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a272bc4144b1ac5a3f7f1ad25c0e39e03">addConversion</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a272bc4144b1ac5a3f7f1ad25c0e39e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a conversion function.  <a href="classmlir_1_1TypeConverter.html#a272bc4144b1ac5a3f7f1ad25c0e39e03">More...</a><br /></td></tr>
<tr class="separator:a272bc4144b1ac5a3f7f1ad25c0e39e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf35c0b4faa6fa6d8eda987ad71393e9"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:aaf35c0b4faa6fa6d8eda987ad71393e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#aaf35c0b4faa6fa6d8eda987ad71393e9">addSourceMaterialization</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:aaf35c0b4faa6fa6d8eda987ad71393e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">All of the following materializations require function objects that are convertible to the following form: <code>Value(OpBuilder &amp;, T, ValueRange, Location)</code>, where <code>T</code> is any subclass of <code><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a></code>.  <a href="classmlir_1_1TypeConverter.html#aaf35c0b4faa6fa6d8eda987ad71393e9">More...</a><br /></td></tr>
<tr class="separator:aaf35c0b4faa6fa6d8eda987ad71393e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe54f9a4348e1d8aa30535f53ddaf37"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:acfe54f9a4348e1d8aa30535f53ddaf37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#acfe54f9a4348e1d8aa30535f53ddaf37">addTargetMaterialization</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:acfe54f9a4348e1d8aa30535f53ddaf37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method registers a materialization that will be called when converting a value to a target type according to a pattern's type converter.  <a href="classmlir_1_1TypeConverter.html#acfe54f9a4348e1d8aa30535f53ddaf37">More...</a><br /></td></tr>
<tr class="separator:acfe54f9a4348e1d8aa30535f53ddaf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b36cbf0a62aab9acb39d9299336980"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;0&gt;, typename A  = typename llvm::function_traits&lt;std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:ac5b36cbf0a62aab9acb39d9299336980"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ac5b36cbf0a62aab9acb39d9299336980">addTypeAttributeConversion</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:ac5b36cbf0a62aab9acb39d9299336980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a conversion function for attributes within types.  <a href="classmlir_1_1TypeConverter.html#ac5b36cbf0a62aab9acb39d9299336980">More...</a><br /></td></tr>
<tr class="separator:ac5b36cbf0a62aab9acb39d9299336980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1fae4fc72123cef7302a93ba314c6a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#aad1fae4fc72123cef7302a93ba314c6a">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;results) const</td></tr>
<tr class="memdesc:aad1fae4fc72123cef7302a93ba314c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given type.  <a href="classmlir_1_1TypeConverter.html#aad1fae4fc72123cef7302a93ba314c6a">More...</a><br /></td></tr>
<tr class="separator:aad1fae4fc72123cef7302a93ba314c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c28856d7176c4af44f64906de33b6ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a7c28856d7176c4af44f64906de33b6ac">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t) const</td></tr>
<tr class="memdesc:a7c28856d7176c4af44f64906de33b6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook simplifies defining 1-1 type conversions.  <a href="classmlir_1_1TypeConverter.html#a7c28856d7176c4af44f64906de33b6ac">More...</a><br /></td></tr>
<tr class="separator:a7c28856d7176c4af44f64906de33b6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781dc5f696e4309ad385645a74295fe0"><td class="memTemplParams" colspan="2">template&lt;typename TargetType &gt; </td></tr>
<tr class="memitem:a781dc5f696e4309ad385645a74295fe0"><td class="memTemplItemLeft" align="right" valign="top">TargetType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a781dc5f696e4309ad385645a74295fe0">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t) const</td></tr>
<tr class="memdesc:a781dc5f696e4309ad385645a74295fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts a 1-1 type conversion, expecting the result type to be <code>TargetType</code>.  <a href="classmlir_1_1TypeConverter.html#a781dc5f696e4309ad385645a74295fe0">More...</a><br /></td></tr>
<tr class="separator:a781dc5f696e4309ad385645a74295fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a2339e9128e1b05df14b075f6c3914"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ad8a2339e9128e1b05df14b075f6c3914">convertTypes</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;results) const</td></tr>
<tr class="memdesc:ad8a2339e9128e1b05df14b075f6c3914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given set of types, filling 'results' as necessary.  <a href="classmlir_1_1TypeConverter.html#ad8a2339e9128e1b05df14b075f6c3914">More...</a><br /></td></tr>
<tr class="separator:ad8a2339e9128e1b05df14b075f6c3914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3050e11aff691748a33f690d842ada1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a3050e11aff691748a33f690d842ada1c">isLegal</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type) const</td></tr>
<tr class="memdesc:a3050e11aff691748a33f690d842ada1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given type is legal for this type converter, i.e.  <a href="classmlir_1_1TypeConverter.html#a3050e11aff691748a33f690d842ada1c">More...</a><br /></td></tr>
<tr class="separator:a3050e11aff691748a33f690d842ada1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fd289b2940df99c1e068a8dfef4759"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a75fd289b2940df99c1e068a8dfef4759"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_convertible&lt; RangeT, <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;::value &amp;&amp;!std::is_convertible&lt; RangeT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a75fd289b2940df99c1e068a8dfef4759">isLegal</a> (RangeT &amp;&amp;range) const</td></tr>
<tr class="memdesc:a75fd289b2940df99c1e068a8dfef4759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all of the given types are legal for this type converter.  <a href="classmlir_1_1TypeConverter.html#a75fd289b2940df99c1e068a8dfef4759">More...</a><br /></td></tr>
<tr class="separator:a75fd289b2940df99c1e068a8dfef4759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1eee88c23ccdc294537f1a04a79d3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a2b1eee88c23ccdc294537f1a04a79d3c">isLegal</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op) const</td></tr>
<tr class="memdesc:a2b1eee88c23ccdc294537f1a04a79d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given operation has legal operand and result types.  <a href="classmlir_1_1TypeConverter.html#a2b1eee88c23ccdc294537f1a04a79d3c">More...</a><br /></td></tr>
<tr class="separator:a2b1eee88c23ccdc294537f1a04a79d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672cfe5a3dfbc0a44bb6ad90e496867f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a672cfe5a3dfbc0a44bb6ad90e496867f">isLegal</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> *region) const</td></tr>
<tr class="memdesc:a672cfe5a3dfbc0a44bb6ad90e496867f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the types of block arguments within the region are legal.  <a href="classmlir_1_1TypeConverter.html#a672cfe5a3dfbc0a44bb6ad90e496867f">More...</a><br /></td></tr>
<tr class="separator:a672cfe5a3dfbc0a44bb6ad90e496867f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22e7873e1d10ad53ffc8bc89bf4e094"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ae22e7873e1d10ad53ffc8bc89bf4e094">isSignatureLegal</a> (FunctionType ty) const</td></tr>
<tr class="memdesc:ae22e7873e1d10ad53ffc8bc89bf4e094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the inputs and outputs of the given function type are legal.  <a href="classmlir_1_1TypeConverter.html#ae22e7873e1d10ad53ffc8bc89bf4e094">More...</a><br /></td></tr>
<tr class="separator:ae22e7873e1d10ad53ffc8bc89bf4e094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a08ffe75d1915342f5961a910cf700"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a79a08ffe75d1915342f5961a910cf700">convertSignatureArg</a> (unsigned inputNo, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;result) const</td></tr>
<tr class="memdesc:a79a08ffe75d1915342f5961a910cf700"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows for converting a specific argument of a signature.  <a href="classmlir_1_1TypeConverter.html#a79a08ffe75d1915342f5961a910cf700">More...</a><br /></td></tr>
<tr class="separator:a79a08ffe75d1915342f5961a910cf700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60393514e60087a6f446c7f63f516bf9"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a60393514e60087a6f446c7f63f516bf9">convertSignatureArgs</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types, <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;result, unsigned origInputOffset=0) const</td></tr>
<tr class="separator:a60393514e60087a6f446c7f63f516bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8d5e5f4f53b68ae964d852a16e5352"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#aad8d5e5f4f53b68ae964d852a16e5352">convertBlockSignature</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block) const</td></tr>
<tr class="memdesc:aad8d5e5f4f53b68ae964d852a16e5352"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the type signature of the given block, by invoking 'convertSignatureArg' for each argument.  <a href="classmlir_1_1TypeConverter.html#aad8d5e5f4f53b68ae964d852a16e5352">More...</a><br /></td></tr>
<tr class="separator:aad8d5e5f4f53b68ae964d852a16e5352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0694982a6432fdec13ec854cd011c632"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a0694982a6432fdec13ec854cd011c632">materializeSourceConversion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inputs) const</td></tr>
<tr class="memdesc:a0694982a6432fdec13ec854cd011c632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a conversion from a set of types into one result type by generating a cast sequence of some kind.  <a href="classmlir_1_1TypeConverter.html#a0694982a6432fdec13ec854cd011c632">More...</a><br /></td></tr>
<tr class="separator:a0694982a6432fdec13ec854cd011c632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af266521b8a2e7e87a2e7048dbcf5745d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#af266521b8a2e7e87a2e7048dbcf5745d">materializeTargetConversion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inputs, <a class="el" href="classmlir_1_1Type.html">Type</a> originalType={}) const</td></tr>
<tr class="separator:af266521b8a2e7e87a2e7048dbcf5745d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7b2e78bd21ab025bf2274ae81ce834"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#acc7b2e78bd21ab025bf2274ae81ce834">materializeTargetConversion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inputs, <a class="el" href="classmlir_1_1Type.html">Type</a> originalType={}) const</td></tr>
<tr class="separator:acc7b2e78bd21ab025bf2274ae81ce834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011b143e5a619f6f44d5bd46c29b95cc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a011b143e5a619f6f44d5bd46c29b95cc">convertTypeAttribute</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr) const</td></tr>
<tr class="memdesc:a011b143e5a619f6f44d5bd46c29b95cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an attribute present <code>attr</code> from within the type <code>type</code> using the registered conversion functions.  <a href="classmlir_1_1TypeConverter.html#a011b143e5a619f6f44d5bd46c29b95cc">More...</a><br /></td></tr>
<tr class="separator:a011b143e5a619f6f44d5bd46c29b95cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> conversion class. </p>
<p>Specific conversions and materializations can be registered using addConversion and addMaterialization, respectively. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00041">41</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac23c45fa40bd2771f27702f46fac5232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23c45fa40bd2771f27702f46fac5232">&#9670;&nbsp;</a></span>~TypeConverter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual mlir::TypeConverter::~TypeConverter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7055830377e3f38b6160a9712b5beba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7055830377e3f38b6160a9712b5beba1">&#9670;&nbsp;</a></span>TypeConverter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::TypeConverter::TypeConverter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b77498262ce63baee43eafd23b3e6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b77498262ce63baee43eafd23b3e6df">&#9670;&nbsp;</a></span>TypeConverter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::TypeConverter::TypeConverter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00046">46</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a272bc4144b1ac5a3f7f1ad25c0e39e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272bc4144b1ac5a3f7f1ad25c0e39e03">&#9670;&nbsp;</a></span>addConversion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;0&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::TypeConverter::addConversion </td>
          <td>(</td>
          <td class="paramtype">FnT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a conversion function. </p>
<p>A conversion function must be convertible to any of the following forms (where <code>T</code> is a class derived from <code><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a></code>):</p>
<ul>
<li>std::optional&lt;Type&gt;(T)<ul>
<li>This form represents a 1-1 type conversion. It should return nullptr or <code>std::nullopt</code> to signify failure. If <code>std::nullopt</code> is returned, the converter is allowed to try another conversion function to perform the conversion.</li>
</ul>
</li>
<li>std::optional&lt;LogicalResult&gt;(T, SmallVectorImpl&lt;Type&gt; &amp;)<ul>
<li>This form represents a 1-N type conversion. It should return <code>failure</code> or <code>std::nullopt</code> to signify a failed conversion. If the new set of types is empty, the type is removed and any usages of the existing value are expected to be removed during conversion. If <code>std::nullopt</code> is returned, the converter is allowed to try another conversion function to perform the conversion.</li>
</ul>
</li>
</ul>
<p>Note: When attempting to convert a type, e.g. via 'convertType', the mostly recently added conversions will be invoked first. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00161">161</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l01546">addOpaquePointerConversion()</a>, <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00441">mlir::configureGpuToNVVMTypeConverter()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00262">mlir::xegpu::doSCFStructuralTypeConversionWithTensorType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00115">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00168">mlir::spirv::MemorySpaceToStorageClassConverter::MemorySpaceToStorageClassConverter()</a>, <a class="el" href="Arith_2Transforms_2EmulateNarrowType_8cpp_source.html#l00027">mlir::arith::NarrowTypeEmulationConverter::NarrowTypeEmulationConverter()</a>, <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00041">mlir::populateAMXLegalizeForLLVMExportPatterns()</a>, <a class="el" href="ArmSMEToLLVM_8cpp_source.html#l00981">mlir::populateArmSMEToLLVMConversionPatterns()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l01151">mlir::populateAsyncStructuralTypeConversionsAndLegality()</a>, <a class="el" href="TypeConversions_8cpp_source.html#l00030">mlir::populateEmitCSizeTTypeConversions()</a>, <a class="el" href="EmulateUnsupportedFloats_8cpp_source.html#l00087">mlir::arith::populateEmulateUnsupportedFloatsConversions()</a>, <a class="el" href="ExtendToSupportedTypes_8cpp_source.html#l00053">mlir::math::populateExtendToSupportedTypesTypeConverter()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00635">mlir::memref::populateMemRefNarrowTypeEmulationConversions()</a>, <a class="el" href="MemRefToEmitC_8cpp_source.html#l00293">mlir::populateMemRefToEmitCTypeConversion()</a>, <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html#l00148">mlir::memref::populateMemRefWideIntEmulationConversions()</a>, <a class="el" href="WmmaOpsToSPIRV_8cpp_source.html#l00365">mlir::populateMMAToSPIRVCoopMatrixTypeConversion()</a>, <a class="el" href="MPIToLLVM_8cpp_source.html#l00796">mlir::mpi::populateMPIToLLVMConversionPatterns()</a>, <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00147">mlir::populateOpenMPToLLVMConversionPatterns()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l01795">mlir::populateSPIRVToLLVMTypeConversion()</a>, <a class="el" href="TosaTypeConverters_8cpp_source.html#l00020">mlir::tosa::populateTosaTypeConversion()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01471">mlir::SPIRVTypeConverter::SPIRVTypeConverter()</a>, and <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l01228">mlir::arith::WideIntEmulationConverter::WideIntEmulationConverter()</a>.</p>

</div>
</div>
<a id="aaf35c0b4faa6fa6d8eda987ad71393e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf35c0b4faa6fa6d8eda987ad71393e9">&#9670;&nbsp;</a></span>addSourceMaterialization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::TypeConverter::addSourceMaterialization </td>
          <td>(</td>
          <td class="paramtype">FnT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All of the following materializations require function objects that are convertible to the following form: <code>Value(OpBuilder &amp;, T, ValueRange, Location)</code>, where <code>T</code> is any subclass of <code><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a></code>. </p>
<p>This function is responsible for creating an operation, using the <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations.">OpBuilder</a> and <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> provided, that "casts" a range of values into a single value of the given type <code>T</code>. It must return a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> of the type <code>T</code> on success and <code>nullptr</code> if it failed but other materialization should be attempted. Materialization functions must be provided when a type conversion may persist after the conversion has finished.</p>
<p>Note: Target materializations may optionally accept an additional <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> parameter, which is the original type of the SSA value. Furthermore, <code>T</code> can be a <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types.">TypeRange</a>; in that case, the function must return a <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value&gt;</a>. This method registers a materialization that will be called when converting a replacement value back to its original source type. This is used when some uses of the original value persist beyond the main conversion. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00187">187</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00262">mlir::xegpu::doSCFStructuralTypeConversionWithTensorType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00115">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="TypeConversions_8cpp_source.html#l00030">mlir::populateEmitCSizeTTypeConversions()</a>, <a class="el" href="MemRefToEmitC_8cpp_source.html#l00293">mlir::populateMemRefToEmitCTypeConversion()</a>, <a class="el" href="TosaTypeConverters_8cpp_source.html#l00020">mlir::tosa::populateTosaTypeConversion()</a>, and <a class="el" href="SPIRVConversion_8cpp_source.html#l01471">mlir::SPIRVTypeConverter::SPIRVTypeConverter()</a>.</p>

</div>
</div>
<a id="acfe54f9a4348e1d8aa30535f53ddaf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe54f9a4348e1d8aa30535f53ddaf37">&#9670;&nbsp;</a></span>addTargetMaterialization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::TypeConverter::addTargetMaterialization </td>
          <td>(</td>
          <td class="paramtype">FnT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method registers a materialization that will be called when converting a value to a target type according to a pattern's type converter. </p>
<p>Note: Target materializations can optionally inspect the "original" type. This type may be different from the type of the input value. For example, let's assume that a conversion pattern "P1" replaced an SSA value "v1" (type "t1") with "v2" (type "t2"). Then a different conversion pattern "P2" matches an op that has "v1" as an operand. Let's furthermore assume that "P2" determines that the converted target type of "t1" is "t3", which may be different from "t2". In this example, the target materialization will be invoked with: outputType = "t3", inputs = "v2", originalType = "t1". Note that the original type "t1" cannot be recovered from just "t3" and "v2"; that's why the originalType parameter exists.</p>
<p>Note: During a 1:N conversion, the result types can be a <a class="el" href="classmlir_1_1TypeRange.html" title="This class provides an abstraction over the various different ranges of value types.">TypeRange</a>. In that case the materialization produces a <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value&gt;</a>. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00211">211</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="XeGPUUtils_8cpp_source.html#l00262">mlir::xegpu::doSCFStructuralTypeConversionWithTensorType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00115">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="TypeConversions_8cpp_source.html#l00030">mlir::populateEmitCSizeTTypeConversions()</a>, <a class="el" href="EmulateUnsupportedFloats_8cpp_source.html#l00087">mlir::arith::populateEmulateUnsupportedFloatsConversions()</a>, <a class="el" href="ExtendToSupportedTypes_8cpp_source.html#l00053">mlir::math::populateExtendToSupportedTypesTypeConverter()</a>, <a class="el" href="MemRefToEmitC_8cpp_source.html#l00293">mlir::populateMemRefToEmitCTypeConversion()</a>, <a class="el" href="TosaTypeConverters_8cpp_source.html#l00020">mlir::tosa::populateTosaTypeConversion()</a>, and <a class="el" href="SPIRVConversion_8cpp_source.html#l01471">mlir::SPIRVTypeConverter::SPIRVTypeConverter()</a>.</p>

</div>
</div>
<a id="ac5b36cbf0a62aab9acb39d9299336980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b36cbf0a62aab9acb39d9299336980">&#9670;&nbsp;</a></span>addTypeAttributeConversion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;0&gt;, typename A  = typename llvm::function_traits&lt;std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::TypeConverter::addTypeAttributeConversion </td>
          <td>(</td>
          <td class="paramtype">FnT &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a conversion function for attributes within types. </p>
<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> converters may call this function in order to allow hoking into the translation of attributes that exist within types. For example, a type converter for the <code>memref</code> type could use these conversions to convert memory spaces or layouts in an extensible way.</p>
<p>The conversion functions take a non-null <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> or subclass of <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> and a non-null <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> (or subclass of <a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a>), and returns a <code><a class="el" href="classmlir_1_1TypeConverter_1_1AttributeConversionResult.html" title="The general result of a type attribute conversion callback, allowing for early termination.">AttributeConversionResult</a></code>. This result can either contain an <code><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a></code>, which may be <code>nullptr</code>, representing the conversion's success, <code><a class="el" href="classmlir_1_1TypeConverter_1_1AttributeConversionResult.html#ab40c7c8e5e53f8511eb6ee1fcdf16679">AttributeConversionResult::na()</a></code> (the default empty value), indicating that the conversion function did not apply and that further conversion functions should be checked, or <code><a class="el" href="classmlir_1_1TypeConverter_1_1AttributeConversionResult.html#a942b3a926893266cf17b6cf1b2dac6da">AttributeConversionResult::abort()</a></code> indicating that the conversion process should be aborted.</p>
<p>Registered conversion functions are callled in the reverse of the order in which they were registered. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00240">240</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00115">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l01905">mlir::populateAMDGPUMemorySpaceAttributeConversions()</a>, and <a class="el" href="GPUOpsLowering_8cpp_source.html#l00814">mlir::populateGpuMemorySpaceAttributeConversions()</a>.</p>

</div>
</div>
<a id="aad8d5e5f4f53b68ae964d852a16e5352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8d5e5f4f53b68ae964d852a16e5352">&#9670;&nbsp;</a></span>convertBlockSignature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">TypeConverter::SignatureConversion</a> &gt; TypeConverter::convertBlockSignature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts the type signature of the given block, by invoking 'convertSignatureArg' for each argument. </p>
<p>This function should return a valid conversion for the signature on success, std::nullopt otherwise. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03181">3181</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03132">convertSignatureArgs()</a>, <a class="el" href="Block_8cpp_source.html#l00149">mlir::Block::getArgumentTypes()</a>, and <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getNumArguments()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l01383">mlir::detail::ConversionPatternRewriterImpl::convertRegionTypes()</a>.</p>

</div>
</div>
<a id="a79a08ffe75d1915342f5961a910cf700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a08ffe75d1915342f5961a910cf700">&#9670;&nbsp;</a></span>convertSignatureArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult TypeConverter::convertSignatureArg </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>inputNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allows for converting a specific argument of a signature. </p>
<p>It takes as inputs the original argument input number, type. On success, it populates 'result' with any new mappings. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03116">3116</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02997">mlir::TypeConverter::SignatureConversion::addInputs()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l03027">convertType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l03132">convertSignatureArgs()</a>.</p>

</div>
</div>
<a id="a60393514e60087a6f446c7f63f516bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60393514e60087a6f446c7f63f516bf9">&#9670;&nbsp;</a></span>convertSignatureArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult TypeConverter::convertSignatureArgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>origInputOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03132">3132</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03116">convertSignatureArg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l03181">convertBlockSignature()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l03240">convertFuncOpTypes()</a>.</p>

</div>
</div>
<a id="a7c28856d7176c4af44f64906de33b6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c28856d7176c4af44f64906de33b6ac">&#9670;&nbsp;</a></span>convertType() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> TypeConverter::convertType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This hook simplifies defining 1-1 type conversions. </p>
<p>This function returns the type to convert to on success, and a null type on failure. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03079">3079</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03027">convertType()</a>.</p>

</div>
</div>
<a id="a781dc5f696e4309ad385645a74295fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781dc5f696e4309ad385645a74295fe0">&#9670;&nbsp;</a></span>convertType() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TargetType mlir::TypeConverter::convertType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts a 1-1 type conversion, expecting the result type to be <code>TargetType</code>. </p>
<p>Returns the converted type cast to <code>TargetType</code> on success, and a null type on conversion or cast failure. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00259">259</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03027">convertType()</a>.</p>

</div>
</div>
<a id="aad1fae4fc72123cef7302a93ba314c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1fae4fc72123cef7302a93ba314c6a">&#9670;&nbsp;</a></span>convertType() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult TypeConverter::convertType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given type. </p>
<p>This function should return failure if no valid conversion exists, success otherwise. If the new set of types is empty, the type is removed and any usages of the existing value are expected to be removed during conversion. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03027">3027</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l00577">mlir::MLIRContext::isMultithreadingEnabled()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00068">adjustAccessChainForBitwidth()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00148">broadcast()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00255">convertArrayType()</a>, <a class="el" href="MapMemRefStorageClassPass_8cpp_source.html#l00249">mlir::spirv::convertMemRefTypesAndAttrs()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00281">convertRuntimeArrayType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03116">convertSignatureArg()</a>, <a class="el" href="DialectConversion_8h_source.html#l00259">convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03090">convertTypes()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00190">mlir::ConvertToLLVMPattern::createMemRefDescriptor()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00929">emitElementwiseComputation()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00088">mlir::ConvertToLLVMPattern::getMemRefDescriptorSizes()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00143">mlir::ConvertToLLVMPattern::getSizeInBytes()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00074">mlir::ConvertToLLVMPattern::isConvertibleAndHasIdentityMaps()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03098">isLegal()</a>, <a class="el" href="ControlFlowToSPIRV_8cpp_source.html#l00028">legalizeBlockArguments()</a>, <a class="el" href="GPUToSPIRV_8cpp_source.html#l00231">lowerAsEntryFunction()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00717">mlir::GPUDynamicSharedMemoryOpLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00077">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00390">mlir::GPUPrintfOpToHIPLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00490">mlir::GPUPrintfOpToLLVMCallLowering::matchAndRewrite()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00536">mlir::GPUPrintfOpToVPrintfLowering::matchAndRewrite()</a>, <a class="el" href="lib_2Conversion_2SPIRVCommon_2Pattern_8h_source.html#l00027">mlir::spirv::ElementwiseOpPattern&lt; Op, SPIRVOp &gt;::matchAndRewrite()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l01151">mlir::populateAsyncStructuralTypeConversionsAndLegality()</a>, <a class="el" href="MemRefToEmitC_8cpp_source.html#l00293">mlir::populateMemRefToEmitCTypeConversion()</a>, <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html#l00148">mlir::memref::populateMemRefWideIntEmulationConversions()</a>, <a class="el" href="TosaTypeConverters_8cpp_source.html#l00020">mlir::tosa::populateTosaTypeConversion()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01315">mlir::detail::ConversionPatternRewriterImpl::remapValues()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00226">replaceWithLoadOrStore()</a>, and <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00673">wmmaPushInputOperand()</a>.</p>

</div>
</div>
<a id="a011b143e5a619f6f44d5bd46c29b95cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011b143e5a619f6f44d5bd46c29b95cc">&#9670;&nbsp;</a></span>convertTypeAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; TypeConverter::convertTypeAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an attribute present <code>attr</code> from within the type <code>type</code> using the registered conversion functions. </p>
<p>If no applicable conversion has been registered, return std::nullopt. Note that the empty attribute/<code>nullptr</code> is a valid return value for this function. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03224">3224</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03218">mlir::TypeConverter::AttributeConversionResult::getResult()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03206">mlir::TypeConverter::AttributeConversionResult::hasResult()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l03214">mlir::TypeConverter::AttributeConversionResult::isAbort()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00574">mlir::LLVMTypeConverter::getMemRefAddressSpace()</a>.</p>

</div>
</div>
<a id="ad8a2339e9128e1b05df14b075f6c3914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a2339e9128e1b05df14b075f6c3914">&#9670;&nbsp;</a></span>convertTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult TypeConverter::convertTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given set of types, filling 'results' as necessary. </p>
<p>This returns failure if the conversion of any of the types fails, success otherwise. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03090">3090</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03027">convertType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l03240">convertFuncOpTypes()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03296">mlir::convertOpResultTypes()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00208">convertStructTypePacked()</a>, <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00195">convertStructTypeWithOffset()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00115">mlir::LLVMTypeConverter::LLVMTypeConverter()</a>, <a class="el" href="Arith_2Transforms_2EmulateNarrowType_8cpp_source.html#l00027">mlir::arith::NarrowTypeEmulationConverter::NarrowTypeEmulationConverter()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03506">mlir::registerConversionPDLFunctions()</a>, and <a class="el" href="Arith_2Transforms_2EmulateWideInt_8cpp_source.html#l01228">mlir::arith::WideIntEmulationConverter::WideIntEmulationConverter()</a>.</p>

</div>
</div>
<a id="a2b1eee88c23ccdc294537f1a04a79d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1eee88c23ccdc294537f1a04a79d3c">&#9670;&nbsp;</a></span>isLegal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeConverter::isLegal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given operation has legal operand and result types. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03101">3101</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00397">mlir::Operation::getOperandTypes()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00428">mlir::Operation::getResultTypes()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l03098">isLegal()</a>.</p>

</div>
</div>
<a id="a75fd289b2940df99c1e068a8dfef4759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75fd289b2940df99c1e068a8dfef4759">&#9670;&nbsp;</a></span>isLegal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_convertible&lt;RangeT, <a class="el" href="classmlir_1_1Type.html">Type</a>&gt;::value &amp;&amp; !std::is_convertible&lt;RangeT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;::value, bool&gt; mlir::TypeConverter::isLegal </td>
          <td>(</td>
          <td class="paramtype">RangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all of the given types are legal for this type converter. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00278">278</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03098">isLegal()</a>.</p>

</div>
</div>
<a id="a672cfe5a3dfbc0a44bb6ad90e496867f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672cfe5a3dfbc0a44bb6ad90e496867f">&#9670;&nbsp;</a></span>isLegal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeConverter::isLegal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the types of block arguments within the region are legal. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03105">3105</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8cpp_source.html#l00149">mlir::Block::getArgumentTypes()</a>, and <a class="el" href="DialectConversion_8cpp_source.html#l03098">isLegal()</a>.</p>

</div>
</div>
<a id="a3050e11aff691748a33f690d842ada1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3050e11aff691748a33f690d842ada1c">&#9670;&nbsp;</a></span>isLegal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeConverter::isLegal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given type is legal for this type converter, i.e. </p>
<p>the type converts to itself. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03098">3098</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03027">convertType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OpenMPToLLVM_8cpp_source.html#l00119">mlir::configureOpenMPToLLVMConversionLegality()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03296">mlir::convertOpResultTypes()</a>, <a class="el" href="DialectConversion_8h_source.html#l00278">isLegal()</a>, <a class="el" href="FuncConversions_8cpp_source.html#l00143">mlir::isLegalForBranchOpInterfaceTypeConversionPattern()</a>, <a class="el" href="FuncConversions_8cpp_source.html#l00164">mlir::isLegalForReturnOpTypeConversionPattern()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03111">isSignatureLegal()</a>, <a class="el" href="ControlFlowToSPIRV_8cpp_source.html#l00028">legalizeBlockArguments()</a>, <a class="el" href="AsyncToLLVM_8cpp_source.html#l01151">mlir::populateAsyncStructuralTypeConversionsAndLegality()</a>, <a class="el" href="EmulateUnsupportedFloats_8cpp_source.html#l00112">mlir::arith::populateEmulateUnsupportedFloatsLegality()</a>, <a class="el" href="ExtendToSupportedTypes_8cpp_source.html#l00082">mlir::math::populateExtendToSupportedTypesConversionTarget()</a>, and <a class="el" href="StructuralTypeConversions_8cpp_source.html#l00226">mlir::scf::populateSCFStructuralTypeConversionTarget()</a>.</p>

</div>
</div>
<a id="ae22e7873e1d10ad53ffc8bc89bf4e094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22e7873e1d10ad53ffc8bc89bf4e094">&#9670;&nbsp;</a></span>isSignatureLegal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeConverter::isSignatureLegal </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>ty</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the inputs and outputs of the given function type are legal. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03111">3111</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03098">isLegal()</a>.</p>

</div>
</div>
<a id="a0694982a6432fdec13ec854cd011c632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0694982a6432fdec13ec854cd011c632">&#9670;&nbsp;</a></span>materializeSourceConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> TypeConverter::materializeSourceConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>resultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Materialize a conversion from a set of types into one result type by generating a cast sequence of some kind. </p>
<p>See the respective <code>add*Materialization</code> for more information on the context for these methods. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03141">3141</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ControlFlowToSPIRV_8cpp_source.html#l00028">legalizeBlockArguments()</a>.</p>

</div>
</div>
<a id="af266521b8a2e7e87a2e7048dbcf5745d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af266521b8a2e7e87a2e7048dbcf5745d">&#9670;&nbsp;</a></span>materializeTargetConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> TypeConverter::materializeTargetConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>resultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>originalType</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03151">3151</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

</div>
</div>
<a id="acc7b2e78bd21ab025bf2274ae81ce834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7b2e78bd21ab025bf2274ae81ce834">&#9670;&nbsp;</a></span>materializeTargetConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; TypeConverter::materializeTargetConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>resultType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>originalType</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l03163">3163</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

</div>
</div>
<a id="a7e7c8bca88d9cd366e8b727b1aca27ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7c8bca88d9cd366e8b727b1aca27ae">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a>&amp; mlir::TypeConverter::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00051">51</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Transforms/<a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a></li>
<li>lib/Transforms/Utils/<a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:30 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
