<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: include/mlir/Dialect/SCF/Transforms/TileUsingInterface.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_5654f77406fb9ceec87e68ef828ceea2.html">mlir</a></li><li class="navelem"><a class="el" href="dir_d07a6fac82475a065a3b2953573f00a0.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_47aca9e8d6a16a6d14cf434a05d15774.html">SCF</a></li><li class="navelem"><a class="el" href="dir_969e10377b9c65c13050e8e8e380eba9.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TileUsingInterface.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html">mlir/Dialect/SCF/IR/SCF.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Tensor_2Transforms_2Transforms_8h_source.html">mlir/Dialect/Tensor/Transforms/Transforms.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopLikeInterface_8h_source.html">mlir/Interfaces/LoopLikeInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TilingInterface_8h_source.html">mlir/Interfaces/TilingInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ViewLikeInterface_8h_source.html">mlir/Interfaces/ViewLikeInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="FrozenRewritePatternSet_8h_source.html">mlir/Rewrite/FrozenRewritePatternSet.h</a>&quot;</code><br />
<code>#include &lt;deque&gt;</code><br />
</div>
<p><a href="TileUsingInterface_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFTilingOptions.html">mlir::scf::SCFTilingOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to use to control tiling.  <a href="structmlir_1_1scf_1_1SCFTilingOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFTilingResult.html">mlir::scf::SCFTilingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after tiling.  <a href="structmlir_1_1scf_1_1SCFTilingResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFTileAndFuseOptions.html">mlir::scf::SCFTileAndFuseOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options used to control tile + fuse.  <a href="structmlir_1_1scf_1_1SCFTileAndFuseOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFTileAndFuseOptions_1_1ControlFnResult.html">mlir::scf::SCFTileAndFuseOptions::ControlFnResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control function to check if a slice needs to be fused or not, The control function receives 1) the slice along which fusion is to be done, 2) the producer value that is to be fused 3) a boolean value set to <code>true</code> if the fusion is from a destination operand.  <a href="structmlir_1_1scf_1_1SCFTileAndFuseOptions_1_1ControlFnResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFFuseProducerOfSliceResult.html">mlir::scf::SCFFuseProducerOfSliceResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse the producer of the source of <code>candidateSliceOp</code> by computing the required slice of the producer in-place.  <a href="structmlir_1_1scf_1_1SCFFuseProducerOfSliceResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFTileAndFuseResult.html">mlir::scf::SCFTileAndFuseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after tile and fuse.  <a href="structmlir_1_1scf_1_1SCFTileAndFuseResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1scf_1_1SCFFuseConsumerOfSliceResult.html">mlir::scf::SCFFuseConsumerOfSliceResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse the consumer <code>candidateSlices</code> by computing the required slice of the consumer in-place.  <a href="structmlir_1_1scf_1_1SCFFuseConsumerOfSliceResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1scf"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html">mlir::scf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acaf645f000a54e5dfb286a03b15eeea7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#acaf645f000a54e5dfb286a03b15eeea7">mlir::scf::SCFTileSizeComputationFunction</a> = std::function&lt; SmallVector&lt; OpFoldResult &gt;(OpBuilder &amp;, Operation *)&gt;</td></tr>
<tr class="separator:acaf645f000a54e5dfb286a03b15eeea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4c2e44210871d8d64abb0349e0748ded"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; SCFTilingResult &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a4c2e44210871d8d64abb0349e0748ded">mlir::scf::tileUsingSCF</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, const SCFTilingOptions &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a4c2e44210871d8d64abb0349e0748ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to tile an op that implements the <code>TilingInterface</code> using <code>scf.for</code> for iterating over the tiles.  <a href="namespacemlir_1_1scf.html#a4c2e44210871d8d64abb0349e0748ded">More...</a><br /></td></tr>
<tr class="separator:a4c2e44210871d8d64abb0349e0748ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c8763d41581b3e107f131ba4b5fa9c"><td class="memItemLeft" align="right" valign="top">std::optional&lt; SCFFuseProducerOfSliceResult &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#ad9c8763d41581b3e107f131ba4b5fa9c">mlir::scf::tileAndFuseProducerOfSlice</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::ExtractSliceOp candidateSliceOp, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt; loops)</td></tr>
<tr class="memdesc:ad9c8763d41581b3e107f131ba4b5fa9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of fusing producer of a single slice by computing the slice of the producer in-place.  <a href="namespacemlir_1_1scf.html#ad9c8763d41581b3e107f131ba4b5fa9c">More...</a><br /></td></tr>
<tr class="separator:ad9c8763d41581b3e107f131ba4b5fa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9889da190565ac39fa39b8df7fca6892"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a9889da190565ac39fa39b8df7fca6892">mlir::scf::yieldReplacementForFusedProducer</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::ExtractSliceOp sliceOp, <a class="el" href="structmlir_1_1scf_1_1SCFFuseProducerOfSliceResult.html">scf::SCFFuseProducerOfSliceResult</a> fusedProducerInfo, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt; loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; yieldResultNumber=<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt;{})</td></tr>
<tr class="memdesc:a9889da190565ac39fa39b8df7fca6892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstruct the fused producer from within the tiled-and-fused code.  <a href="namespacemlir_1_1scf.html#a9889da190565ac39fa39b8df7fca6892">More...</a><br /></td></tr>
<tr class="separator:a9889da190565ac39fa39b8df7fca6892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3958464fe5500cde467d45e98faa1d"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; SCFTileAndFuseResult &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#aad3958464fe5500cde467d45e98faa1d">mlir::scf::tileConsumerAndFuseProducersUsingSCF</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface consumer, const SCFTileAndFuseOptions &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:aad3958464fe5500cde467d45e98faa1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to tile and fuse a sequence of operations, by tiling the consumer and fusing its producers.  <a href="namespacemlir_1_1scf.html#aad3958464fe5500cde467d45e98faa1d">More...</a><br /></td></tr>
<tr class="separator:aad3958464fe5500cde467d45e98faa1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a250462b710ed5743a3b5adbf11cf3d"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1scf_1_1SCFFuseConsumerOfSliceResult.html">scf::SCFFuseConsumerOfSliceResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a8a250462b710ed5743a3b5adbf11cf3d">mlir::scf::tileAndFuseConsumerOfSlices</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; candidateSlices, <a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; LoopLikeOpInterface &gt; loops)</td></tr>
<tr class="memdesc:a8a250462b710ed5743a3b5adbf11cf3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of fusing consumer of a single slice by computing the slice of the consumer in-place for scf loop.  <a href="namespacemlir_1_1scf.html#a8a250462b710ed5743a3b5adbf11cf3d">More...</a><br /></td></tr>
<tr class="separator:a8a250462b710ed5743a3b5adbf11cf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923f55dccab8af632622d7efa517f6d2"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; scf::ForOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a923f55dccab8af632622d7efa517f6d2">mlir::scf::lowerToLoopsUsingSCFForOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op)</td></tr>
<tr class="memdesc:a923f55dccab8af632622d7efa517f6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to lower an <code>op</code> that implements the <code>TilingInterface</code> to loops/scalars.  <a href="namespacemlir_1_1scf.html#a923f55dccab8af632622d7efa517f6d2">More...</a><br /></td></tr>
<tr class="separator:a923f55dccab8af632622d7efa517f6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085d4ab1d6cf50988ee9fd5b963f4e76"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1scf_1_1SCFTilingResult.html">scf::SCFTilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a085d4ab1d6cf50988ee9fd5b963f4e76">mlir::scf::tileReductionUsingScf</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, PartialReductionOpInterface op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes)</td></tr>
<tr class="memdesc:a085d4ab1d6cf50988ee9fd5b963f4e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to tile a reduction and generate a parallel op within a serial loop.  <a href="namespacemlir_1_1scf.html#a085d4ab1d6cf50988ee9fd5b963f4e76">More...</a><br /></td></tr>
<tr class="separator:a085d4ab1d6cf50988ee9fd5b963f4e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:27 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
